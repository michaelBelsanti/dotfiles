/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 130);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(global,factory){"use strict";if( true&&typeof module.exports==="object"){module.exports=global.document?factory(global,true):function(w){if(!w.document){throw new Error("jQuery requires a window with a document");}return factory(w);};}else{factory(global);}})(typeof window!=="undefined"?window:this,function(window,noGlobal){"use strict";var arr=[];var getProto=Object.getPrototypeOf;var slice=arr.slice;var flat=arr.flat?function(array){return arr.flat.call(array);}:function(array){return arr.concat.apply([],array);};var push=arr.push;var indexOf=arr.indexOf;var class2type={};var toString=class2type.toString;var hasOwn=class2type.hasOwnProperty;var fnToString=hasOwn.toString;var ObjectFunctionString=fnToString.call(Object);var support={};var isFunction=function(obj){return typeof obj==="function"&&typeof obj.nodeType!=="number"&&typeof obj.item!=="function";};var isWindow=function(obj){return obj!=null&&obj===obj.window;};var document=window.document;var preservedScriptAttributes={type:true,src:true,nonce:true,noModule:true};function DOMEval(code,node,doc){doc=doc||document;var i,val,script=doc.createElement("script");script.text=code;if(node){for(i in preservedScriptAttributes){val=node[i]||node.getAttribute&&node.getAttribute(i);if(val){script.setAttribute(i,val);}}}doc.head.appendChild(script).parentNode.removeChild(script);}function toType(obj){if(obj==null){return obj+"";}return typeof obj==="object"||typeof obj==="function"?class2type[toString.call(obj)]||"object":typeof obj;}var version="3.6.0",jQuery=function(selector,context){return new jQuery.fn.init(selector,context);};jQuery.fn=jQuery.prototype={jquery:version,constructor:jQuery,length:0,toArray:function(){return slice.call(this);},get:function(num){if(num==null){return slice.call(this);}return num<0?this[num+this.length]:this[num];},pushStack:function(elems){var ret=jQuery.merge(this.constructor(),elems);ret.prevObject=this;return ret;},each:function(callback){return jQuery.each(this,callback);},map:function(callback){return this.pushStack(jQuery.map(this,function(elem,i){return callback.call(elem,i,elem);}));},slice:function(){return this.pushStack(slice.apply(this,arguments));},first:function(){return this.eq(0);},last:function(){return this.eq(-1);},even:function(){return this.pushStack(jQuery.grep(this,function(_elem,i){return(i+1)%2;}));},odd:function(){return this.pushStack(jQuery.grep(this,function(_elem,i){return i%2;}));},eq:function(i){var len=this.length,j=+i+(i<0?len:0);return this.pushStack(j>=0&&j<len?[this[j]]:[]);},end:function(){return this.prevObject||this.constructor();},push:push,sort:arr.sort,splice:arr.splice};jQuery.extend=jQuery.fn.extend=function(){var options,name,src,copy,copyIsArray,clone,target=arguments[0]||{},i=1,length=arguments.length,deep=false;if(typeof target==="boolean"){deep=target;target=arguments[i]||{};i++;}if(typeof target!=="object"&&!isFunction(target)){target={};}if(i===length){target=this;i--;}for(;i<length;i++){if((options=arguments[i])!=null){for(name in options){copy=options[name];if(name==="__proto__"||target===copy){continue;}if(deep&&copy&&(jQuery.isPlainObject(copy)||(copyIsArray=Array.isArray(copy)))){src=target[name];if(copyIsArray&&!Array.isArray(src)){clone=[];}else if(!copyIsArray&&!jQuery.isPlainObject(src)){clone={};}else{clone=src;}copyIsArray=false;target[name]=jQuery.extend(deep,clone,copy);}else if(copy!==undefined){target[name]=copy;}}}}return target;};jQuery.extend({expando:"jQuery"+(version+Math.random()).replace(/\D/g,""),isReady:true,error:function(msg){throw new Error(msg);},noop:function(){},isPlainObject:function(obj){var proto,Ctor;if(!obj||toString.call(obj)!=="[object Object]"){return false;}proto=getProto(obj);if(!proto){return true;}Ctor=hasOwn.call(proto,"constructor")&&proto.constructor;return typeof Ctor==="function"&&fnToString.call(Ctor)===ObjectFunctionString;},isEmptyObject:function(obj){for(var name in obj){return false;}return true;},globalEval:function(code,options,doc){DOMEval(code,{nonce:options&&options.nonce},doc);},each:function(obj,callback){var length,i=0;if(isArrayLike(obj)){length=obj.length;for(;i<length;i++){if(callback.call(obj[i],i,obj[i])===false){break;}}}else{for(i in obj){if(callback.call(obj[i],i,obj[i])===false){break;}}}return obj;},makeArray:function(arr,results){var ret=results||[];if(arr!=null){if(isArrayLike(Object(arr))){jQuery.merge(ret,typeof arr==="string"?[arr]:arr);}else{push.call(ret,arr);}}return ret;},inArray:function(elem,arr,i){return arr==null?-1:indexOf.call(arr,elem,i);},merge:function(first,second){var len=+second.length,j=0,i=first.length;for(;j<len;j++){first[i++]=second[j];}first.length=i;return first;},grep:function(elems,callback,invert){var callbackInverse,matches=[],i=0,length=elems.length;for(;i<length;i++){callbackInverse=!callback(elems[i],i);if(callbackInverse!==!invert){matches.push(elems[i]);}}return matches;},map:function(elems,callback,arg){var length,value,i=0,ret=[];if(isArrayLike(elems)){length=elems.length;for(;i<length;i++){value=callback(elems[i],i,arg);if(value!=null){ret.push(value);}}}else{for(i in elems){value=callback(elems[i],i,arg);if(value!=null){ret.push(value);}}}return flat(ret);},guid:1,support:support});if(typeof Symbol==="function"){jQuery.fn[Symbol.iterator]=arr[Symbol.iterator];}jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(_i,name){class2type["[object "+name+"]"]=name.toLowerCase();});function isArrayLike(obj){var length=!!obj&&"length"in obj&&obj.length,type=toType(obj);if(isFunction(obj)||isWindow(obj)){return false;}return type==="array"||length===0||typeof length==="number"&&length>0&&length-1 in obj;}var Sizzle=function(window){var i,support,Expr,getText,isXML,tokenize,compile,select,outermostContext,sortInput,hasDuplicate,setDocument,document,docElem,documentIsHTML,rbuggyQSA,rbuggyMatches,matches,contains,expando="sizzle"+1*new Date(),preferredDoc=window.document,dirruns=0,done=0,classCache=createCache(),tokenCache=createCache(),compilerCache=createCache(),nonnativeSelectorCache=createCache(),sortOrder=function(a,b){if(a===b){hasDuplicate=true;}return 0;},hasOwn={}.hasOwnProperty,arr=[],pop=arr.pop,pushNative=arr.push,push=arr.push,slice=arr.slice,indexOf=function(list,elem){var i=0,len=list.length;for(;i<len;i++){if(list[i]===elem){return i;}}return-1;},booleans="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|"+"ismap|loop|multiple|open|readonly|required|scoped",whitespace="[\\x20\\t\\r\\n\\f]",identifier="(?:\\\\[\\da-fA-F]{1,6}"+whitespace+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",attributes="\\["+whitespace+"*("+identifier+")(?:"+whitespace+"*([*^$|!~]?=)"+whitespace+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+identifier+"))|)"+whitespace+"*\\]",pseudos=":("+identifier+")(?:\\(("+"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|"+"((?:\\\\.|[^\\\\()[\\]]|"+attributes+")*)|"+".*"+")\\)|)",rwhitespace=new RegExp(whitespace+"+","g"),rtrim=new RegExp("^"+whitespace+"+|((?:^|[^\\\\])(?:\\\\.)*)"+whitespace+"+$","g"),rcomma=new RegExp("^"+whitespace+"*,"+whitespace+"*"),rcombinators=new RegExp("^"+whitespace+"*([>+~]|"+whitespace+")"+whitespace+"*"),rdescend=new RegExp(whitespace+"|>"),rpseudo=new RegExp(pseudos),ridentifier=new RegExp("^"+identifier+"$"),matchExpr={"ID":new RegExp("^#("+identifier+")"),"CLASS":new RegExp("^\\.("+identifier+")"),"TAG":new RegExp("^("+identifier+"|[*])"),"ATTR":new RegExp("^"+attributes),"PSEUDO":new RegExp("^"+pseudos),"CHILD":new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+whitespace+"*(even|odd|(([+-]|)(\\d*)n|)"+whitespace+"*(?:([+-]|)"+whitespace+"*(\\d+)|))"+whitespace+"*\\)|)","i"),"bool":new RegExp("^(?:"+booleans+")$","i"),"needsContext":new RegExp("^"+whitespace+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+whitespace+"*((?:-\\d)?\\d*)"+whitespace+"*\\)|)(?=[^-]|$)","i")},rnative=/^[^{]+\{\s*\[native \w/,rsibling=/[+~]/,runescape=new RegExp("\\\\[\\da-fA-F]{1,6}"+whitespace+"?|\\\\([^\\r\\n\\f])","g"),funescape=function(escape,nonHex){var high="0x"+escape.slice(1)-0x10000;return nonHex?nonHex:high<0?String.fromCharCode(high+0x10000):String.fromCharCode(high>>10|0xD800,high&0x3FF|0xDC00);},rcssescape=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,fcssescape=function(ch,asCodePoint){if(asCodePoint){if(ch==="\0"){return"\uFFFD";}return ch.slice(0,-1)+"\\"+ch.charCodeAt(ch.length-1).toString(16)+" ";}return"\\"+ch;},unloadHandler=function(){setDocument();},inDisabledFieldset=addCombinator(function(elem){return elem.disabled===true&&elem.nodeName.toLowerCase()==="fieldset";},{dir:"parentNode",next:"legend"});try{push.apply(arr=slice.call(preferredDoc.childNodes),preferredDoc.childNodes);arr[preferredDoc.childNodes.length].nodeType;}catch(e){push={apply:arr.length?function(target,els){pushNative.apply(target,slice.call(els));}:function(target,els){var j=target.length,i=0;while(target[j++]=els[i++]){}target.length=j-1;}};}function Sizzle(selector,context,results,seed){var m,i,elem,nid,match,groups,newSelector,newContext=context&&context.ownerDocument,nodeType=context?context.nodeType:9;results=results||[];if(typeof selector!=="string"||!selector||nodeType!==1&&nodeType!==9&&nodeType!==11){return results;}if(!seed){setDocument(context);context=context||document;if(documentIsHTML){if(nodeType!==11&&(match=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/.exec(selector))){if(m=match[1]){if(nodeType===9){if(elem=context.getElementById(m)){if(elem.id===m){results.push(elem);return results;}}else{return results;}}else{if(newContext&&(elem=newContext.getElementById(m))&&contains(context,elem)&&elem.id===m){results.push(elem);return results;}}}else if(match[2]){push.apply(results,context.getElementsByTagName(selector));return results;}else if((m=match[3])&&support.getElementsByClassName&&context.getElementsByClassName){push.apply(results,context.getElementsByClassName(m));return results;}}if(support.qsa&&!nonnativeSelectorCache[selector+" "]&&(!rbuggyQSA||!rbuggyQSA.test(selector))&&(nodeType!==1||context.nodeName.toLowerCase()!=="object")){newSelector=selector;newContext=context;if(nodeType===1&&(rdescend.test(selector)||rcombinators.test(selector))){newContext=rsibling.test(selector)&&testContext(context.parentNode)||context;if(newContext!==context||!support.scope){if(nid=context.getAttribute("id")){nid=nid.replace(rcssescape,fcssescape);}else{context.setAttribute("id",nid=expando);}}groups=tokenize(selector);i=groups.length;while(i--){groups[i]=(nid?"#"+nid:":scope")+" "+toSelector(groups[i]);}newSelector=groups.join(",");}try{push.apply(results,newContext.querySelectorAll(newSelector));return results;}catch(qsaError){nonnativeSelectorCache(selector,true);}finally{if(nid===expando){context.removeAttribute("id");}}}}}return select(selector.replace(rtrim,"$1"),context,results,seed);}function createCache(){var keys=[];function cache(key,value){if(keys.push(key+" ")>Expr.cacheLength){delete cache[keys.shift()];}return cache[key+" "]=value;}return cache;}function markFunction(fn){fn[expando]=true;return fn;}function assert(fn){var el=document.createElement("fieldset");try{return!!fn(el);}catch(e){return false;}finally{if(el.parentNode){el.parentNode.removeChild(el);}el=null;}}function addHandle(attrs,handler){var arr=attrs.split("|"),i=arr.length;while(i--){Expr.attrHandle[arr[i]]=handler;}}function siblingCheck(a,b){var cur=b&&a,diff=cur&&a.nodeType===1&&b.nodeType===1&&a.sourceIndex-b.sourceIndex;if(diff){return diff;}if(cur){while(cur=cur.nextSibling){if(cur===b){return-1;}}}return a?1:-1;}function createInputPseudo(type){return function(elem){var name=elem.nodeName.toLowerCase();return name==="input"&&elem.type===type;};}function createButtonPseudo(type){return function(elem){var name=elem.nodeName.toLowerCase();return(name==="input"||name==="button")&&elem.type===type;};}function createDisabledPseudo(disabled){return function(elem){if("form"in elem){if(elem.parentNode&&elem.disabled===false){if("label"in elem){if("label"in elem.parentNode){return elem.parentNode.disabled===disabled;}else{return elem.disabled===disabled;}}return elem.isDisabled===disabled||elem.isDisabled!==!disabled&&inDisabledFieldset(elem)===disabled;}return elem.disabled===disabled;}else if("label"in elem){return elem.disabled===disabled;}return false;};}function createPositionalPseudo(fn){return markFunction(function(argument){argument=+argument;return markFunction(function(seed,matches){var j,matchIndexes=fn([],seed.length,argument),i=matchIndexes.length;while(i--){if(seed[j=matchIndexes[i]]){seed[j]=!(matches[j]=seed[j]);}}});});}function testContext(context){return context&&typeof context.getElementsByTagName!=="undefined"&&context;}support=Sizzle.support={};isXML=Sizzle.isXML=function(elem){var namespace=elem&&elem.namespaceURI,docElem=elem&&(elem.ownerDocument||elem).documentElement;return!/HTML$/i.test(namespace||docElem&&docElem.nodeName||"HTML");};setDocument=Sizzle.setDocument=function(node){var hasCompare,subWindow,doc=node?node.ownerDocument||node:preferredDoc;if(doc==document||doc.nodeType!==9||!doc.documentElement){return document;}document=doc;docElem=document.documentElement;documentIsHTML=!isXML(document);if(preferredDoc!=document&&(subWindow=document.defaultView)&&subWindow.top!==subWindow){if(subWindow.addEventListener){subWindow.addEventListener("unload",unloadHandler,false);}else if(subWindow.attachEvent){subWindow.attachEvent("onunload",unloadHandler);}}support.scope=assert(function(el){docElem.appendChild(el).appendChild(document.createElement("div"));return typeof el.querySelectorAll!=="undefined"&&!el.querySelectorAll(":scope fieldset div").length;});support.attributes=assert(function(el){el.className="i";return!el.getAttribute("className");});support.getElementsByTagName=assert(function(el){el.appendChild(document.createComment(""));return!el.getElementsByTagName("*").length;});support.getElementsByClassName=rnative.test(document.getElementsByClassName);support.getById=assert(function(el){docElem.appendChild(el).id=expando;return!document.getElementsByName||!document.getElementsByName(expando).length;});if(support.getById){Expr.filter["ID"]=function(id){var attrId=id.replace(runescape,funescape);return function(elem){return elem.getAttribute("id")===attrId;};};Expr.find["ID"]=function(id,context){if(typeof context.getElementById!=="undefined"&&documentIsHTML){var elem=context.getElementById(id);return elem?[elem]:[];}};}else{Expr.filter["ID"]=function(id){var attrId=id.replace(runescape,funescape);return function(elem){var node=typeof elem.getAttributeNode!=="undefined"&&elem.getAttributeNode("id");return node&&node.value===attrId;};};Expr.find["ID"]=function(id,context){if(typeof context.getElementById!=="undefined"&&documentIsHTML){var node,i,elems,elem=context.getElementById(id);if(elem){node=elem.getAttributeNode("id");if(node&&node.value===id){return[elem];}elems=context.getElementsByName(id);i=0;while(elem=elems[i++]){node=elem.getAttributeNode("id");if(node&&node.value===id){return[elem];}}}return[];}};}Expr.find["TAG"]=support.getElementsByTagName?function(tag,context){if(typeof context.getElementsByTagName!=="undefined"){return context.getElementsByTagName(tag);}else if(support.qsa){return context.querySelectorAll(tag);}}:function(tag,context){var elem,tmp=[],i=0,results=context.getElementsByTagName(tag);if(tag==="*"){while(elem=results[i++]){if(elem.nodeType===1){tmp.push(elem);}}return tmp;}return results;};Expr.find["CLASS"]=support.getElementsByClassName&&function(className,context){if(typeof context.getElementsByClassName!=="undefined"&&documentIsHTML){return context.getElementsByClassName(className);}};rbuggyMatches=[];rbuggyQSA=[];if(support.qsa=rnative.test(document.querySelectorAll)){assert(function(el){var input;docElem.appendChild(el).innerHTML="<a id='"+expando+"'></a>"+"<select id='"+expando+"-\r\\' msallowcapture=''>"+"<option selected=''></option></select>";if(el.querySelectorAll("[msallowcapture^='']").length){rbuggyQSA.push("[*^$]="+whitespace+"*(?:''|\"\")");}if(!el.querySelectorAll("[selected]").length){rbuggyQSA.push("\\["+whitespace+"*(?:value|"+booleans+")");}if(!el.querySelectorAll("[id~="+expando+"-]").length){rbuggyQSA.push("~=");}input=document.createElement("input");input.setAttribute("name","");el.appendChild(input);if(!el.querySelectorAll("[name='']").length){rbuggyQSA.push("\\["+whitespace+"*name"+whitespace+"*="+whitespace+"*(?:''|\"\")");}if(!el.querySelectorAll(":checked").length){rbuggyQSA.push(":checked");}if(!el.querySelectorAll("a#"+expando+"+*").length){rbuggyQSA.push(".#.+[+~]");}el.querySelectorAll("\\\f");rbuggyQSA.push("[\\r\\n\\f]");});assert(function(el){el.innerHTML="<a href='' disabled='disabled'></a>"+"<select disabled='disabled'><option/></select>";var input=document.createElement("input");input.setAttribute("type","hidden");el.appendChild(input).setAttribute("name","D");if(el.querySelectorAll("[name=d]").length){rbuggyQSA.push("name"+whitespace+"*[*^$|!~]?=");}if(el.querySelectorAll(":enabled").length!==2){rbuggyQSA.push(":enabled",":disabled");}docElem.appendChild(el).disabled=true;if(el.querySelectorAll(":disabled").length!==2){rbuggyQSA.push(":enabled",":disabled");}el.querySelectorAll("*,:x");rbuggyQSA.push(",.*:");});}if(support.matchesSelector=rnative.test(matches=docElem.matches||docElem.webkitMatchesSelector||docElem.mozMatchesSelector||docElem.oMatchesSelector||docElem.msMatchesSelector)){assert(function(el){support.disconnectedMatch=matches.call(el,"*");matches.call(el,"[s!='']:x");rbuggyMatches.push("!=",pseudos);});}rbuggyQSA=rbuggyQSA.length&&new RegExp(rbuggyQSA.join("|"));rbuggyMatches=rbuggyMatches.length&&new RegExp(rbuggyMatches.join("|"));hasCompare=rnative.test(docElem.compareDocumentPosition);contains=hasCompare||rnative.test(docElem.contains)?function(a,b){var adown=a.nodeType===9?a.documentElement:a,bup=b&&b.parentNode;return a===bup||!!(bup&&bup.nodeType===1&&(adown.contains?adown.contains(bup):a.compareDocumentPosition&&a.compareDocumentPosition(bup)&16));}:function(a,b){if(b){while(b=b.parentNode){if(b===a){return true;}}}return false;};sortOrder=hasCompare?function(a,b){if(a===b){hasDuplicate=true;return 0;}var compare=!a.compareDocumentPosition-!b.compareDocumentPosition;if(compare){return compare;}compare=(a.ownerDocument||a)==(b.ownerDocument||b)?a.compareDocumentPosition(b):1;if(compare&1||!support.sortDetached&&b.compareDocumentPosition(a)===compare){if(a==document||a.ownerDocument==preferredDoc&&contains(preferredDoc,a)){return-1;}if(b==document||b.ownerDocument==preferredDoc&&contains(preferredDoc,b)){return 1;}return sortInput?indexOf(sortInput,a)-indexOf(sortInput,b):0;}return compare&4?-1:1;}:function(a,b){if(a===b){hasDuplicate=true;return 0;}var cur,i=0,aup=a.parentNode,bup=b.parentNode,ap=[a],bp=[b];if(!aup||!bup){return a==document?-1:b==document?1:aup?-1:bup?1:sortInput?indexOf(sortInput,a)-indexOf(sortInput,b):0;}else if(aup===bup){return siblingCheck(a,b);}cur=a;while(cur=cur.parentNode){ap.unshift(cur);}cur=b;while(cur=cur.parentNode){bp.unshift(cur);}while(ap[i]===bp[i]){i++;}return i?siblingCheck(ap[i],bp[i]):ap[i]==preferredDoc?-1:bp[i]==preferredDoc?1:0;};return document;};Sizzle.matches=function(expr,elements){return Sizzle(expr,null,null,elements);};Sizzle.matchesSelector=function(elem,expr){setDocument(elem);if(support.matchesSelector&&documentIsHTML&&!nonnativeSelectorCache[expr+" "]&&(!rbuggyMatches||!rbuggyMatches.test(expr))&&(!rbuggyQSA||!rbuggyQSA.test(expr))){try{var ret=matches.call(elem,expr);if(ret||support.disconnectedMatch||elem.document&&elem.document.nodeType!==11){return ret;}}catch(e){nonnativeSelectorCache(expr,true);}}return Sizzle(expr,document,null,[elem]).length>0;};Sizzle.contains=function(context,elem){if((context.ownerDocument||context)!=document){setDocument(context);}return contains(context,elem);};Sizzle.attr=function(elem,name){if((elem.ownerDocument||elem)!=document){setDocument(elem);}var fn=Expr.attrHandle[name.toLowerCase()],val=fn&&hasOwn.call(Expr.attrHandle,name.toLowerCase())?fn(elem,name,!documentIsHTML):undefined;return val!==undefined?val:support.attributes||!documentIsHTML?elem.getAttribute(name):(val=elem.getAttributeNode(name))&&val.specified?val.value:null;};Sizzle.escape=function(sel){return(sel+"").replace(rcssescape,fcssescape);};Sizzle.error=function(msg){throw new Error("Syntax error, unrecognized expression: "+msg);};Sizzle.uniqueSort=function(results){var elem,duplicates=[],j=0,i=0;hasDuplicate=!support.detectDuplicates;sortInput=!support.sortStable&&results.slice(0);results.sort(sortOrder);if(hasDuplicate){while(elem=results[i++]){if(elem===results[i]){j=duplicates.push(i);}}while(j--){results.splice(duplicates[j],1);}}sortInput=null;return results;};getText=Sizzle.getText=function(elem){var node,ret="",i=0,nodeType=elem.nodeType;if(!nodeType){while(node=elem[i++]){ret+=getText(node);}}else if(nodeType===1||nodeType===9||nodeType===11){if(typeof elem.textContent==="string"){return elem.textContent;}else{for(elem=elem.firstChild;elem;elem=elem.nextSibling){ret+=getText(elem);}}}else if(nodeType===3||nodeType===4){return elem.nodeValue;}return ret;};Expr=Sizzle.selectors={cacheLength:50,createPseudo:markFunction,match:matchExpr,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:true}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:true},"~":{dir:"previousSibling"}},preFilter:{"ATTR":function(match){match[1]=match[1].replace(runescape,funescape);match[3]=(match[3]||match[4]||match[5]||"").replace(runescape,funescape);if(match[2]==="~="){match[3]=" "+match[3]+" ";}return match.slice(0,4);},"CHILD":function(match){match[1]=match[1].toLowerCase();if(match[1].slice(0,3)==="nth"){if(!match[3]){Sizzle.error(match[0]);}match[4]=+(match[4]?match[5]+(match[6]||1):2*(match[3]==="even"||match[3]==="odd"));match[5]=+(match[7]+match[8]||match[3]==="odd");}else if(match[3]){Sizzle.error(match[0]);}return match;},"PSEUDO":function(match){var excess,unquoted=!match[6]&&match[2];if(matchExpr["CHILD"].test(match[0])){return null;}if(match[3]){match[2]=match[4]||match[5]||"";}else if(unquoted&&rpseudo.test(unquoted)&&(excess=tokenize(unquoted,true))&&(excess=unquoted.indexOf(")",unquoted.length-excess)-unquoted.length)){match[0]=match[0].slice(0,excess);match[2]=unquoted.slice(0,excess);}return match.slice(0,3);}},filter:{"TAG":function(nodeNameSelector){var nodeName=nodeNameSelector.replace(runescape,funescape).toLowerCase();return nodeNameSelector==="*"?function(){return true;}:function(elem){return elem.nodeName&&elem.nodeName.toLowerCase()===nodeName;};},"CLASS":function(className){var pattern=classCache[className+" "];return pattern||(pattern=new RegExp("(^|"+whitespace+")"+className+"("+whitespace+"|$)"))&&classCache(className,function(elem){return pattern.test(typeof elem.className==="string"&&elem.className||typeof elem.getAttribute!=="undefined"&&elem.getAttribute("class")||"");});},"ATTR":function(name,operator,check){return function(elem){var result=Sizzle.attr(elem,name);if(result==null){return operator==="!=";}if(!operator){return true;}result+="";return operator==="="?result===check:operator==="!="?result!==check:operator==="^="?check&&result.indexOf(check)===0:operator==="*="?check&&result.indexOf(check)>-1:operator==="$="?check&&result.slice(-check.length)===check:operator==="~="?(" "+result.replace(rwhitespace," ")+" ").indexOf(check)>-1:operator==="|="?result===check||result.slice(0,check.length+1)===check+"-":false;};},"CHILD":function(type,what,_argument,first,last){var simple=type.slice(0,3)!=="nth",forward=type.slice(-4)!=="last",ofType=what==="of-type";return first===1&&last===0?function(elem){return!!elem.parentNode;}:function(elem,_context,xml){var cache,uniqueCache,outerCache,node,nodeIndex,start,dir=simple!==forward?"nextSibling":"previousSibling",parent=elem.parentNode,name=ofType&&elem.nodeName.toLowerCase(),useCache=!xml&&!ofType,diff=false;if(parent){if(simple){while(dir){node=elem;while(node=node[dir]){if(ofType?node.nodeName.toLowerCase()===name:node.nodeType===1){return false;}}start=dir=type==="only"&&!start&&"nextSibling";}return true;}start=[forward?parent.firstChild:parent.lastChild];if(forward&&useCache){node=parent;outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});cache=uniqueCache[type]||[];nodeIndex=cache[0]===dirruns&&cache[1];diff=nodeIndex&&cache[2];node=nodeIndex&&parent.childNodes[nodeIndex];while(node=++nodeIndex&&node&&node[dir]||(diff=nodeIndex=0)||start.pop()){if(node.nodeType===1&&++diff&&node===elem){uniqueCache[type]=[dirruns,nodeIndex,diff];break;}}}else{if(useCache){node=elem;outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});cache=uniqueCache[type]||[];nodeIndex=cache[0]===dirruns&&cache[1];diff=nodeIndex;}if(diff===false){while(node=++nodeIndex&&node&&node[dir]||(diff=nodeIndex=0)||start.pop()){if((ofType?node.nodeName.toLowerCase()===name:node.nodeType===1)&&++diff){if(useCache){outerCache=node[expando]||(node[expando]={});uniqueCache=outerCache[node.uniqueID]||(outerCache[node.uniqueID]={});uniqueCache[type]=[dirruns,diff];}if(node===elem){break;}}}}}diff-=last;return diff===first||diff%first===0&&diff/first>=0;}};},"PSEUDO":function(pseudo,argument){var args,fn=Expr.pseudos[pseudo]||Expr.setFilters[pseudo.toLowerCase()]||Sizzle.error("unsupported pseudo: "+pseudo);if(fn[expando]){return fn(argument);}if(fn.length>1){args=[pseudo,pseudo,"",argument];return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())?markFunction(function(seed,matches){var idx,matched=fn(seed,argument),i=matched.length;while(i--){idx=indexOf(seed,matched[i]);seed[idx]=!(matches[idx]=matched[i]);}}):function(elem){return fn(elem,0,args);};}return fn;}},pseudos:{"not":markFunction(function(selector){var input=[],results=[],matcher=compile(selector.replace(rtrim,"$1"));return matcher[expando]?markFunction(function(seed,matches,_context,xml){var elem,unmatched=matcher(seed,null,xml,[]),i=seed.length;while(i--){if(elem=unmatched[i]){seed[i]=!(matches[i]=elem);}}}):function(elem,_context,xml){input[0]=elem;matcher(input,null,xml,results);input[0]=null;return!results.pop();};}),"has":markFunction(function(selector){return function(elem){return Sizzle(selector,elem).length>0;};}),"contains":markFunction(function(text){text=text.replace(runescape,funescape);return function(elem){return(elem.textContent||getText(elem)).indexOf(text)>-1;};}),"lang":markFunction(function(lang){if(!ridentifier.test(lang||"")){Sizzle.error("unsupported lang: "+lang);}lang=lang.replace(runescape,funescape).toLowerCase();return function(elem){var elemLang;do{if(elemLang=documentIsHTML?elem.lang:elem.getAttribute("xml:lang")||elem.getAttribute("lang")){elemLang=elemLang.toLowerCase();return elemLang===lang||elemLang.indexOf(lang+"-")===0;}}while((elem=elem.parentNode)&&elem.nodeType===1);return false;};}),"target":function(elem){var hash=window.location&&window.location.hash;return hash&&hash.slice(1)===elem.id;},"root":function(elem){return elem===docElem;},"focus":function(elem){return elem===document.activeElement&&(!document.hasFocus||document.hasFocus())&&!!(elem.type||elem.href||~elem.tabIndex);},"enabled":createDisabledPseudo(false),"disabled":createDisabledPseudo(true),"checked":function(elem){var nodeName=elem.nodeName.toLowerCase();return nodeName==="input"&&!!elem.checked||nodeName==="option"&&!!elem.selected;},"selected":function(elem){if(elem.parentNode){elem.parentNode.selectedIndex;}return elem.selected===true;},"empty":function(elem){for(elem=elem.firstChild;elem;elem=elem.nextSibling){if(elem.nodeType<6){return false;}}return true;},"parent":function(elem){return!Expr.pseudos["empty"](elem);},"header":function(elem){return /^h\d$/i.test(elem.nodeName);},"input":function(elem){return /^(?:input|select|textarea|button)$/i.test(elem.nodeName);},"button":function(elem){var name=elem.nodeName.toLowerCase();return name==="input"&&elem.type==="button"||name==="button";},"text":function(elem){var attr;return elem.nodeName.toLowerCase()==="input"&&elem.type==="text"&&((attr=elem.getAttribute("type"))==null||attr.toLowerCase()==="text");},"first":createPositionalPseudo(function(){return[0];}),"last":createPositionalPseudo(function(_matchIndexes,length){return[length-1];}),"eq":createPositionalPseudo(function(_matchIndexes,length,argument){return[argument<0?argument+length:argument];}),"even":createPositionalPseudo(function(matchIndexes,length){var i=0;for(;i<length;i+=2){matchIndexes.push(i);}return matchIndexes;}),"odd":createPositionalPseudo(function(matchIndexes,length){var i=1;for(;i<length;i+=2){matchIndexes.push(i);}return matchIndexes;}),"lt":createPositionalPseudo(function(matchIndexes,length,argument){var i=argument<0?argument+length:argument>length?length:argument;for(;--i>=0;){matchIndexes.push(i);}return matchIndexes;}),"gt":createPositionalPseudo(function(matchIndexes,length,argument){var i=argument<0?argument+length:argument;for(;++i<length;){matchIndexes.push(i);}return matchIndexes;})}};Expr.pseudos["nth"]=Expr.pseudos["eq"];for(i in{radio:true,checkbox:true,file:true,password:true,image:true}){Expr.pseudos[i]=createInputPseudo(i);}for(i in{submit:true,reset:true}){Expr.pseudos[i]=createButtonPseudo(i);}function setFilters(){}setFilters.prototype=Expr.filters=Expr.pseudos;Expr.setFilters=new setFilters();tokenize=Sizzle.tokenize=function(selector,parseOnly){var matched,match,tokens,type,soFar,groups,preFilters,cached=tokenCache[selector+" "];if(cached){return parseOnly?0:cached.slice(0);}soFar=selector;groups=[];preFilters=Expr.preFilter;while(soFar){if(!matched||(match=rcomma.exec(soFar))){if(match){soFar=soFar.slice(match[0].length)||soFar;}groups.push(tokens=[]);}matched=false;if(match=rcombinators.exec(soFar)){matched=match.shift();tokens.push({value:matched,type:match[0].replace(rtrim," ")});soFar=soFar.slice(matched.length);}for(type in Expr.filter){if((match=matchExpr[type].exec(soFar))&&(!preFilters[type]||(match=preFilters[type](match)))){matched=match.shift();tokens.push({value:matched,type:type,matches:match});soFar=soFar.slice(matched.length);}}if(!matched){break;}}return parseOnly?soFar.length:soFar?Sizzle.error(selector):tokenCache(selector,groups).slice(0);};function toSelector(tokens){var i=0,len=tokens.length,selector="";for(;i<len;i++){selector+=tokens[i].value;}return selector;}function addCombinator(matcher,combinator,base){var dir=combinator.dir,skip=combinator.next,key=skip||dir,checkNonElements=base&&key==="parentNode",doneName=done++;return combinator.first?function(elem,context,xml){while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){return matcher(elem,context,xml);}}return false;}:function(elem,context,xml){var oldCache,uniqueCache,outerCache,newCache=[dirruns,doneName];if(xml){while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){if(matcher(elem,context,xml)){return true;}}}}else{while(elem=elem[dir]){if(elem.nodeType===1||checkNonElements){outerCache=elem[expando]||(elem[expando]={});uniqueCache=outerCache[elem.uniqueID]||(outerCache[elem.uniqueID]={});if(skip&&skip===elem.nodeName.toLowerCase()){elem=elem[dir]||elem;}else if((oldCache=uniqueCache[key])&&oldCache[0]===dirruns&&oldCache[1]===doneName){return newCache[2]=oldCache[2];}else{uniqueCache[key]=newCache;if(newCache[2]=matcher(elem,context,xml)){return true;}}}}}return false;};}function elementMatcher(matchers){return matchers.length>1?function(elem,context,xml){var i=matchers.length;while(i--){if(!matchers[i](elem,context,xml)){return false;}}return true;}:matchers[0];}function multipleContexts(selector,contexts,results){var i=0,len=contexts.length;for(;i<len;i++){Sizzle(selector,contexts[i],results);}return results;}function condense(unmatched,map,filter,context,xml){var elem,newUnmatched=[],i=0,len=unmatched.length;for(;i<len;i++){if(elem=unmatched[i]){if(!filter||filter(elem,context,xml)){newUnmatched.push(elem);if(map!=null){map.push(i);}}}}return newUnmatched;}function setMatcher(preFilter,selector,matcher,postFilter,postFinder,postSelector){if(postFilter&&!postFilter[expando]){postFilter=setMatcher(postFilter);}if(postFinder&&!postFinder[expando]){postFinder=setMatcher(postFinder,postSelector);}return markFunction(function(seed,results,context,xml){var temp,i,elem,preMap=[],postMap=[],preexisting=results.length,elems=seed||multipleContexts(selector||"*",context.nodeType?[context]:context,[]),matcherIn=preFilter&&(seed||!selector)?condense(elems,preMap,preFilter,context,xml):elems,matcherOut=matcher?postFinder||(seed?preFilter:preexisting||postFilter)?[]:results:matcherIn;if(matcher){matcher(matcherIn,matcherOut,context,xml);}if(postFilter){temp=condense(matcherOut,postMap);postFilter(temp,[],context,xml);i=temp.length;while(i--){if(elem=temp[i]){matcherOut[postMap[i]]=!(matcherIn[postMap[i]]=elem);}}}if(seed){if(postFinder||preFilter){if(postFinder){temp=[];i=matcherOut.length;while(i--){if(elem=matcherOut[i]){temp.push(matcherIn[i]=elem);}}postFinder(null,matcherOut=[],temp,xml);}i=matcherOut.length;while(i--){if((elem=matcherOut[i])&&(temp=postFinder?indexOf(seed,elem):preMap[i])>-1){seed[temp]=!(results[temp]=elem);}}}}else{matcherOut=condense(matcherOut===results?matcherOut.splice(preexisting,matcherOut.length):matcherOut);if(postFinder){postFinder(null,results,matcherOut,xml);}else{push.apply(results,matcherOut);}}});}function matcherFromTokens(tokens){var checkContext,matcher,j,len=tokens.length,leadingRelative=Expr.relative[tokens[0].type],implicitRelative=leadingRelative||Expr.relative[" "],i=leadingRelative?1:0,matchContext=addCombinator(function(elem){return elem===checkContext;},implicitRelative,true),matchAnyContext=addCombinator(function(elem){return indexOf(checkContext,elem)>-1;},implicitRelative,true),matchers=[function(elem,context,xml){var ret=!leadingRelative&&(xml||context!==outermostContext)||((checkContext=context).nodeType?matchContext(elem,context,xml):matchAnyContext(elem,context,xml));checkContext=null;return ret;}];for(;i<len;i++){if(matcher=Expr.relative[tokens[i].type]){matchers=[addCombinator(elementMatcher(matchers),matcher)];}else{matcher=Expr.filter[tokens[i].type].apply(null,tokens[i].matches);if(matcher[expando]){j=++i;for(;j<len;j++){if(Expr.relative[tokens[j].type]){break;}}return setMatcher(i>1&&elementMatcher(matchers),i>1&&toSelector(tokens.slice(0,i-1).concat({value:tokens[i-2].type===" "?"*":""})).replace(rtrim,"$1"),matcher,i<j&&matcherFromTokens(tokens.slice(i,j)),j<len&&matcherFromTokens(tokens=tokens.slice(j)),j<len&&toSelector(tokens));}matchers.push(matcher);}}return elementMatcher(matchers);}function matcherFromGroupMatchers(elementMatchers,setMatchers){var bySet=setMatchers.length>0,byElement=elementMatchers.length>0,superMatcher=function(seed,context,xml,results,outermost){var elem,j,matcher,matchedCount=0,i="0",unmatched=seed&&[],setMatched=[],contextBackup=outermostContext,elems=seed||byElement&&Expr.find["TAG"]("*",outermost),dirrunsUnique=dirruns+=contextBackup==null?1:Math.random()||0.1,len=elems.length;if(outermost){outermostContext=context==document||context||outermost;}for(;i!==len&&(elem=elems[i])!=null;i++){if(byElement&&elem){j=0;if(!context&&elem.ownerDocument!=document){setDocument(elem);xml=!documentIsHTML;}while(matcher=elementMatchers[j++]){if(matcher(elem,context||document,xml)){results.push(elem);break;}}if(outermost){dirruns=dirrunsUnique;}}if(bySet){if(elem=!matcher&&elem){matchedCount--;}if(seed){unmatched.push(elem);}}}matchedCount+=i;if(bySet&&i!==matchedCount){j=0;while(matcher=setMatchers[j++]){matcher(unmatched,setMatched,context,xml);}if(seed){if(matchedCount>0){while(i--){if(!(unmatched[i]||setMatched[i])){setMatched[i]=pop.call(results);}}}setMatched=condense(setMatched);}push.apply(results,setMatched);if(outermost&&!seed&&setMatched.length>0&&matchedCount+setMatchers.length>1){Sizzle.uniqueSort(results);}}if(outermost){dirruns=dirrunsUnique;outermostContext=contextBackup;}return unmatched;};return bySet?markFunction(superMatcher):superMatcher;}compile=Sizzle.compile=function(selector,match){var i,setMatchers=[],elementMatchers=[],cached=compilerCache[selector+" "];if(!cached){if(!match){match=tokenize(selector);}i=match.length;while(i--){cached=matcherFromTokens(match[i]);if(cached[expando]){setMatchers.push(cached);}else{elementMatchers.push(cached);}}cached=compilerCache(selector,matcherFromGroupMatchers(elementMatchers,setMatchers));cached.selector=selector;}return cached;};select=Sizzle.select=function(selector,context,results,seed){var i,tokens,token,type,find,compiled=typeof selector==="function"&&selector,match=!seed&&tokenize(selector=compiled.selector||selector);results=results||[];if(match.length===1){tokens=match[0]=match[0].slice(0);if(tokens.length>2&&(token=tokens[0]).type==="ID"&&context.nodeType===9&&documentIsHTML&&Expr.relative[tokens[1].type]){context=(Expr.find["ID"](token.matches[0].replace(runescape,funescape),context)||[])[0];if(!context){return results;}else if(compiled){context=context.parentNode;}selector=selector.slice(tokens.shift().value.length);}i=matchExpr["needsContext"].test(selector)?0:tokens.length;while(i--){token=tokens[i];if(Expr.relative[type=token.type]){break;}if(find=Expr.find[type]){if(seed=find(token.matches[0].replace(runescape,funescape),rsibling.test(tokens[0].type)&&testContext(context.parentNode)||context)){tokens.splice(i,1);selector=seed.length&&toSelector(tokens);if(!selector){push.apply(results,seed);return results;}break;}}}}(compiled||compile(selector,match))(seed,context,!documentIsHTML,results,!context||rsibling.test(selector)&&testContext(context.parentNode)||context);return results;};support.sortStable=expando.split("").sort(sortOrder).join("")===expando;support.detectDuplicates=!!hasDuplicate;setDocument();support.sortDetached=assert(function(el){return el.compareDocumentPosition(document.createElement("fieldset"))&1;});if(!assert(function(el){el.innerHTML="<a href='#'></a>";return el.firstChild.getAttribute("href")==="#";})){addHandle("type|href|height|width",function(elem,name,isXML){if(!isXML){return elem.getAttribute(name,name.toLowerCase()==="type"?1:2);}});}if(!support.attributes||!assert(function(el){el.innerHTML="<input/>";el.firstChild.setAttribute("value","");return el.firstChild.getAttribute("value")==="";})){addHandle("value",function(elem,_name,isXML){if(!isXML&&elem.nodeName.toLowerCase()==="input"){return elem.defaultValue;}});}if(!assert(function(el){return el.getAttribute("disabled")==null;})){addHandle(booleans,function(elem,name,isXML){var val;if(!isXML){return elem[name]===true?name.toLowerCase():(val=elem.getAttributeNode(name))&&val.specified?val.value:null;}});}return Sizzle;}(window);jQuery.find=Sizzle;jQuery.expr=Sizzle.selectors;jQuery.expr[":"]=jQuery.expr.pseudos;jQuery.uniqueSort=jQuery.unique=Sizzle.uniqueSort;jQuery.text=Sizzle.getText;jQuery.isXMLDoc=Sizzle.isXML;jQuery.contains=Sizzle.contains;jQuery.escapeSelector=Sizzle.escape;var dir=function(elem,dir,until){var matched=[],truncate=until!==undefined;while((elem=elem[dir])&&elem.nodeType!==9){if(elem.nodeType===1){if(truncate&&jQuery(elem).is(until)){break;}matched.push(elem);}}return matched;};var siblings=function(n,elem){var matched=[];for(;n;n=n.nextSibling){if(n.nodeType===1&&n!==elem){matched.push(n);}}return matched;};var rneedsContext=jQuery.expr.match.needsContext;function nodeName(elem,name){return elem.nodeName&&elem.nodeName.toLowerCase()===name.toLowerCase();}var rsingleTag=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function winnow(elements,qualifier,not){if(isFunction(qualifier)){return jQuery.grep(elements,function(elem,i){return!!qualifier.call(elem,i,elem)!==not;});}if(qualifier.nodeType){return jQuery.grep(elements,function(elem){return elem===qualifier!==not;});}if(typeof qualifier!=="string"){return jQuery.grep(elements,function(elem){return indexOf.call(qualifier,elem)>-1!==not;});}return jQuery.filter(qualifier,elements,not);}jQuery.filter=function(expr,elems,not){var elem=elems[0];if(not){expr=":not("+expr+")";}if(elems.length===1&&elem.nodeType===1){return jQuery.find.matchesSelector(elem,expr)?[elem]:[];}return jQuery.find.matches(expr,jQuery.grep(elems,function(elem){return elem.nodeType===1;}));};jQuery.fn.extend({find:function(selector){var i,ret,len=this.length,self=this;if(typeof selector!=="string"){return this.pushStack(jQuery(selector).filter(function(){for(i=0;i<len;i++){if(jQuery.contains(self[i],this)){return true;}}}));}ret=this.pushStack([]);for(i=0;i<len;i++){jQuery.find(selector,self[i],ret);}return len>1?jQuery.uniqueSort(ret):ret;},filter:function(selector){return this.pushStack(winnow(this,selector||[],false));},not:function(selector){return this.pushStack(winnow(this,selector||[],true));},is:function(selector){return!!winnow(this,typeof selector==="string"&&rneedsContext.test(selector)?jQuery(selector):selector||[],false).length;}});var rootjQuery,init=jQuery.fn.init=function(selector,context,root){var match,elem;if(!selector){return this;}root=root||rootjQuery;if(typeof selector==="string"){if(selector[0]==="<"&&selector[selector.length-1]===">"&&selector.length>=3){match=[null,selector,null];}else{match=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/.exec(selector);}if(match&&(match[1]||!context)){if(match[1]){context=context instanceof jQuery?context[0]:context;jQuery.merge(this,jQuery.parseHTML(match[1],context&&context.nodeType?context.ownerDocument||context:document,true));if(rsingleTag.test(match[1])&&jQuery.isPlainObject(context)){for(match in context){if(isFunction(this[match])){this[match](context[match]);}else{this.attr(match,context[match]);}}}return this;}else{elem=document.getElementById(match[2]);if(elem){this[0]=elem;this.length=1;}return this;}}else if(!context||context.jquery){return(context||root).find(selector);}else{return this.constructor(context).find(selector);}}else if(selector.nodeType){this[0]=selector;this.length=1;return this;}else if(isFunction(selector)){return root.ready!==undefined?root.ready(selector):selector(jQuery);}return jQuery.makeArray(selector,this);};init.prototype=jQuery.fn;rootjQuery=jQuery(document);var guaranteedUnique={children:true,contents:true,next:true,prev:true};jQuery.fn.extend({has:function(target){var targets=jQuery(target,this),l=targets.length;return this.filter(function(){var i=0;for(;i<l;i++){if(jQuery.contains(this,targets[i])){return true;}}});},closest:function(selectors,context){var cur,i=0,l=this.length,matched=[],targets=typeof selectors!=="string"&&jQuery(selectors);if(!rneedsContext.test(selectors)){for(;i<l;i++){for(cur=this[i];cur&&cur!==context;cur=cur.parentNode){if(cur.nodeType<11&&(targets?targets.index(cur)>-1:cur.nodeType===1&&jQuery.find.matchesSelector(cur,selectors))){matched.push(cur);break;}}}}return this.pushStack(matched.length>1?jQuery.uniqueSort(matched):matched);},index:function(elem){if(!elem){return this[0]&&this[0].parentNode?this.first().prevAll().length:-1;}if(typeof elem==="string"){return indexOf.call(jQuery(elem),this[0]);}return indexOf.call(this,elem.jquery?elem[0]:elem);},add:function(selector,context){return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(),jQuery(selector,context))));},addBack:function(selector){return this.add(selector==null?this.prevObject:this.prevObject.filter(selector));}});function sibling(cur,dir){while((cur=cur[dir])&&cur.nodeType!==1){}return cur;}jQuery.each({parent:function(elem){var parent=elem.parentNode;return parent&&parent.nodeType!==11?parent:null;},parents:function(elem){return dir(elem,"parentNode");},parentsUntil:function(elem,_i,until){return dir(elem,"parentNode",until);},next:function(elem){return sibling(elem,"nextSibling");},prev:function(elem){return sibling(elem,"previousSibling");},nextAll:function(elem){return dir(elem,"nextSibling");},prevAll:function(elem){return dir(elem,"previousSibling");},nextUntil:function(elem,_i,until){return dir(elem,"nextSibling",until);},prevUntil:function(elem,_i,until){return dir(elem,"previousSibling",until);},siblings:function(elem){return siblings((elem.parentNode||{}).firstChild,elem);},children:function(elem){return siblings(elem.firstChild);},contents:function(elem){if(elem.contentDocument!=null&&getProto(elem.contentDocument)){return elem.contentDocument;}if(nodeName(elem,"template")){elem=elem.content||elem;}return jQuery.merge([],elem.childNodes);}},function(name,fn){jQuery.fn[name]=function(until,selector){var matched=jQuery.map(this,fn,until);if(name.slice(-5)!=="Until"){selector=until;}if(selector&&typeof selector==="string"){matched=jQuery.filter(selector,matched);}if(this.length>1){if(!guaranteedUnique[name]){jQuery.uniqueSort(matched);}if(/^(?:parents|prev(?:Until|All))/.test(name)){matched.reverse();}}return this.pushStack(matched);};});var rnothtmlwhite=/[^\x20\t\r\n\f]+/g;function createOptions(options){var object={};jQuery.each(options.match(rnothtmlwhite)||[],function(_,flag){object[flag]=true;});return object;}jQuery.Callbacks=function(options){options=typeof options==="string"?createOptions(options):jQuery.extend({},options);var firing,memory,fired,locked,list=[],queue=[],firingIndex=-1,fire=function(){locked=locked||options.once;fired=firing=true;for(;queue.length;firingIndex=-1){memory=queue.shift();while(++firingIndex<list.length){if(list[firingIndex].apply(memory[0],memory[1])===false&&options.stopOnFalse){firingIndex=list.length;memory=false;}}}if(!options.memory){memory=false;}firing=false;if(locked){if(memory){list=[];}else{list="";}}},self={add:function(){if(list){if(memory&&!firing){firingIndex=list.length-1;queue.push(memory);}(function add(args){jQuery.each(args,function(_,arg){if(isFunction(arg)){if(!options.unique||!self.has(arg)){list.push(arg);}}else if(arg&&arg.length&&toType(arg)!=="string"){add(arg);}});})(arguments);if(memory&&!firing){fire();}}return this;},remove:function(){jQuery.each(arguments,function(_,arg){var index;while((index=jQuery.inArray(arg,list,index))>-1){list.splice(index,1);if(index<=firingIndex){firingIndex--;}}});return this;},has:function(fn){return fn?jQuery.inArray(fn,list)>-1:list.length>0;},empty:function(){if(list){list=[];}return this;},disable:function(){locked=queue=[];list=memory="";return this;},disabled:function(){return!list;},lock:function(){locked=queue=[];if(!memory&&!firing){list=memory="";}return this;},locked:function(){return!!locked;},fireWith:function(context,args){if(!locked){args=args||[];args=[context,args.slice?args.slice():args];queue.push(args);if(!firing){fire();}}return this;},fire:function(){self.fireWith(this,arguments);return this;},fired:function(){return!!fired;}};return self;};function Identity(v){return v;}function Thrower(ex){throw ex;}function adoptValue(value,resolve,reject,noValue){var method;try{if(value&&isFunction(method=value.promise)){method.call(value).done(resolve).fail(reject);}else if(value&&isFunction(method=value.then)){method.call(value,resolve,reject);}else{resolve.apply(undefined,[value].slice(noValue));}}catch(value){reject.apply(undefined,[value]);}}jQuery.extend({Deferred:function(func){var tuples=[["notify","progress",jQuery.Callbacks("memory"),jQuery.Callbacks("memory"),2],["resolve","done",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),0,"resolved"],["reject","fail",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),1,"rejected"]],state="pending",promise={state:function(){return state;},always:function(){deferred.done(arguments).fail(arguments);return this;},"catch":function(fn){return promise.then(null,fn);},pipe:function(){var fns=arguments;return jQuery.Deferred(function(newDefer){jQuery.each(tuples,function(_i,tuple){var fn=isFunction(fns[tuple[4]])&&fns[tuple[4]];deferred[tuple[1]](function(){var returned=fn&&fn.apply(this,arguments);if(returned&&isFunction(returned.promise)){returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);}else{newDefer[tuple[0]+"With"](this,fn?[returned]:arguments);}});});fns=null;}).promise();},then:function(onFulfilled,onRejected,onProgress){var maxDepth=0;function resolve(depth,deferred,handler,special){return function(){var that=this,args=arguments,mightThrow=function(){var returned,then;if(depth<maxDepth){return;}returned=handler.apply(that,args);if(returned===deferred.promise()){throw new TypeError("Thenable self-resolution");}then=returned&&(typeof returned==="object"||typeof returned==="function")&&returned.then;if(isFunction(then)){if(special){then.call(returned,resolve(maxDepth,deferred,Identity,special),resolve(maxDepth,deferred,Thrower,special));}else{maxDepth++;then.call(returned,resolve(maxDepth,deferred,Identity,special),resolve(maxDepth,deferred,Thrower,special),resolve(maxDepth,deferred,Identity,deferred.notifyWith));}}else{if(handler!==Identity){that=undefined;args=[returned];}(special||deferred.resolveWith)(that,args);}},process=special?mightThrow:function(){try{mightThrow();}catch(e){if(jQuery.Deferred.exceptionHook){jQuery.Deferred.exceptionHook(e,process.stackTrace);}if(depth+1>=maxDepth){if(handler!==Thrower){that=undefined;args=[e];}deferred.rejectWith(that,args);}}};if(depth){process();}else{if(jQuery.Deferred.getStackHook){process.stackTrace=jQuery.Deferred.getStackHook();}window.setTimeout(process);}};}return jQuery.Deferred(function(newDefer){tuples[0][3].add(resolve(0,newDefer,isFunction(onProgress)?onProgress:Identity,newDefer.notifyWith));tuples[1][3].add(resolve(0,newDefer,isFunction(onFulfilled)?onFulfilled:Identity));tuples[2][3].add(resolve(0,newDefer,isFunction(onRejected)?onRejected:Thrower));}).promise();},promise:function(obj){return obj!=null?jQuery.extend(obj,promise):promise;}},deferred={};jQuery.each(tuples,function(i,tuple){var list=tuple[2],stateString=tuple[5];promise[tuple[1]]=list.add;if(stateString){list.add(function(){state=stateString;},tuples[3-i][2].disable,tuples[3-i][3].disable,tuples[0][2].lock,tuples[0][3].lock);}list.add(tuple[3].fire);deferred[tuple[0]]=function(){deferred[tuple[0]+"With"](this===deferred?undefined:this,arguments);return this;};deferred[tuple[0]+"With"]=list.fireWith;});promise.promise(deferred);if(func){func.call(deferred,deferred);}return deferred;},when:function(singleValue){var remaining=arguments.length,i=remaining,resolveContexts=Array(i),resolveValues=slice.call(arguments),primary=jQuery.Deferred(),updateFunc=function(i){return function(value){resolveContexts[i]=this;resolveValues[i]=arguments.length>1?slice.call(arguments):value;if(! --remaining){primary.resolveWith(resolveContexts,resolveValues);}};};if(remaining<=1){adoptValue(singleValue,primary.done(updateFunc(i)).resolve,primary.reject,!remaining);if(primary.state()==="pending"||isFunction(resolveValues[i]&&resolveValues[i].then)){return primary.then();}}while(i--){adoptValue(resolveValues[i],updateFunc(i),primary.reject);}return primary.promise();}});jQuery.Deferred.exceptionHook=function(error,stack){if(window.console&&window.console.warn&&error&&/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/.test(error.name)){window.console.warn("jQuery.Deferred exception: "+error.message,error.stack,stack);}};jQuery.readyException=function(error){window.setTimeout(function(){throw error;});};var readyList=jQuery.Deferred();jQuery.fn.ready=function(fn){readyList.then(fn).catch(function(error){jQuery.readyException(error);});return this;};jQuery.extend({isReady:false,readyWait:1,ready:function(wait){if(wait===true?--jQuery.readyWait:jQuery.isReady){return;}jQuery.isReady=true;if(wait!==true&&--jQuery.readyWait>0){return;}readyList.resolveWith(document,[jQuery]);}});jQuery.ready.then=readyList.then;function completed(){document.removeEventListener("DOMContentLoaded",completed);window.removeEventListener("load",completed);jQuery.ready();}if(document.readyState==="complete"||document.readyState!=="loading"&&!document.documentElement.doScroll){window.setTimeout(jQuery.ready);}else{document.addEventListener("DOMContentLoaded",completed);window.addEventListener("load",completed);}var access=function(elems,fn,key,value,chainable,emptyGet,raw){var i=0,len=elems.length,bulk=key==null;if(toType(key)==="object"){chainable=true;for(i in key){access(elems,fn,i,key[i],true,emptyGet,raw);}}else if(value!==undefined){chainable=true;if(!isFunction(value)){raw=true;}if(bulk){if(raw){fn.call(elems,value);fn=null;}else{bulk=fn;fn=function(elem,_key,value){return bulk.call(jQuery(elem),value);};}}if(fn){for(;i<len;i++){fn(elems[i],key,raw?value:value.call(elems[i],i,fn(elems[i],key)));}}}if(chainable){return elems;}if(bulk){return fn.call(elems);}return len?fn(elems[0],key):emptyGet;};function fcamelCase(_all,letter){return letter.toUpperCase();}function camelCase(string){return string.replace(/^-ms-/,"ms-").replace(/-([a-z])/g,fcamelCase);}var acceptData=function(owner){return owner.nodeType===1||owner.nodeType===9||!+owner.nodeType;};function Data(){this.expando=jQuery.expando+Data.uid++;}Data.uid=1;Data.prototype={cache:function(owner){var value=owner[this.expando];if(!value){value={};if(acceptData(owner)){if(owner.nodeType){owner[this.expando]=value;}else{Object.defineProperty(owner,this.expando,{value:value,configurable:true});}}}return value;},set:function(owner,data,value){var prop,cache=this.cache(owner);if(typeof data==="string"){cache[camelCase(data)]=value;}else{for(prop in data){cache[camelCase(prop)]=data[prop];}}return cache;},get:function(owner,key){return key===undefined?this.cache(owner):owner[this.expando]&&owner[this.expando][camelCase(key)];},access:function(owner,key,value){if(key===undefined||key&&typeof key==="string"&&value===undefined){return this.get(owner,key);}this.set(owner,key,value);return value!==undefined?value:key;},remove:function(owner,key){var i,cache=owner[this.expando];if(cache===undefined){return;}if(key!==undefined){if(Array.isArray(key)){key=key.map(camelCase);}else{key=camelCase(key);key=key in cache?[key]:key.match(rnothtmlwhite)||[];}i=key.length;while(i--){delete cache[key[i]];}}if(key===undefined||jQuery.isEmptyObject(cache)){if(owner.nodeType){owner[this.expando]=undefined;}else{delete owner[this.expando];}}},hasData:function(owner){var cache=owner[this.expando];return cache!==undefined&&!jQuery.isEmptyObject(cache);}};var dataPriv=new Data();var dataUser=new Data();function getData(data){if(data==="true"){return true;}if(data==="false"){return false;}if(data==="null"){return null;}if(data===+data+""){return+data;}if(/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/.test(data)){return JSON.parse(data);}return data;}function dataAttr(elem,key,data){var name;if(data===undefined&&elem.nodeType===1){name="data-"+key.replace(/[A-Z]/g,"-$&").toLowerCase();data=elem.getAttribute(name);if(typeof data==="string"){try{data=getData(data);}catch(e){}dataUser.set(elem,key,data);}else{data=undefined;}}return data;}jQuery.extend({hasData:function(elem){return dataUser.hasData(elem)||dataPriv.hasData(elem);},data:function(elem,name,data){return dataUser.access(elem,name,data);},removeData:function(elem,name){dataUser.remove(elem,name);},_data:function(elem,name,data){return dataPriv.access(elem,name,data);},_removeData:function(elem,name){dataPriv.remove(elem,name);}});jQuery.fn.extend({data:function(key,value){var i,name,data,elem=this[0],attrs=elem&&elem.attributes;if(key===undefined){if(this.length){data=dataUser.get(elem);if(elem.nodeType===1&&!dataPriv.get(elem,"hasDataAttrs")){i=attrs.length;while(i--){if(attrs[i]){name=attrs[i].name;if(name.indexOf("data-")===0){name=camelCase(name.slice(5));dataAttr(elem,name,data[name]);}}}dataPriv.set(elem,"hasDataAttrs",true);}}return data;}if(typeof key==="object"){return this.each(function(){dataUser.set(this,key);});}return access(this,function(value){var data;if(elem&&value===undefined){data=dataUser.get(elem,key);if(data!==undefined){return data;}data=dataAttr(elem,key);if(data!==undefined){return data;}return;}this.each(function(){dataUser.set(this,key,value);});},null,value,arguments.length>1,null,true);},removeData:function(key){return this.each(function(){dataUser.remove(this,key);});}});jQuery.extend({queue:function(elem,type,data){var queue;if(elem){type=(type||"fx")+"queue";queue=dataPriv.get(elem,type);if(data){if(!queue||Array.isArray(data)){queue=dataPriv.access(elem,type,jQuery.makeArray(data));}else{queue.push(data);}}return queue||[];}},dequeue:function(elem,type){type=type||"fx";var queue=jQuery.queue(elem,type),startLength=queue.length,fn=queue.shift(),hooks=jQuery._queueHooks(elem,type),next=function(){jQuery.dequeue(elem,type);};if(fn==="inprogress"){fn=queue.shift();startLength--;}if(fn){if(type==="fx"){queue.unshift("inprogress");}delete hooks.stop;fn.call(elem,next,hooks);}if(!startLength&&hooks){hooks.empty.fire();}},_queueHooks:function(elem,type){var key=type+"queueHooks";return dataPriv.get(elem,key)||dataPriv.access(elem,key,{empty:jQuery.Callbacks("once memory").add(function(){dataPriv.remove(elem,[type+"queue",key]);})});}});jQuery.fn.extend({queue:function(type,data){var setter=2;if(typeof type!=="string"){data=type;type="fx";setter--;}if(arguments.length<setter){return jQuery.queue(this[0],type);}return data===undefined?this:this.each(function(){var queue=jQuery.queue(this,type,data);jQuery._queueHooks(this,type);if(type==="fx"&&queue[0]!=="inprogress"){jQuery.dequeue(this,type);}});},dequeue:function(type){return this.each(function(){jQuery.dequeue(this,type);});},clearQueue:function(type){return this.queue(type||"fx",[]);},promise:function(type,obj){var tmp,count=1,defer=jQuery.Deferred(),elements=this,i=this.length,resolve=function(){if(! --count){defer.resolveWith(elements,[elements]);}};if(typeof type!=="string"){obj=type;type=undefined;}type=type||"fx";while(i--){tmp=dataPriv.get(elements[i],type+"queueHooks");if(tmp&&tmp.empty){count++;tmp.empty.add(resolve);}}resolve();return defer.promise(obj);}});var pnum=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;var rcssNum=new RegExp("^(?:([+-])=|)("+pnum+")([a-z%]*)$","i");var cssExpand=["Top","Right","Bottom","Left"];var documentElement=document.documentElement;var isAttached=function(elem){return jQuery.contains(elem.ownerDocument,elem);},composed={composed:true};if(documentElement.getRootNode){isAttached=function(elem){return jQuery.contains(elem.ownerDocument,elem)||elem.getRootNode(composed)===elem.ownerDocument;};}var isHiddenWithinTree=function(elem,el){elem=el||elem;return elem.style.display==="none"||elem.style.display===""&&isAttached(elem)&&jQuery.css(elem,"display")==="none";};function adjustCSS(elem,prop,valueParts,tween){var adjusted,scale,maxIterations=20,currentValue=tween?function(){return tween.cur();}:function(){return jQuery.css(elem,prop,"");},initial=currentValue(),unit=valueParts&&valueParts[3]||(jQuery.cssNumber[prop]?"":"px"),initialInUnit=elem.nodeType&&(jQuery.cssNumber[prop]||unit!=="px"&&+initial)&&rcssNum.exec(jQuery.css(elem,prop));if(initialInUnit&&initialInUnit[3]!==unit){initial=initial/2;unit=unit||initialInUnit[3];initialInUnit=+initial||1;while(maxIterations--){jQuery.style(elem,prop,initialInUnit+unit);if((1-scale)*(1-(scale=currentValue()/initial||0.5))<=0){maxIterations=0;}initialInUnit=initialInUnit/scale;}initialInUnit=initialInUnit*2;jQuery.style(elem,prop,initialInUnit+unit);valueParts=valueParts||[];}if(valueParts){initialInUnit=+initialInUnit||+initial||0;adjusted=valueParts[1]?initialInUnit+(valueParts[1]+1)*valueParts[2]:+valueParts[2];if(tween){tween.unit=unit;tween.start=initialInUnit;tween.end=adjusted;}}return adjusted;}var defaultDisplayMap={};function getDefaultDisplay(elem){var temp,doc=elem.ownerDocument,nodeName=elem.nodeName,display=defaultDisplayMap[nodeName];if(display){return display;}temp=doc.body.appendChild(doc.createElement(nodeName));display=jQuery.css(temp,"display");temp.parentNode.removeChild(temp);if(display==="none"){display="block";}defaultDisplayMap[nodeName]=display;return display;}function showHide(elements,show){var display,elem,values=[],index=0,length=elements.length;for(;index<length;index++){elem=elements[index];if(!elem.style){continue;}display=elem.style.display;if(show){if(display==="none"){values[index]=dataPriv.get(elem,"display")||null;if(!values[index]){elem.style.display="";}}if(elem.style.display===""&&isHiddenWithinTree(elem)){values[index]=getDefaultDisplay(elem);}}else{if(display!=="none"){values[index]="none";dataPriv.set(elem,"display",display);}}}for(index=0;index<length;index++){if(values[index]!=null){elements[index].style.display=values[index];}}return elements;}jQuery.fn.extend({show:function(){return showHide(this,true);},hide:function(){return showHide(this);},toggle:function(state){if(typeof state==="boolean"){return state?this.show():this.hide();}return this.each(function(){if(isHiddenWithinTree(this)){jQuery(this).show();}else{jQuery(this).hide();}});}});var rcheckableType=/^(?:checkbox|radio)$/i;var rtagName=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i;var rscriptType=/^$|^module$|\/(?:java|ecma)script/i;(function(){var fragment=document.createDocumentFragment(),div=fragment.appendChild(document.createElement("div")),input=document.createElement("input");input.setAttribute("type","radio");input.setAttribute("checked","checked");input.setAttribute("name","t");div.appendChild(input);support.checkClone=div.cloneNode(true).cloneNode(true).lastChild.checked;div.innerHTML="<textarea>x</textarea>";support.noCloneChecked=!!div.cloneNode(true).lastChild.defaultValue;div.innerHTML="<option></option>";support.option=!!div.lastChild;})();var wrapMap={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};wrapMap.tbody=wrapMap.tfoot=wrapMap.colgroup=wrapMap.caption=wrapMap.thead;wrapMap.th=wrapMap.td;if(!support.option){wrapMap.optgroup=wrapMap.option=[1,"<select multiple='multiple'>","</select>"];}function getAll(context,tag){var ret;if(typeof context.getElementsByTagName!=="undefined"){ret=context.getElementsByTagName(tag||"*");}else if(typeof context.querySelectorAll!=="undefined"){ret=context.querySelectorAll(tag||"*");}else{ret=[];}if(tag===undefined||tag&&nodeName(context,tag)){return jQuery.merge([context],ret);}return ret;}function setGlobalEval(elems,refElements){var i=0,l=elems.length;for(;i<l;i++){dataPriv.set(elems[i],"globalEval",!refElements||dataPriv.get(refElements[i],"globalEval"));}}function buildFragment(elems,context,scripts,selection,ignored){var elem,tmp,tag,wrap,attached,j,fragment=context.createDocumentFragment(),nodes=[],i=0,l=elems.length;for(;i<l;i++){elem=elems[i];if(elem||elem===0){if(toType(elem)==="object"){jQuery.merge(nodes,elem.nodeType?[elem]:elem);}else if(!/<|&#?\w+;/.test(elem)){nodes.push(context.createTextNode(elem));}else{tmp=tmp||fragment.appendChild(context.createElement("div"));tag=(rtagName.exec(elem)||["",""])[1].toLowerCase();wrap=wrapMap[tag]||wrapMap._default;tmp.innerHTML=wrap[1]+jQuery.htmlPrefilter(elem)+wrap[2];j=wrap[0];while(j--){tmp=tmp.lastChild;}jQuery.merge(nodes,tmp.childNodes);tmp=fragment.firstChild;tmp.textContent="";}}}fragment.textContent="";i=0;while(elem=nodes[i++]){if(selection&&jQuery.inArray(elem,selection)>-1){if(ignored){ignored.push(elem);}continue;}attached=isAttached(elem);tmp=getAll(fragment.appendChild(elem),"script");if(attached){setGlobalEval(tmp);}if(scripts){j=0;while(elem=tmp[j++]){if(rscriptType.test(elem.type||"")){scripts.push(elem);}}}}return fragment;}var rtypenamespace=/^([^.]*)(?:\.(.+)|)/;function returnTrue(){return true;}function returnFalse(){return false;}function expectSync(elem,type){return elem===safeActiveElement()===(type==="focus");}function safeActiveElement(){try{return document.activeElement;}catch(err){}}function on(elem,types,selector,data,fn,one){var origFn,type;if(typeof types==="object"){if(typeof selector!=="string"){data=data||selector;selector=undefined;}for(type in types){on(elem,type,selector,data,types[type],one);}return elem;}if(data==null&&fn==null){fn=selector;data=selector=undefined;}else if(fn==null){if(typeof selector==="string"){fn=data;data=undefined;}else{fn=data;data=selector;selector=undefined;}}if(fn===false){fn=returnFalse;}else if(!fn){return elem;}if(one===1){origFn=fn;fn=function(event){jQuery().off(event);return origFn.apply(this,arguments);};fn.guid=origFn.guid||(origFn.guid=jQuery.guid++);}return elem.each(function(){jQuery.event.add(this,types,fn,data,selector);});}jQuery.event={global:{},add:function(elem,types,handler,data,selector){var handleObjIn,eventHandle,tmp,events,t,handleObj,special,handlers,type,namespaces,origType,elemData=dataPriv.get(elem);if(!acceptData(elem)){return;}if(handler.handler){handleObjIn=handler;handler=handleObjIn.handler;selector=handleObjIn.selector;}if(selector){jQuery.find.matchesSelector(documentElement,selector);}if(!handler.guid){handler.guid=jQuery.guid++;}if(!(events=elemData.events)){events=elemData.events=Object.create(null);}if(!(eventHandle=elemData.handle)){eventHandle=elemData.handle=function(e){return typeof jQuery!=="undefined"&&jQuery.event.triggered!==e.type?jQuery.event.dispatch.apply(elem,arguments):undefined;};}types=(types||"").match(rnothtmlwhite)||[""];t=types.length;while(t--){tmp=rtypenamespace.exec(types[t])||[];type=origType=tmp[1];namespaces=(tmp[2]||"").split(".").sort();if(!type){continue;}special=jQuery.event.special[type]||{};type=(selector?special.delegateType:special.bindType)||type;special=jQuery.event.special[type]||{};handleObj=jQuery.extend({type:type,origType:origType,data:data,handler:handler,guid:handler.guid,selector:selector,needsContext:selector&&jQuery.expr.match.needsContext.test(selector),namespace:namespaces.join(".")},handleObjIn);if(!(handlers=events[type])){handlers=events[type]=[];handlers.delegateCount=0;if(!special.setup||special.setup.call(elem,data,namespaces,eventHandle)===false){if(elem.addEventListener){elem.addEventListener(type,eventHandle);}}}if(special.add){special.add.call(elem,handleObj);if(!handleObj.handler.guid){handleObj.handler.guid=handler.guid;}}if(selector){handlers.splice(handlers.delegateCount++,0,handleObj);}else{handlers.push(handleObj);}jQuery.event.global[type]=true;}},remove:function(elem,types,handler,selector,mappedTypes){var j,origCount,tmp,events,t,handleObj,special,handlers,type,namespaces,origType,elemData=dataPriv.hasData(elem)&&dataPriv.get(elem);if(!elemData||!(events=elemData.events)){return;}types=(types||"").match(rnothtmlwhite)||[""];t=types.length;while(t--){tmp=rtypenamespace.exec(types[t])||[];type=origType=tmp[1];namespaces=(tmp[2]||"").split(".").sort();if(!type){for(type in events){jQuery.event.remove(elem,type+types[t],handler,selector,true);}continue;}special=jQuery.event.special[type]||{};type=(selector?special.delegateType:special.bindType)||type;handlers=events[type]||[];tmp=tmp[2]&&new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)");origCount=j=handlers.length;while(j--){handleObj=handlers[j];if((mappedTypes||origType===handleObj.origType)&&(!handler||handler.guid===handleObj.guid)&&(!tmp||tmp.test(handleObj.namespace))&&(!selector||selector===handleObj.selector||selector==="**"&&handleObj.selector)){handlers.splice(j,1);if(handleObj.selector){handlers.delegateCount--;}if(special.remove){special.remove.call(elem,handleObj);}}}if(origCount&&!handlers.length){if(!special.teardown||special.teardown.call(elem,namespaces,elemData.handle)===false){jQuery.removeEvent(elem,type,elemData.handle);}delete events[type];}}if(jQuery.isEmptyObject(events)){dataPriv.remove(elem,"handle events");}},dispatch:function(nativeEvent){var i,j,ret,matched,handleObj,handlerQueue,args=new Array(arguments.length),event=jQuery.event.fix(nativeEvent),handlers=(dataPriv.get(this,"events")||Object.create(null))[event.type]||[],special=jQuery.event.special[event.type]||{};args[0]=event;for(i=1;i<arguments.length;i++){args[i]=arguments[i];}event.delegateTarget=this;if(special.preDispatch&&special.preDispatch.call(this,event)===false){return;}handlerQueue=jQuery.event.handlers.call(this,event,handlers);i=0;while((matched=handlerQueue[i++])&&!event.isPropagationStopped()){event.currentTarget=matched.elem;j=0;while((handleObj=matched.handlers[j++])&&!event.isImmediatePropagationStopped()){if(!event.rnamespace||handleObj.namespace===false||event.rnamespace.test(handleObj.namespace)){event.handleObj=handleObj;event.data=handleObj.data;ret=((jQuery.event.special[handleObj.origType]||{}).handle||handleObj.handler).apply(matched.elem,args);if(ret!==undefined){if((event.result=ret)===false){event.preventDefault();event.stopPropagation();}}}}}if(special.postDispatch){special.postDispatch.call(this,event);}return event.result;},handlers:function(event,handlers){var i,handleObj,sel,matchedHandlers,matchedSelectors,handlerQueue=[],delegateCount=handlers.delegateCount,cur=event.target;if(delegateCount&&cur.nodeType&&!(event.type==="click"&&event.button>=1)){for(;cur!==this;cur=cur.parentNode||this){if(cur.nodeType===1&&!(event.type==="click"&&cur.disabled===true)){matchedHandlers=[];matchedSelectors={};for(i=0;i<delegateCount;i++){handleObj=handlers[i];sel=handleObj.selector+" ";if(matchedSelectors[sel]===undefined){matchedSelectors[sel]=handleObj.needsContext?jQuery(sel,this).index(cur)>-1:jQuery.find(sel,this,null,[cur]).length;}if(matchedSelectors[sel]){matchedHandlers.push(handleObj);}}if(matchedHandlers.length){handlerQueue.push({elem:cur,handlers:matchedHandlers});}}}}cur=this;if(delegateCount<handlers.length){handlerQueue.push({elem:cur,handlers:handlers.slice(delegateCount)});}return handlerQueue;},addProp:function(name,hook){Object.defineProperty(jQuery.Event.prototype,name,{enumerable:true,configurable:true,get:isFunction(hook)?function(){if(this.originalEvent){return hook(this.originalEvent);}}:function(){if(this.originalEvent){return this.originalEvent[name];}},set:function(value){Object.defineProperty(this,name,{enumerable:true,configurable:true,writable:true,value:value});}});},fix:function(originalEvent){return originalEvent[jQuery.expando]?originalEvent:new jQuery.Event(originalEvent);},special:{load:{noBubble:true},click:{setup:function(data){var el=this||data;if(rcheckableType.test(el.type)&&el.click&&nodeName(el,"input")){leverageNative(el,"click",returnTrue);}return false;},trigger:function(data){var el=this||data;if(rcheckableType.test(el.type)&&el.click&&nodeName(el,"input")){leverageNative(el,"click");}return true;},_default:function(event){var target=event.target;return rcheckableType.test(target.type)&&target.click&&nodeName(target,"input")&&dataPriv.get(target,"click")||nodeName(target,"a");}},beforeunload:{postDispatch:function(event){if(event.result!==undefined&&event.originalEvent){event.originalEvent.returnValue=event.result;}}}}};function leverageNative(el,type,expectSync){if(!expectSync){if(dataPriv.get(el,type)===undefined){jQuery.event.add(el,type,returnTrue);}return;}dataPriv.set(el,type,false);jQuery.event.add(el,type,{namespace:false,handler:function(event){var notAsync,result,saved=dataPriv.get(this,type);if(event.isTrigger&1&&this[type]){if(!saved.length){saved=slice.call(arguments);dataPriv.set(this,type,saved);notAsync=expectSync(this,type);this[type]();result=dataPriv.get(this,type);if(saved!==result||notAsync){dataPriv.set(this,type,false);}else{result={};}if(saved!==result){event.stopImmediatePropagation();event.preventDefault();return result&&result.value;}}else if((jQuery.event.special[type]||{}).delegateType){event.stopPropagation();}}else if(saved.length){dataPriv.set(this,type,{value:jQuery.event.trigger(jQuery.extend(saved[0],jQuery.Event.prototype),saved.slice(1),this)});event.stopImmediatePropagation();}}});}jQuery.removeEvent=function(elem,type,handle){if(elem.removeEventListener){elem.removeEventListener(type,handle);}};jQuery.Event=function(src,props){if(!(this instanceof jQuery.Event)){return new jQuery.Event(src,props);}if(src&&src.type){this.originalEvent=src;this.type=src.type;this.isDefaultPrevented=src.defaultPrevented||src.defaultPrevented===undefined&&src.returnValue===false?returnTrue:returnFalse;this.target=src.target&&src.target.nodeType===3?src.target.parentNode:src.target;this.currentTarget=src.currentTarget;this.relatedTarget=src.relatedTarget;}else{this.type=src;}if(props){jQuery.extend(this,props);}this.timeStamp=src&&src.timeStamp||Date.now();this[jQuery.expando]=true;};jQuery.Event.prototype={constructor:jQuery.Event,isDefaultPrevented:returnFalse,isPropagationStopped:returnFalse,isImmediatePropagationStopped:returnFalse,isSimulated:false,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=returnTrue;if(e&&!this.isSimulated){e.preventDefault();}},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=returnTrue;if(e&&!this.isSimulated){e.stopPropagation();}},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=returnTrue;if(e&&!this.isSimulated){e.stopImmediatePropagation();}this.stopPropagation();}};jQuery.each({altKey:true,bubbles:true,cancelable:true,changedTouches:true,ctrlKey:true,detail:true,eventPhase:true,metaKey:true,pageX:true,pageY:true,shiftKey:true,view:true,"char":true,code:true,charCode:true,key:true,keyCode:true,button:true,buttons:true,clientX:true,clientY:true,offsetX:true,offsetY:true,pointerId:true,pointerType:true,screenX:true,screenY:true,targetTouches:true,toElement:true,touches:true,which:true},jQuery.event.addProp);jQuery.each({focus:"focusin",blur:"focusout"},function(type,delegateType){jQuery.event.special[type]={setup:function(){leverageNative(this,type,expectSync);return false;},trigger:function(){leverageNative(this,type);return true;},_default:function(){return true;},delegateType:delegateType};});jQuery.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(orig,fix){jQuery.event.special[orig]={delegateType:fix,bindType:fix,handle:function(event){var ret,target=this,related=event.relatedTarget,handleObj=event.handleObj;if(!related||related!==target&&!jQuery.contains(target,related)){event.type=handleObj.origType;ret=handleObj.handler.apply(this,arguments);event.type=fix;}return ret;}};});jQuery.fn.extend({on:function(types,selector,data,fn){return on(this,types,selector,data,fn);},one:function(types,selector,data,fn){return on(this,types,selector,data,fn,1);},off:function(types,selector,fn){var handleObj,type;if(types&&types.preventDefault&&types.handleObj){handleObj=types.handleObj;jQuery(types.delegateTarget).off(handleObj.namespace?handleObj.origType+"."+handleObj.namespace:handleObj.origType,handleObj.selector,handleObj.handler);return this;}if(typeof types==="object"){for(type in types){this.off(type,selector,types[type]);}return this;}if(selector===false||typeof selector==="function"){fn=selector;selector=undefined;}if(fn===false){fn=returnFalse;}return this.each(function(){jQuery.event.remove(this,types,fn,selector);});}});function manipulationTarget(elem,content){if(nodeName(elem,"table")&&nodeName(content.nodeType!==11?content:content.firstChild,"tr")){return jQuery(elem).children("tbody")[0]||elem;}return elem;}function disableScript(elem){elem.type=(elem.getAttribute("type")!==null)+"/"+elem.type;return elem;}function restoreScript(elem){if((elem.type||"").slice(0,5)==="true/"){elem.type=elem.type.slice(5);}else{elem.removeAttribute("type");}return elem;}function cloneCopyEvent(src,dest){var i,l,type,pdataOld,udataOld,udataCur,events;if(dest.nodeType!==1){return;}if(dataPriv.hasData(src)){pdataOld=dataPriv.get(src);events=pdataOld.events;if(events){dataPriv.remove(dest,"handle events");for(type in events){for(i=0,l=events[type].length;i<l;i++){jQuery.event.add(dest,type,events[type][i]);}}}}if(dataUser.hasData(src)){udataOld=dataUser.access(src);udataCur=jQuery.extend({},udataOld);dataUser.set(dest,udataCur);}}function fixInput(src,dest){var nodeName=dest.nodeName.toLowerCase();if(nodeName==="input"&&rcheckableType.test(src.type)){dest.checked=src.checked;}else if(nodeName==="input"||nodeName==="textarea"){dest.defaultValue=src.defaultValue;}}function domManip(collection,args,callback,ignored){args=flat(args);var fragment,first,scripts,hasScripts,node,doc,i=0,l=collection.length,value=args[0],valueIsFunction=isFunction(value);if(valueIsFunction||l>1&&typeof value==="string"&&!support.checkClone&&/checked\s*(?:[^=]|=\s*.checked.)/i.test(value)){return collection.each(function(index){var self=collection.eq(index);if(valueIsFunction){args[0]=value.call(this,index,self.html());}domManip(self,args,callback,ignored);});}if(l){fragment=buildFragment(args,collection[0].ownerDocument,false,collection,ignored);first=fragment.firstChild;if(fragment.childNodes.length===1){fragment=first;}if(first||ignored){scripts=jQuery.map(getAll(fragment,"script"),disableScript);hasScripts=scripts.length;for(;i<l;i++){node=fragment;if(i!==l-1){node=jQuery.clone(node,true,true);if(hasScripts){jQuery.merge(scripts,getAll(node,"script"));}}callback.call(collection[i],node,i);}if(hasScripts){doc=scripts[scripts.length-1].ownerDocument;jQuery.map(scripts,restoreScript);for(i=0;i<hasScripts;i++){node=scripts[i];if(rscriptType.test(node.type||"")&&!dataPriv.access(node,"globalEval")&&jQuery.contains(doc,node)){if(node.src&&(node.type||"").toLowerCase()!=="module"){if(jQuery._evalUrl&&!node.noModule){jQuery._evalUrl(node.src,{nonce:node.nonce||node.getAttribute("nonce")},doc);}}else{DOMEval(node.textContent.replace(/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,""),node,doc);}}}}}}return collection;}function remove(elem,selector,keepData){var node,nodes=selector?jQuery.filter(selector,elem):elem,i=0;for(;(node=nodes[i])!=null;i++){if(!keepData&&node.nodeType===1){jQuery.cleanData(getAll(node));}if(node.parentNode){if(keepData&&isAttached(node)){setGlobalEval(getAll(node,"script"));}node.parentNode.removeChild(node);}}return elem;}jQuery.extend({htmlPrefilter:function(html){return html;},clone:function(elem,dataAndEvents,deepDataAndEvents){var i,l,srcElements,destElements,clone=elem.cloneNode(true),inPage=isAttached(elem);if(!support.noCloneChecked&&(elem.nodeType===1||elem.nodeType===11)&&!jQuery.isXMLDoc(elem)){destElements=getAll(clone);srcElements=getAll(elem);for(i=0,l=srcElements.length;i<l;i++){fixInput(srcElements[i],destElements[i]);}}if(dataAndEvents){if(deepDataAndEvents){srcElements=srcElements||getAll(elem);destElements=destElements||getAll(clone);for(i=0,l=srcElements.length;i<l;i++){cloneCopyEvent(srcElements[i],destElements[i]);}}else{cloneCopyEvent(elem,clone);}}destElements=getAll(clone,"script");if(destElements.length>0){setGlobalEval(destElements,!inPage&&getAll(elem,"script"));}return clone;},cleanData:function(elems){var data,elem,type,special=jQuery.event.special,i=0;for(;(elem=elems[i])!==undefined;i++){if(acceptData(elem)){if(data=elem[dataPriv.expando]){if(data.events){for(type in data.events){if(special[type]){jQuery.event.remove(elem,type);}else{jQuery.removeEvent(elem,type,data.handle);}}}elem[dataPriv.expando]=undefined;}if(elem[dataUser.expando]){elem[dataUser.expando]=undefined;}}}}});jQuery.fn.extend({detach:function(selector){return remove(this,selector,true);},remove:function(selector){return remove(this,selector);},text:function(value){return access(this,function(value){return value===undefined?jQuery.text(this):this.empty().each(function(){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){this.textContent=value;}});},null,value,arguments.length);},append:function(){return domManip(this,arguments,function(elem){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var target=manipulationTarget(this,elem);target.appendChild(elem);}});},prepend:function(){return domManip(this,arguments,function(elem){if(this.nodeType===1||this.nodeType===11||this.nodeType===9){var target=manipulationTarget(this,elem);target.insertBefore(elem,target.firstChild);}});},before:function(){return domManip(this,arguments,function(elem){if(this.parentNode){this.parentNode.insertBefore(elem,this);}});},after:function(){return domManip(this,arguments,function(elem){if(this.parentNode){this.parentNode.insertBefore(elem,this.nextSibling);}});},empty:function(){var elem,i=0;for(;(elem=this[i])!=null;i++){if(elem.nodeType===1){jQuery.cleanData(getAll(elem,false));elem.textContent="";}}return this;},clone:function(dataAndEvents,deepDataAndEvents){dataAndEvents=dataAndEvents==null?false:dataAndEvents;deepDataAndEvents=deepDataAndEvents==null?dataAndEvents:deepDataAndEvents;return this.map(function(){return jQuery.clone(this,dataAndEvents,deepDataAndEvents);});},html:function(value){return access(this,function(value){var elem=this[0]||{},i=0,l=this.length;if(value===undefined&&elem.nodeType===1){return elem.innerHTML;}if(typeof value==="string"&&!/<script|<style|<link/i.test(value)&&!wrapMap[(rtagName.exec(value)||["",""])[1].toLowerCase()]){value=jQuery.htmlPrefilter(value);try{for(;i<l;i++){elem=this[i]||{};if(elem.nodeType===1){jQuery.cleanData(getAll(elem,false));elem.innerHTML=value;}}elem=0;}catch(e){}}if(elem){this.empty().append(value);}},null,value,arguments.length);},replaceWith:function(){var ignored=[];return domManip(this,arguments,function(elem){var parent=this.parentNode;if(jQuery.inArray(this,ignored)<0){jQuery.cleanData(getAll(this));if(parent){parent.replaceChild(elem,this);}}},ignored);}});jQuery.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(name,original){jQuery.fn[name]=function(selector){var elems,ret=[],insert=jQuery(selector),last=insert.length-1,i=0;for(;i<=last;i++){elems=i===last?this:this.clone(true);jQuery(insert[i])[original](elems);push.apply(ret,elems.get());}return this.pushStack(ret);};});var rnumnonpx=new RegExp("^("+pnum+")(?!px)[a-z%]+$","i");var getStyles=function(elem){var view=elem.ownerDocument.defaultView;if(!view||!view.opener){view=window;}return view.getComputedStyle(elem);};var swap=function(elem,options,callback){var ret,name,old={};for(name in options){old[name]=elem.style[name];elem.style[name]=options[name];}ret=callback.call(elem);for(name in options){elem.style[name]=old[name];}return ret;};var rboxStyle=new RegExp(cssExpand.join("|"),"i");(function(){function computeStyleTests(){if(!div){return;}container.style.cssText="position:absolute;left:-11111px;width:60px;"+"margin-top:1px;padding:0;border:0";div.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;"+"margin:auto;border:1px;padding:1px;"+"width:60%;top:1%";documentElement.appendChild(container).appendChild(div);var divStyle=window.getComputedStyle(div);pixelPositionVal=divStyle.top!=="1%";reliableMarginLeftVal=roundPixelMeasures(divStyle.marginLeft)===12;div.style.right="60%";pixelBoxStylesVal=roundPixelMeasures(divStyle.right)===36;boxSizingReliableVal=roundPixelMeasures(divStyle.width)===36;div.style.position="absolute";scrollboxSizeVal=roundPixelMeasures(div.offsetWidth/3)===12;documentElement.removeChild(container);div=null;}function roundPixelMeasures(measure){return Math.round(parseFloat(measure));}var pixelPositionVal,boxSizingReliableVal,scrollboxSizeVal,pixelBoxStylesVal,reliableTrDimensionsVal,reliableMarginLeftVal,container=document.createElement("div"),div=document.createElement("div");if(!div.style){return;}div.style.backgroundClip="content-box";div.cloneNode(true).style.backgroundClip="";support.clearCloneStyle=div.style.backgroundClip==="content-box";jQuery.extend(support,{boxSizingReliable:function(){computeStyleTests();return boxSizingReliableVal;},pixelBoxStyles:function(){computeStyleTests();return pixelBoxStylesVal;},pixelPosition:function(){computeStyleTests();return pixelPositionVal;},reliableMarginLeft:function(){computeStyleTests();return reliableMarginLeftVal;},scrollboxSize:function(){computeStyleTests();return scrollboxSizeVal;},reliableTrDimensions:function(){var table,tr,trChild,trStyle;if(reliableTrDimensionsVal==null){table=document.createElement("table");tr=document.createElement("tr");trChild=document.createElement("div");table.style.cssText="position:absolute;left:-11111px;border-collapse:separate";tr.style.cssText="border:1px solid";tr.style.height="1px";trChild.style.height="9px";trChild.style.display="block";documentElement.appendChild(table).appendChild(tr).appendChild(trChild);trStyle=window.getComputedStyle(tr);reliableTrDimensionsVal=parseInt(trStyle.height,10)+parseInt(trStyle.borderTopWidth,10)+parseInt(trStyle.borderBottomWidth,10)===tr.offsetHeight;documentElement.removeChild(table);}return reliableTrDimensionsVal;}});})();function curCSS(elem,name,computed){var width,minWidth,maxWidth,ret,style=elem.style;computed=computed||getStyles(elem);if(computed){ret=computed.getPropertyValue(name)||computed[name];if(ret===""&&!isAttached(elem)){ret=jQuery.style(elem,name);}if(!support.pixelBoxStyles()&&rnumnonpx.test(ret)&&rboxStyle.test(name)){width=style.width;minWidth=style.minWidth;maxWidth=style.maxWidth;style.minWidth=style.maxWidth=style.width=ret;ret=computed.width;style.width=width;style.minWidth=minWidth;style.maxWidth=maxWidth;}}return ret!==undefined?ret+"":ret;}function addGetHookIf(conditionFn,hookFn){return{get:function(){if(conditionFn()){delete this.get;return;}return(this.get=hookFn).apply(this,arguments);}};}var cssPrefixes=["Webkit","Moz","ms"],emptyStyle=document.createElement("div").style,vendorProps={};function vendorPropName(name){var capName=name[0].toUpperCase()+name.slice(1),i=cssPrefixes.length;while(i--){name=cssPrefixes[i]+capName;if(name in emptyStyle){return name;}}}function finalPropName(name){var final=jQuery.cssProps[name]||vendorProps[name];if(final){return final;}if(name in emptyStyle){return name;}return vendorProps[name]=vendorPropName(name)||name;}var rcustomProp=/^--/,cssShow={position:"absolute",visibility:"hidden",display:"block"},cssNormalTransform={letterSpacing:"0",fontWeight:"400"};function setPositiveNumber(_elem,value,subtract){var matches=rcssNum.exec(value);return matches?Math.max(0,matches[2]-(subtract||0))+(matches[3]||"px"):value;}function boxModelAdjustment(elem,dimension,box,isBorderBox,styles,computedVal){var i=dimension==="width"?1:0,extra=0,delta=0;if(box===(isBorderBox?"border":"content")){return 0;}for(;i<4;i+=2){if(box==="margin"){delta+=jQuery.css(elem,box+cssExpand[i],true,styles);}if(!isBorderBox){delta+=jQuery.css(elem,"padding"+cssExpand[i],true,styles);if(box!=="padding"){delta+=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}else{extra+=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}}else{if(box==="content"){delta-=jQuery.css(elem,"padding"+cssExpand[i],true,styles);}if(box!=="margin"){delta-=jQuery.css(elem,"border"+cssExpand[i]+"Width",true,styles);}}}if(!isBorderBox&&computedVal>=0){delta+=Math.max(0,Math.ceil(elem["offset"+dimension[0].toUpperCase()+dimension.slice(1)]-computedVal-delta-extra-0.5))||0;}return delta;}function getWidthOrHeight(elem,dimension,extra){var styles=getStyles(elem),boxSizingNeeded=!support.boxSizingReliable()||extra,isBorderBox=boxSizingNeeded&&jQuery.css(elem,"boxSizing",false,styles)==="border-box",valueIsBorderBox=isBorderBox,val=curCSS(elem,dimension,styles),offsetProp="offset"+dimension[0].toUpperCase()+dimension.slice(1);if(rnumnonpx.test(val)){if(!extra){return val;}val="auto";}if((!support.boxSizingReliable()&&isBorderBox||!support.reliableTrDimensions()&&nodeName(elem,"tr")||val==="auto"||!parseFloat(val)&&jQuery.css(elem,"display",false,styles)==="inline")&&elem.getClientRects().length){isBorderBox=jQuery.css(elem,"boxSizing",false,styles)==="border-box";valueIsBorderBox=offsetProp in elem;if(valueIsBorderBox){val=elem[offsetProp];}}val=parseFloat(val)||0;return val+boxModelAdjustment(elem,dimension,extra||(isBorderBox?"border":"content"),valueIsBorderBox,styles,val)+"px";}jQuery.extend({cssHooks:{opacity:{get:function(elem,computed){if(computed){var ret=curCSS(elem,"opacity");return ret===""?"1":ret;}}}},cssNumber:{"animationIterationCount":true,"columnCount":true,"fillOpacity":true,"flexGrow":true,"flexShrink":true,"fontWeight":true,"gridArea":true,"gridColumn":true,"gridColumnEnd":true,"gridColumnStart":true,"gridRow":true,"gridRowEnd":true,"gridRowStart":true,"lineHeight":true,"opacity":true,"order":true,"orphans":true,"widows":true,"zIndex":true,"zoom":true},cssProps:{},style:function(elem,name,value,extra){if(!elem||elem.nodeType===3||elem.nodeType===8||!elem.style){return;}var ret,type,hooks,origName=camelCase(name),isCustomProp=rcustomProp.test(name),style=elem.style;if(!isCustomProp){name=finalPropName(origName);}hooks=jQuery.cssHooks[name]||jQuery.cssHooks[origName];if(value!==undefined){type=typeof value;if(type==="string"&&(ret=rcssNum.exec(value))&&ret[1]){value=adjustCSS(elem,name,ret);type="number";}if(value==null||value!==value){return;}if(type==="number"&&!isCustomProp){value+=ret&&ret[3]||(jQuery.cssNumber[origName]?"":"px");}if(!support.clearCloneStyle&&value===""&&name.indexOf("background")===0){style[name]="inherit";}if(!hooks||!("set"in hooks)||(value=hooks.set(elem,value,extra))!==undefined){if(isCustomProp){style.setProperty(name,value);}else{style[name]=value;}}}else{if(hooks&&"get"in hooks&&(ret=hooks.get(elem,false,extra))!==undefined){return ret;}return style[name];}},css:function(elem,name,extra,styles){var val,num,hooks,origName=camelCase(name),isCustomProp=rcustomProp.test(name);if(!isCustomProp){name=finalPropName(origName);}hooks=jQuery.cssHooks[name]||jQuery.cssHooks[origName];if(hooks&&"get"in hooks){val=hooks.get(elem,true,extra);}if(val===undefined){val=curCSS(elem,name,styles);}if(val==="normal"&&name in cssNormalTransform){val=cssNormalTransform[name];}if(extra===""||extra){num=parseFloat(val);return extra===true||isFinite(num)?num||0:val;}return val;}});jQuery.each(["height","width"],function(_i,dimension){jQuery.cssHooks[dimension]={get:function(elem,computed,extra){if(computed){return /^(none|table(?!-c[ea]).+)/.test(jQuery.css(elem,"display"))&&(!elem.getClientRects().length||!elem.getBoundingClientRect().width)?swap(elem,cssShow,function(){return getWidthOrHeight(elem,dimension,extra);}):getWidthOrHeight(elem,dimension,extra);}},set:function(elem,value,extra){var matches,styles=getStyles(elem),scrollboxSizeBuggy=!support.scrollboxSize()&&styles.position==="absolute",isBorderBox=(scrollboxSizeBuggy||extra)&&jQuery.css(elem,"boxSizing",false,styles)==="border-box",subtract=extra?boxModelAdjustment(elem,dimension,extra,isBorderBox,styles):0;if(isBorderBox&&scrollboxSizeBuggy){subtract-=Math.ceil(elem["offset"+dimension[0].toUpperCase()+dimension.slice(1)]-parseFloat(styles[dimension])-boxModelAdjustment(elem,dimension,"border",false,styles)-0.5);}if(subtract&&(matches=rcssNum.exec(value))&&(matches[3]||"px")!=="px"){elem.style[dimension]=value;value=jQuery.css(elem,dimension);}return setPositiveNumber(elem,value,subtract);}};});jQuery.cssHooks.marginLeft=addGetHookIf(support.reliableMarginLeft,function(elem,computed){if(computed){return(parseFloat(curCSS(elem,"marginLeft"))||elem.getBoundingClientRect().left-swap(elem,{marginLeft:0},function(){return elem.getBoundingClientRect().left;}))+"px";}});jQuery.each({margin:"",padding:"",border:"Width"},function(prefix,suffix){jQuery.cssHooks[prefix+suffix]={expand:function(value){var i=0,expanded={},parts=typeof value==="string"?value.split(" "):[value];for(;i<4;i++){expanded[prefix+cssExpand[i]+suffix]=parts[i]||parts[i-2]||parts[0];}return expanded;}};if(prefix!=="margin"){jQuery.cssHooks[prefix+suffix].set=setPositiveNumber;}});jQuery.fn.extend({css:function(name,value){return access(this,function(elem,name,value){var styles,len,map={},i=0;if(Array.isArray(name)){styles=getStyles(elem);len=name.length;for(;i<len;i++){map[name[i]]=jQuery.css(elem,name[i],false,styles);}return map;}return value!==undefined?jQuery.style(elem,name,value):jQuery.css(elem,name);},name,value,arguments.length>1);}});function Tween(elem,options,prop,end,easing){return new Tween.prototype.init(elem,options,prop,end,easing);}jQuery.Tween=Tween;Tween.prototype={constructor:Tween,init:function(elem,options,prop,end,easing,unit){this.elem=elem;this.prop=prop;this.easing=easing||jQuery.easing._default;this.options=options;this.start=this.now=this.cur();this.end=end;this.unit=unit||(jQuery.cssNumber[prop]?"":"px");},cur:function(){var hooks=Tween.propHooks[this.prop];return hooks&&hooks.get?hooks.get(this):Tween.propHooks._default.get(this);},run:function(percent){var eased,hooks=Tween.propHooks[this.prop];if(this.options.duration){this.pos=eased=jQuery.easing[this.easing](percent,this.options.duration*percent,0,1,this.options.duration);}else{this.pos=eased=percent;}this.now=(this.end-this.start)*eased+this.start;if(this.options.step){this.options.step.call(this.elem,this.now,this);}if(hooks&&hooks.set){hooks.set(this);}else{Tween.propHooks._default.set(this);}return this;}};Tween.prototype.init.prototype=Tween.prototype;Tween.propHooks={_default:{get:function(tween){var result;if(tween.elem.nodeType!==1||tween.elem[tween.prop]!=null&&tween.elem.style[tween.prop]==null){return tween.elem[tween.prop];}result=jQuery.css(tween.elem,tween.prop,"");return!result||result==="auto"?0:result;},set:function(tween){if(jQuery.fx.step[tween.prop]){jQuery.fx.step[tween.prop](tween);}else if(tween.elem.nodeType===1&&(jQuery.cssHooks[tween.prop]||tween.elem.style[finalPropName(tween.prop)]!=null)){jQuery.style(tween.elem,tween.prop,tween.now+tween.unit);}else{tween.elem[tween.prop]=tween.now;}}}};Tween.propHooks.scrollTop=Tween.propHooks.scrollLeft={set:function(tween){if(tween.elem.nodeType&&tween.elem.parentNode){tween.elem[tween.prop]=tween.now;}}};jQuery.easing={linear:function(p){return p;},swing:function(p){return 0.5-Math.cos(p*Math.PI)/2;},_default:"swing"};jQuery.fx=Tween.prototype.init;jQuery.fx.step={};var fxNow,inProgress;function schedule(){if(inProgress){if(document.hidden===false&&window.requestAnimationFrame){window.requestAnimationFrame(schedule);}else{window.setTimeout(schedule,jQuery.fx.interval);}jQuery.fx.tick();}}function createFxNow(){window.setTimeout(function(){fxNow=undefined;});return fxNow=Date.now();}function genFx(type,includeWidth){var which,i=0,attrs={height:type};includeWidth=includeWidth?1:0;for(;i<4;i+=2-includeWidth){which=cssExpand[i];attrs["margin"+which]=attrs["padding"+which]=type;}if(includeWidth){attrs.opacity=attrs.width=type;}return attrs;}function createTween(value,prop,animation){var tween,collection=(Animation.tweeners[prop]||[]).concat(Animation.tweeners["*"]),index=0,length=collection.length;for(;index<length;index++){if(tween=collection[index].call(animation,prop,value)){return tween;}}}function defaultPrefilter(elem,props,opts){var prop,value,toggle,hooks,oldfire,propTween,restoreDisplay,display,isBox="width"in props||"height"in props,anim=this,orig={},style=elem.style,hidden=elem.nodeType&&isHiddenWithinTree(elem),dataShow=dataPriv.get(elem,"fxshow");if(!opts.queue){hooks=jQuery._queueHooks(elem,"fx");if(hooks.unqueued==null){hooks.unqueued=0;oldfire=hooks.empty.fire;hooks.empty.fire=function(){if(!hooks.unqueued){oldfire();}};}hooks.unqueued++;anim.always(function(){anim.always(function(){hooks.unqueued--;if(!jQuery.queue(elem,"fx").length){hooks.empty.fire();}});});}for(prop in props){value=props[prop];if(/^(?:toggle|show|hide)$/.test(value)){delete props[prop];toggle=toggle||value==="toggle";if(value===(hidden?"hide":"show")){if(value==="show"&&dataShow&&dataShow[prop]!==undefined){hidden=true;}else{continue;}}orig[prop]=dataShow&&dataShow[prop]||jQuery.style(elem,prop);}}propTween=!jQuery.isEmptyObject(props);if(!propTween&&jQuery.isEmptyObject(orig)){return;}if(isBox&&elem.nodeType===1){opts.overflow=[style.overflow,style.overflowX,style.overflowY];restoreDisplay=dataShow&&dataShow.display;if(restoreDisplay==null){restoreDisplay=dataPriv.get(elem,"display");}display=jQuery.css(elem,"display");if(display==="none"){if(restoreDisplay){display=restoreDisplay;}else{showHide([elem],true);restoreDisplay=elem.style.display||restoreDisplay;display=jQuery.css(elem,"display");showHide([elem]);}}if(display==="inline"||display==="inline-block"&&restoreDisplay!=null){if(jQuery.css(elem,"float")==="none"){if(!propTween){anim.done(function(){style.display=restoreDisplay;});if(restoreDisplay==null){display=style.display;restoreDisplay=display==="none"?"":display;}}style.display="inline-block";}}}if(opts.overflow){style.overflow="hidden";anim.always(function(){style.overflow=opts.overflow[0];style.overflowX=opts.overflow[1];style.overflowY=opts.overflow[2];});}propTween=false;for(prop in orig){if(!propTween){if(dataShow){if("hidden"in dataShow){hidden=dataShow.hidden;}}else{dataShow=dataPriv.access(elem,"fxshow",{display:restoreDisplay});}if(toggle){dataShow.hidden=!hidden;}if(hidden){showHide([elem],true);}anim.done(function(){if(!hidden){showHide([elem]);}dataPriv.remove(elem,"fxshow");for(prop in orig){jQuery.style(elem,prop,orig[prop]);}});}propTween=createTween(hidden?dataShow[prop]:0,prop,anim);if(!(prop in dataShow)){dataShow[prop]=propTween.start;if(hidden){propTween.end=propTween.start;propTween.start=0;}}}}function propFilter(props,specialEasing){var index,name,easing,value,hooks;for(index in props){name=camelCase(index);easing=specialEasing[name];value=props[index];if(Array.isArray(value)){easing=value[1];value=props[index]=value[0];}if(index!==name){props[name]=value;delete props[index];}hooks=jQuery.cssHooks[name];if(hooks&&"expand"in hooks){value=hooks.expand(value);delete props[name];for(index in value){if(!(index in props)){props[index]=value[index];specialEasing[index]=easing;}}}else{specialEasing[name]=easing;}}}function Animation(elem,properties,options){var result,stopped,index=0,length=Animation.prefilters.length,deferred=jQuery.Deferred().always(function(){delete tick.elem;}),tick=function(){if(stopped){return false;}var currentTime=fxNow||createFxNow(),remaining=Math.max(0,animation.startTime+animation.duration-currentTime),temp=remaining/animation.duration||0,percent=1-temp,index=0,length=animation.tweens.length;for(;index<length;index++){animation.tweens[index].run(percent);}deferred.notifyWith(elem,[animation,percent,remaining]);if(percent<1&&length){return remaining;}if(!length){deferred.notifyWith(elem,[animation,1,0]);}deferred.resolveWith(elem,[animation]);return false;},animation=deferred.promise({elem:elem,props:jQuery.extend({},properties),opts:jQuery.extend(true,{specialEasing:{},easing:jQuery.easing._default},options),originalProperties:properties,originalOptions:options,startTime:fxNow||createFxNow(),duration:options.duration,tweens:[],createTween:function(prop,end){var tween=jQuery.Tween(elem,animation.opts,prop,end,animation.opts.specialEasing[prop]||animation.opts.easing);animation.tweens.push(tween);return tween;},stop:function(gotoEnd){var index=0,length=gotoEnd?animation.tweens.length:0;if(stopped){return this;}stopped=true;for(;index<length;index++){animation.tweens[index].run(1);}if(gotoEnd){deferred.notifyWith(elem,[animation,1,0]);deferred.resolveWith(elem,[animation,gotoEnd]);}else{deferred.rejectWith(elem,[animation,gotoEnd]);}return this;}}),props=animation.props;propFilter(props,animation.opts.specialEasing);for(;index<length;index++){result=Animation.prefilters[index].call(animation,elem,props,animation.opts);if(result){if(isFunction(result.stop)){jQuery._queueHooks(animation.elem,animation.opts.queue).stop=result.stop.bind(result);}return result;}}jQuery.map(props,createTween,animation);if(isFunction(animation.opts.start)){animation.opts.start.call(elem,animation);}animation.progress(animation.opts.progress).done(animation.opts.done,animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);jQuery.fx.timer(jQuery.extend(tick,{elem:elem,anim:animation,queue:animation.opts.queue}));return animation;}jQuery.Animation=jQuery.extend(Animation,{tweeners:{"*":[function(prop,value){var tween=this.createTween(prop,value);adjustCSS(tween.elem,prop,rcssNum.exec(value),tween);return tween;}]},tweener:function(props,callback){if(isFunction(props)){callback=props;props=["*"];}else{props=props.match(rnothtmlwhite);}var prop,index=0,length=props.length;for(;index<length;index++){prop=props[index];Animation.tweeners[prop]=Animation.tweeners[prop]||[];Animation.tweeners[prop].unshift(callback);}},prefilters:[defaultPrefilter],prefilter:function(callback,prepend){if(prepend){Animation.prefilters.unshift(callback);}else{Animation.prefilters.push(callback);}}});jQuery.speed=function(speed,easing,fn){var opt=speed&&typeof speed==="object"?jQuery.extend({},speed):{complete:fn||!fn&&easing||isFunction(speed)&&speed,duration:speed,easing:fn&&easing||easing&&!isFunction(easing)&&easing};if(jQuery.fx.off){opt.duration=0;}else{if(typeof opt.duration!=="number"){if(opt.duration in jQuery.fx.speeds){opt.duration=jQuery.fx.speeds[opt.duration];}else{opt.duration=jQuery.fx.speeds._default;}}}if(opt.queue==null||opt.queue===true){opt.queue="fx";}opt.old=opt.complete;opt.complete=function(){if(isFunction(opt.old)){opt.old.call(this);}if(opt.queue){jQuery.dequeue(this,opt.queue);}};return opt;};jQuery.fn.extend({fadeTo:function(speed,to,easing,callback){return this.filter(isHiddenWithinTree).css("opacity",0).show().end().animate({opacity:to},speed,easing,callback);},animate:function(prop,speed,easing,callback){var empty=jQuery.isEmptyObject(prop),optall=jQuery.speed(speed,easing,callback),doAnimation=function(){var anim=Animation(this,jQuery.extend({},prop),optall);if(empty||dataPriv.get(this,"finish")){anim.stop(true);}};doAnimation.finish=doAnimation;return empty||optall.queue===false?this.each(doAnimation):this.queue(optall.queue,doAnimation);},stop:function(type,clearQueue,gotoEnd){var stopQueue=function(hooks){var stop=hooks.stop;delete hooks.stop;stop(gotoEnd);};if(typeof type!=="string"){gotoEnd=clearQueue;clearQueue=type;type=undefined;}if(clearQueue){this.queue(type||"fx",[]);}return this.each(function(){var dequeue=true,index=type!=null&&type+"queueHooks",timers=jQuery.timers,data=dataPriv.get(this);if(index){if(data[index]&&data[index].stop){stopQueue(data[index]);}}else{for(index in data){if(data[index]&&data[index].stop&&/queueHooks$/.test(index)){stopQueue(data[index]);}}}for(index=timers.length;index--;){if(timers[index].elem===this&&(type==null||timers[index].queue===type)){timers[index].anim.stop(gotoEnd);dequeue=false;timers.splice(index,1);}}if(dequeue||!gotoEnd){jQuery.dequeue(this,type);}});},finish:function(type){if(type!==false){type=type||"fx";}return this.each(function(){var index,data=dataPriv.get(this),queue=data[type+"queue"],hooks=data[type+"queueHooks"],timers=jQuery.timers,length=queue?queue.length:0;data.finish=true;jQuery.queue(this,type,[]);if(hooks&&hooks.stop){hooks.stop.call(this,true);}for(index=timers.length;index--;){if(timers[index].elem===this&&timers[index].queue===type){timers[index].anim.stop(true);timers.splice(index,1);}}for(index=0;index<length;index++){if(queue[index]&&queue[index].finish){queue[index].finish.call(this);}}delete data.finish;});}});jQuery.each(["toggle","show","hide"],function(_i,name){var cssFn=jQuery.fn[name];jQuery.fn[name]=function(speed,easing,callback){return speed==null||typeof speed==="boolean"?cssFn.apply(this,arguments):this.animate(genFx(name,true),speed,easing,callback);};});jQuery.each({slideDown:genFx("show"),slideUp:genFx("hide"),slideToggle:genFx("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(name,props){jQuery.fn[name]=function(speed,easing,callback){return this.animate(props,speed,easing,callback);};});jQuery.timers=[];jQuery.fx.tick=function(){var timer,i=0,timers=jQuery.timers;fxNow=Date.now();for(;i<timers.length;i++){timer=timers[i];if(!timer()&&timers[i]===timer){timers.splice(i--,1);}}if(!timers.length){jQuery.fx.stop();}fxNow=undefined;};jQuery.fx.timer=function(timer){jQuery.timers.push(timer);jQuery.fx.start();};jQuery.fx.interval=13;jQuery.fx.start=function(){if(inProgress){return;}inProgress=true;schedule();};jQuery.fx.stop=function(){inProgress=null;};jQuery.fx.speeds={slow:600,fast:200,_default:400};jQuery.fn.delay=function(time,type){time=jQuery.fx?jQuery.fx.speeds[time]||time:time;type=type||"fx";return this.queue(type,function(next,hooks){var timeout=window.setTimeout(next,time);hooks.stop=function(){window.clearTimeout(timeout);};});};(function(){var input=document.createElement("input"),select=document.createElement("select"),opt=select.appendChild(document.createElement("option"));input.type="checkbox";support.checkOn=input.value!=="";support.optSelected=opt.selected;input=document.createElement("input");input.value="t";input.type="radio";support.radioValue=input.value==="t";})();var boolHook,attrHandle=jQuery.expr.attrHandle;jQuery.fn.extend({attr:function(name,value){return access(this,jQuery.attr,name,value,arguments.length>1);},removeAttr:function(name){return this.each(function(){jQuery.removeAttr(this,name);});}});jQuery.extend({attr:function(elem,name,value){var ret,hooks,nType=elem.nodeType;if(nType===3||nType===8||nType===2){return;}if(typeof elem.getAttribute==="undefined"){return jQuery.prop(elem,name,value);}if(nType!==1||!jQuery.isXMLDoc(elem)){hooks=jQuery.attrHooks[name.toLowerCase()]||(jQuery.expr.match.bool.test(name)?boolHook:undefined);}if(value!==undefined){if(value===null){jQuery.removeAttr(elem,name);return;}if(hooks&&"set"in hooks&&(ret=hooks.set(elem,value,name))!==undefined){return ret;}elem.setAttribute(name,value+"");return value;}if(hooks&&"get"in hooks&&(ret=hooks.get(elem,name))!==null){return ret;}ret=jQuery.find.attr(elem,name);return ret==null?undefined:ret;},attrHooks:{type:{set:function(elem,value){if(!support.radioValue&&value==="radio"&&nodeName(elem,"input")){var val=elem.value;elem.setAttribute("type",value);if(val){elem.value=val;}return value;}}}},removeAttr:function(elem,value){var name,i=0,attrNames=value&&value.match(rnothtmlwhite);if(attrNames&&elem.nodeType===1){while(name=attrNames[i++]){elem.removeAttribute(name);}}}});boolHook={set:function(elem,value,name){if(value===false){jQuery.removeAttr(elem,name);}else{elem.setAttribute(name,name);}return name;}};jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g),function(_i,name){var getter=attrHandle[name]||jQuery.find.attr;attrHandle[name]=function(elem,name,isXML){var ret,handle,lowercaseName=name.toLowerCase();if(!isXML){handle=attrHandle[lowercaseName];attrHandle[lowercaseName]=ret;ret=getter(elem,name,isXML)!=null?lowercaseName:null;attrHandle[lowercaseName]=handle;}return ret;};});jQuery.fn.extend({prop:function(name,value){return access(this,jQuery.prop,name,value,arguments.length>1);},removeProp:function(name){return this.each(function(){delete this[jQuery.propFix[name]||name];});}});jQuery.extend({prop:function(elem,name,value){var ret,hooks,nType=elem.nodeType;if(nType===3||nType===8||nType===2){return;}if(nType!==1||!jQuery.isXMLDoc(elem)){name=jQuery.propFix[name]||name;hooks=jQuery.propHooks[name];}if(value!==undefined){if(hooks&&"set"in hooks&&(ret=hooks.set(elem,value,name))!==undefined){return ret;}return elem[name]=value;}if(hooks&&"get"in hooks&&(ret=hooks.get(elem,name))!==null){return ret;}return elem[name];},propHooks:{tabIndex:{get:function(elem){var tabindex=jQuery.find.attr(elem,"tabindex");if(tabindex){return parseInt(tabindex,10);}if(/^(?:input|select|textarea|button)$/i.test(elem.nodeName)||/^(?:a|area)$/i.test(elem.nodeName)&&elem.href){return 0;}return-1;}}},propFix:{"for":"htmlFor","class":"className"}});if(!support.optSelected){jQuery.propHooks.selected={get:function(elem){var parent=elem.parentNode;if(parent&&parent.parentNode){parent.parentNode.selectedIndex;}return null;},set:function(elem){var parent=elem.parentNode;if(parent){parent.selectedIndex;if(parent.parentNode){parent.parentNode.selectedIndex;}}}};}jQuery.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){jQuery.propFix[this.toLowerCase()]=this;});function stripAndCollapse(value){var tokens=value.match(rnothtmlwhite)||[];return tokens.join(" ");}function getClass(elem){return elem.getAttribute&&elem.getAttribute("class")||"";}function classesToArray(value){if(Array.isArray(value)){return value;}if(typeof value==="string"){return value.match(rnothtmlwhite)||[];}return[];}jQuery.fn.extend({addClass:function(value){var classes,elem,cur,curValue,clazz,j,finalValue,i=0;if(isFunction(value)){return this.each(function(j){jQuery(this).addClass(value.call(this,j,getClass(this)));});}classes=classesToArray(value);if(classes.length){while(elem=this[i++]){curValue=getClass(elem);cur=elem.nodeType===1&&" "+stripAndCollapse(curValue)+" ";if(cur){j=0;while(clazz=classes[j++]){if(cur.indexOf(" "+clazz+" ")<0){cur+=clazz+" ";}}finalValue=stripAndCollapse(cur);if(curValue!==finalValue){elem.setAttribute("class",finalValue);}}}}return this;},removeClass:function(value){var classes,elem,cur,curValue,clazz,j,finalValue,i=0;if(isFunction(value)){return this.each(function(j){jQuery(this).removeClass(value.call(this,j,getClass(this)));});}if(!arguments.length){return this.attr("class","");}classes=classesToArray(value);if(classes.length){while(elem=this[i++]){curValue=getClass(elem);cur=elem.nodeType===1&&" "+stripAndCollapse(curValue)+" ";if(cur){j=0;while(clazz=classes[j++]){while(cur.indexOf(" "+clazz+" ")>-1){cur=cur.replace(" "+clazz+" "," ");}}finalValue=stripAndCollapse(cur);if(curValue!==finalValue){elem.setAttribute("class",finalValue);}}}}return this;},toggleClass:function(value,stateVal){var type=typeof value,isValidValue=type==="string"||Array.isArray(value);if(typeof stateVal==="boolean"&&isValidValue){return stateVal?this.addClass(value):this.removeClass(value);}if(isFunction(value)){return this.each(function(i){jQuery(this).toggleClass(value.call(this,i,getClass(this),stateVal),stateVal);});}return this.each(function(){var className,i,self,classNames;if(isValidValue){i=0;self=jQuery(this);classNames=classesToArray(value);while(className=classNames[i++]){if(self.hasClass(className)){self.removeClass(className);}else{self.addClass(className);}}}else if(value===undefined||type==="boolean"){className=getClass(this);if(className){dataPriv.set(this,"__className__",className);}if(this.setAttribute){this.setAttribute("class",className||value===false?"":dataPriv.get(this,"__className__")||"");}}});},hasClass:function(selector){var className,elem,i=0;className=" "+selector+" ";while(elem=this[i++]){if(elem.nodeType===1&&(" "+stripAndCollapse(getClass(elem))+" ").indexOf(className)>-1){return true;}}return false;}});jQuery.fn.extend({val:function(value){var hooks,ret,valueIsFunction,elem=this[0];if(!arguments.length){if(elem){hooks=jQuery.valHooks[elem.type]||jQuery.valHooks[elem.nodeName.toLowerCase()];if(hooks&&"get"in hooks&&(ret=hooks.get(elem,"value"))!==undefined){return ret;}ret=elem.value;if(typeof ret==="string"){return ret.replace(/\r/g,"");}return ret==null?"":ret;}return;}valueIsFunction=isFunction(value);return this.each(function(i){var val;if(this.nodeType!==1){return;}if(valueIsFunction){val=value.call(this,i,jQuery(this).val());}else{val=value;}if(val==null){val="";}else if(typeof val==="number"){val+="";}else if(Array.isArray(val)){val=jQuery.map(val,function(value){return value==null?"":value+"";});}hooks=jQuery.valHooks[this.type]||jQuery.valHooks[this.nodeName.toLowerCase()];if(!hooks||!("set"in hooks)||hooks.set(this,val,"value")===undefined){this.value=val;}});}});jQuery.extend({valHooks:{option:{get:function(elem){var val=jQuery.find.attr(elem,"value");return val!=null?val:stripAndCollapse(jQuery.text(elem));}},select:{get:function(elem){var value,option,i,options=elem.options,index=elem.selectedIndex,one=elem.type==="select-one",values=one?null:[],max=one?index+1:options.length;if(index<0){i=max;}else{i=one?index:0;}for(;i<max;i++){option=options[i];if((option.selected||i===index)&&!option.disabled&&(!option.parentNode.disabled||!nodeName(option.parentNode,"optgroup"))){value=jQuery(option).val();if(one){return value;}values.push(value);}}return values;},set:function(elem,value){var optionSet,option,options=elem.options,values=jQuery.makeArray(value),i=options.length;while(i--){option=options[i];if(option.selected=jQuery.inArray(jQuery.valHooks.option.get(option),values)>-1){optionSet=true;}}if(!optionSet){elem.selectedIndex=-1;}return values;}}}});jQuery.each(["radio","checkbox"],function(){jQuery.valHooks[this]={set:function(elem,value){if(Array.isArray(value)){return elem.checked=jQuery.inArray(jQuery(elem).val(),value)>-1;}}};if(!support.checkOn){jQuery.valHooks[this].get=function(elem){return elem.getAttribute("value")===null?"on":elem.value;};}});support.focusin="onfocusin"in window;var rfocusMorph=/^(?:focusinfocus|focusoutblur)$/,stopPropagationCallback=function(e){e.stopPropagation();};jQuery.extend(jQuery.event,{trigger:function(event,data,elem,onlyHandlers){var i,cur,tmp,bubbleType,ontype,handle,special,lastElement,eventPath=[elem||document],type=hasOwn.call(event,"type")?event.type:event,namespaces=hasOwn.call(event,"namespace")?event.namespace.split("."):[];cur=lastElement=tmp=elem=elem||document;if(elem.nodeType===3||elem.nodeType===8){return;}if(rfocusMorph.test(type+jQuery.event.triggered)){return;}if(type.indexOf(".")>-1){namespaces=type.split(".");type=namespaces.shift();namespaces.sort();}ontype=type.indexOf(":")<0&&"on"+type;event=event[jQuery.expando]?event:new jQuery.Event(type,typeof event==="object"&&event);event.isTrigger=onlyHandlers?2:3;event.namespace=namespaces.join(".");event.rnamespace=event.namespace?new RegExp("(^|\\.)"+namespaces.join("\\.(?:.*\\.|)")+"(\\.|$)"):null;event.result=undefined;if(!event.target){event.target=elem;}data=data==null?[event]:jQuery.makeArray(data,[event]);special=jQuery.event.special[type]||{};if(!onlyHandlers&&special.trigger&&special.trigger.apply(elem,data)===false){return;}if(!onlyHandlers&&!special.noBubble&&!isWindow(elem)){bubbleType=special.delegateType||type;if(!rfocusMorph.test(bubbleType+type)){cur=cur.parentNode;}for(;cur;cur=cur.parentNode){eventPath.push(cur);tmp=cur;}if(tmp===(elem.ownerDocument||document)){eventPath.push(tmp.defaultView||tmp.parentWindow||window);}}i=0;while((cur=eventPath[i++])&&!event.isPropagationStopped()){lastElement=cur;event.type=i>1?bubbleType:special.bindType||type;handle=(dataPriv.get(cur,"events")||Object.create(null))[event.type]&&dataPriv.get(cur,"handle");if(handle){handle.apply(cur,data);}handle=ontype&&cur[ontype];if(handle&&handle.apply&&acceptData(cur)){event.result=handle.apply(cur,data);if(event.result===false){event.preventDefault();}}}event.type=type;if(!onlyHandlers&&!event.isDefaultPrevented()){if((!special._default||special._default.apply(eventPath.pop(),data)===false)&&acceptData(elem)){if(ontype&&isFunction(elem[type])&&!isWindow(elem)){tmp=elem[ontype];if(tmp){elem[ontype]=null;}jQuery.event.triggered=type;if(event.isPropagationStopped()){lastElement.addEventListener(type,stopPropagationCallback);}elem[type]();if(event.isPropagationStopped()){lastElement.removeEventListener(type,stopPropagationCallback);}jQuery.event.triggered=undefined;if(tmp){elem[ontype]=tmp;}}}}return event.result;},simulate:function(type,elem,event){var e=jQuery.extend(new jQuery.Event(),event,{type:type,isSimulated:true});jQuery.event.trigger(e,null,elem);}});jQuery.fn.extend({trigger:function(type,data){return this.each(function(){jQuery.event.trigger(type,data,this);});},triggerHandler:function(type,data){var elem=this[0];if(elem){return jQuery.event.trigger(type,data,elem,true);}}});if(!support.focusin){jQuery.each({focus:"focusin",blur:"focusout"},function(orig,fix){var handler=function(event){jQuery.event.simulate(fix,event.target,jQuery.event.fix(event));};jQuery.event.special[fix]={setup:function(){var doc=this.ownerDocument||this.document||this,attaches=dataPriv.access(doc,fix);if(!attaches){doc.addEventListener(orig,handler,true);}dataPriv.access(doc,fix,(attaches||0)+1);},teardown:function(){var doc=this.ownerDocument||this.document||this,attaches=dataPriv.access(doc,fix)-1;if(!attaches){doc.removeEventListener(orig,handler,true);dataPriv.remove(doc,fix);}else{dataPriv.access(doc,fix,attaches);}}};});}var location=window.location;var nonce={guid:Date.now()};var rquery=/\?/;jQuery.parseXML=function(data){var xml,parserErrorElem;if(!data||typeof data!=="string"){return null;}try{xml=new window.DOMParser().parseFromString(data,"text/xml");}catch(e){}parserErrorElem=xml&&xml.getElementsByTagName("parsererror")[0];if(!xml||parserErrorElem){jQuery.error("Invalid XML: "+(parserErrorElem?jQuery.map(parserErrorElem.childNodes,function(el){return el.textContent;}).join("\n"):data));}return xml;};var rCRLF=/\r?\n/g;function buildParams(prefix,obj,traditional,add){if(Array.isArray(obj)){jQuery.each(obj,function(i,v){if(traditional||/\[\]$/.test(prefix)){add(prefix,v);}else{buildParams(prefix+"["+(typeof v==="object"&&v!=null?i:"")+"]",v,traditional,add);}});}else if(!traditional&&toType(obj)==="object"){for(var name in obj){buildParams(prefix+"["+name+"]",obj[name],traditional,add);}}else{add(prefix,obj);}}jQuery.param=function(a,traditional){var prefix,s=[],add=function(key,valueOrFunction){var value=isFunction(valueOrFunction)?valueOrFunction():valueOrFunction;s[s.length]=encodeURIComponent(key)+"="+encodeURIComponent(value==null?"":value);};if(a==null){return"";}if(Array.isArray(a)||a.jquery&&!jQuery.isPlainObject(a)){jQuery.each(a,function(){add(this.name,this.value);});}else{for(prefix in a){buildParams(prefix,a[prefix],traditional,add);}}return s.join("&");};jQuery.fn.extend({serialize:function(){return jQuery.param(this.serializeArray());},serializeArray:function(){return this.map(function(){var elements=jQuery.prop(this,"elements");return elements?jQuery.makeArray(elements):this;}).filter(function(){var type=this.type;return this.name&&!jQuery(this).is(":disabled")&&/^(?:input|select|textarea|keygen)/i.test(this.nodeName)&&!/^(?:submit|button|image|reset|file)$/i.test(type)&&(this.checked||!rcheckableType.test(type));}).map(function(_i,elem){var val=jQuery(this).val();if(val==null){return null;}if(Array.isArray(val)){return jQuery.map(val,function(val){return{name:elem.name,value:val.replace(rCRLF,"\r\n")};});}return{name:elem.name,value:val.replace(rCRLF,"\r\n")};}).get();}});var prefilters={},transports={},allTypes="*/".concat("*"),originAnchor=document.createElement("a");originAnchor.href=location.href;function addToPrefiltersOrTransports(structure){return function(dataTypeExpression,func){if(typeof dataTypeExpression!=="string"){func=dataTypeExpression;dataTypeExpression="*";}var dataType,i=0,dataTypes=dataTypeExpression.toLowerCase().match(rnothtmlwhite)||[];if(isFunction(func)){while(dataType=dataTypes[i++]){if(dataType[0]==="+"){dataType=dataType.slice(1)||"*";(structure[dataType]=structure[dataType]||[]).unshift(func);}else{(structure[dataType]=structure[dataType]||[]).push(func);}}}};}function inspectPrefiltersOrTransports(structure,options,originalOptions,jqXHR){var inspected={},seekingTransport=structure===transports;function inspect(dataType){var selected;inspected[dataType]=true;jQuery.each(structure[dataType]||[],function(_,prefilterOrFactory){var dataTypeOrTransport=prefilterOrFactory(options,originalOptions,jqXHR);if(typeof dataTypeOrTransport==="string"&&!seekingTransport&&!inspected[dataTypeOrTransport]){options.dataTypes.unshift(dataTypeOrTransport);inspect(dataTypeOrTransport);return false;}else if(seekingTransport){return!(selected=dataTypeOrTransport);}});return selected;}return inspect(options.dataTypes[0])||!inspected["*"]&&inspect("*");}function ajaxExtend(target,src){var key,deep,flatOptions=jQuery.ajaxSettings.flatOptions||{};for(key in src){if(src[key]!==undefined){(flatOptions[key]?target:deep||(deep={}))[key]=src[key];}}if(deep){jQuery.extend(true,target,deep);}return target;}function ajaxHandleResponses(s,jqXHR,responses){var ct,type,finalDataType,firstDataType,contents=s.contents,dataTypes=s.dataTypes;while(dataTypes[0]==="*"){dataTypes.shift();if(ct===undefined){ct=s.mimeType||jqXHR.getResponseHeader("Content-Type");}}if(ct){for(type in contents){if(contents[type]&&contents[type].test(ct)){dataTypes.unshift(type);break;}}}if(dataTypes[0]in responses){finalDataType=dataTypes[0];}else{for(type in responses){if(!dataTypes[0]||s.converters[type+" "+dataTypes[0]]){finalDataType=type;break;}if(!firstDataType){firstDataType=type;}}finalDataType=finalDataType||firstDataType;}if(finalDataType){if(finalDataType!==dataTypes[0]){dataTypes.unshift(finalDataType);}return responses[finalDataType];}}function ajaxConvert(s,response,jqXHR,isSuccess){var conv2,current,conv,tmp,prev,converters={},dataTypes=s.dataTypes.slice();if(dataTypes[1]){for(conv in s.converters){converters[conv.toLowerCase()]=s.converters[conv];}}current=dataTypes.shift();while(current){if(s.responseFields[current]){jqXHR[s.responseFields[current]]=response;}if(!prev&&isSuccess&&s.dataFilter){response=s.dataFilter(response,s.dataType);}prev=current;current=dataTypes.shift();if(current){if(current==="*"){current=prev;}else if(prev!=="*"&&prev!==current){conv=converters[prev+" "+current]||converters["* "+current];if(!conv){for(conv2 in converters){tmp=conv2.split(" ");if(tmp[1]===current){conv=converters[prev+" "+tmp[0]]||converters["* "+tmp[0]];if(conv){if(conv===true){conv=converters[conv2];}else if(converters[conv2]!==true){current=tmp[0];dataTypes.unshift(tmp[1]);}break;}}}}if(conv!==true){if(conv&&s.throws){response=conv(response);}else{try{response=conv(response);}catch(e){return{state:"parsererror",error:conv?e:"No conversion from "+prev+" to "+current};}}}}}}return{state:"success",data:response};}jQuery.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:location.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(location.protocol),global:true,processData:true,async:true,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":allTypes,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":true,"text json":JSON.parse,"text xml":jQuery.parseXML},flatOptions:{url:true,context:true}},ajaxSetup:function(target,settings){return settings?ajaxExtend(ajaxExtend(target,jQuery.ajaxSettings),settings):ajaxExtend(jQuery.ajaxSettings,target);},ajaxPrefilter:addToPrefiltersOrTransports(prefilters),ajaxTransport:addToPrefiltersOrTransports(transports),ajax:function(url,options){if(typeof url==="object"){options=url;url=undefined;}options=options||{};var transport,cacheURL,responseHeadersString,responseHeaders,timeoutTimer,urlAnchor,completed,fireGlobals,i,uncached,s=jQuery.ajaxSetup({},options),callbackContext=s.context||s,globalEventContext=s.context&&(callbackContext.nodeType||callbackContext.jquery)?jQuery(callbackContext):jQuery.event,deferred=jQuery.Deferred(),completeDeferred=jQuery.Callbacks("once memory"),statusCode=s.statusCode||{},requestHeaders={},requestHeadersNames={},strAbort="canceled",jqXHR={readyState:0,getResponseHeader:function(key){var match;if(completed){if(!responseHeaders){responseHeaders={};while(match=/^(.*?):[ \t]*([^\r\n]*)$/mg.exec(responseHeadersString)){responseHeaders[match[1].toLowerCase()+" "]=(responseHeaders[match[1].toLowerCase()+" "]||[]).concat(match[2]);}}match=responseHeaders[key.toLowerCase()+" "];}return match==null?null:match.join(", ");},getAllResponseHeaders:function(){return completed?responseHeadersString:null;},setRequestHeader:function(name,value){if(completed==null){name=requestHeadersNames[name.toLowerCase()]=requestHeadersNames[name.toLowerCase()]||name;requestHeaders[name]=value;}return this;},overrideMimeType:function(type){if(completed==null){s.mimeType=type;}return this;},statusCode:function(map){if(map){if(completed){jqXHR.always(map[jqXHR.status]);}else{for(var code in map){statusCode[code]=[statusCode[code],map[code]];}}}return this;},abort:function(statusText){var finalText=statusText||strAbort;if(transport){transport.abort(finalText);}done(0,finalText);return this;}};deferred.promise(jqXHR);s.url=((url||s.url||location.href)+"").replace(/^\/\//,location.protocol+"//");s.type=options.method||options.type||s.method||s.type;s.dataTypes=(s.dataType||"*").toLowerCase().match(rnothtmlwhite)||[""];if(s.crossDomain==null){urlAnchor=document.createElement("a");try{urlAnchor.href=s.url;urlAnchor.href=urlAnchor.href;s.crossDomain=originAnchor.protocol+"//"+originAnchor.host!==urlAnchor.protocol+"//"+urlAnchor.host;}catch(e){s.crossDomain=true;}}if(s.data&&s.processData&&typeof s.data!=="string"){s.data=jQuery.param(s.data,s.traditional);}inspectPrefiltersOrTransports(prefilters,s,options,jqXHR);if(completed){return jqXHR;}fireGlobals=jQuery.event&&s.global;if(fireGlobals&&jQuery.active++===0){jQuery.event.trigger("ajaxStart");}s.type=s.type.toUpperCase();s.hasContent=!/^(?:GET|HEAD)$/.test(s.type);cacheURL=s.url.replace(/#.*$/,"");if(!s.hasContent){uncached=s.url.slice(cacheURL.length);if(s.data&&(s.processData||typeof s.data==="string")){cacheURL+=(rquery.test(cacheURL)?"&":"?")+s.data;delete s.data;}if(s.cache===false){cacheURL=cacheURL.replace(/([?&])_=[^&]*/,"$1");uncached=(rquery.test(cacheURL)?"&":"?")+"_="+nonce.guid++ +uncached;}s.url=cacheURL+uncached;}else if(s.data&&s.processData&&(s.contentType||"").indexOf("application/x-www-form-urlencoded")===0){s.data=s.data.replace(/%20/g,"+");}if(s.ifModified){if(jQuery.lastModified[cacheURL]){jqXHR.setRequestHeader("If-Modified-Since",jQuery.lastModified[cacheURL]);}if(jQuery.etag[cacheURL]){jqXHR.setRequestHeader("If-None-Match",jQuery.etag[cacheURL]);}}if(s.data&&s.hasContent&&s.contentType!==false||options.contentType){jqXHR.setRequestHeader("Content-Type",s.contentType);}jqXHR.setRequestHeader("Accept",s.dataTypes[0]&&s.accepts[s.dataTypes[0]]?s.accepts[s.dataTypes[0]]+(s.dataTypes[0]!=="*"?", "+allTypes+"; q=0.01":""):s.accepts["*"]);for(i in s.headers){jqXHR.setRequestHeader(i,s.headers[i]);}if(s.beforeSend&&(s.beforeSend.call(callbackContext,jqXHR,s)===false||completed)){return jqXHR.abort();}strAbort="abort";completeDeferred.add(s.complete);jqXHR.done(s.success);jqXHR.fail(s.error);transport=inspectPrefiltersOrTransports(transports,s,options,jqXHR);if(!transport){done(-1,"No Transport");}else{jqXHR.readyState=1;if(fireGlobals){globalEventContext.trigger("ajaxSend",[jqXHR,s]);}if(completed){return jqXHR;}if(s.async&&s.timeout>0){timeoutTimer=window.setTimeout(function(){jqXHR.abort("timeout");},s.timeout);}try{completed=false;transport.send(requestHeaders,done);}catch(e){if(completed){throw e;}done(-1,e);}}function done(status,nativeStatusText,responses,headers){var isSuccess,success,error,response,modified,statusText=nativeStatusText;if(completed){return;}completed=true;if(timeoutTimer){window.clearTimeout(timeoutTimer);}transport=undefined;responseHeadersString=headers||"";jqXHR.readyState=status>0?4:0;isSuccess=status>=200&&status<300||status===304;if(responses){response=ajaxHandleResponses(s,jqXHR,responses);}if(!isSuccess&&jQuery.inArray("script",s.dataTypes)>-1&&jQuery.inArray("json",s.dataTypes)<0){s.converters["text script"]=function(){};}response=ajaxConvert(s,response,jqXHR,isSuccess);if(isSuccess){if(s.ifModified){modified=jqXHR.getResponseHeader("Last-Modified");if(modified){jQuery.lastModified[cacheURL]=modified;}modified=jqXHR.getResponseHeader("etag");if(modified){jQuery.etag[cacheURL]=modified;}}if(status===204||s.type==="HEAD"){statusText="nocontent";}else if(status===304){statusText="notmodified";}else{statusText=response.state;success=response.data;error=response.error;isSuccess=!error;}}else{error=statusText;if(status||!statusText){statusText="error";if(status<0){status=0;}}}jqXHR.status=status;jqXHR.statusText=(nativeStatusText||statusText)+"";if(isSuccess){deferred.resolveWith(callbackContext,[success,statusText,jqXHR]);}else{deferred.rejectWith(callbackContext,[jqXHR,statusText,error]);}jqXHR.statusCode(statusCode);statusCode=undefined;if(fireGlobals){globalEventContext.trigger(isSuccess?"ajaxSuccess":"ajaxError",[jqXHR,s,isSuccess?success:error]);}completeDeferred.fireWith(callbackContext,[jqXHR,statusText]);if(fireGlobals){globalEventContext.trigger("ajaxComplete",[jqXHR,s]);if(! --jQuery.active){jQuery.event.trigger("ajaxStop");}}}return jqXHR;},getJSON:function(url,data,callback){return jQuery.get(url,data,callback,"json");},getScript:function(url,callback){return jQuery.get(url,undefined,callback,"script");}});jQuery.each(["get","post"],function(_i,method){jQuery[method]=function(url,data,callback,type){if(isFunction(data)){type=type||callback;callback=data;data=undefined;}return jQuery.ajax(jQuery.extend({url:url,type:method,dataType:type,data:data,success:callback},jQuery.isPlainObject(url)&&url));};});jQuery.ajaxPrefilter(function(s){for(var i in s.headers){if(i.toLowerCase()==="content-type"){s.contentType=s.headers[i]||"";}}});jQuery._evalUrl=function(url,options,doc){return jQuery.ajax({url:url,type:"GET",dataType:"script",cache:true,async:false,global:false,converters:{"text script":function(){}},dataFilter:function(response){jQuery.globalEval(response,options,doc);}});};jQuery.fn.extend({wrapAll:function(html){var wrap;if(this[0]){if(isFunction(html)){html=html.call(this[0]);}wrap=jQuery(html,this[0].ownerDocument).eq(0).clone(true);if(this[0].parentNode){wrap.insertBefore(this[0]);}wrap.map(function(){var elem=this;while(elem.firstElementChild){elem=elem.firstElementChild;}return elem;}).append(this);}return this;},wrapInner:function(html){if(isFunction(html)){return this.each(function(i){jQuery(this).wrapInner(html.call(this,i));});}return this.each(function(){var self=jQuery(this),contents=self.contents();if(contents.length){contents.wrapAll(html);}else{self.append(html);}});},wrap:function(html){var htmlIsFunction=isFunction(html);return this.each(function(i){jQuery(this).wrapAll(htmlIsFunction?html.call(this,i):html);});},unwrap:function(selector){this.parent(selector).not("body").each(function(){jQuery(this).replaceWith(this.childNodes);});return this;}});jQuery.expr.pseudos.hidden=function(elem){return!jQuery.expr.pseudos.visible(elem);};jQuery.expr.pseudos.visible=function(elem){return!!(elem.offsetWidth||elem.offsetHeight||elem.getClientRects().length);};jQuery.ajaxSettings.xhr=function(){try{return new window.XMLHttpRequest();}catch(e){}};var xhrSuccessStatus={0:200,1223:204},xhrSupported=jQuery.ajaxSettings.xhr();support.cors=!!xhrSupported&&"withCredentials"in xhrSupported;support.ajax=xhrSupported=!!xhrSupported;jQuery.ajaxTransport(function(options){var callback,errorCallback;if(support.cors||xhrSupported&&!options.crossDomain){return{send:function(headers,complete){var i,xhr=options.xhr();xhr.open(options.type,options.url,options.async,options.username,options.password);if(options.xhrFields){for(i in options.xhrFields){xhr[i]=options.xhrFields[i];}}if(options.mimeType&&xhr.overrideMimeType){xhr.overrideMimeType(options.mimeType);}if(!options.crossDomain&&!headers["X-Requested-With"]){headers["X-Requested-With"]="XMLHttpRequest";}for(i in headers){xhr.setRequestHeader(i,headers[i]);}callback=function(type){return function(){if(callback){callback=errorCallback=xhr.onload=xhr.onerror=xhr.onabort=xhr.ontimeout=xhr.onreadystatechange=null;if(type==="abort"){xhr.abort();}else if(type==="error"){if(typeof xhr.status!=="number"){complete(0,"error");}else{complete(xhr.status,xhr.statusText);}}else{complete(xhrSuccessStatus[xhr.status]||xhr.status,xhr.statusText,(xhr.responseType||"text")!=="text"||typeof xhr.responseText!=="string"?{binary:xhr.response}:{text:xhr.responseText},xhr.getAllResponseHeaders());}}};};xhr.onload=callback();errorCallback=xhr.onerror=xhr.ontimeout=callback("error");if(xhr.onabort!==undefined){xhr.onabort=errorCallback;}else{xhr.onreadystatechange=function(){if(xhr.readyState===4){window.setTimeout(function(){if(callback){errorCallback();}});}};}callback=callback("abort");try{xhr.send(options.hasContent&&options.data||null);}catch(e){if(callback){throw e;}}},abort:function(){if(callback){callback();}}};}});jQuery.ajaxPrefilter(function(s){if(s.crossDomain){s.contents.script=false;}});jQuery.ajaxSetup({accepts:{script:"text/javascript, application/javascript, "+"application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(text){jQuery.globalEval(text);return text;}}});jQuery.ajaxPrefilter("script",function(s){if(s.cache===undefined){s.cache=false;}if(s.crossDomain){s.type="GET";}});jQuery.ajaxTransport("script",function(s){if(s.crossDomain||s.scriptAttrs){var script,callback;return{send:function(_,complete){script=jQuery("<script>").attr(s.scriptAttrs||{}).prop({charset:s.scriptCharset,src:s.url}).on("load error",callback=function(evt){script.remove();callback=null;if(evt){complete(evt.type==="error"?404:200,evt.type);}});document.head.appendChild(script[0]);},abort:function(){if(callback){callback();}}};}});var oldCallbacks=[],rjsonp=/(=)\?(?=&|$)|\?\?/;jQuery.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var callback=oldCallbacks.pop()||jQuery.expando+"_"+nonce.guid++;this[callback]=true;return callback;}});jQuery.ajaxPrefilter("json jsonp",function(s,originalSettings,jqXHR){var callbackName,overwritten,responseContainer,jsonProp=s.jsonp!==false&&(rjsonp.test(s.url)?"url":typeof s.data==="string"&&(s.contentType||"").indexOf("application/x-www-form-urlencoded")===0&&rjsonp.test(s.data)&&"data");if(jsonProp||s.dataTypes[0]==="jsonp"){callbackName=s.jsonpCallback=isFunction(s.jsonpCallback)?s.jsonpCallback():s.jsonpCallback;if(jsonProp){s[jsonProp]=s[jsonProp].replace(rjsonp,"$1"+callbackName);}else if(s.jsonp!==false){s.url+=(rquery.test(s.url)?"&":"?")+s.jsonp+"="+callbackName;}s.converters["script json"]=function(){if(!responseContainer){jQuery.error(callbackName+" was not called");}return responseContainer[0];};s.dataTypes[0]="json";overwritten=window[callbackName];window[callbackName]=function(){responseContainer=arguments;};jqXHR.always(function(){if(overwritten===undefined){jQuery(window).removeProp(callbackName);}else{window[callbackName]=overwritten;}if(s[callbackName]){s.jsonpCallback=originalSettings.jsonpCallback;oldCallbacks.push(callbackName);}if(responseContainer&&isFunction(overwritten)){overwritten(responseContainer[0]);}responseContainer=overwritten=undefined;});return"script";}});support.createHTMLDocument=function(){var body=document.implementation.createHTMLDocument("").body;body.innerHTML="<form></form><form></form>";return body.childNodes.length===2;}();jQuery.parseHTML=function(data,context,keepScripts){if(typeof data!=="string"){return[];}if(typeof context==="boolean"){keepScripts=context;context=false;}var base,parsed,scripts;if(!context){if(support.createHTMLDocument){context=document.implementation.createHTMLDocument("");base=context.createElement("base");base.href=document.location.href;context.head.appendChild(base);}else{context=document;}}parsed=rsingleTag.exec(data);scripts=!keepScripts&&[];if(parsed){return[context.createElement(parsed[1])];}parsed=buildFragment([data],context,scripts);if(scripts&&scripts.length){jQuery(scripts).remove();}return jQuery.merge([],parsed.childNodes);};jQuery.fn.load=function(url,params,callback){var selector,type,response,self=this,off=url.indexOf(" ");if(off>-1){selector=stripAndCollapse(url.slice(off));url=url.slice(0,off);}if(isFunction(params)){callback=params;params=undefined;}else if(params&&typeof params==="object"){type="POST";}if(self.length>0){jQuery.ajax({url:url,type:type||"GET",dataType:"html",data:params}).done(function(responseText){response=arguments;self.html(selector?jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector):responseText);}).always(callback&&function(jqXHR,status){self.each(function(){callback.apply(this,response||[jqXHR.responseText,status,jqXHR]);});});}return this;};jQuery.expr.pseudos.animated=function(elem){return jQuery.grep(jQuery.timers,function(fn){return elem===fn.elem;}).length;};jQuery.offset={setOffset:function(elem,options,i){var curPosition,curLeft,curCSSTop,curTop,curOffset,curCSSLeft,calculatePosition,position=jQuery.css(elem,"position"),curElem=jQuery(elem),props={};if(position==="static"){elem.style.position="relative";}curOffset=curElem.offset();curCSSTop=jQuery.css(elem,"top");curCSSLeft=jQuery.css(elem,"left");calculatePosition=(position==="absolute"||position==="fixed")&&(curCSSTop+curCSSLeft).indexOf("auto")>-1;if(calculatePosition){curPosition=curElem.position();curTop=curPosition.top;curLeft=curPosition.left;}else{curTop=parseFloat(curCSSTop)||0;curLeft=parseFloat(curCSSLeft)||0;}if(isFunction(options)){options=options.call(elem,i,jQuery.extend({},curOffset));}if(options.top!=null){props.top=options.top-curOffset.top+curTop;}if(options.left!=null){props.left=options.left-curOffset.left+curLeft;}if("using"in options){options.using.call(elem,props);}else{curElem.css(props);}}};jQuery.fn.extend({offset:function(options){if(arguments.length){return options===undefined?this:this.each(function(i){jQuery.offset.setOffset(this,options,i);});}var rect,win,elem=this[0];if(!elem){return;}if(!elem.getClientRects().length){return{top:0,left:0};}rect=elem.getBoundingClientRect();win=elem.ownerDocument.defaultView;return{top:rect.top+win.pageYOffset,left:rect.left+win.pageXOffset};},position:function(){if(!this[0]){return;}var offsetParent,offset,doc,elem=this[0],parentOffset={top:0,left:0};if(jQuery.css(elem,"position")==="fixed"){offset=elem.getBoundingClientRect();}else{offset=this.offset();doc=elem.ownerDocument;offsetParent=elem.offsetParent||doc.documentElement;while(offsetParent&&(offsetParent===doc.body||offsetParent===doc.documentElement)&&jQuery.css(offsetParent,"position")==="static"){offsetParent=offsetParent.parentNode;}if(offsetParent&&offsetParent!==elem&&offsetParent.nodeType===1){parentOffset=jQuery(offsetParent).offset();parentOffset.top+=jQuery.css(offsetParent,"borderTopWidth",true);parentOffset.left+=jQuery.css(offsetParent,"borderLeftWidth",true);}}return{top:offset.top-parentOffset.top-jQuery.css(elem,"marginTop",true),left:offset.left-parentOffset.left-jQuery.css(elem,"marginLeft",true)};},offsetParent:function(){return this.map(function(){var offsetParent=this.offsetParent;while(offsetParent&&jQuery.css(offsetParent,"position")==="static"){offsetParent=offsetParent.offsetParent;}return offsetParent||documentElement;});}});jQuery.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(method,prop){var top="pageYOffset"===prop;jQuery.fn[method]=function(val){return access(this,function(elem,method,val){var win;if(isWindow(elem)){win=elem;}else if(elem.nodeType===9){win=elem.defaultView;}if(val===undefined){return win?win[prop]:elem[method];}if(win){win.scrollTo(!top?val:win.pageXOffset,top?val:win.pageYOffset);}else{elem[method]=val;}},method,val,arguments.length);};});jQuery.each(["top","left"],function(_i,prop){jQuery.cssHooks[prop]=addGetHookIf(support.pixelPosition,function(elem,computed){if(computed){computed=curCSS(elem,prop);return rnumnonpx.test(computed)?jQuery(elem).position()[prop]+"px":computed;}});});jQuery.each({Height:"height",Width:"width"},function(name,type){jQuery.each({padding:"inner"+name,content:type,"":"outer"+name},function(defaultExtra,funcName){jQuery.fn[funcName]=function(margin,value){var chainable=arguments.length&&(defaultExtra||typeof margin!=="boolean"),extra=defaultExtra||(margin===true||value===true?"margin":"border");return access(this,function(elem,type,value){var doc;if(isWindow(elem)){return funcName.indexOf("outer")===0?elem["inner"+name]:elem.document.documentElement["client"+name];}if(elem.nodeType===9){doc=elem.documentElement;return Math.max(elem.body["scroll"+name],doc["scroll"+name],elem.body["offset"+name],doc["offset"+name],doc["client"+name]);}return value===undefined?jQuery.css(elem,type,extra):jQuery.style(elem,type,value,extra);},type,chainable?margin:undefined,chainable);};});});jQuery.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(_i,type){jQuery.fn[type]=function(fn){return this.on(type,fn);};});jQuery.fn.extend({bind:function(types,data,fn){return this.on(types,null,data,fn);},unbind:function(types,fn){return this.off(types,null,fn);},delegate:function(selector,types,data,fn){return this.on(types,selector,data,fn);},undelegate:function(selector,types,fn){return arguments.length===1?this.off(selector,"**"):this.off(types,selector||"**",fn);},hover:function(fnOver,fnOut){return this.mouseenter(fnOver).mouseleave(fnOut||fnOver);}});jQuery.each(("blur focus focusin focusout resize scroll click dblclick "+"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave "+"change select submit keydown keypress keyup contextmenu").split(" "),function(_i,name){jQuery.fn[name]=function(data,fn){return arguments.length>0?this.on(name,null,data,fn):this.trigger(name);};});jQuery.proxy=function(fn,context){var tmp,args,proxy;if(typeof context==="string"){tmp=fn[context];context=fn;fn=tmp;}if(!isFunction(fn)){return undefined;}args=slice.call(arguments,2);proxy=function(){return fn.apply(context||this,args.concat(slice.call(arguments)));};proxy.guid=fn.guid=fn.guid||jQuery.guid++;return proxy;};jQuery.holdReady=function(hold){if(hold){jQuery.readyWait++;}else{jQuery.ready(true);}};jQuery.isArray=Array.isArray;jQuery.parseJSON=JSON.parse;jQuery.nodeName=nodeName;jQuery.isFunction=isFunction;jQuery.isWindow=isWindow;jQuery.camelCase=camelCase;jQuery.type=toType;jQuery.now=Date.now;jQuery.isNumeric=function(obj){var type=jQuery.type(obj);return(type==="number"||type==="string")&&!isNaN(obj-parseFloat(obj));};jQuery.trim=function(text){return text==null?"":(text+"").replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");};if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return jQuery;}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}var _jQuery=window.jQuery,_$=window.$;jQuery.noConflict=function(deep){if(window.$===jQuery){window.$=_$;}if(deep&&window.jQuery===jQuery){window.jQuery=_jQuery;}return jQuery;};if(typeof noGlobal==="undefined"){window.jQuery=window.$=jQuery;}return jQuery;});

/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "r", function() { return /* binding */ waitForEvent; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* binding */ waitForChild; });
__webpack_require__.d(__webpack_exports__, "t", function() { return /* binding */ watchForChildren; });
__webpack_require__.d(__webpack_exports__, "v", function() { return /* binding */ watchForFutureChildren; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* binding */ waitForDescendant; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* binding */ waitForDescendantChange; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* binding */ waitForAttach; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* binding */ waitForDetach; });
__webpack_require__.d(__webpack_exports__, "u", function() { return /* binding */ watchForDescendants; });
__webpack_require__.d(__webpack_exports__, "w", function() { return /* binding */ watchForFutureDescendants; });
__webpack_require__.d(__webpack_exports__, "s", function() { return /* binding */ waitForSelectorMatch; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ empty; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ click; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ getViewportSize; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ elementInViewport; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ getPercentageVisibleYAxis; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* binding */ scrollToElement; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _addHeaderId; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ getHeaderOffset; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ getD2xBodyOffset; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ addCSS; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ isLastNodeInDOM; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ preventCloning; });

// EXTERNAL MODULE: ./node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(93);

// EXTERNAL MODULE: ./node_modules/lodash-es/_basePickBy.js + 1 modules
var _basePickBy = __webpack_require__(92);

// EXTERNAL MODULE: ./node_modules/lodash-es/hasIn.js + 2 modules
var hasIn = __webpack_require__(88);

// CONCATENATED MODULE: ./node_modules/lodash-es/_basePick.js
function basePick(object,paths){return Object(_basePickBy["a" /* default */])(object,paths,function(value,path){return Object(hasIn["a" /* default */])(object,path);});}/* harmony default export */ var _basePick = (basePick);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseFlatten.js + 1 modules
var _baseFlatten = __webpack_require__(69);

// CONCATENATED MODULE: ./node_modules/lodash-es/flatten.js
function flatten(array){var length=array==null?0:array.length;return length?Object(_baseFlatten["a" /* default */])(array,1):[];}/* harmony default export */ var lodash_es_flatten = (flatten);
// EXTERNAL MODULE: ./node_modules/lodash-es/_overRest.js
var _overRest = __webpack_require__(78);

// EXTERNAL MODULE: ./node_modules/lodash-es/_setToString.js + 2 modules
var _setToString = __webpack_require__(68);

// CONCATENATED MODULE: ./node_modules/lodash-es/_flatRest.js
function flatRest(func){return Object(_setToString["a" /* default */])(Object(_overRest["a" /* default */])(func,undefined,lodash_es_flatten),func+'');}/* harmony default export */ var _flatRest = (flatRest);
// CONCATENATED MODULE: ./node_modules/lodash-es/pick.js
var pick=_flatRest(function(object,paths){return object==null?{}:_basePick(object,paths);});/* harmony default export */ var lodash_es_pick = (pick);
// EXTERNAL MODULE: ./node_modules/lodash-es/once.js + 1 modules
var once = __webpack_require__(132);

// EXTERNAL MODULE: ./node_modules/lodash-es/_copyObject.js
var _copyObject = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseRest.js
var _baseRest = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/lodash-es/_isIterateeCall.js
var _isIterateeCall = __webpack_require__(54);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner){return Object(_baseRest["a" /* default */])(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&Object(_isIterateeCall["a" /* default */])(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/* harmony default export */ var _createAssigner = (createAssigner);
// EXTERNAL MODULE: ./node_modules/lodash-es/keysIn.js + 2 modules
var keysIn = __webpack_require__(47);

// CONCATENATED MODULE: ./node_modules/lodash-es/assignIn.js
var assignIn=_createAssigner(function(object,source){Object(_copyObject["a" /* default */])(source,Object(keysIn["a" /* default */])(source),object);});/* harmony default export */ var lodash_es_assignIn = (assignIn);
// EXTERNAL MODULE: ./lib/utils/flow.js
var flow = __webpack_require__(16);

// CONCATENATED MODULE: ./lib/utils/dom.js


function waitForEvent(ele, ...events) {
  return Promise.race(events.map(event => new Promise(resolve => {
    ele.addEventListener(event, function fire(e) {
      ele.removeEventListener(event, fire);
      resolve(e);
    });
  })));
}
function waitForChild(ele, selector) {
  return new Promise(resolve => {
    const child = Array.from(ele.children).find(child => child.matches(selector));

    if (child) {
      resolve(child);
      return;
    }

    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE && node.matches(selector)) {
            observer.disconnect();
            resolve(Object(flow["a" /* downcast */])(node, HTMLElement));
            return;
          }
        }
      }
    });
    observer.observe(ele, {
      childList: true
    });
  });
}
function watchForChildren(ele, selector, callback) {
  for (const child of Array.from(ele.children).filter(child => child.matches(selector))) {
    callback(child);
  }

  watchForFutureChildren(ele, selector, callback);
}
function watchForFutureChildren(ele, selector, callback) {
  new MutationObserver(mutations => {
    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE && node.matches(selector)) {
          callback(Object(flow["a" /* downcast */])(node, HTMLElement));
        }
      }
    }
  }).observe(ele, {
    childList: true
  });
}
function waitForDescendant(ele, selector) {
  return new Promise(resolve => {
    const child = ele.querySelector(selector);

    if (child) {
      resolve(child);
      return;
    }

    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const child = ele.querySelector(selector);

            if (child) {
              observer.disconnect();
              resolve(child);
            }

            return;
          }
        }
      }
    });
    observer.observe(ele, {
      childList: true,
      subtree: true
    });
  });
}
function waitForDescendantChange(ele, selector) {
  return new Promise(resolve => {
    const found = () => {
      observer.disconnect();
      resolve();
    };

    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        if (mutation.target.matches(selector)) return found();

        for (const node of mutation.addedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE && node.querySelector(selector)) return found();
        }

        for (const node of mutation.removedNodes) {
          if (node.nodeType === Node.ELEMENT_NODE && node.querySelector(selector)) return found();
        }
      }
    });
    observer.observe(ele, {
      childList: true,
      subtree: true
    });
  });
}
function waitForAttach(parent, el, cancel) {
  if (parent.contains(el)) return Promise.resolve();
  return new Promise((resolve, reject) => {
    const observer = new MutationObserver(() => {
      if (parent.contains(el)) {
        resolve();
        observer.disconnect();
      }
    });
    observer.observe(parent, {
      subtree: true,
      childList: true
    });
    if (cancel) cancel.then(() => {
      observer.disconnect();
      reject(new Error('Canceled'));
    });
  });
}
function waitForDetach(el, cancel) {
  const parent = document.documentElement;
  if (!parent.contains(el)) return Promise.resolve();
  return new Promise((resolve, reject) => {
    const observer = new MutationObserver(() => {
      if (!parent.contains(el)) {
        resolve();
        observer.disconnect();
      }
    });
    observer.observe(parent, {
      subtree: true,
      childList: true
    });
    if (cancel) cancel.then(() => {
      observer.disconnect();
      reject(new Error('Canceled'));
    });
  });
}
function watchForDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches = false) {
  for (const child of ele.querySelectorAll(selector)) {
    callback(child);
  }

  watchForFutureDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches);
}
function watchForFutureDescendants(ele, selector, callback, ignoreChildrenIfAddedNodeMatches = false) {
  new MutationObserver(mutations => {
    const children = new Set();

    for (const mutation of mutations) {
      for (const node of mutation.addedNodes) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.matches(selector)) {
            children.add(node);
            if (ignoreChildrenIfAddedNodeMatches) continue;
          }

          for (const child of node.querySelectorAll(selector)) {
            children.add(child);
          }
        }
      }
    }

    for (const child of children) {
      callback(Object(flow["a" /* downcast */])(child, HTMLElement));
    }
  }).observe(ele, {
    childList: true,
    subtree: true
  });
}
function waitForSelectorMatch(ele, selector) {
  if (ele.matches(selector)) return Promise.resolve();
  return new Promise(resolve => {
    const observer = new MutationObserver(() => {
      if (ele.matches(selector)) {
        resolve();
        observer.disconnect();
      }
    });
    observer.observe(ele, {
      attributes: true
    });
  });
}
function empty(parent) {
  while (parent.lastChild) parent.removeChild(parent.lastChild);

  return parent;
}
function click(obj, button = 0) {
  obj.dispatchEvent(new MouseEvent('click', {
    bubbles: true,
    cancelable: true,
    detail: 0,
    screenX: 1,
    screenY: 1,
    clientX: 1,
    clientY: 1,
    button
  }));
}

click.isProgrammaticEvent = e => e.clientX === 1 && e.clientY === 1;

const getViewportSize = Object(memoize["a" /* default */])(() => {
  waitForEvent(window, 'resize').then(() => {
    getViewportSize.cache.clear();
  });
  let visualViewport;

  if (window.visualViewport) {
    visualViewport = window.visualViewport;
  } else {
    const viewportSizedElement = document.createElement('div');
    viewportSizedElement.style.width = viewportSizedElement.style.height = '100%';
    viewportSizedElement.style.position = 'fixed';
    document.body.appendChild(viewportSizedElement);
    visualViewport = viewportSizedElement.getBoundingClientRect();

    if (!visualViewport.height || !visualViewport.width) {
      visualViewport = document.documentElement.getBoundingClientRect();
    }

    viewportSizedElement.remove();
  }

  return lodash_es_pick(visualViewport, ['height', 'width']);
});
function elementInViewport(ele) {
  if (!ele || !ele.offsetParent) return false;
  const {
    top,
    left,
    bottom,
    right
  } = ele.getBoundingClientRect();
  return top >= 0 && left >= 0 && bottom <= getViewportSize().height && right <= getViewportSize().width;
}

function getViewportDimensions() {
  const headerOffset = getHeaderOffset();
  const left = window.pageXOffset;
  const top = window.pageYOffset + headerOffset;
  const width = getViewportSize().width;
  const height = getViewportSize().height - headerOffset;
  return {
    yOffset: headerOffset,
    left,
    top,
    bottom: top + height,
    right: left + width,
    width,
    height
  };
}

function getPercentageVisibleYAxis(obj) {
  const rect = obj.getBoundingClientRect();
  const top = Math.max(0, rect.bottom - rect.height);
  const bottom = Math.min(getViewportSize().height, rect.bottom);

  if (rect.height === 0) {
    return 0;
  }

  return Math.max(0, (bottom - top) / rect.height);
}
const padBottom = Object(once["a" /* default */])(() => {
  const element = document.createElement('div');
  element.style.clear = 'both';
  return (scrollTop, viewportHeight) => {
    const currentPadding = element.clientHeight;
    const paddingRequired = 50 + -(document.documentElement.scrollHeight - scrollTop - viewportHeight - currentPadding);
    if (paddingRequired > 0) document.body.append(element);else element.remove();
    element.style.height = `${paddingRequired}px`;
  };
});
let recentScroll = false;
let scrollInvokationToken;
function scrollToElement(to, from, {
  scrollStyle,
  restrictDirectionTo,
  direction: selectedDirection,
  anchor,
  waitTillVisible
}) {
  const _scrollInvokationToken = scrollInvokationToken = {};

  if (scrollStyle === 'none' && !anchor) {
    return;
  }

  if (waitTillVisible && !to.offsetParent) {
    requestAnimationFrame(() => {
      if (scrollInvokationToken === _scrollInvokationToken) scrollToElement(...arguments);
    });
    return;
  }

  if (!to.offsetParent) {
    console.error('Element is not visible.');
    return;
  }

  if (scrollStyle === 'none' && anchor) {
    const diff = to.getBoundingClientRect().top - anchor.to;
    if (diff) window.scrollBy(0, diff);
  }

  const viewport = getViewportDimensions();
  const target = lodash_es_assignIn({}, to.getBoundingClientRect());
  target.top -= viewport.yOffset;
  target.bottom -= viewport.yOffset;
  const top = viewport.top + target.top - 5;

  if (scrollStyle === 'middle' && target.height >= viewport.height) {
    scrollStyle = 'top';
  }

  let compensateHeader = true;
  let scrollY;

  if (scrollStyle === 'top') {
    padBottom()(top, viewport.height);
    scrollY = top;
  } else if (from && scrollStyle === 'adopt') {
    const fromTop = anchor && typeof anchor.from === 'number' ? anchor.from : from.getBoundingClientRect().top;
    let diff = to.getBoundingClientRect().top - fromTop;

    if (fromTop < 0) {
      diff += fromTop;
    } else if (fromTop > viewport.height - 60) {
      diff += fromTop - viewport.height + 60;
    }

    scrollY = window.scrollY + diff;
    compensateHeader = false;
  } else if (scrollStyle === 'middle') {
    const buffer = (viewport.height - target.height) / 2;
    const newScrollY = top - buffer;

    if (elementInViewport(to)) {
      const viewportDirection = newScrollY >= window.scrollY ? 'down' : 'up';
      if (viewportDirection !== selectedDirection) return;
    }

    scrollY = newScrollY;
  } else if (target.top >= 0 && target.bottom <= viewport.height) {} else if (scrollStyle === 'legacy') {
    scrollY = top;
  } else if (target.top < viewport.yOffset) {
    scrollY = top;
  } else if (viewport.height < target.bottom && target.height < viewport.height) {
    if (scrollStyle === 'page') {
      scrollY = top;
    } else {
      scrollY = viewport.top + target.bottom - viewport.height;
    }
  } else {
    scrollY = top;
  }

  if (scrollY !== undefined) {
    if (compensateHeader) scrollY -= getHeaderOffset();
    const scollDirection = scrollY > viewport.top ? 'down' : 'up';
    if (viewport.top === scrollY || restrictDirectionTo && restrictDirectionTo !== scollDirection) return;
    window.scrollTo(0, scrollY);
    recentScroll = true;
    waitForEvent(window, 'scroll').then(() => {
      recentScroll = false;
    });
  }
}

scrollToElement.isProgrammaticEvent = () => recentScroll;

const headerIds = {
  fullWidth: [],
  partialWidth: []
};
function _addHeaderId(elementId, partialWidth = false) {
  headerIds[partialWidth ? 'partialWidth' : 'fullWidth'].push(elementId);
}
const getHeaderOffset = Object(memoize["a" /* default */])((includePartialWidthHeaders = false) => {
  const headers = [...headerIds.fullWidth, ...(includePartialWidthHeaders ? headerIds.partialWidth : [])];
  return headers.map(id => document.getElementById(id)).reduce((a, b) => a + b.getBoundingClientRect().height, 0);
});
const getD2xBodyOffset = Object(memoize["a" /* default */])(() => {
  try {
    return document.getElementById('2x-container').offsetTop;
  } catch (e) {
    return 65;
  }
});
function addCSS(css) {
  let style = addStyle(css);
  return {
    remove() {
      if (!style) return;
      style.remove();
      style.textContent = '';
      style = undefined;
    }

  };
}

function addStyle(css) {
  const style = document.createElement('style');
  style.textContent = css;
  (document.head || document.documentElement).appendChild(style);
  return style;
}

const isLastNodeInDOM = node => {
  let _last = node;

  do {
    if (_last.nextSibling) break;
  } while (_last = _last.parentNode);

  return !_last;
};
const preventCloning = (() => {
  if (typeof window === 'undefined') return e => e;
  const attribute = `res-prevent-cloning-${Date.now()}`;
  const elements = new WeakSet();
  waitForEvent(window, 'DOMContentLoaded', 'load').then(() => {
    const {
      watchForThings
    } = __webpack_require__(53);

    watchForThings(null, thing => {
      for (const ele of [...thing.entry.querySelectorAll(`[${attribute}]`)]) {
        if (!elements.has(ele)) ele.remove();
      }
    }, {
      immediate: true
    });
  });
  return element => {
    element.setAttribute(attribute, '');
    elements.add(element);
    return element;
  };
})();

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ waitFor; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ forEachChunked; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ batch; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ fastAsync; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ keyedMutex; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ mutex; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ throttle; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ frameDebounce; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ frameThrottle; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ throttleQueuePositionReset; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ idleThrottle; });

// UNUSED EXPORTS: asyncFlow, reifyPromise

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIteratee.js + 9 modules
var _baseIteratee = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/lodash-es/_castPath.js + 2 modules
var _castPath = __webpack_require__(34);

// CONCATENATED MODULE: ./node_modules/lodash-es/last.js
function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/* harmony default export */ var lodash_es_last = (last);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGet.js
var _baseGet = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseSlice.js
var _baseSlice = __webpack_require__(75);

// CONCATENATED MODULE: ./node_modules/lodash-es/_parent.js
function _parent_parent(object,path){return path.length<2?object:Object(_baseGet["a" /* default */])(object,Object(_baseSlice["a" /* default */])(path,0,-1));}/* harmony default export */ var _parent = (_parent_parent);
// EXTERNAL MODULE: ./node_modules/lodash-es/_toKey.js
var _toKey = __webpack_require__(20);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseUnset.js
function baseUnset(object,path){path=Object(_castPath["a" /* default */])(path,object);object=_parent(object,path);return object==null||delete object[Object(_toKey["a" /* default */])(lodash_es_last(path))];}/* harmony default export */ var _baseUnset = (baseUnset);
// EXTERNAL MODULE: ./node_modules/lodash-es/_isIndex.js
var _isIndex = __webpack_require__(21);

// CONCATENATED MODULE: ./node_modules/lodash-es/_basePullAt.js
var arrayProto=Array.prototype;var splice=arrayProto.splice;function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(Object(_isIndex["a" /* default */])(index)){splice.call(array,index,1);}else{_baseUnset(array,index);}}}return array;}/* harmony default export */ var _basePullAt = (basePullAt);
// CONCATENATED MODULE: ./node_modules/lodash-es/remove.js
function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=Object(_baseIteratee["a" /* default */])(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}_basePullAt(array,indexes);return result;}/* harmony default export */ var lodash_es_remove = (remove);
// EXTERNAL MODULE: ./node_modules/lodash-es/curryRight.js + 30 modules
var curryRight = __webpack_require__(131);

// EXTERNAL MODULE: ./node_modules/lodash-es/once.js + 1 modules
var once = __webpack_require__(132);

// EXTERNAL MODULE: ./node_modules/lodash-es/debounce.js + 1 modules
var debounce = __webpack_require__(109);

// EXTERNAL MODULE: ./node_modules/lodash-es/pull.js + 3 modules
var pull = __webpack_require__(133);

// EXTERNAL MODULE: ./lib/utils/generator.js
var generator = __webpack_require__(35);

// CONCATENATED MODULE: ./lib/utils/async.js


function waitFor(callback, interval = 1) {
  return new Promise(resolve => {
    (function repeat() {
      const val = callback();

      if (!val) {
        setTimeout(repeat, interval);
        return;
      }

      resolve(val);
    })();
  });
}
const forEachChunked = (() => {
  const queues = [];
  const run = frameThrottle(() => {
    const start = performance.now();

    do {
      lodash_es_remove(queues, ({
        generator,
        callback,
        resolve,
        reject
      }) => {
        const {
          value,
          done
        } = generator.next();

        if (done) {
          resolve();
          return true;
        }

        try {
          callback(value);
        } catch (e) {
          if (generator.return) generator.return();
          reject(e);
          return true;
        }
      });

      if (!queues.length) {
        return;
      }
    } while (performance.now() - start < 1000 / 30);

    run();
  });
  return Object(curryRight["a" /* default */])((collection, callback) => new Promise((resolve, reject) => {
    const iterable = Symbol.iterator in collection ? collection : Array.from(collection);
    queues.push({
      generator: iterable[Symbol.iterator](),
      callback,
      resolve,
      reject
    });
    run();
  }));
})();
function batch(callback, {
  size = 100,
  delay = 50,
  flushBeforeUnload = false
} = {}) {
  let invoke;

  function* batchAccumulator() {
    const entries = [];
    const promises = [];

    function addPromise() {
      if (entries.length) {
        return new Promise((resolve, reject) => {
          promises.push({
            resolve,
            reject
          });
        });
      } else {
        return undefined;
      }
    }

    invoke = Object(once["a" /* default */])(async () => {
      startNewBatch();
      if (!entries.length) return;

      try {
        const results = (await callback(entries)) || [];

        for (const [{
          resolve,
          reject
        }, result] of Object(generator["b" /* zip */])(promises, results)) {
          if (result instanceof Error) reject(result);else resolve(result);
        }
      } catch (e) {
        for (const {
          reject
        } of promises) {
          reject(e);
        }
      }
    });
    const timeout = delay ? Object(debounce["a" /* default */])(invoke, delay) : throttle(invoke);

    while (entries.length < size) {
      const entry = yield addPromise();
      if (entry === undefined) throw new Error('undefined passed into batch generator');
      entries.push(entry);
      timeout();
    }

    const lastPromise = addPromise();
    invoke();
    yield lastPromise;
  }

  let currentBatch;

  function startNewBatch() {
    currentBatch = batchAccumulator();
    currentBatch.next();
  }

  startNewBatch();
  if (flushBeforeUnload) window.addEventListener('beforeunload', () => {
    invoke();
  }, true);
  return entry => {
    const {
      value
    } = currentBatch.next(entry);
    if (value === undefined) throw new Error('Batch generator was not replaced after completion');
    return value;
  };
}

function always(promise, callback) {
  return promise.then(callback, callback);
}

function fastAsync(callback) {
  return function (...args) {
    return function next(generator, arg, throwing) {
      const {
        value,
        done
      } = !throwing ? generator.next(arg) : generator.throw(arg);

      if (done) {
        return value;
      } else if (!(value instanceof Promise)) {
        return next(generator, value, false);
      } else {
        return value.then(val => next(generator, val, false), err => next(generator, err, true));
      }
    }(Reflect.apply(callback, this, args), undefined, false);
  };
}
function asyncFlow(firstFn, ...fns) {
  return fastAsync(function* (...args) {
    let accum = firstFn(...args);

    for (const fn of fns) {
      accum = fn(yield accum);
    }

    return accum;
  });
}
function reifyPromise(promise) {
  let val = promise;
  promise.then(x => {
    val = x;
  });
  return {
    get: () => val
  };
}
function keyedMutex(callback, keyResolver = x => x) {
  const queues = new Map();
  return function (...args) {
    const key = keyResolver(...args);
    const tail = queues.has(key) ? always(queues.get(key), () => Reflect.apply(callback, this, args)) : Reflect.apply(callback, this, args);

    if (tail instanceof Promise) {
      queues.set(key, tail);
      always(tail, () => {
        if (queues.get(key) === tail) queues.delete(key);
      });
    }

    return tail;
  };
}
function mutex(callback) {
  let queue;
  return function (...args) {
    const tail = queue ? always(queue, () => Reflect.apply(callback, this, args)) : Reflect.apply(callback, this, args);

    if (tail instanceof Promise) {
      queue = tail;
      always(tail, () => {
        if (queue === tail) queue = undefined;
      });
    }

    return tail;
  };
}
function throttle(callback) {
  let promise;
  return () => {
    promise = promise || Promise.resolve().then(() => {
      promise = null;
      callback();
    });
    return promise;
  };
}
function frameDebounce(callback, debounce = 1) {
  let remaining;
  const update = frameThrottle(() => {
    if (remaining) requestAnimationFrame(() => {
      update();
    });else callback();
    remaining -= 1;
  });
  return () => {
    remaining = debounce;
    requestAnimationFrame(() => {
      update();
    });
  };
}
function frameThrottle(callback) {
  let args = [];
  let promise;
  return (...a) => {
    args = a;
    promise = promise || new Promise((res, rej) => {
      requestAnimationFrame(() => {
        promise = null;

        try {
          res(callback(...args));
        } catch (e) {
          rej(e);
        }
      });
    });
    return promise;
  };
}
const throttleQueuePositionReset = (() => {
  let queues = [];
  const run = throttle(() => {
    for (const fn of queues) {
      try {
        fn();
      } catch (e) {}
    }

    queues = [];
  });
  return function (callback) {
    let queued = false;
    return (...a) => {
      if (queued) {
        Object(pull["a" /* default */])(queues, callback);
      } else {
        queued = true;
      }

      queues.push(callback);
      run();
    };
  };
})();
function idleThrottle(callback) {
  let args = [];
  let promise;
  return (...a) => {
    args = a;
    promise = promise || new Promise((res, rej) => {
      requestIdleCallback(() => {
        promise = null;

        try {
          res(callback(...args));
        } catch (e) {
          rej(e);
        }
      });
    });
    return promise;
  };
}

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "o", function() { return /* binding */ matchesPageLocation; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* binding */ regexes; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ execRegexes; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ appType; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ isAppType; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* binding */ isPageType; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ currentSubreddit; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* binding */ isCurrentSubreddit; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ currentMultireddit; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* binding */ isCurrentMultireddit; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ currentDomain; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ currentUserProfile; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ fullLocation; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ isCommentCode; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* binding */ isEmptyLink; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ inQuarantinedSubreddit; });

// UNUSED EXPORTS: pageType, matchesPageRegex

// EXTERNAL MODULE: ./node_modules/lodash-es/_createAggregator.js + 2 modules
var _createAggregator = __webpack_require__(66);

// CONCATENATED MODULE: ./node_modules/lodash-es/partition.js
var partition=Object(_createAggregator["a" /* default */])(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/* harmony default export */ var lodash_es_partition = (partition);
// EXTERNAL MODULE: ./node_modules/lodash-es/once.js + 1 modules
var once = __webpack_require__(132);

// EXTERNAL MODULE: ./node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(93);

// EXTERNAL MODULE: ./lib/utils/dom.js + 6 modules
var dom = __webpack_require__(2);

// CONCATENATED MODULE: ./lib/utils/location.js


function matchesPageLocation(includes, excludes = []) {
  const [includeStrings, includeRegExps] = lodash_es_partition(includes, x => typeof x === 'string');
  const [excludeStrings, excludeRegExps] = lodash_es_partition(excludes, x => typeof x === 'string');
  return (!excludes.length || !(isPageType(...excludeStrings) || isAppType(...excludeStrings) || matchesPageRegex(...excludeRegExps))) && (!includes.length || isPageType(...includeStrings) || isAppType(...includeStrings) || matchesPageRegex(...includeRegExps));
}
const regexes = {
  frontpage: /^\/(?:hot|new|rising|controversial|top)?(?:\/|$)/i,
  comments: /^\/(?:r\/([\w\.]+)\/|(u(?:ser)?\/[\w-]+)\/)?comments\/([a-z0-9]+)(?:\/|$)/i,
  commentsLinklist: /^\/(r\/[\w\.\+]+\/|u(?:ser)?\/[\w-]+\/)?comments\/?$/i,
  inbox: /^\/(?:r\/([\w\.]+)\/)?message(?:\/|$)/i,
  profile: /^\/user\/([\w\-]+)(?:\/(?:(?!m\/)(\w+)))?\/?$/i,
  profile2x: /^\/user\/([\w\-]+)(?:\/(?:(?!m\/)(\w+)))?\/?$/i,
  profileCommentsPage: /^\/user\/([\w\-]+)\/comments\/([a-z0-9]+)(?:\/|$)/i,
  submit: /^\/(?:r\/([\w\.\+]+)\/)?submit(?:\/|$)/i,
  prefs: /^\/prefs(?:\/|$)/i,
  account: /^\/account-activity(?:\/|$)/i,
  wiki: /^\/(?:r\/([\w\.]+)\/)?wiki(?:\/|$)/i,
  stylesheet: /^\/(?:r\/([\w\.]+)\/)about\/stylesheet(?:\/|$)/i,
  search: /^\/(?:r\/[\w\.\+]+\/|(?:me|user\/[\w\-]+)\/[mf]\/[\w\.\+]+\/|domain\/[^\/]+\/)?search(?:\/|$)/i,
  commentPermalink: /^\/(?:r\/([\w\.]+)\/)?comments\/([a-z0-9]+)\/[^\/]*\/([a-z0-9]+)(?:\/|$)/i,
  duplicates: /^\/r\/[\w\.\+]+\/duplicates\/([a-z0-9]+)/i,
  subreddit: /^\/r\/([\w\.\+]+)(?:\/|$)/i,
  subredditAbout: /^\/r\/([\w\.]+)\/about(?:\/(?!modqueue|reports|spam|unmoderated|edited)|$)/i,
  modqueue: /^\/(?:r|me\/f)\/([\w\.\+]+)\/about\/(?:modqueue|reports|spam|unmoderated|edited)(?:\/|$)/i,
  multireddit: /^\/((?:me|user\/[\w\-]+)\/[mf]\/[\w\.\+]+)(?:\/|$)/i,
  domain: /^\/domain\/([\w\.]+)(?:\/|$)/i,
  composeMessage: /^\/(?:r\/([\w\.\+]+)\/)?message\/compose(?:\/|$)/i,
  liveThread: /^\/live\/(?!create(?:\/|$))([a-z0-9]+)(?:\/|$)/i
};
const execRegexes = {
  comments: path => {
    const match = regexes.comments.exec(path);
    if (!match) return match;
    match.splice(1, 2, match[1] || match[2] && match[2].replace(/^u.*\//, 'u_'));
    return match;
  }
};
const appType = Object(once["a" /* default */])(() => {
  if (document.documentElement.hasAttribute('res-options')) {
    return 'options';
  }

  if (document.documentElement.getAttribute('xmlns')) {
    return 'r2';
  }

  return 'd2x';
});
function isAppType(...types) {
  const thisApp = appType();
  return types.some(type => type === thisApp);
}
const appPageTypes = {
  r2: {
    default: 'linklist',
    pageTypes: ['wiki', 'search', 'stylesheet', 'modqueue', 'subredditAbout', 'comments', 'commentsLinklist', 'profile', 'liveThread', 'inbox', 'submit', 'account', 'prefs']
  },
  d2x: {
    pageTypes: ['profile2x', 'profileCommentsPage', 'submit']
  },
  options: {
    pageTypes: []
  }
};
const pageType = Object(memoize["a" /* default */])(() => {
  Object(dom["r" /* waitForEvent */])(document, 'reddit.urlChanged').then(() => {
    pageType.cache.clear();
  });
  const spec = appPageTypes[appType()];
  return spec.pageTypes.find(pageType => regexes[pageType].test(location.pathname)) || spec.default;
});
function isPageType(...types) {
  const thisPage = pageType();
  return types.some(type => type === thisPage);
}
function matchesPageRegex(...regexps) {
  return regexps.some(regex => regex.test(location.pathname));
}
const currentSubreddit = Object(once["a" /* default */])(() => {
  const match = location.pathname.match(regexes.subreddit);
  if (match) return match[1];
});
function isCurrentSubreddit(...subreddits) {
  const sub = (currentSubreddit() || '').toLowerCase();
  if (!sub) return false;
  return subreddits.some(v => v.toLowerCase() === sub);
}
const currentMultireddit = Object(once["a" /* default */])(() => {
  const match = location.pathname.match(regexes.multireddit);
  if (match) return match[1];
});
function isCurrentMultireddit(...multireddits) {
  const multi = (currentMultireddit() || '').toLowerCase();
  if (!multi) return false;
  return multireddits.some(v => v.toLowerCase() === multi);
}
const currentDomain = Object(once["a" /* default */])(() => {
  const match = location.pathname.match(regexes.domain);
  if (match) return match[1];
});
const currentUserProfile = Object(once["a" /* default */])(() => {
  const match = location.pathname.match(regexes.profile);
  if (match) return match[1];
});
const fullLocation = (pathname = location.pathname) => {
  const regex = Object.keys(regexes).find(key => pathname.match(regexes[key]));
  if (!regex) return pathname.toLowerCase();
  return [regex, ...(pathname.match(regexes[regex]) || []).slice(1)].filter(v => v).join('-').toLowerCase();
};
const COMMENT_CODE_REGEX = /^[\/#].+$/;
function isCommentCode(link) {
  const href = link.getAttribute('href');
  const emptyText = link.textContent.length === 0;
  const isCommentCode = COMMENT_CODE_REGEX.test(href);
  return emptyText && isCommentCode;
}
function isEmptyLink(link) {
  const href = link.getAttribute('href');
  return typeof href !== 'string' || href.startsWith('javascript:') || href === '#';
}
const inQuarantinedSubreddit = Object(once["a" /* default */])(() => document.body.classList.contains('quarantine'));

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var isArray=Array.isArray;/* harmony default export */ __webpack_exports__["a"] = (isArray);

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76);
var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;var root=_freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]||freeSelf||Function('return this')();/* harmony default export */ __webpack_exports__["a"] = (root);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/* harmony default export */ __webpack_exports__["a"] = (isObject);

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_Stack.js + 5 modules
var _Stack = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIsEqual.js + 6 modules
var _baseIsEqual = __webpack_require__(65);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new _Stack["a" /* default */]();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?Object(_baseIsEqual["a" /* default */])(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/* harmony default export */ var _baseIsMatch = (baseIsMatch);
// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(7);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value){return value===value&&!Object(isObject["a" /* default */])(value);}/* harmony default export */ var _isStrictComparable = (isStrictComparable);
// EXTERNAL MODULE: ./node_modules/lodash-es/keys.js
var keys = __webpack_require__(32);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getMatchData.js
function getMatchData(object){var result=Object(keys["a" /* default */])(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,_isStrictComparable(value)];}return result;}/* harmony default export */ var _getMatchData = (getMatchData);
// CONCATENATED MODULE: ./node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/* harmony default export */ var _matchesStrictComparable = (matchesStrictComparable);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMatches.js
function baseMatches(source){var matchData=_getMatchData(source);if(matchData.length==1&&matchData[0][2]){return _matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||_baseIsMatch(object,source,matchData);};}/* harmony default export */ var _baseMatches = (baseMatches);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGet.js
var _baseGet = __webpack_require__(29);

// CONCATENATED MODULE: ./node_modules/lodash-es/get.js
function get(object,path,defaultValue){var result=object==null?undefined:Object(_baseGet["a" /* default */])(object,path);return result===undefined?defaultValue:result;}/* harmony default export */ var lodash_es_get = (get);
// EXTERNAL MODULE: ./node_modules/lodash-es/hasIn.js + 2 modules
var hasIn = __webpack_require__(88);

// EXTERNAL MODULE: ./node_modules/lodash-es/_isKey.js
var _isKey = __webpack_require__(59);

// EXTERNAL MODULE: ./node_modules/lodash-es/_toKey.js
var _toKey = __webpack_require__(20);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMatchesProperty.js
var _baseMatchesProperty_COMPARE_PARTIAL_FLAG=1,_baseMatchesProperty_COMPARE_UNORDERED_FLAG=2;function baseMatchesProperty(path,srcValue){if(Object(_isKey["a" /* default */])(path)&&_isStrictComparable(srcValue)){return _matchesStrictComparable(Object(_toKey["a" /* default */])(path),srcValue);}return function(object){var objValue=lodash_es_get(object,path);return objValue===undefined&&objValue===srcValue?Object(hasIn["a" /* default */])(object,path):Object(_baseIsEqual["a" /* default */])(srcValue,objValue,_baseMatchesProperty_COMPARE_PARTIAL_FLAG|_baseMatchesProperty_COMPARE_UNORDERED_FLAG);};}/* harmony default export */ var _baseMatchesProperty = (baseMatchesProperty);
// EXTERNAL MODULE: ./node_modules/lodash-es/identity.js
var identity = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseProperty.js
var _baseProperty = __webpack_require__(85);

// CONCATENATED MODULE: ./node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path){return function(object){return Object(_baseGet["a" /* default */])(object,path);};}/* harmony default export */ var _basePropertyDeep = (basePropertyDeep);
// CONCATENATED MODULE: ./node_modules/lodash-es/property.js
function property(path){return Object(_isKey["a" /* default */])(path)?Object(_baseProperty["a" /* default */])(Object(_toKey["a" /* default */])(path)):_basePropertyDeep(path);}/* harmony default export */ var lodash_es_property = (property);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value){if(typeof value=='function'){return value;}if(value==null){return identity["a" /* default */];}if(typeof value=='object'){return Object(isArray["a" /* default */])(value)?_baseMatchesProperty(value[0],value[1]):_baseMatches(value);}return lodash_es_property(value);}/* harmony default export */ var _baseIteratee = __webpack_exports__["a"] = (baseIteratee);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/* harmony default export */ __webpack_exports__["a"] = (arrayMap);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function isObjectLike(value){return value!=null&&typeof value=='object';}/* harmony default export */ __webpack_exports__["a"] = (isObjectLike);

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
var Symbol=_root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Symbol;/* harmony default export */ __webpack_exports__["a"] = (Symbol);

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _overRest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78);
/* harmony import */ var _setToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68);
function baseRest(func,start){return Object(_setToString_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(Object(_overRest_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(func,start,_identity_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]),func+'');}/* harmony default export */ __webpack_exports__["a"] = (baseRest);

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
function isArrayLike(value){return value!=null&&Object(_isLength_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(value.length)&&!Object(_isFunction_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value);}/* harmony default export */ __webpack_exports__["a"] = (isArrayLike);

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function baseUnary(func){return function(value){return func(value);};}/* harmony default export */ __webpack_exports__["a"] = (baseUnary);

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/isFunction.js
var isFunction = __webpack_require__(57);

// EXTERNAL MODULE: ./node_modules/lodash-es/_root.js
var _root = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/lodash-es/_coreJsData.js
var coreJsData=_root["a" /* default */]['__core-js_shared__'];/* harmony default export */ var _coreJsData = (coreJsData);
// CONCATENATED MODULE: ./node_modules/lodash-es/_isMasked.js
var maskSrcKey=function(){var uid=/[^.]+$/.exec(_coreJsData&&_coreJsData.keys&&_coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/* harmony default export */ var _isMasked = (isMasked);
// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/lodash-es/_toSource.js
var _toSource = __webpack_require__(39);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsNative.js
var reRegExpChar=/[\\^$.*+?()[\]{}|]/g;var reIsHostCtor=/^\[object .+?Constructor\]$/;var funcProto=Function.prototype,objectProto=Object.prototype;var funcToString=funcProto.toString;var _baseIsNative_hasOwnProperty=objectProto.hasOwnProperty;var reIsNative=RegExp('^'+funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');function baseIsNative(value){if(!Object(isObject["a" /* default */])(value)||_isMasked(value)){return false;}var pattern=Object(isFunction["a" /* default */])(value)?reIsNative:reIsHostCtor;return pattern.test(Object(_toSource["a" /* default */])(value));}/* harmony default export */ var _baseIsNative = (baseIsNative);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getValue.js
function getValue(object,key){return object==null?undefined:object[key];}/* harmony default export */ var _getValue = (getValue);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getNative.js
function getNative(object,key){var value=_getValue(object,key);return _baseIsNative(value)?value:undefined;}/* harmony default export */ var _getNative = __webpack_exports__["a"] = (getNative);

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return downcast; });
function downcast(val, ty) {
  return val;
}

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return MINUTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return HOUR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return WEEK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return fromSecondsToTime; });
const MINUTE = 1000 * 60;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const WEEK = 7 * DAY;
function fromSecondsToTime(timeInSeconds) {
  const minutes = Math.floor(timeInSeconds / 60) % 60;
  const hours = Math.floor(timeInSeconds / 3600);
  const time = [minutes, timeInSeconds % 60];

  if (hours > 0) {
    time.unshift(hours);
  }

  return time.map(part => String(part).padStart(2, '0')).join(':');
}

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
var symbolTag='[object Symbol]';function isSymbol(value){return typeof value=='symbol'||Object(_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(value)&&Object(_baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value)==symbolTag;}/* harmony default export */ __webpack_exports__["a"] = (isSymbol);

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return forEachSeq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return asyncFilter; });
/* unused harmony export asyncReduce */
/* unused harmony export asyncFind */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return asyncSome; });
/* unused harmony export asyncEvery */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return filterMap; });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(131);
/* harmony import */ var _async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);


async function forEachSeq(iterable, callback) {
  for (const val of iterable) {
    await callback(val);
  }
}
async function asyncFilter(array, predicate) {
  const shouldKeep = await Promise.all(array.map(predicate));
  return array.filter((e, i) => shouldKeep[i]);
}
async function asyncReduce(iterable, callback, initialValue) {
  let accumulator = initialValue;

  for (const val of iterable) {
    accumulator = await callback(accumulator, val);
  }

  return accumulator;
}
const asyncFind = Object(_async__WEBPACK_IMPORTED_MODULE_1__[/* fastAsync */ "b"])(function* (iterable, predicate) {
  for (const val of iterable) {
    if (yield predicate(val)) return val;
  }
});

function concurrentFold(array, reduce, initialValue, baseCase) {
  if (!array.length) return Promise.resolve(initialValue);
  return new Promise((resolve, reject) => {
    let remaining = array.length;
    let accum = initialValue;

    function onResolve(x) {
      if (remaining === 0) return;
      accum = reduce(accum, x);

      if (accum === baseCase || --remaining === 0) {
        remaining = 0;
        resolve(accum);
      }
    }

    function onReject(err) {
      if (remaining === 0) return;
      remaining = 0;
      reject(err);
    }

    array.forEach(promise => promise.then(onResolve, onReject));
  });
}

function asyncSome(array, predicate) {
  return concurrentFold(array.map(predicate), (a, b) => a || !!b, false, true);
}
function asyncEvery(array, predicate) {
  return concurrentFold(array.map(predicate), (a, b) => a && !!b, true, false);
}
const filterMap = Object(lodash_es__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])((iterable, callback) => {
  const mapped = [];

  for (const x of iterable) {
    const result = callback(x);
    if (result) mapped.push(result[0]);
  }

  return mapped;
});

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
var INFINITY=1/0;function toKey(value){if(typeof value=='string'||Object(_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/* harmony default export */ __webpack_exports__["a"] = (toKey);

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var MAX_SAFE_INTEGER=9007199254740991;var reIsUint=/^(?:0|[1-9]\d*)$/;function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/* harmony default export */ __webpack_exports__["a"] = (isIndex);

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bodyStart", function() { return bodyStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contentStart", function() { return contentStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contentLoaded", function() { return contentLoaded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadComplete", function() { return loadComplete; });
/* harmony import */ var _async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);


const bodyStart = Object(_dom__WEBPACK_IMPORTED_MODULE_1__[/* waitForChild */ "n"])(document.documentElement, 'body').then(() => Object(_async__WEBPACK_IMPORTED_MODULE_0__[/* waitFor */ "k"])(() => document.body, 10));
const contentStart = bodyStart.then(() => Promise.race([bodyStart.then(() => Object(_dom__WEBPACK_IMPORTED_MODULE_1__[/* waitForDescendant */ "o"])(document.body, '#siteTable')), contentLoaded]));
const contentLoaded = bodyStart.then(() => Promise.race([Object(_dom__WEBPACK_IMPORTED_MODULE_1__[/* waitForEvent */ "r"])(window, 'DOMContentLoaded', 'load'), Object(_async__WEBPACK_IMPORTED_MODULE_0__[/* waitFor */ "k"])(() => document.readyState === 'interactive' || document.readyState === 'complete', 500)]));
const loadComplete = bodyStart.then(() => Promise.race([Object(_dom__WEBPACK_IMPORTED_MODULE_1__[/* waitForEvent */ "r"])(window, 'load'), Object(_async__WEBPACK_IMPORTED_MODULE_0__[/* waitFor */ "k"])(() => document.readyState === 'complete', 500)]));

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(102);
var freeExports=typeof exports=='object'&&exports&&!exports.nodeType&&exports;var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;var moduleExports=freeModule&&freeModule.exports===freeExports;var Buffer=moduleExports?_root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Buffer:undefined;var nativeIsBuffer=Buffer?Buffer.isBuffer:undefined;var isBuffer=nativeIsBuffer||_stubFalse_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"];/* harmony default export */ __webpack_exports__["a"] = (isBuffer);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(94)(module)))

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_Symbol.js
var _Symbol = __webpack_require__(11);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getRawTag.js
var objectProto=Object.prototype;var _getRawTag_hasOwnProperty=objectProto.hasOwnProperty;var nativeObjectToString=objectProto.toString;var symToStringTag=_Symbol["a" /* default */]?_Symbol["a" /* default */].toStringTag:undefined;function getRawTag(value){var isOwn=_getRawTag_hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/* harmony default export */ var _getRawTag = (getRawTag);
// CONCATENATED MODULE: ./node_modules/lodash-es/_objectToString.js
var _objectToString_objectProto=Object.prototype;var _objectToString_nativeObjectToString=_objectToString_objectProto.toString;function objectToString(value){return _objectToString_nativeObjectToString.call(value);}/* harmony default export */ var _objectToString = (objectToString);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetTag.js
var nullTag='[object Null]',undefinedTag='[object Undefined]';var _baseGetTag_symToStringTag=_Symbol["a" /* default */]?_Symbol["a" /* default */].toStringTag:undefined;function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return _baseGetTag_symToStringTag&&_baseGetTag_symToStringTag in Object(value)?_getRawTag(value):_objectToString(value);}/* harmony default export */ var _baseGetTag = __webpack_exports__["a"] = (baseGetTag);

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_getNative.js + 4 modules
var _getNative = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/lodash-es/_root.js
var _root = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/lodash-es/_DataView.js
var DataView=Object(_getNative["a" /* default */])(_root["a" /* default */],'DataView');/* harmony default export */ var _DataView = (DataView);
// EXTERNAL MODULE: ./node_modules/lodash-es/_Map.js
var _Map = __webpack_require__(50);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Promise.js
var Promise=Object(_getNative["a" /* default */])(_root["a" /* default */],'Promise');/* harmony default export */ var _Promise = (Promise);
// EXTERNAL MODULE: ./node_modules/lodash-es/_Set.js
var _Set = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/lodash-es/_WeakMap.js
var _WeakMap = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGetTag.js + 2 modules
var _baseGetTag = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/lodash-es/_toSource.js
var _toSource = __webpack_require__(39);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getTag.js
var mapTag='[object Map]',objectTag='[object Object]',promiseTag='[object Promise]',setTag='[object Set]',weakMapTag='[object WeakMap]';var dataViewTag='[object DataView]';var dataViewCtorString=Object(_toSource["a" /* default */])(_DataView),mapCtorString=Object(_toSource["a" /* default */])(_Map["a" /* default */]),promiseCtorString=Object(_toSource["a" /* default */])(_Promise),setCtorString=Object(_toSource["a" /* default */])(_Set["a" /* default */]),weakMapCtorString=Object(_toSource["a" /* default */])(_WeakMap["a" /* default */]);var getTag=_baseGetTag["a" /* default */];if(_DataView&&getTag(new _DataView(new ArrayBuffer(1)))!=dataViewTag||_Map["a" /* default */]&&getTag(new _Map["a" /* default */]())!=mapTag||_Promise&&getTag(_Promise.resolve())!=promiseTag||_Set["a" /* default */]&&getTag(new _Set["a" /* default */]())!=setTag||_WeakMap["a" /* default */]&&getTag(new _WeakMap["a" /* default */]())!=weakMapTag){getTag=function(value){var result=Object(_baseGetTag["a" /* default */])(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?Object(_toSource["a" /* default */])(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/* harmony default export */ var _getTag = __webpack_exports__["a"] = (getTag);

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Thing; });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var _flow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4);






const elementMap = new WeakMap();
const things = new Set();
const SECRET_TOKEN = new class {}();
class Thing {
  static things(doc) {
    return Thing.thingElements(doc).map(e => Thing.checkedFrom(e));
  }

  static visibleThingElements(doc) {
    return Thing.thingElements(doc).filter(v => v.offsetParent);
  }

  static visibleThings(doc) {
    return Object(_array__WEBPACK_IMPORTED_MODULE_1__[/* filterMap */ "c"])(Thing.visibleThingElements(doc), ele => {
      const thing = Thing.from(ele);
      if (thing) return [thing];
    });
  }

  static checkedFrom(element) {
    const thing = Thing.from(element);

    if (!thing) {
      throw new Error(`Could not construct Thing from ${String(element)}`);
    }

    return thing;
  }

  static from(element) {
    if (!element) return null;
    if (element instanceof Thing) return element;
    const thingElement = element.closest(Thing.thingSelector);
    if (!thingElement) return null;
    if (elementMap.has(thingElement)) return elementMap.get(thingElement);
    const entry = thingElement.querySelector(Thing.entrySelector) || thingElement;
    const thing = new Thing(SECRET_TOKEN, Object(_flow__WEBPACK_IMPORTED_MODULE_4__[/* downcast */ "a"])(thingElement, HTMLElement), entry);
    Thing.thingElements.cache.clear();
    elementMap.set(thingElement, thing);
    things.add(thing);
    return thing;
  }

  constructor(token, thing, entry) {
    this.element = void 0;
    this.entry = void 0;
    this.parent = void 0;
    this.children = new Set();
    this.tasks = {
      completed: false,
      visible: [],
      immediate: [],
      byId: new Map()
    };
    this.refreshPartialVisibility = Object(_async__WEBPACK_IMPORTED_MODULE_2__[/* throttleQueuePositionReset */ "j"])(() => {
      this.element.classList.toggle('res-thing-partial', this.isHiddenByFilter(true) && (this.element.matches('.morerecursion, .morechildren') || Array.from(this.children).some(v => !v.isHiddenByFilter())));
    });

    if (token !== SECRET_TOKEN) {
      throw new Error('Use Thing.from() or Thing.checkedFrom() instead of new Thing()');
    }

    this.element = thing;
    this.entry = entry;
    const _p = this.element.parentElement;
    this.parent = _p && Thing.from(_p.closest('.thing'));
    if (this.parent) this.parent.children.add(this);
  }

  runTasks() {
    if (this.tasks.completed) return;
    this.tasks.completed = true;
    this.tasks.immediate.map(fn => fn());
    this.tasks.visible.map(fn => fn());
  }

  runSurroundingTasks(margin = 10) {
    const thingElements = Thing.thingElements();
    const idx = thingElements.indexOf(this.element);
    const min = Math.max(idx - margin, 0);
    const max = Math.min(idx + margin, thingElements.length - 1);

    for (let i = min; i <= max; i++) {
      const thing = Thing.checkedFrom(thingElements[i]);
      if (!thing.tasks.completed && thing.isVisible()) thing.runTasks();
    }
  }

  anchor() {
    const anchor = Object(_dom__WEBPACK_IMPORTED_MODULE_3__[/* getPercentageVisibleYAxis */ "h"])(this.entry) && {
      to: this.entry.getBoundingClientRect().top
    };
    if (!anchor) return;
    requestAnimationFrame(() => {
      if (!this.entry.offsetParent) return;
      Object(_dom__WEBPACK_IMPORTED_MODULE_3__[/* scrollToElement */ "l"])(this.entry, undefined, {
        scrollStyle: 'none',
        anchor
      });
    });
  }

  setHideFilter(match) {
    this.element.classList.toggle('res-thing-filter-hide', !!match);

    if (this.isComment()) {
      this.refreshPartialVisibility();

      for (const p of this.getParents()) p.refreshPartialVisibility();
    }
  }

  setFilterReasons(elements) {
    for (const old of this.element.querySelectorAll('.res-thing-filter-remove-matching-entry')) old.remove();

    this.element.prepend(...elements);
  }

  getDirectionOf(other) {
    if (!this.isVisible() || !other.isVisible()) return;
    return other.entry.compareDocumentPosition(this.entry) & Node.DOCUMENT_POSITION_FOLLOWING ? 'up' : 'down';
  }

  getThreadTop() {
    let thing = this;
    let current = this.element;

    while (current = current.parentElement) {
      if (current.matches(Thing.thingSelector)) thing = Object(_flow__WEBPACK_IMPORTED_MODULE_4__[/* downcast */ "a"])(current, HTMLElement);
    }

    return Thing.checkedFrom(thing);
  }

  getParents() {
    const parents = [];
    let level = this;

    while (level = level.parent) parents.push(level);

    return parents;
  }

  getNext({
    direction = 'down',
    excludeMoreChildren = false
  } = {}, things = Thing.thingElements()) {
    let index = things.indexOf(this.element);
    let target;

    do {
      index += direction === 'down' ? 1 : -1;
      const _target = things[index];
      target = _target;
      if (!target) return null;
      if (excludeMoreChildren && target.matches('.morechildren')) continue;
    } while (!target.offsetParent);

    return Thing.from(target);
  }

  getNextSibling(options) {
    if (!this.element.parentElement) return null;
    const things = Array.from(this.element.parentElement.children).filter(e => e.matches(Thing.thingSelector));
    return this.getNext(options, things);
  }

  getClosest(func, ...args) {
    const target = Reflect.apply(func, this, args);

    if (target) {
      return target;
    } else {
      if (this.parent) return this.parent.getClosest(func, ...args);
    }
  }

  getClosestVisible(options = {
    excludeMoreChildren: true
  }) {
    if (this.element.offsetParent) return this;
    return this.getNext({
      direction: 'down',
      ...options
    }) || this.getNext({
      direction: 'up',
      ...options
    });
  }

  isMessage() {
    return this.element.classList.contains('message');
  }

  isSubreddit() {
    return this.element.classList.contains('subreddit');
  }

  isPost() {
    return this.element.classList.contains('link') || this.element.classList.contains('search-result-link');
  }

  isLinkPost() {
    if (!this.isPost()) {
      return false;
    }

    if (this.element.classList.contains('search-result-link')) {
      return !this.element.querySelector('a').classList.contains('self');
    } else {
      return !this.element.classList.contains('self');
    }
  }

  isSelfPost() {
    if (!this.isPost()) {
      return false;
    }

    if (this.element.classList.contains('search-result-link')) {
      return this.element.querySelector('a').classList.contains('self');
    } else {
      return this.element.classList.contains('self');
    }
  }

  isComment() {
    return this.element.classList.contains('comment') || this.element.classList.contains('was-comment');
  }

  isTopLevelComment() {
    return this.isComment() && !!this.element.parentElement && this.element.parentElement.classList.contains('nestedlisting');
  }

  getTitle() {
    const element = this.getTitleElement();
    return element && element.textContent || '';
  }

  getTitleElement() {
    return this.entry.querySelector('a.title, a.search-title') || this.entry.querySelector('.title');
  }

  getTitleUrl() {
    const element = this.getTitleElement();

    if (element) {
      return element.href;
    }

    return '';
  }

  getPostLink() {
    return Object(_flow__WEBPACK_IMPORTED_MODULE_4__[/* downcast */ "a"])(this.entry.querySelector('a.title, a.search-link'), HTMLAnchorElement);
  }

  getPostUrl() {
    return this.element.dataset.url || this.getPostLink().href;
  }

  getTextBody() {
    return this.entry.querySelector('.md');
  }

  getCommentsLink() {
    const a = this.entry.querySelector('a.comments, a.search-comments');
    return a instanceof HTMLAnchorElement ? a : undefined;
  }

  getCommentPermalink() {
    return this.entry.querySelector('a.bylink');
  }

  getHideElement() {
    return this.entry.querySelector('.hide-button a, .unhide-button a');
  }

  getButtons() {
    return this.entry.querySelector('.flat-list.buttons');
  }

  getNumberOfChildren() {
    const numChildrenElem = this.entry.querySelector('.numchildren');
    const match = numChildrenElem && /(\d+)/.exec(numChildrenElem.textContent);
    return match && parseInt(match[1], 10) || 0;
  }

  static _parseScore(scoreEle) {
    return parseInt(scoreEle.title || scoreEle.textContent, 10) || 0;
  }

  getScore() {
    const element = this._getActiveScoreElement();

    return element && Thing._parseScore(element);
  }

  _getActiveScoreElement() {
    if (this.isPost()) {
      return this.element.querySelector(['.midcol.unvoted > .score.unvoted', '.midcol.likes > .score.likes', '.midcol.dislikes > .score.dislikes', '.search-score'].join(', '));
    } else {
      return this.entry.querySelector('.tagline > .score');
    }
  }

  getAllScoreElements() {
    const toScoreTuple = ele => [ele, Thing._parseScore(ele)];

    if (this.isPost()) {
      return Array.from(this.element.querySelectorAll('.midcol > .score, .search-score')).map(toScoreTuple);
    } else {
      return Array.from(this.entry.querySelectorAll('.tagline > .score')).map(toScoreTuple);
    }
  }

  getAuthor() {
    const data = this.element.getAttribute('data-author');

    if (data) {
      return data;
    }

    const element = this.getAuthorElement();

    if (element) {
      const match = _location__WEBPACK_IMPORTED_MODULE_5__[/* regexes */ "p"].profile.exec(element.pathname);

      if (match) {
        return match[1];
      }
    }
  }

  getAuthorUrl() {
    const author = this.getAuthor();

    if (author) {
      return `/user/${author}/`;
    }

    return '';
  }

  getAuthorElement() {
    return this.entry.querySelector('.tagline a.author, .search-author .author');
  }

  getSubreddit() {
    const data = this.element.getAttribute('data-subreddit');

    if (data) {
      return data;
    }

    const element = this.getSubredditLink();

    if (element) {
      const match = _location__WEBPACK_IMPORTED_MODULE_5__[/* regexes */ "p"].subreddit.exec(element.pathname);

      if (match) {
        return match[1];
      }
    } else {
      return Object(_location__WEBPACK_IMPORTED_MODULE_5__[/* currentSubreddit */ "d"])();
    }
  }

  getSubredditLink() {
    if (this.isPost()) {
      return this.entry.querySelector('.tagline a.subreddit, a.search-subreddit-link');
    } else if (this.isComment()) {
      return this.entry.querySelector('.parent a.subreddit, .tagline .subreddit a');
    }
  }

  getPostDomain() {
    const data = this.element.getAttribute('data-domain');

    if (data) {
      return data;
    }

    const element = this.getPostDomainLink();

    if (element) {
      return element.textContent;
    }

    const text = this.getPostDomainText();

    if (text) {
      return text;
    }

    const subreddit = this.getSubreddit();

    if (subreddit) {
      return `self.${subreddit}`;
    }

    return 'reddit.com';
  }

  getPostDomainUrl() {
    const link = this.getPostDomainLink();

    if (link) {
      return link.href;
    }

    return `/domain/${this.getPostDomain()}/`;
  }

  getPostDomainLink() {
    return this.entry.querySelector('.domain a');
  }

  getPostDomainText() {
    const data = this.element.getAttribute('data-domain');

    if (data) {
      return data;
    }

    const element = this.element.querySelector('.domain');
    if (!element) return '';
    const text = element.textContent || '';
    return text.replace(/[\(\)\s]/g, '');
  }

  getCommentCount() {
    const element = this.getCommentCountElement();
    if (!element) return;
    return parseInt(/\d+/.exec(element.getAttribute('data-text') || element.textContent), 10) || 0;
  }

  getCommentCountElement() {
    if (this.isPost()) {
      return this.entry.querySelector('.buttons .comments');
    } else if (this.isComment()) {
      return this.entry.querySelector('.buttons a.full-comments');
    }
  }

  getPostThumbnailUrl() {
    const thumbnail = this.getPostThumbnailElement();
    if (!thumbnail) return '';
    return thumbnail.src || '';
  }

  getPostThumbnailElement() {
    return this.element.querySelector('.thumbnail img');
  }

  getPostFlairText() {
    const element = this.getPostFlairElement();
    return element && element.textContent || '';
  }

  getPostFlairElement() {
    return this.entry.querySelector('.title > .linkflairlabel');
  }

  getUserFlairText() {
    const element = this.getUserFlairElement();
    return element && element.textContent || '';
  }

  getUserFlairElement() {
    return this.entry.querySelector('.tagline > .flair');
  }

  getCrosspostBadgeElement() {
    return this.entry.querySelector('.crosspost-badge');
  }

  getUpvoteButton() {
    return this._getVoteButton('div.up, div.upmod');
  }

  getDownvoteButton() {
    return this._getVoteButton('div.down, div.downmod');
  }

  _getVoteButton(selector) {
    const previousSibling = this.entry.previousSibling;

    if (previousSibling.tagName === 'A') {
      return previousSibling.previousSibling.querySelector(selector);
    } else {
      return previousSibling.querySelector(selector);
    }
  }

  getTimestamp() {
    const element = this.getTimestampElement();
    return element && new Date(element.getAttribute('datetime'));
  }

  getTimestampElement() {
    return this.entry.querySelector('time');
  }

  getPostEditTimestamp() {
    const element = this.getPostEditTimestampElement();
    return element && Date.parse(element.getAttribute('datetime')) / 1000 || 0;
  }

  getPostEditTimestampElement() {
    return this.entry.querySelector('time.edited-timestamp');
  }

  getFullname() {
    return this.element.getAttribute('data-fullname') || '';
  }

  getUserattrsElement() {
    return this.entry.querySelector('.userattrs');
  }

  getRank() {
    const rank = parseInt(this.element.getAttribute('data-rank'), 10);
    if (!isNaN(rank)) return rank;
  }

  getRankElement() {
    if (!this.isPost()) return;
    return this.element.querySelector('.rank');
  }

  getTaglineElement() {
    return this.entry.querySelector('.tagline');
  }

  getCommentCollapseToggleElement() {
    return this.entry.querySelector('.expand');
  }

  setCommentCollapse(state, reason, openOnlyWhenSameReason = false) {
    const toggle = this.getCommentCollapseToggleElement();
    if (!toggle) return;
    if (state) toggle.setAttribute('collapse-reason', reason);
    if (this.isCollapsed() === state) return;
    if (!state && openOnlyWhenSameReason && toggle.getAttribute('collapse-reason') !== reason) return;
    if (!state) toggle.removeAttribute('collapse-reason');
    Object(_dom__WEBPACK_IMPORTED_MODULE_3__[/* click */ "c"])(toggle);
  }

  getPostTime() {
    const element = this.getPostTimeElement();

    if (element) {
      return element.textContent;
    }

    return '';
  }

  getPostTimeElement() {
    return this.entry.querySelector('.tagline time');
  }

  isNSFW() {
    return this.element.classList.contains('over18') || !!this.entry.querySelector('.nsfw-stamp');
  }

  isSpoiler() {
    if (this.element.classList.contains('search-result')) {
      return !!this.entry.querySelector('.spoiler-stamp');
    }

    return this.element.classList.contains('spoiler');
  }

  isCrosspost() {
    return !!this.getCrosspostBadgeElement();
  }

  isLocked() {
    if (this.element.classList.contains('search-result')) {
      return this.element.classList.contains('linkflair-locked');
    }

    return this.element.classList.contains('locked');
  }

  isDeleted() {
    return this.element.classList.contains('deleted');
  }

  isHiddenByFilter(partialAsFiltered = false) {
    if (this.element.matches('body.hideOver18 .over18:not(.allowOver18)')) return true;
    if (!this.element.classList.contains('res-thing-filter-hide')) return false;
    if (this.element.classList.contains('res-filterline-highlight-match')) return false;

    if (partialAsFiltered) {
      if (this.element.classList.contains('res-thing-partial') && this.element.classList.contains('res-selected')) return false;
      return true;
    } else {
      if (this.element.classList.contains('res-thing-hide-children')) return true;
      return !this.element.classList.contains('res-thing-partial');
    }
  }

  isCollapsed() {
    return this.element.classList.contains('collapsed');
  }

  isVisible() {
    if (this.element.classList.contains('promoted')) return false;
    if (!document.body.classList.contains('res-filters-disabled') && this.isHiddenByFilter()) return false;
    const {
      parent
    } = this;

    if (parent) {
      if (parent.isCollapsed()) return false;
      if (parent.element.classList.contains('res-children-hidden')) return false;
      if (!parent.isVisible()) return false;
    }

    return true;
  }

  isContentVisible() {
    return !(this.element.classList.contains('res-thing-has-placeholder') || !document.body.classList.contains('res-filters-disabled') && this.isHiddenByFilter(true) || this.isCollapsed() || !this.isVisible());
  }

  isSelected() {
    return this.element.classList.contains('res-selected');
  }

  isUpvoted() {
    return this.entry.classList.contains('likes');
  }

  isDownvoted() {
    return this.entry.classList.contains('dislikes');
  }

  isUnvoted() {
    return this.entry.classList.contains('unvoted');
  }

}
Thing.thingSelector = '.thing, .search-result-link';
Thing.entrySelector = '.entry';
Thing.thingElements = Object(lodash_es__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])((doc = document.body.querySelector('.content[role="main"]')) => Array.from(doc.querySelectorAll(Thing.thingSelector)));

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():undefined;}(this,function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t;},D="en",v={};v[D]=M;var p=function(t){return t instanceof _;},S=function(t,e,n){var r;if(!t)return D;if("string"==typeof t)v[t]&&(r=t),e&&(v[t]=e,r=t);else{var i=t.name;v[i]=t,r=i;}return!n&&r&&(D=r),r||!n&&D;},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n);},O={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60);return(e<=0?"+":"-")+m(r,2,"0")+":"+m(n%60,2,"0");},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0);},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t);},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"");},u:function(t){return void 0===t;}};O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset});};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date();if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s);}}return new Date(e);}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O;},m.isValid=function(){return!(this.$d.toString()===$);},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e);},m.isAfter=function(t,e){return w(t)<this.startOf(e);},m.isBefore=function(t,e){return this.endOf(e)<w(t);},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t);},m.unix=function(){return Math.floor(this.valueOf()/1e3);},m.valueOf=function(){return this.$d.getTime();},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a);},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n);},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var D=this.$locale().weekStart||0,v=(y<D?y+7:y)-D;return $(r?m-v:m+(6-v),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone();}},m.endOf=function(t){return this.startOf(t,!1);},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else $&&this.$d[$](l);return this.init(),this;},m.set=function(t,e){return this.clone().$set(t,e);},m.get=function(t){return this[O.p(t)]();},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$);};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this);},m.subtract=function(t,e){return this.add(-1*t,e);},m.format=function(t){var e=this;if(!this.isValid())return $;var n=t||"YYYY-MM-DDTHH:mm:ssZ",r=O.z(this),i=this.$locale(),s=this.$H,u=this.$m,a=this.$M,o=i.weekdays,f=i.months,h=function(t,r,i,s){return t&&(t[r]||t(e,n))||i[r].substr(0,s);},c=function(t){return O.s(s%12||12,t,"0");},d=i.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r;},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(i.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(i.weekdaysMin,this.$W,o,2),ddd:h(i.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:r};return n.replace(/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,function(t,e){return e||l[t]||r.replace(":","");});},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15);},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,D=O.m(this,M);return D=(l={},l[c]=D/12,l[f]=D,l[h]=D/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?D:O.a(D);},m.daysInMonth=function(){return this.endOf(f).$D;},m.$locale=function(){return v[this.$L];},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n;},m.clone=function(){return O.w(this.$d,this);},m.toDate=function(){return new Date(this.valueOf());},m.toJSON=function(){return this.isValid()?this.toISOString():null;},m.toISOString=function(){return this.$d.toISOString();},m.toString=function(){return this.$d.toUTCString();},M;}(),b=_.prototype;return w.prototype=b,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach(function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1]);};}),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w;},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t);},w.en=v[D],w.Ls=v,w.p={},w;});

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function identity(value){return value;}/* harmony default export */ __webpack_exports__["a"] = (identity);

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
function baseGet(object,path){path=Object(_castPath_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[Object(_toKey_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(path[index++])];}return index&&index==length?object:undefined;}/* harmony default export */ __webpack_exports__["a"] = (baseGet);

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
function baseAssignValue(object,key,value){if(key=='__proto__'&&_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]){Object(_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/* harmony default export */ __webpack_exports__["a"] = (baseAssignValue);

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60);
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){Object(_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(object,key,newValue);}else{Object(_assignValue_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(object,key,newValue);}}return object;}/* harmony default export */ __webpack_exports__["a"] = (copyObject);

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var _baseKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89);
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
function keys(object){return Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(object)?Object(_arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(object):Object(_baseKeys_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(object);}/* harmony default export */ __webpack_exports__["a"] = (keys);

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
var objectCreate=Object.create;var baseCreate=function(){function object(){}return function(proto){if(!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/* harmony default export */ __webpack_exports__["a"] = (baseCreate);

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/lodash-es/_isKey.js
var _isKey = __webpack_require__(59);

// EXTERNAL MODULE: ./node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(93);

// CONCATENATED MODULE: ./node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE=500;function memoizeCapped(func){var result=Object(memoize["a" /* default */])(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/* harmony default export */ var _memoizeCapped = (memoizeCapped);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stringToPath.js
var rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;var reEscapeChar=/\\(\\)?/g;var stringToPath=_memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/* harmony default export */ var _stringToPath = (stringToPath);
// EXTERNAL MODULE: ./node_modules/lodash-es/toString.js + 1 modules
var lodash_es_toString = __webpack_require__(91);

// CONCATENATED MODULE: ./node_modules/lodash-es/_castPath.js
function castPath(value,object){if(Object(isArray["a" /* default */])(value)){return value;}return Object(_isKey["a" /* default */])(value,object)?[value]:_stringToPath(Object(lodash_es_toString["a" /* default */])(value));}/* harmony default export */ var _castPath = __webpack_exports__["a"] = (castPath);

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return zip; });
function* range(start, end) {
  for (let i = start; i < end; ++i) {
    yield i;
  }
}
function* zip(...iterables) {
  const generators = iterables.map(it => it[Symbol.iterator]());
  let results;

  while ((results = generators.map(gen => gen.next())).some(r => !r.done)) {
    yield results.map(r => r.value);
  }
}

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function cacheHas(cache,key){return cache.has(key);}/* harmony default export */ __webpack_exports__["a"] = (cacheHas);

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76);
var freeExports=typeof exports=='object'&&exports&&!exports.nodeType&&exports;var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;var moduleExports=freeModule&&freeModule.exports===freeExports;var freeProcess=moduleExports&&_freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].process;var nodeUtil=function(){try{var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* harmony default export */ __webpack_exports__["a"] = (nodeUtil);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(94)(module)))

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace=/\s/;function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/* harmony default export */ var _trimmedEndIndex = (trimmedEndIndex);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseTrim.js
var reTrimStart=/^\s+/;function baseTrim(string){return string?string.slice(0,_trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/* harmony default export */ var _baseTrim = (baseTrim);
// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/lodash-es/isSymbol.js
var isSymbol = __webpack_require__(18);

// CONCATENATED MODULE: ./node_modules/lodash-es/toNumber.js
var NAN=0/0;var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;var reIsBinary=/^0b[01]+$/i;var reIsOctal=/^0o[0-7]+$/i;var freeParseInt=parseInt;function toNumber(value){if(typeof value=='number'){return value;}if(Object(isSymbol["a" /* default */])(value)){return NAN;}if(Object(isObject["a" /* default */])(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=Object(isObject["a" /* default */])(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=_baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/* harmony default export */ var lodash_es_toNumber = __webpack_exports__["a"] = (toNumber);

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var funcProto=Function.prototype;var funcToString=funcProto.toString;function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/* harmony default export */ __webpack_exports__["a"] = (toSource);

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function eq(value,other){return value===other||value!==value&&other!==other;}/* harmony default export */ __webpack_exports__["a"] = (eq);

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/* harmony default export */ __webpack_exports__["a"] = (apply);

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var objectProto=Object.prototype;function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/* harmony default export */ __webpack_exports__["a"] = (isPrototype);

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/* harmony default export */ __webpack_exports__["a"] = (copyArray);

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _baseIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87);
function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&Object(_baseIndexOf_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(array,value,0)>-1;}/* harmony default export */ __webpack_exports__["a"] = (arrayIncludes);

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheClear.js
function listCacheClear(){this.__data__=[];this.size=0;}/* harmony default export */ var _listCacheClear = (listCacheClear);
// EXTERNAL MODULE: ./node_modules/lodash-es/eq.js
var eq = __webpack_require__(40);

// CONCATENATED MODULE: ./node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array,key){var length=array.length;while(length--){if(Object(eq["a" /* default */])(array[length][0],key)){return length;}}return-1;}/* harmony default export */ var _assocIndexOf = (assocIndexOf);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheDelete.js
var arrayProto=Array.prototype;var splice=arrayProto.splice;function listCacheDelete(key){var data=this.__data__,index=_assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/* harmony default export */ var _listCacheDelete = (listCacheDelete);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key){var data=this.__data__,index=_assocIndexOf(data,key);return index<0?undefined:data[index][1];}/* harmony default export */ var _listCacheGet = (listCacheGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key){return _assocIndexOf(this.__data__,key)>-1;}/* harmony default export */ var _listCacheHas = (listCacheHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key,value){var data=this.__data__,index=_assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}/* harmony default export */ var _listCacheSet = (listCacheSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_ListCache.js
function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}ListCache.prototype.clear=_listCacheClear;ListCache.prototype['delete']=_listCacheDelete;ListCache.prototype.get=_listCacheGet;ListCache.prototype.has=_listCacheHas;ListCache.prototype.set=_listCacheSet;/* harmony default export */ var _ListCache = __webpack_exports__["a"] = (ListCache);

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_MapCache.js + 14 modules
var _MapCache = __webpack_require__(55);

// CONCATENATED MODULE: ./node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED='__lodash_hash_undefined__';function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/* harmony default export */ var _setCacheAdd = (setCacheAdd);
// CONCATENATED MODULE: ./node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value){return this.__data__.has(value);}/* harmony default export */ var _setCacheHas = (setCacheHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_SetCache.js
function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new _MapCache["a" /* default */]();while(++index<length){this.add(values[index]);}}SetCache.prototype.add=SetCache.prototype.push=_setCacheAdd;SetCache.prototype.has=_setCacheHas;/* harmony default export */ var _SetCache = __webpack_exports__["a"] = (SetCache);

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayLikeKeys.js
var _arrayLikeKeys = __webpack_require__(79);

// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/lodash-es/_isPrototype.js
var _isPrototype = __webpack_require__(42);

// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/* harmony default export */ var _nativeKeysIn = (nativeKeysIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeysIn.js
var objectProto=Object.prototype;var _baseKeysIn_hasOwnProperty=objectProto.hasOwnProperty;function baseKeysIn(object){if(!Object(isObject["a" /* default */])(object)){return _nativeKeysIn(object);}var isProto=Object(_isPrototype["a" /* default */])(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!_baseKeysIn_hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/* harmony default export */ var _baseKeysIn = (baseKeysIn);
// EXTERNAL MODULE: ./node_modules/lodash-es/isArrayLike.js
var isArrayLike = __webpack_require__(13);

// CONCATENATED MODULE: ./node_modules/lodash-es/keysIn.js
function keysIn(object){return Object(isArrayLike["a" /* default */])(object)?Object(_arrayLikeKeys["a" /* default */])(object,true):_baseKeysIn(object);}/* harmony default export */ var lodash_es_keysIn = __webpack_exports__["a"] = (keysIn);

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGetTag.js + 2 modules
var _baseGetTag = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/lodash-es/isLength.js
var isLength = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/lodash-es/isObjectLike.js
var isObjectLike = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsTypedArray.js
var argsTag='[object Arguments]',arrayTag='[object Array]',boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',mapTag='[object Map]',numberTag='[object Number]',objectTag='[object Object]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',weakMapTag='[object WeakMap]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;function baseIsTypedArray(value){return Object(isObjectLike["a" /* default */])(value)&&Object(isLength["a" /* default */])(value.length)&&!!typedArrayTags[Object(_baseGetTag["a" /* default */])(value)];}/* harmony default export */ var _baseIsTypedArray = (baseIsTypedArray);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseUnary.js
var _baseUnary = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/lodash-es/_nodeUtil.js
var _nodeUtil = __webpack_require__(37);

// CONCATENATED MODULE: ./node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray=_nodeUtil["a" /* default */]&&_nodeUtil["a" /* default */].isTypedArray;var isTypedArray=nodeIsTypedArray?Object(_baseUnary["a" /* default */])(nodeIsTypedArray):_baseIsTypedArray;/* harmony default export */ var lodash_es_isTypedArray = __webpack_exports__["a"] = (isTypedArray);

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGetTag.js + 2 modules
var _baseGetTag = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/lodash-es/isObjectLike.js
var isObjectLike = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsArguments.js
var argsTag='[object Arguments]';function baseIsArguments(value){return Object(isObjectLike["a" /* default */])(value)&&Object(_baseGetTag["a" /* default */])(value)==argsTag;}/* harmony default export */ var _baseIsArguments = (baseIsArguments);
// CONCATENATED MODULE: ./node_modules/lodash-es/isArguments.js
var objectProto=Object.prototype;var isArguments_hasOwnProperty=objectProto.hasOwnProperty;var propertyIsEnumerable=objectProto.propertyIsEnumerable;var isArguments=_baseIsArguments(function(){return arguments;}())?_baseIsArguments:function(value){return Object(isObjectLike["a" /* default */])(value)&&isArguments_hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/* harmony default export */ var lodash_es_isArguments = __webpack_exports__["a"] = (isArguments);

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
var Map=Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(_root_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],'Map');/* harmony default export */ __webpack_exports__["a"] = (Map);

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_ListCache.js + 6 modules
var _ListCache = __webpack_require__(45);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackClear.js
function stackClear(){this.__data__=new _ListCache["a" /* default */]();this.size=0;}/* harmony default export */ var _stackClear = (stackClear);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stackDelete.js
function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/* harmony default export */ var _stackDelete = (stackDelete);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stackGet.js
function stackGet(key){return this.__data__.get(key);}/* harmony default export */ var _stackGet = (stackGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_stackHas.js
function stackHas(key){return this.__data__.has(key);}/* harmony default export */ var _stackHas = (stackHas);
// EXTERNAL MODULE: ./node_modules/lodash-es/_Map.js
var _Map = __webpack_require__(50);

// EXTERNAL MODULE: ./node_modules/lodash-es/_MapCache.js + 14 modules
var _MapCache = __webpack_require__(55);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE=200;function stackSet(key,value){var data=this.__data__;if(data instanceof _ListCache["a" /* default */]){var pairs=data.__data__;if(!_Map["a" /* default */]||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new _MapCache["a" /* default */](pairs);}data.set(key,value);this.size=data.size;return this;}/* harmony default export */ var _stackSet = (stackSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_Stack.js
function Stack(entries){var data=this.__data__=new _ListCache["a" /* default */](entries);this.size=data.size;}Stack.prototype.clear=_stackClear;Stack.prototype['delete']=_stackDelete;Stack.prototype.get=_stackGet;Stack.prototype.has=_stackHas;Stack.prototype.set=_stackSet;/* harmony default export */ var _Stack = __webpack_exports__["a"] = (Stack);

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
var Set=Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(_root_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],'Set');/* harmony default export */ __webpack_exports__["a"] = (Set);

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "watchForThings", function() { return watchForThings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "watchForElements", function() { return watchForElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerPage", function() { return registerPage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r2WatcherContentStart", function() { return r2WatcherContentStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r2WatcherContentLoaded", function() { return r2WatcherContentLoaded; });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(132);
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);
/* harmony import */ var _Thing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
/* harmony import */ var _pagePhases__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22);
/* harmony import */ var _time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17);






const elementWatchers = {
  page: [],
  selfText: []
};
const thingWatchers = {
  comment: [],
  message: [],
  post: [],
  subreddit: []
};

const runCallback = fn => {
  try {
    return fn();
  } catch (e) {
    console.error(e);
  }
};

const addCallback = (callback, actingOnElement, {
  immediate,
  id
} = {}) => {
  const thing = _Thing__WEBPACK_IMPORTED_MODULE_2__[/* Thing */ "a"].from(actingOnElement);

  if (thing) {
    const task = Object(lodash_es__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(() => runCallback(callback));
    if (id) thing.tasks.byId.set(id, task);
    (immediate ? thing.tasks.immediate : thing.tasks.visible).push(task);
    if (immediate || thing.tasks.completed) task();
  } else {
    runCallback(callback);
  }
};

function registerElement(type, element) {
  for (const {
    selector,
    callback,
    options,
    registered
  } of elementWatchers[type]) {
    const elements = selector && !element.matches(selector) ? Array.from(element.querySelectorAll(selector)) : [element];

    for (const e of elements) {
      if (registered.has(e)) continue;
      registered.add(e);
      addCallback(() => callback(e), e, options);
    }
  }
}

const dupeSet = new Map();

function registerThing(element) {
  const thing = _Thing__WEBPACK_IMPORTED_MODULE_2__[/* Thing */ "a"].checkedFrom(element);
  const id = thing.getFullname();

  if (id.length === 9) {
    const existing = dupeSet.get(id);
    if (existing === element) return;

    if (existing && document.contains(existing)) {
      element.remove();
      return;
    }

    dupeSet.set(id, element);
  }

  const thingWatcherCallbacks = thing.isPost() && thingWatchers.post || thing.isComment() && thingWatchers.comment || thing.isMessage() && thingWatchers.message || thing.isSubreddit() && thingWatchers.subreddit || [];

  for (const {
    callback,
    options,
    registered
  } of thingWatcherCallbacks) {
    if (registered.has(thing)) continue;
    registered.add(thing);
    addCallback(() => callback(thing), thing.element, options);
  }
}

function watchForThings(types, callback, options) {
  if (!types) types = Object.keys(thingWatchers);
  const entry = {
    callback,
    options,
    registered: new WeakSet()
  };

  for (const type of types) thingWatchers[type].push(entry);
}
function watchForElements(types, selector, callback, options) {
  const entry = {
    selector,
    callback,
    options,
    registered: new WeakSet()
  };

  for (const type of types) elementWatchers[type].push(entry);
}
function registerPage(page) {
  if (page.matches(_Thing__WEBPACK_IMPORTED_MODULE_2__[/* Thing */ "a"].thingSelector)) registerThing(page);

  for (const ele of page.querySelectorAll(_Thing__WEBPACK_IMPORTED_MODULE_2__[/* Thing */ "a"].thingSelector)) registerThing(ele);

  registerElement('page', page);
}
const HIDE_FOLLOWING_CLASS = 'res-hide-following';

const cleanHideClasses = () => {
  for (const ele of [...document.getElementsByClassName(HIDE_FOLLOWING_CLASS)]) ele.classList.remove(HIDE_FOLLOWING_CLASS);
};

async function r2WatcherContentStart() {
  const initialProcessSize = Math.ceil(screen.availHeight / window.devicePixelRatio / 55);
  const container = document.body.querySelector('.content[role="main"]');
  watchForThings(['post'], async thing => {
    const container = thing.entry.querySelector('div.expando');
    if (!container) return;
    let body = thing.getTextBody();

    if (!body || container.matches('.thing.spoiler .expando')) {
      await Object(_dom__WEBPACK_IMPORTED_MODULE_4__[/* waitForSelectorMatch */ "s"])(container, ':not(.expando--with-interstitial, .expando-uninitialized)');
    }

    Object(_dom__WEBPACK_IMPORTED_MODULE_4__[/* watchForChildren */ "t"])(container, 'form', () => {
      body = thing.getTextBody();
      if (body) registerElement('selfText', body);
    });
  }, {
    immediate: true
  });
  watchForThings(null, (() => {
    let max = initialProcessSize;
    const queue = [];
    let i = 0;
    _pagePhases__WEBPACK_IMPORTED_MODULE_5__["contentLoaded"].then(() => {
      setInterval(() => {
        queue.length = 0;
        i = 0;
      }, 0.5 * _time__WEBPACK_IMPORTED_MODULE_6__[/* MINUTE */ "c"]);
    });
    return thing => {
      const n = i++;

      const check = queue[n] = async () => {
        delete queue[n];
        const filterTask = thing.tasks.byId.get('filter');
        if (filterTask instanceof Promise) await filterTask();

        if (thing.tasks.completed || thing.isVisible()) {
          thing.runTasks();
        } else if (n < max) {
          max++;
          const nextCheck = queue.find(Boolean);
          if (nextCheck) nextCheck();
        }
      };

      if (n < max) check();
    };
  })(), {
    immediate: true
  });
  const io = new IntersectionObserver(entries => {
    for (const {
      target,
      isIntersecting
    } of entries) {
      if (isIntersecting) {
        io.unobserve(target);
        _Thing__WEBPACK_IMPORTED_MODULE_2__[/* Thing */ "a"].checkedFrom(target).runTasks();
      }
    }
  }, {
    rootMargin: '100%',
    delay: 200
  });
  watchForThings(null, async thing => {
    if (thing.tasks.completed) return;
    if (!container.contains(thing.element)) await Object(_dom__WEBPACK_IMPORTED_MODULE_4__[/* waitForAttach */ "m"])(container, thing.element);
    io.observe(thing.entry);
  }, {
    immediate: true
  });

  const getReadyThingElements = () => {
    _Thing__WEBPACK_IMPORTED_MODULE_2__[/* Thing */ "a"].thingElements.cache.clear();
    const thingElements = _Thing__WEBPACK_IMPORTED_MODULE_2__[/* Thing */ "a"].thingElements(container);
    let _last = thingElements.slice(-1)[0];

    if (_last) {
      if (Object(_dom__WEBPACK_IMPORTED_MODULE_4__[/* isLastNodeInDOM */ "j"])(_last)) {
        thingElements.pop();

        if (thingElements.length) {
          _last = thingElements.slice(-1)[0];
        } else {
          while (!_last.previousElementSibling) {
            _last = _last.parentElement;
          }

          _last = _last.previousElementSibling;
        }
      }

      cleanHideClasses();

      do {
        _last.classList.add(HIDE_FOLLOWING_CLASS);
      } while ((_last = _last.parentElement) && _last !== container);
    }

    return thingElements;
  };

  while (true) {
    const thingElements = getReadyThingElements();

    for (const e of thingElements) registerThing(e);

    if (thingElements.length >= initialProcessSize) return;

    try {
      await Promise.race([_pagePhases__WEBPACK_IMPORTED_MODULE_5__["contentLoaded"].then(() => Promise.reject()), Promise.all([thingElements.length ? new Promise(res => {
        setTimeout(res, 100);
      }) : Promise.resolve(), Object(_dom__WEBPACK_IMPORTED_MODULE_4__[/* waitForDescendantChange */ "p"])(container, _Thing__WEBPACK_IMPORTED_MODULE_2__[/* Thing */ "a"].thingSelector)])]);
    } catch (e) {
      break;
    }
  }
}
function r2WatcherContentLoaded() {
  cleanHideClasses();

  if (Object(_location__WEBPACK_IMPORTED_MODULE_3__[/* isPageType */ "n"])('comments')) {
    const commentarea = document.body.querySelector('.commentarea');
    if (commentarea) Object(_dom__WEBPACK_IMPORTED_MODULE_4__[/* watchForFutureDescendants */ "w"])(commentarea, '.thing', registerPage, true);
  } else {
    const watchList = Object(lodash_es__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(ele => {
      if (ele) Object(_dom__WEBPACK_IMPORTED_MODULE_4__[/* watchForFutureChildren */ "v"])(ele, '.thing', registerPage);
    });
    watchForThings(null, thing => {
      watchList(thing.element.parentElement);
    });
  }

  registerPage(document.body);
}

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
function isIterateeCall(value,index,object){if(!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(object)){return false;}var type=typeof index;if(type=='number'?Object(_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(object)&&Object(_isIndex_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(index,object.length):type=='string'&&index in object){return Object(_eq_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(object[index],value);}return false;}/* harmony default export */ __webpack_exports__["a"] = (isIterateeCall);

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_getNative.js + 4 modules
var _getNative = __webpack_require__(15);

// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeCreate.js
var nativeCreate=Object(_getNative["a" /* default */])(Object,'create');/* harmony default export */ var _nativeCreate = (nativeCreate);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashClear.js
function hashClear(){this.__data__=_nativeCreate?_nativeCreate(null):{};this.size=0;}/* harmony default export */ var _hashClear = (hashClear);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashDelete.js
function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/* harmony default export */ var _hashDelete = (hashDelete);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED='__lodash_hash_undefined__';var objectProto=Object.prototype;var _hashGet_hasOwnProperty=objectProto.hasOwnProperty;function hashGet(key){var data=this.__data__;if(_nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return _hashGet_hasOwnProperty.call(data,key)?data[key]:undefined;}/* harmony default export */ var _hashGet = (hashGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashHas.js
var _hashHas_objectProto=Object.prototype;var _hashHas_hasOwnProperty=_hashHas_objectProto.hasOwnProperty;function hashHas(key){var data=this.__data__;return _nativeCreate?data[key]!==undefined:_hashHas_hasOwnProperty.call(data,key);}/* harmony default export */ var _hashHas = (hashHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_hashSet.js
var _hashSet_HASH_UNDEFINED='__lodash_hash_undefined__';function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=_nativeCreate&&value===undefined?_hashSet_HASH_UNDEFINED:value;return this;}/* harmony default export */ var _hashSet = (hashSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_Hash.js
function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}Hash.prototype.clear=_hashClear;Hash.prototype['delete']=_hashDelete;Hash.prototype.get=_hashGet;Hash.prototype.has=_hashHas;Hash.prototype.set=_hashSet;/* harmony default export */ var _Hash = (Hash);
// EXTERNAL MODULE: ./node_modules/lodash-es/_ListCache.js + 6 modules
var _ListCache = __webpack_require__(45);

// EXTERNAL MODULE: ./node_modules/lodash-es/_Map.js
var _Map = __webpack_require__(50);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear(){this.size=0;this.__data__={'hash':new _Hash(),'map':new(_Map["a" /* default */]||_ListCache["a" /* default */])(),'string':new _Hash()};}/* harmony default export */ var _mapCacheClear = (mapCacheClear);
// CONCATENATED MODULE: ./node_modules/lodash-es/_isKeyable.js
function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/* harmony default export */ var _isKeyable = (isKeyable);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getMapData.js
function getMapData(map,key){var data=map.__data__;return _isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/* harmony default export */ var _getMapData = (getMapData);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key){var result=_getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/* harmony default export */ var _mapCacheDelete = (mapCacheDelete);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key){return _getMapData(this,key).get(key);}/* harmony default export */ var _mapCacheGet = (mapCacheGet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key){return _getMapData(this,key).has(key);}/* harmony default export */ var _mapCacheHas = (mapCacheHas);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key,value){var data=_getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}/* harmony default export */ var _mapCacheSet = (mapCacheSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_MapCache.js
function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}MapCache.prototype.clear=_mapCacheClear;MapCache.prototype['delete']=_mapCacheDelete;MapCache.prototype.get=_mapCacheGet;MapCache.prototype.has=_mapCacheHas;MapCache.prototype.set=_mapCacheSet;/* harmony default export */ var _MapCache = __webpack_exports__["a"] = (MapCache);

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
var WeakMap=Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(_root_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],'WeakMap');/* harmony default export */ __webpack_exports__["a"] = (WeakMap);

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
var asyncTag='[object AsyncFunction]',funcTag='[object Function]',genTag='[object GeneratorFunction]',proxyTag='[object Proxy]';function isFunction(value){if(!Object(_isObject_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(value)){return false;}var tag=Object(_baseGetTag_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/* harmony default export */ __webpack_exports__["a"] = (isFunction);

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/* harmony default export */ __webpack_exports__["a"] = (arrayPush);

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/;function isKey(value,object){if(Object(_isArray_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||Object(_isSymbol_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/* harmony default export */ __webpack_exports__["a"] = (isKey);

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&Object(_eq_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(objValue,value))||value===undefined&&!(key in object)){Object(_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(object,key,value);}}/* harmony default export */ __webpack_exports__["a"] = (assignValue);

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var MAX_SAFE_INTEGER=9007199254740991;function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/* harmony default export */ __webpack_exports__["a"] = (isLength);

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/* harmony default export */ __webpack_exports__["a"] = (setToArray);

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _arrayFilter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var _stubArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83);
var objectProto=Object.prototype;var propertyIsEnumerable=objectProto.propertyIsEnumerable;var nativeGetSymbols=Object.getOwnPropertySymbols;var getSymbols=!nativeGetSymbols?_stubArray_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]:function(object){if(object==null){return[];}object=Object(object);return Object(_arrayFilter_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/* harmony default export */ __webpack_exports__["a"] = (getSymbols);

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/* harmony default export */ __webpack_exports__["a"] = (arrayEach);

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_Stack.js + 5 modules
var _Stack = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/lodash-es/_SetCache.js + 2 modules
var _SetCache = __webpack_require__(46);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arraySome.js
function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/* harmony default export */ var _arraySome = (arraySome);
// EXTERNAL MODULE: ./node_modules/lodash-es/_cacheHas.js
var _cacheHas = __webpack_require__(36);

// CONCATENATED MODULE: ./node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new _SetCache["a" /* default */]():undefined;stack.set(array,other);stack.set(other,array);while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}if(seen){if(!_arraySome(other,function(othValue,othIndex){if(!Object(_cacheHas["a" /* default */])(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/* harmony default export */ var _equalArrays = (equalArrays);
// EXTERNAL MODULE: ./node_modules/lodash-es/_Symbol.js
var _Symbol = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/lodash-es/_Uint8Array.js
var _Uint8Array = __webpack_require__(71);

// EXTERNAL MODULE: ./node_modules/lodash-es/eq.js
var eq = __webpack_require__(40);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapToArray.js
function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/* harmony default export */ var _mapToArray = (mapToArray);
// EXTERNAL MODULE: ./node_modules/lodash-es/_setToArray.js
var _setToArray = __webpack_require__(62);

// CONCATENATED MODULE: ./node_modules/lodash-es/_equalByTag.js
var _equalByTag_COMPARE_PARTIAL_FLAG=1,_equalByTag_COMPARE_UNORDERED_FLAG=2;var boolTag='[object Boolean]',dateTag='[object Date]',errorTag='[object Error]',mapTag='[object Map]',numberTag='[object Number]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]';var symbolProto=_Symbol["a" /* default */]?_Symbol["a" /* default */].prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined;function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new _Uint8Array["a" /* default */](object),new _Uint8Array["a" /* default */](other))){return false;}return true;case boolTag:case dateTag:case numberTag:return Object(eq["a" /* default */])(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:return object==other+'';case mapTag:var convert=_mapToArray;case setTag:var isPartial=bitmask&_equalByTag_COMPARE_PARTIAL_FLAG;convert||(convert=_setToArray["a" /* default */]);if(object.size!=other.size&&!isPartial){return false;}var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=_equalByTag_COMPARE_UNORDERED_FLAG;stack.set(object,other);var result=_equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/* harmony default export */ var _equalByTag = (equalByTag);
// EXTERNAL MODULE: ./node_modules/lodash-es/_getAllKeys.js
var _getAllKeys = __webpack_require__(74);

// CONCATENATED MODULE: ./node_modules/lodash-es/_equalObjects.js
var _equalObjects_COMPARE_PARTIAL_FLAG=1;var objectProto=Object.prototype;var _equalObjects_hasOwnProperty=objectProto.hasOwnProperty;function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&_equalObjects_COMPARE_PARTIAL_FLAG,objProps=Object(_getAllKeys["a" /* default */])(object),objLength=objProps.length,othProps=Object(_getAllKeys["a" /* default */])(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:_equalObjects_hasOwnProperty.call(other,key))){return false;}}var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/* harmony default export */ var _equalObjects = (equalObjects);
// EXTERNAL MODULE: ./node_modules/lodash-es/_getTag.js + 2 modules
var _getTag = __webpack_require__(25);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/lodash-es/isBuffer.js
var isBuffer = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/lodash-es/isTypedArray.js + 1 modules
var isTypedArray = __webpack_require__(48);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsEqualDeep.js
var _baseIsEqualDeep_COMPARE_PARTIAL_FLAG=1;var argsTag='[object Arguments]',arrayTag='[object Array]',objectTag='[object Object]';var _baseIsEqualDeep_objectProto=Object.prototype;var _baseIsEqualDeep_hasOwnProperty=_baseIsEqualDeep_objectProto.hasOwnProperty;function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=Object(isArray["a" /* default */])(object),othIsArr=Object(isArray["a" /* default */])(other),objTag=objIsArr?arrayTag:Object(_getTag["a" /* default */])(object),othTag=othIsArr?arrayTag:Object(_getTag["a" /* default */])(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&Object(isBuffer["a" /* default */])(object)){if(!Object(isBuffer["a" /* default */])(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new _Stack["a" /* default */]());return objIsArr||Object(isTypedArray["a" /* default */])(object)?_equalArrays(object,other,bitmask,customizer,equalFunc,stack):_equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&_baseIsEqualDeep_COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&_baseIsEqualDeep_hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&_baseIsEqualDeep_hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new _Stack["a" /* default */]());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new _Stack["a" /* default */]());return _equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/* harmony default export */ var _baseIsEqualDeep = (baseIsEqualDeep);
// EXTERNAL MODULE: ./node_modules/lodash-es/isObjectLike.js
var isObjectLike = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!Object(isObjectLike["a" /* default */])(value)&&!Object(isObjectLike["a" /* default */])(other)){return value!==value&&other!==other;}return _baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/* harmony default export */ var _baseIsEqual = __webpack_exports__["a"] = (baseIsEqual);

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/* harmony default export */ var _arrayAggregator = (arrayAggregator);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseEach.js + 1 modules
var _baseEach = __webpack_require__(90);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection,setter,iteratee,accumulator){Object(_baseEach["a" /* default */])(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/* harmony default export */ var _baseAggregator = (baseAggregator);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIteratee.js + 9 modules
var _baseIteratee = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createAggregator.js
function createAggregator(setter,initializer){return function(collection,iteratee){var func=Object(isArray["a" /* default */])(collection)?_arrayAggregator:_baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,Object(_baseIteratee["a" /* default */])(iteratee,2),accumulator);};}/* harmony default export */ var _createAggregator = __webpack_exports__["a"] = (createAggregator);

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/* harmony default export */ var _createBaseFor = (createBaseFor);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseFor.js
var baseFor=_createBaseFor();/* harmony default export */ var _baseFor = (baseFor);
// EXTERNAL MODULE: ./node_modules/lodash-es/keys.js
var keys = __webpack_require__(32);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object,iteratee){return object&&_baseFor(object,iteratee,keys["a" /* default */]);}/* harmony default export */ var _baseForOwn = __webpack_exports__["a"] = (baseForOwn);

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/lodash-es/constant.js
function constant(value){return function(){return value;};}/* harmony default export */ var lodash_es_constant = (constant);
// EXTERNAL MODULE: ./node_modules/lodash-es/_defineProperty.js
var _defineProperty = __webpack_require__(70);

// EXTERNAL MODULE: ./node_modules/lodash-es/identity.js
var identity = __webpack_require__(28);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSetToString.js
var baseSetToString=!_defineProperty["a" /* default */]?identity["a" /* default */]:function(func,string){return Object(_defineProperty["a" /* default */])(func,'toString',{'configurable':true,'enumerable':false,'value':lodash_es_constant(string),'writable':true});};/* harmony default export */ var _baseSetToString = (baseSetToString);
// EXTERNAL MODULE: ./node_modules/lodash-es/_shortOut.js
var _shortOut = __webpack_require__(77);

// CONCATENATED MODULE: ./node_modules/lodash-es/_setToString.js
var setToString=Object(_shortOut["a" /* default */])(_baseSetToString);/* harmony default export */ var _setToString = __webpack_exports__["a"] = (setToString);

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayPush.js
var _arrayPush = __webpack_require__(58);

// EXTERNAL MODULE: ./node_modules/lodash-es/_Symbol.js
var _Symbol = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArguments.js + 1 modules
var isArguments = __webpack_require__(49);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol=_Symbol["a" /* default */]?_Symbol["a" /* default */].isConcatSpreadable:undefined;function isFlattenable(value){return Object(isArray["a" /* default */])(value)||Object(isArguments["a" /* default */])(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/* harmony default export */ var _isFlattenable = (isFlattenable);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=_isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){baseFlatten(value,depth-1,predicate,isStrict,result);}else{Object(_arrayPush["a" /* default */])(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/* harmony default export */ var _baseFlatten = __webpack_exports__["a"] = (baseFlatten);

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
var defineProperty=function(){try{var func=Object(_getNative_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/* harmony default export */ __webpack_exports__["a"] = (defineProperty);

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
var Uint8Array=_root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Uint8Array;/* harmony default export */ __webpack_exports__["a"] = (Uint8Array);

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _toFinite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
function toInteger(value){var result=Object(_toFinite_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/* harmony default export */ __webpack_exports__["a"] = (toInteger);

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
var INFINITY=1/0,MAX_INTEGER=1.7976931348623157e+308;function toFinite(value){if(!value){return value===0?value:0;}value=Object(_toNumber_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/* harmony default export */ __webpack_exports__["a"] = (toFinite);

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);
/* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
function getAllKeys(object){return Object(_baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(object,_keys_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],_getSymbols_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);}/* harmony default export */ __webpack_exports__["a"] = (getAllKeys);

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/* harmony default export */ __webpack_exports__["a"] = (baseSlice);

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var HOT_COUNT=800,HOT_SPAN=16;var nativeNow=Date.now;function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/* harmony default export */ __webpack_exports__["a"] = (shortOut);

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _apply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
var nativeMax=Math.max;function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return Object(_apply_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(func,this,otherArgs);};}/* harmony default export */ __webpack_exports__["a"] = (overRest);

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _baseTimes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21);
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48);
var objectProto=Object.prototype;var hasOwnProperty=objectProto.hasOwnProperty;function arrayLikeKeys(value,inherited){var isArr=Object(_isArray_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(value),isArg=!isArr&&Object(_isArguments_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(value),isBuff=!isArr&&!isArg&&Object(_isBuffer_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(value),isType=!isArr&&!isArg&&!isBuff&&Object(_isTypedArray_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?Object(_baseTimes_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(key=='length'||isBuff&&(key=='offset'||key=='parent')||isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||Object(_isIndex_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(key,length)))){result.push(key);}}return result;}/* harmony default export */ __webpack_exports__["a"] = (arrayLikeKeys);

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/* harmony default export */ __webpack_exports__["a"] = (baseTimes);

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return Object(_isArray_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(object)?result:Object(_arrayPush_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(result,symbolsFunc(object));}/* harmony default export */ __webpack_exports__["a"] = (baseGetAllKeys);

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function overArg(func,transform){return function(arg){return func(transform(arg));};}/* harmony default export */ __webpack_exports__["a"] = (overArg);

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function stubArray(){return[];}/* harmony default export */ __webpack_exports__["a"] = (stubArray);

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/* harmony default export */ __webpack_exports__["a"] = (arrayFilter);

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/* harmony default export */ __webpack_exports__["a"] = (baseProperty);

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function noop(){}/* harmony default export */ __webpack_exports__["a"] = (noop);

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/* harmony default export */ var _baseFindIndex = (baseFindIndex);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value){return value!==value;}/* harmony default export */ var _baseIsNaN = (baseIsNaN);
// CONCATENATED MODULE: ./node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/* harmony default export */ var _strictIndexOf = (strictIndexOf);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array,value,fromIndex){return value===value?_strictIndexOf(array,value,fromIndex):_baseFindIndex(array,_baseIsNaN,fromIndex);}/* harmony default export */ var _baseIndexOf = __webpack_exports__["a"] = (baseIndexOf);

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object,key){return object!=null&&key in Object(object);}/* harmony default export */ var _baseHasIn = (baseHasIn);
// EXTERNAL MODULE: ./node_modules/lodash-es/_castPath.js + 2 modules
var _castPath = __webpack_require__(34);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArguments.js + 1 modules
var isArguments = __webpack_require__(49);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/lodash-es/_isIndex.js
var _isIndex = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/lodash-es/isLength.js
var isLength = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/lodash-es/_toKey.js
var _toKey = __webpack_require__(20);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hasPath.js
function hasPath(object,path,hasFunc){path=Object(_castPath["a" /* default */])(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=Object(_toKey["a" /* default */])(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&Object(isLength["a" /* default */])(length)&&Object(_isIndex["a" /* default */])(key,length)&&(Object(isArray["a" /* default */])(object)||Object(isArguments["a" /* default */])(object));}/* harmony default export */ var _hasPath = (hasPath);
// CONCATENATED MODULE: ./node_modules/lodash-es/hasIn.js
function hasIn(object,path){return object!=null&&_hasPath(object,path,_baseHasIn);}/* harmony default export */ var lodash_es_hasIn = __webpack_exports__["a"] = (hasIn);

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_isPrototype.js
var _isPrototype = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/lodash-es/_overArg.js
var _overArg = __webpack_require__(82);

// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeys.js
var nativeKeys=Object(_overArg["a" /* default */])(Object.keys,Object);/* harmony default export */ var _nativeKeys = (nativeKeys);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeys.js
var objectProto=Object.prototype;var _baseKeys_hasOwnProperty=objectProto.hasOwnProperty;function baseKeys(object){if(!Object(_isPrototype["a" /* default */])(object)){return _nativeKeys(object);}var result=[];for(var key in Object(object)){if(_baseKeys_hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/* harmony default export */ var _baseKeys = __webpack_exports__["a"] = (baseKeys);

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseForOwn.js + 2 modules
var _baseForOwn = __webpack_require__(67);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArrayLike.js
var isArrayLike = __webpack_require__(13);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!Object(isArrayLike["a" /* default */])(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/* harmony default export */ var _createBaseEach = (createBaseEach);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseEach.js
var baseEach=_createBaseEach(_baseForOwn["a" /* default */]);/* harmony default export */ var _baseEach = __webpack_exports__["a"] = (baseEach);

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_Symbol.js
var _Symbol = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayMap.js
var _arrayMap = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/lodash-es/isSymbol.js
var isSymbol = __webpack_require__(18);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseToString.js
var INFINITY=1/0;var symbolProto=_Symbol["a" /* default */]?_Symbol["a" /* default */].prototype:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;function baseToString(value){if(typeof value=='string'){return value;}if(Object(isArray["a" /* default */])(value)){return Object(_arrayMap["a" /* default */])(value,baseToString)+'';}if(Object(isSymbol["a" /* default */])(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/* harmony default export */ var _baseToString = (baseToString);
// CONCATENATED MODULE: ./node_modules/lodash-es/toString.js
function toString_toString(value){return value==null?'':_baseToString(value);}/* harmony default export */ var lodash_es_toString = __webpack_exports__["a"] = (toString_toString);

/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGet.js
var _baseGet = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/lodash-es/_assignValue.js
var _assignValue = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/lodash-es/_castPath.js + 2 modules
var _castPath = __webpack_require__(34);

// EXTERNAL MODULE: ./node_modules/lodash-es/_isIndex.js
var _isIndex = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/lodash-es/_toKey.js
var _toKey = __webpack_require__(20);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSet.js
function baseSet(object,path,value,customizer){if(!Object(isObject["a" /* default */])(object)){return object;}path=Object(_castPath["a" /* default */])(path,object);var index=-1,length=path.length,nested=object;while(nested!=null&&++index<length){var key=Object(_toKey["a" /* default */])(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=length-1){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=Object(isObject["a" /* default */])(objValue)?objValue:Object(_isIndex["a" /* default */])(path[index+1])?[]:{};}}Object(_assignValue["a" /* default */])(nested,key,newValue);nested=nested[key];}return object;}/* harmony default export */ var _baseSet = (baseSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_basePickBy.js
function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=Object(_baseGet["a" /* default */])(object,path);if(predicate(value,path)){_baseSet(result,Object(_castPath["a" /* default */])(path,object),value);}}return result;}/* harmony default export */ var _basePickBy = __webpack_exports__["a"] = (basePickBy);

/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
var FUNC_ERROR_TEXT='Expected a function';function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||_MapCache_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])();return memoized;}memoize.Cache=_MapCache_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"];/* harmony default export */ __webpack_exports__["a"] = (memoize);

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports=function(originalModule){if(!originalModule.webpackPolyfill){var module=Object.create(originalModule);if(!module.children)module.children=[];Object.defineProperty(module,"loaded",{enumerable:true,get:function(){return module.l;}});Object.defineProperty(module,"id",{enumerable:true,get:function(){return module.i;}});Object.defineProperty(module,"exports",{enumerable:true});module.webpackPolyfill=1;}return module;};

/***/ }),
/* 95 */
/***/ (function(module, exports) {

const SEMVER_SPEC_VERSION='2.0.0';const MAX_LENGTH=256;const MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER||9007199254740991;const MAX_SAFE_COMPONENT_LENGTH=16;module.exports={SEMVER_SPEC_VERSION,MAX_LENGTH,MAX_SAFE_INTEGER,MAX_SAFE_COMPONENT_LENGTH};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;(function(Math){var tinyCounter=0,mathRound=Math.round,mathMin=Math.min,mathMax=Math.max,mathRandom=Math.random;function tinycolor(color,opts){color=color?color:'';opts=opts||{};if(color instanceof tinycolor){return color;}if(!(this instanceof tinycolor)){return new tinycolor(color,opts);}var rgb=inputToRGB(color);this._originalInput=color,this._r=rgb.r,this._g=rgb.g,this._b=rgb.b,this._a=rgb.a,this._roundA=mathRound(100*this._a)/100,this._format=opts.format||rgb.format;this._gradientType=opts.gradientType;if(this._r<1){this._r=mathRound(this._r);}if(this._g<1){this._g=mathRound(this._g);}if(this._b<1){this._b=mathRound(this._b);}this._ok=rgb.ok;this._tc_id=tinyCounter++;}tinycolor.prototype={isDark:function(){return this.getBrightness()<128;},isLight:function(){return!this.isDark();},isValid:function(){return this._ok;},getOriginalInput:function(){return this._originalInput;},getFormat:function(){return this._format;},getAlpha:function(){return this._a;},getBrightness:function(){var rgb=this.toRgb();return(rgb.r*299+rgb.g*587+rgb.b*114)/1000;},getLuminance:function(){var rgb=this.toRgb();var RsRGB,GsRGB,BsRGB,R,G,B;RsRGB=rgb.r/255;GsRGB=rgb.g/255;BsRGB=rgb.b/255;if(RsRGB<=0.03928){R=RsRGB/12.92;}else{R=Math.pow((RsRGB+0.055)/1.055,2.4);}if(GsRGB<=0.03928){G=GsRGB/12.92;}else{G=Math.pow((GsRGB+0.055)/1.055,2.4);}if(BsRGB<=0.03928){B=BsRGB/12.92;}else{B=Math.pow((BsRGB+0.055)/1.055,2.4);}return 0.2126*R+0.7152*G+0.0722*B;},setAlpha:function(value){this._a=boundAlpha(value);this._roundA=mathRound(100*this._a)/100;return this;},toHsv:function(){var hsv=rgbToHsv(this._r,this._g,this._b);return{h:hsv.h*360,s:hsv.s,v:hsv.v,a:this._a};},toHsvString:function(){var hsv=rgbToHsv(this._r,this._g,this._b);var h=mathRound(hsv.h*360),s=mathRound(hsv.s*100),v=mathRound(hsv.v*100);return this._a==1?"hsv("+h+", "+s+"%, "+v+"%)":"hsva("+h+", "+s+"%, "+v+"%, "+this._roundA+")";},toHsl:function(){var hsl=rgbToHsl(this._r,this._g,this._b);return{h:hsl.h*360,s:hsl.s,l:hsl.l,a:this._a};},toHslString:function(){var hsl=rgbToHsl(this._r,this._g,this._b);var h=mathRound(hsl.h*360),s=mathRound(hsl.s*100),l=mathRound(hsl.l*100);return this._a==1?"hsl("+h+", "+s+"%, "+l+"%)":"hsla("+h+", "+s+"%, "+l+"%, "+this._roundA+")";},toHex:function(allow3Char){return rgbToHex(this._r,this._g,this._b,allow3Char);},toHexString:function(allow3Char){return'#'+this.toHex(allow3Char);},toHex8:function(allow4Char){return rgbaToHex(this._r,this._g,this._b,this._a,allow4Char);},toHex8String:function(allow4Char){return'#'+this.toHex8(allow4Char);},toRgb:function(){return{r:mathRound(this._r),g:mathRound(this._g),b:mathRound(this._b),a:this._a};},toRgbString:function(){return this._a==1?"rgb("+mathRound(this._r)+", "+mathRound(this._g)+", "+mathRound(this._b)+")":"rgba("+mathRound(this._r)+", "+mathRound(this._g)+", "+mathRound(this._b)+", "+this._roundA+")";},toPercentageRgb:function(){return{r:mathRound(bound01(this._r,255)*100)+"%",g:mathRound(bound01(this._g,255)*100)+"%",b:mathRound(bound01(this._b,255)*100)+"%",a:this._a};},toPercentageRgbString:function(){return this._a==1?"rgb("+mathRound(bound01(this._r,255)*100)+"%, "+mathRound(bound01(this._g,255)*100)+"%, "+mathRound(bound01(this._b,255)*100)+"%)":"rgba("+mathRound(bound01(this._r,255)*100)+"%, "+mathRound(bound01(this._g,255)*100)+"%, "+mathRound(bound01(this._b,255)*100)+"%, "+this._roundA+")";},toName:function(){if(this._a===0){return"transparent";}if(this._a<1){return false;}return hexNames[rgbToHex(this._r,this._g,this._b,true)]||false;},toFilter:function(secondColor){var hex8String='#'+rgbaToArgbHex(this._r,this._g,this._b,this._a);var secondHex8String=hex8String;var gradientType=this._gradientType?"GradientType = 1, ":"";if(secondColor){var s=tinycolor(secondColor);secondHex8String='#'+rgbaToArgbHex(s._r,s._g,s._b,s._a);}return"progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";},toString:function(format){var formatSet=!!format;format=format||this._format;var formattedString=false;var hasAlpha=this._a<1&&this._a>=0;var needsAlphaFormat=!formatSet&&hasAlpha&&(format==="hex"||format==="hex6"||format==="hex3"||format==="hex4"||format==="hex8"||format==="name");if(needsAlphaFormat){if(format==="name"&&this._a===0){return this.toName();}return this.toRgbString();}if(format==="rgb"){formattedString=this.toRgbString();}if(format==="prgb"){formattedString=this.toPercentageRgbString();}if(format==="hex"||format==="hex6"){formattedString=this.toHexString();}if(format==="hex3"){formattedString=this.toHexString(true);}if(format==="hex4"){formattedString=this.toHex8String(true);}if(format==="hex8"){formattedString=this.toHex8String();}if(format==="name"){formattedString=this.toName();}if(format==="hsl"){formattedString=this.toHslString();}if(format==="hsv"){formattedString=this.toHsvString();}return formattedString||this.toHexString();},clone:function(){return tinycolor(this.toString());},_applyModification:function(fn,args){var color=fn.apply(null,[this].concat([].slice.call(args)));this._r=color._r;this._g=color._g;this._b=color._b;this.setAlpha(color._a);return this;},lighten:function(){return this._applyModification(lighten,arguments);},brighten:function(){return this._applyModification(brighten,arguments);},darken:function(){return this._applyModification(darken,arguments);},desaturate:function(){return this._applyModification(desaturate,arguments);},saturate:function(){return this._applyModification(saturate,arguments);},greyscale:function(){return this._applyModification(greyscale,arguments);},spin:function(){return this._applyModification(spin,arguments);},_applyCombination:function(fn,args){return fn.apply(null,[this].concat([].slice.call(args)));},analogous:function(){return this._applyCombination(analogous,arguments);},complement:function(){return this._applyCombination(complement,arguments);},monochromatic:function(){return this._applyCombination(monochromatic,arguments);},splitcomplement:function(){return this._applyCombination(splitcomplement,arguments);},triad:function(){return this._applyCombination(triad,arguments);},tetrad:function(){return this._applyCombination(tetrad,arguments);}};tinycolor.fromRatio=function(color,opts){if(typeof color=="object"){var newColor={};for(var i in color){if(color.hasOwnProperty(i)){if(i==="a"){newColor[i]=color[i];}else{newColor[i]=convertToPercentage(color[i]);}}}color=newColor;}return tinycolor(color,opts);};function inputToRGB(color){var rgb={r:0,g:0,b:0};var a=1;var s=null;var v=null;var l=null;var ok=false;var format=false;if(typeof color=="string"){color=stringInputToObject(color);}if(typeof color=="object"){if(isValidCSSUnit(color.r)&&isValidCSSUnit(color.g)&&isValidCSSUnit(color.b)){rgb=rgbToRgb(color.r,color.g,color.b);ok=true;format=String(color.r).substr(-1)==="%"?"prgb":"rgb";}else if(isValidCSSUnit(color.h)&&isValidCSSUnit(color.s)&&isValidCSSUnit(color.v)){s=convertToPercentage(color.s);v=convertToPercentage(color.v);rgb=hsvToRgb(color.h,s,v);ok=true;format="hsv";}else if(isValidCSSUnit(color.h)&&isValidCSSUnit(color.s)&&isValidCSSUnit(color.l)){s=convertToPercentage(color.s);l=convertToPercentage(color.l);rgb=hslToRgb(color.h,s,l);ok=true;format="hsl";}if(color.hasOwnProperty("a")){a=color.a;}}a=boundAlpha(a);return{ok:ok,format:color.format||format,r:mathMin(255,mathMax(rgb.r,0)),g:mathMin(255,mathMax(rgb.g,0)),b:mathMin(255,mathMax(rgb.b,0)),a:a};}function rgbToRgb(r,g,b){return{r:bound01(r,255)*255,g:bound01(g,255)*255,b:bound01(b,255)*255};}function rgbToHsl(r,g,b){r=bound01(r,255);g=bound01(g,255);b=bound01(b,255);var max=mathMax(r,g,b),min=mathMin(r,g,b);var h,s,l=(max+min)/2;if(max==min){h=s=0;}else{var d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return{h:h,s:s,l:l};}function hslToRgb(h,s,l){var r,g,b;h=bound01(h,360);s=bound01(s,100);l=bound01(l,100);function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}if(s===0){r=g=b=l;}else{var q=l<0.5?l*(1+s):l+s-l*s;var p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return{r:r*255,g:g*255,b:b*255};}function rgbToHsv(r,g,b){r=bound01(r,255);g=bound01(g,255);b=bound01(b,255);var max=mathMax(r,g,b),min=mathMin(r,g,b);var h,s;var d=max-min;s=max===0?0:d/max;if(max==min){h=0;}else{switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return{h:h,s:s,v:max};}function hsvToRgb(h,s,v){h=bound01(h,360)*6;s=bound01(s,100);v=bound01(v,100);var i=Math.floor(h),f=h-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s),mod=i%6,r=[v,q,p,p,t,v][mod],g=[t,v,v,q,p,p][mod],b=[p,p,t,v,v,q][mod];return{r:r*255,g:g*255,b:b*255};}function rgbToHex(r,g,b,allow3Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];if(allow3Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)){return hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0);}return hex.join("");}function rgbaToHex(r,g,b,a,allow4Char){var hex=[pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16)),pad2(convertDecimalToHex(a))];if(allow4Char&&hex[0].charAt(0)==hex[0].charAt(1)&&hex[1].charAt(0)==hex[1].charAt(1)&&hex[2].charAt(0)==hex[2].charAt(1)&&hex[3].charAt(0)==hex[3].charAt(1)){return hex[0].charAt(0)+hex[1].charAt(0)+hex[2].charAt(0)+hex[3].charAt(0);}return hex.join("");}function rgbaToArgbHex(r,g,b,a){var hex=[pad2(convertDecimalToHex(a)),pad2(mathRound(r).toString(16)),pad2(mathRound(g).toString(16)),pad2(mathRound(b).toString(16))];return hex.join("");}tinycolor.equals=function(color1,color2){if(!color1||!color2){return false;}return tinycolor(color1).toRgbString()==tinycolor(color2).toRgbString();};tinycolor.random=function(){return tinycolor.fromRatio({r:mathRandom(),g:mathRandom(),b:mathRandom()});};function desaturate(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.s-=amount/100;hsl.s=clamp01(hsl.s);return tinycolor(hsl);}function saturate(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.s+=amount/100;hsl.s=clamp01(hsl.s);return tinycolor(hsl);}function greyscale(color){return tinycolor(color).desaturate(100);}function lighten(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.l+=amount/100;hsl.l=clamp01(hsl.l);return tinycolor(hsl);}function brighten(color,amount){amount=amount===0?0:amount||10;var rgb=tinycolor(color).toRgb();rgb.r=mathMax(0,mathMin(255,rgb.r-mathRound(255*-(amount/100))));rgb.g=mathMax(0,mathMin(255,rgb.g-mathRound(255*-(amount/100))));rgb.b=mathMax(0,mathMin(255,rgb.b-mathRound(255*-(amount/100))));return tinycolor(rgb);}function darken(color,amount){amount=amount===0?0:amount||10;var hsl=tinycolor(color).toHsl();hsl.l-=amount/100;hsl.l=clamp01(hsl.l);return tinycolor(hsl);}function spin(color,amount){var hsl=tinycolor(color).toHsl();var hue=(hsl.h+amount)%360;hsl.h=hue<0?360+hue:hue;return tinycolor(hsl);}function complement(color){var hsl=tinycolor(color).toHsl();hsl.h=(hsl.h+180)%360;return tinycolor(hsl);}function triad(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+120)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+240)%360,s:hsl.s,l:hsl.l})];}function tetrad(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+90)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+180)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+270)%360,s:hsl.s,l:hsl.l})];}function splitcomplement(color){var hsl=tinycolor(color).toHsl();var h=hsl.h;return[tinycolor(color),tinycolor({h:(h+72)%360,s:hsl.s,l:hsl.l}),tinycolor({h:(h+216)%360,s:hsl.s,l:hsl.l})];}function analogous(color,results,slices){results=results||6;slices=slices||30;var hsl=tinycolor(color).toHsl();var part=360/slices;var ret=[tinycolor(color)];for(hsl.h=(hsl.h-(part*results>>1)+720)%360;--results;){hsl.h=(hsl.h+part)%360;ret.push(tinycolor(hsl));}return ret;}function monochromatic(color,results){results=results||6;var hsv=tinycolor(color).toHsv();var h=hsv.h,s=hsv.s,v=hsv.v;var ret=[];var modification=1/results;while(results--){ret.push(tinycolor({h:h,s:s,v:v}));v=(v+modification)%1;}return ret;}tinycolor.mix=function(color1,color2,amount){amount=amount===0?0:amount||50;var rgb1=tinycolor(color1).toRgb();var rgb2=tinycolor(color2).toRgb();var p=amount/100;var rgba={r:(rgb2.r-rgb1.r)*p+rgb1.r,g:(rgb2.g-rgb1.g)*p+rgb1.g,b:(rgb2.b-rgb1.b)*p+rgb1.b,a:(rgb2.a-rgb1.a)*p+rgb1.a};return tinycolor(rgba);};tinycolor.readability=function(color1,color2){var c1=tinycolor(color1);var c2=tinycolor(color2);return(Math.max(c1.getLuminance(),c2.getLuminance())+0.05)/(Math.min(c1.getLuminance(),c2.getLuminance())+0.05);};tinycolor.isReadable=function(color1,color2,wcag2){var readability=tinycolor.readability(color1,color2);var wcag2Parms,out;out=false;wcag2Parms=validateWCAG2Parms(wcag2);switch(wcag2Parms.level+wcag2Parms.size){case"AAsmall":case"AAAlarge":out=readability>=4.5;break;case"AAlarge":out=readability>=3;break;case"AAAsmall":out=readability>=7;break;}return out;};tinycolor.mostReadable=function(baseColor,colorList,args){var bestColor=null;var bestScore=0;var readability;var includeFallbackColors,level,size;args=args||{};includeFallbackColors=args.includeFallbackColors;level=args.level;size=args.size;for(var i=0;i<colorList.length;i++){readability=tinycolor.readability(baseColor,colorList[i]);if(readability>bestScore){bestScore=readability;bestColor=tinycolor(colorList[i]);}}if(tinycolor.isReadable(baseColor,bestColor,{"level":level,"size":size})||!includeFallbackColors){return bestColor;}else{args.includeFallbackColors=false;return tinycolor.mostReadable(baseColor,["#fff","#000"],args);}};var names=tinycolor.names={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"0ff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000",blanchedalmond:"ffebcd",blue:"00f",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",burntsienna:"ea7e5d",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"0ff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkgrey:"a9a9a9",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"f0f",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",grey:"808080",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgreen:"90ee90",lightgrey:"d3d3d3",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslategray:"789",lightslategrey:"789",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"0f0",limegreen:"32cd32",linen:"faf0e6",magenta:"f0f",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370db",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"db7093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",rebeccapurple:"663399",red:"f00",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",wheat:"f5deb3",white:"fff",whitesmoke:"f5f5f5",yellow:"ff0",yellowgreen:"9acd32"};var hexNames=tinycolor.hexNames=function(o){var flipped={};for(var i in o){if(o.hasOwnProperty(i)){flipped[o[i]]=i;}}return flipped;}(names);function boundAlpha(a){a=parseFloat(a);if(isNaN(a)||a<0||a>1){a=1;}return a;}function bound01(n,max){if(isOnePointZero(n)){n="100%";}var processPercent=isPercentage(n);n=mathMin(max,mathMax(0,parseFloat(n)));if(processPercent){n=parseInt(n*max,10)/100;}if(Math.abs(n-max)<0.000001){return 1;}return n%max/parseFloat(max);}function clamp01(val){return mathMin(1,mathMax(0,val));}function parseIntFromHex(val){return parseInt(val,16);}function isOnePointZero(n){return typeof n=="string"&&n.indexOf('.')!=-1&&parseFloat(n)===1;}function isPercentage(n){return typeof n==="string"&&n.indexOf('%')!=-1;}function pad2(c){return c.length==1?'0'+c:''+c;}function convertToPercentage(n){if(n<=1){n=n*100+"%";}return n;}function convertDecimalToHex(d){return Math.round(parseFloat(d)*255).toString(16);}function convertHexToDecimal(h){return parseIntFromHex(h)/255;}var matchers=function(){var CSS_UNIT="(?:"+"[-\\+]?\\d*\\.\\d+%?"+")|(?:"+"[-\\+]?\\d+%?"+")";var PERMISSIVE_MATCH3="[\\s|\\(]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")\\s*\\)?";var PERMISSIVE_MATCH4="[\\s|\\(]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")[,|\\s]+("+CSS_UNIT+")\\s*\\)?";return{CSS_UNIT:new RegExp(CSS_UNIT),rgb:new RegExp("rgb"+PERMISSIVE_MATCH3),rgba:new RegExp("rgba"+PERMISSIVE_MATCH4),hsl:new RegExp("hsl"+PERMISSIVE_MATCH3),hsla:new RegExp("hsla"+PERMISSIVE_MATCH4),hsv:new RegExp("hsv"+PERMISSIVE_MATCH3),hsva:new RegExp("hsva"+PERMISSIVE_MATCH4),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/};}();function isValidCSSUnit(color){return!!matchers.CSS_UNIT.exec(color);}function stringInputToObject(color){color=color.replace(/^\s+/,'').replace(/\s+$/,'').toLowerCase();var named=false;if(names[color]){color=names[color];named=true;}else if(color=='transparent'){return{r:0,g:0,b:0,a:0,format:"name"};}var match;if(match=matchers.rgb.exec(color)){return{r:match[1],g:match[2],b:match[3]};}if(match=matchers.rgba.exec(color)){return{r:match[1],g:match[2],b:match[3],a:match[4]};}if(match=matchers.hsl.exec(color)){return{h:match[1],s:match[2],l:match[3]};}if(match=matchers.hsla.exec(color)){return{h:match[1],s:match[2],l:match[3],a:match[4]};}if(match=matchers.hsv.exec(color)){return{h:match[1],s:match[2],v:match[3]};}if(match=matchers.hsva.exec(color)){return{h:match[1],s:match[2],v:match[3],a:match[4]};}if(match=matchers.hex8.exec(color)){return{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),a:convertHexToDecimal(match[4]),format:named?"name":"hex8"};}if(match=matchers.hex6.exec(color)){return{r:parseIntFromHex(match[1]),g:parseIntFromHex(match[2]),b:parseIntFromHex(match[3]),format:named?"name":"hex"};}if(match=matchers.hex4.exec(color)){return{r:parseIntFromHex(match[1]+''+match[1]),g:parseIntFromHex(match[2]+''+match[2]),b:parseIntFromHex(match[3]+''+match[3]),a:convertHexToDecimal(match[4]+''+match[4]),format:named?"name":"hex8"};}if(match=matchers.hex3.exec(color)){return{r:parseIntFromHex(match[1]+''+match[1]),g:parseIntFromHex(match[2]+''+match[2]),b:parseIntFromHex(match[3]+''+match[3]),format:named?"name":"hex"};}return false;}function validateWCAG2Parms(parms){var level,size;parms=parms||{"level":"AA","size":"small"};level=(parms.level||"AA").toUpperCase();size=(parms.size||"small").toLowerCase();if(level!=="AA"&&level!=="AAA"){level="AA";}if(size!=="small"&&size!=="large"){size="small";}return{"level":level,"size":size};}if( true&&module.exports){module.exports=tinycolor;}else if(true){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return tinycolor;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else{}})(Math);

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

const SemVer=__webpack_require__(98);const compare=(a,b,loose)=>new SemVer(a,loose).compare(new SemVer(b,loose));module.exports=compare;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

const debug=__webpack_require__(99);const{MAX_LENGTH,MAX_SAFE_INTEGER}=__webpack_require__(95);const{re,t}=__webpack_require__(100);const parseOptions=__webpack_require__(101);const{compareIdentifiers}=__webpack_require__(126);class SemVer{constructor(version,options){options=parseOptions(options);if(version instanceof SemVer){if(version.loose===!!options.loose&&version.includePrerelease===!!options.includePrerelease){return version;}else{version=version.version;}}else if(typeof version!=='string'){throw new TypeError(`Invalid Version: ${version}`);}if(version.length>MAX_LENGTH){throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);}debug('SemVer',version,options);this.options=options;this.loose=!!options.loose;this.includePrerelease=!!options.includePrerelease;const m=version.trim().match(options.loose?re[t.LOOSE]:re[t.FULL]);if(!m){throw new TypeError(`Invalid Version: ${version}`);}this.raw=version;this.major=+m[1];this.minor=+m[2];this.patch=+m[3];if(this.major>MAX_SAFE_INTEGER||this.major<0){throw new TypeError('Invalid major version');}if(this.minor>MAX_SAFE_INTEGER||this.minor<0){throw new TypeError('Invalid minor version');}if(this.patch>MAX_SAFE_INTEGER||this.patch<0){throw new TypeError('Invalid patch version');}if(!m[4]){this.prerelease=[];}else{this.prerelease=m[4].split('.').map(id=>{if(/^[0-9]+$/.test(id)){const num=+id;if(num>=0&&num<MAX_SAFE_INTEGER){return num;}}return id;});}this.build=m[5]?m[5].split('.'):[];this.format();}format(){this.version=`${this.major}.${this.minor}.${this.patch}`;if(this.prerelease.length){this.version+=`-${this.prerelease.join('.')}`;}return this.version;}toString(){return this.version;}compare(other){debug('SemVer.compare',this.version,this.options,other);if(!(other instanceof SemVer)){if(typeof other==='string'&&other===this.version){return 0;}other=new SemVer(other,this.options);}if(other.version===this.version){return 0;}return this.compareMain(other)||this.comparePre(other);}compareMain(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}return compareIdentifiers(this.major,other.major)||compareIdentifiers(this.minor,other.minor)||compareIdentifiers(this.patch,other.patch);}comparePre(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}if(this.prerelease.length&&!other.prerelease.length){return-1;}else if(!this.prerelease.length&&other.prerelease.length){return 1;}else if(!this.prerelease.length&&!other.prerelease.length){return 0;}let i=0;do{const a=this.prerelease[i];const b=other.prerelease[i];debug('prerelease compare',i,a,b);if(a===undefined&&b===undefined){return 0;}else if(b===undefined){return 1;}else if(a===undefined){return-1;}else if(a===b){continue;}else{return compareIdentifiers(a,b);}}while(++i);}compareBuild(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}let i=0;do{const a=this.build[i];const b=other.build[i];debug('prerelease compare',i,a,b);if(a===undefined&&b===undefined){return 0;}else if(b===undefined){return 1;}else if(a===undefined){return-1;}else if(a===b){continue;}else{return compareIdentifiers(a,b);}}while(++i);}inc(release,identifier){switch(release){case'premajor':this.prerelease.length=0;this.patch=0;this.minor=0;this.major++;this.inc('pre',identifier);break;case'preminor':this.prerelease.length=0;this.patch=0;this.minor++;this.inc('pre',identifier);break;case'prepatch':this.prerelease.length=0;this.inc('patch',identifier);this.inc('pre',identifier);break;case'prerelease':if(this.prerelease.length===0){this.inc('patch',identifier);}this.inc('pre',identifier);break;case'major':if(this.minor!==0||this.patch!==0||this.prerelease.length===0){this.major++;}this.minor=0;this.patch=0;this.prerelease=[];break;case'minor':if(this.patch!==0||this.prerelease.length===0){this.minor++;}this.patch=0;this.prerelease=[];break;case'patch':if(this.prerelease.length===0){this.patch++;}this.prerelease=[];break;case'pre':if(this.prerelease.length===0){this.prerelease=[0];}else{let i=this.prerelease.length;while(--i>=0){if(typeof this.prerelease[i]==='number'){this.prerelease[i]++;i=-2;}}if(i===-1){this.prerelease.push(0);}}if(identifier){if(this.prerelease[0]===identifier){if(isNaN(this.prerelease[1])){this.prerelease=[identifier,0];}}else{this.prerelease=[identifier,0];}}break;default:throw new Error(`invalid increment argument: ${release}`);}this.format();this.raw=this.version;return this;}}module.exports=SemVer;

/***/ }),
/* 99 */
/***/ (function(module, exports) {

const debug=typeof process==='object'&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...args)=>console.error('SEMVER',...args):()=>{};module.exports=debug;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

const{MAX_SAFE_COMPONENT_LENGTH}=__webpack_require__(95);const debug=__webpack_require__(99);exports=module.exports={};const re=exports.re=[];const src=exports.src=[];const t=exports.t={};let R=0;const createToken=(name,value,isGlobal)=>{const index=R++;debug(index,value);t[name]=index;src[index]=value;re[index]=new RegExp(value,isGlobal?'g':undefined);};createToken('NUMERICIDENTIFIER','0|[1-9]\\d*');createToken('NUMERICIDENTIFIERLOOSE','[0-9]+');createToken('NONNUMERICIDENTIFIER','\\d*[a-zA-Z-][a-zA-Z0-9-]*');createToken('MAINVERSION',`(${src[t.NUMERICIDENTIFIER]})\\.`+`(${src[t.NUMERICIDENTIFIER]})\\.`+`(${src[t.NUMERICIDENTIFIER]})`);createToken('MAINVERSIONLOOSE',`(${src[t.NUMERICIDENTIFIERLOOSE]})\\.`+`(${src[t.NUMERICIDENTIFIERLOOSE]})\\.`+`(${src[t.NUMERICIDENTIFIERLOOSE]})`);createToken('PRERELEASEIDENTIFIER',`(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);createToken('PRERELEASEIDENTIFIERLOOSE',`(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);createToken('PRERELEASE',`(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);createToken('PRERELEASELOOSE',`(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);createToken('BUILDIDENTIFIER','[0-9A-Za-z-]+');createToken('BUILD',`(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);createToken('FULLPLAIN',`v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);createToken('FULL',`^${src[t.FULLPLAIN]}$`);createToken('LOOSEPLAIN',`[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);createToken('LOOSE',`^${src[t.LOOSEPLAIN]}$`);createToken('GTLT','((?:<|>)?=?)');createToken('XRANGEIDENTIFIERLOOSE',`${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);createToken('XRANGEIDENTIFIER',`${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);createToken('XRANGEPLAIN',`[v=\\s]*(${src[t.XRANGEIDENTIFIER]})`+`(?:\\.(${src[t.XRANGEIDENTIFIER]})`+`(?:\\.(${src[t.XRANGEIDENTIFIER]})`+`(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?`+`)?)?`);createToken('XRANGEPLAINLOOSE',`[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})`+`(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})`+`(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})`+`(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?`+`)?)?`);createToken('XRANGE',`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);createToken('XRANGELOOSE',`^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);createToken('COERCE',`${'(^|[^\\d])'+'(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})`+`(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`+`(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`+`(?:$|[^\\d])`);createToken('COERCERTL',src[t.COERCE],true);createToken('LONETILDE','(?:~>?)');createToken('TILDETRIM',`(\\s*)${src[t.LONETILDE]}\\s+`,true);exports.tildeTrimReplace='$1~';createToken('TILDE',`^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);createToken('TILDELOOSE',`^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);createToken('LONECARET','(?:\\^)');createToken('CARETTRIM',`(\\s*)${src[t.LONECARET]}\\s+`,true);exports.caretTrimReplace='$1^';createToken('CARET',`^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);createToken('CARETLOOSE',`^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);createToken('COMPARATORLOOSE',`^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);createToken('COMPARATOR',`^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);createToken('COMPARATORTRIM',`(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,true);exports.comparatorTrimReplace='$1$2$3';createToken('HYPHENRANGE',`^\\s*(${src[t.XRANGEPLAIN]})`+`\\s+-\\s+`+`(${src[t.XRANGEPLAIN]})`+`\\s*$`);createToken('HYPHENRANGELOOSE',`^\\s*(${src[t.XRANGEPLAINLOOSE]})`+`\\s+-\\s+`+`(${src[t.XRANGEPLAINLOOSE]})`+`\\s*$`);createToken('STAR','(<|>)?=?\\s*\\*');createToken('GTE0','^\\s*>=\\s*0\.0\.0\\s*$');createToken('GTE0PRE','^\\s*>=\\s*0\.0\.0-0\\s*$');

/***/ }),
/* 101 */
/***/ (function(module, exports) {

const opts=['includePrerelease','loose','rtl'];const parseOptions=options=>!options?{}:typeof options!=='object'?{loose:true}:opts.filter(k=>options[k]).reduce((options,k)=>{options[k]=true;return options;},{});module.exports=parseOptions;

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function stubFalse(){return false;}/* harmony default export */ __webpack_exports__["a"] = (stubFalse);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;(function(){'use strict';var collator;try{collator=typeof Intl!=="undefined"&&typeof Intl.Collator!=="undefined"?Intl.Collator("generic",{sensitivity:"base"}):null;}catch(err){console.log("Collator could not be initialized and wouldn't be used");}var levenshtein=__webpack_require__(111);var prevRow=[],str2Char=[];var Levenshtein={get:function(str1,str2,options){var useCollator=options&&collator&&options.useCollator;if(useCollator){var str1Len=str1.length,str2Len=str2.length;if(str1Len===0)return str2Len;if(str2Len===0)return str1Len;var curCol,nextCol,i,j,tmp;for(i=0;i<str2Len;++i){prevRow[i]=i;str2Char[i]=str2.charCodeAt(i);}prevRow[str2Len]=str2Len;var strCmp;for(i=0;i<str1Len;++i){nextCol=i+1;for(j=0;j<str2Len;++j){curCol=nextCol;strCmp=0===collator.compare(str1.charAt(i),String.fromCharCode(str2Char[j]));nextCol=prevRow[j]+(strCmp?0:1);tmp=curCol+1;if(nextCol>tmp){nextCol=tmp;}tmp=prevRow[j+1]+1;if(nextCol>tmp){nextCol=tmp;}prevRow[j]=curCol;}prevRow[j]=nextCol;}return nextCol;}return levenshtein.distance(str1,str2);}};if( true&&__webpack_require__(112)!==null&&__webpack_require__(113)){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Levenshtein;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else if( true&&module!==null&&typeof exports!=="undefined"&&module.exports===exports){module.exports=Levenshtein;}else if(typeof self!=="undefined"&&typeof self.postMessage==='function'&&typeof self.importScripts==='function'){self.Levenshtein=Levenshtein;}else if(typeof window!=="undefined"&&window!==null){window.Levenshtein=Levenshtein;}})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(110)(module)))

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGUAAAAkCAYAAACQePQGAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABcVJREFUeNrsmr9LZFcUx4+bZKIJrBKbUZKMEAgSAo5sYzcjbGGzaBGCndoskkZh/wC1SRfUzq1U0lgEVLaRbRybXTu1SBAbFULUBLO6wiKSZPI+1xxz5857b96M4zor78D13Xd/nnO+55x77hvrRCTrlVWJqWboXqyCGJSYYlBiUGKKQbm79H5Y59TUt5JOfxZ5sYsf9yTx+4VsHh/L6IsXJccnk0np6ekpaFtfX5ft7W2pr683fel02rSfnJzIysqKHB4eSl9fn3nyzrj+/v6ree3t7dLV1SWbm5tmfYpNc3NzMjg4WNCmazc1NRXxwzrsZbefn5+b/fb29kJloZ+x8KT8tbW1STabNX25XK58UAAkk/kyMij7Px1LqiUReTwKhUmUAvMIxvvMzIxRPO8wT0HRKH9hYcHM4x1BGU9hPkIDIu8omTproFSbdE8Uzjr6zj7UGc96Lp/aTh1FT01NmXn2GNZkjPIxOztrQEAexgMcPMFfRZ7y3cXf8mb/WJKHr6Vn5eeSSu47bZBUQ0LSzc2Se/TItGWfPSs5D0GwGhhHmNbWVsM4SgYEiPrw8LDpZzzCoRgEh6gzhyfKUyBQmlqkrWht58m+rKOWr96h4/AgCEUqcHgbvPhZO/toOTo6MvPYA/5ZizmuoUQG5ZfEeyKpZo+RY1kfL63cLEA0NEljIiGZlpbIHqNWpQq23V9JhcAiXVAQXsOdKtUOKxquWI/wZbdreAN0JTsMoUCbD5cvP1lsY4M3niojcgSFrUigVIPGHzy4jOU7O7J3duY7BuuhwLAdqzUWa8hRy9VQRT+0tLRkFKljbAXbQPhZM2AyXkOhnju24l1jIeS5nmefWcy1PUm9krZSgLwVUMb+AyV3cBAICoy6zKrSR0dHjVDqEQoS1ke/AkQ/yqKucV4VOj4+XqA0BZfQiKLsMAjZiYB9INvt6gEuqZepBwK6awy3Csqr849l649L5hL3mr2/vxUxiNC2EpVQGAekKgsFAIiGMZTPXPUK+lCErSi/uK17ah/7kEAAqF+o0sPdbqfOfraC3THwZZ9N2h8FlLrQD5K5JyJkX2s73qgfygYl3dQnn9Z3mPqv51uyebIUX0Kue0+5DSIO66GooQ2L8/Omu0x4St635J7kJf/08hk0JqS033+Y//7rXVOoh431zo685955P/IAyXvnQsF43m2y+0uRB7LZL+p6QevSxlo2IYOXtBTM89Lhorne+RSoixv9zPJP/i9p/rDNFOpBxOE7OTkpqVTKt7+xsVHGxsZ8D9ZKqKOjw+xXjfXcrwPIQHJiZ5ZcGm1aW1vzzQhr5tsXDA8MDEQaWy1QbHDszKwSgqeJiYnCjNMzIL2vsL5tbKenp0VA1hQonBsjIyMFbcvLy9LZ2Sl1dXUyNDRkrAqan58vKUwQoTQtW1tboZZe0V3MU/z+/n6RsZE9uvIxNuzyeesHvasQAOBzhB3WKPYnkEqVZq+5u7tbEG6qJcvq6v9JbCaTMZdaVz43lNWcp2BJ7tmiGZheKCm0a70alh3p0uuFIM5yu4QRvE1PTxedheWErZpMidUbOByxtCDhr+MptieaL9tO2LluGGN9P++LErZq9p5yU1YflvlVi7hLkXktLi5WFLZqAhT3QoiV6WWxu7v7qt2O1dUkkoeg7AtFul4ZBq4S5wjJBJmdn6fWPCgI0Nvbe/VOpoLl6u8rN0V6TwjzEvZ3lRkFFD9je6c+swAKbm0fiBsbGyYtBhgSgaCzpRwivb47374OvhB52Sby5ycij8u/ZB1+kJS5+5cH6dmrj7w/xRZFRuLGYLzH9iC/ZOAuUzgoZ1+JJDxL/dyrP/6m7MVfe+Wlvjx/E+gtXBJdj/EjUs5qHszvJihviVA04OA1+ju9AkT8J5TpWROUGtvv7mePKBS2Xrnr6r2qUu8O/z0lpluh+J/xYlBiikGJQYkpBuUOE9kX/5OZjlVRO/SvAAMADC1T3Wo5vNkAAAAASUVORK5CYII="

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
var freeExports=typeof exports=='object'&&exports&&!exports.nodeType&&exports;var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;var moduleExports=freeModule&&freeModule.exports===freeExports;var Buffer=moduleExports?_root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Buffer:undefined,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined;function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/* harmony default export */ __webpack_exports__["a"] = (cloneBuffer);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(94)(module)))

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

(function(){'use strict';var PI=Math.PI,sin=Math.sin,cos=Math.cos,tan=Math.tan,asin=Math.asin,atan=Math.atan2,acos=Math.acos,rad=PI/180;var dayMs=1000*60*60*24,J1970=2440588,J2000=2451545;function toJulian(date){return date.valueOf()/dayMs-0.5+J1970;}function fromJulian(j){return new Date((j+0.5-J1970)*dayMs);}function toDays(date){return toJulian(date)-J2000;}var e=rad*23.4397;function rightAscension(l,b){return atan(sin(l)*cos(e)-tan(b)*sin(e),cos(l));}function declination(l,b){return asin(sin(b)*cos(e)+cos(b)*sin(e)*sin(l));}function azimuth(H,phi,dec){return atan(sin(H),cos(H)*sin(phi)-tan(dec)*cos(phi));}function altitude(H,phi,dec){return asin(sin(phi)*sin(dec)+cos(phi)*cos(dec)*cos(H));}function siderealTime(d,lw){return rad*(280.16+360.9856235*d)-lw;}function astroRefraction(h){if(h<0)h=0;return 0.0002967/Math.tan(h+0.00312536/(h+0.08901179));}function solarMeanAnomaly(d){return rad*(357.5291+0.98560028*d);}function eclipticLongitude(M){var C=rad*(1.9148*sin(M)+0.02*sin(2*M)+0.0003*sin(3*M));return M+C+rad*102.9372+PI;}function sunCoords(d){var M=solarMeanAnomaly(d),L=eclipticLongitude(M);return{dec:declination(L,0),ra:rightAscension(L,0)};}var SunCalc={};SunCalc.getPosition=function(date,lat,lng){var phi=rad*lat,d=toDays(date),c=sunCoords(d),H=siderealTime(d,rad*-lng)-c.ra;return{azimuth:azimuth(H,phi,c.dec),altitude:altitude(H,phi,c.dec)};};var times=SunCalc.times=[[-0.833,'sunrise','sunset'],[-0.3,'sunriseEnd','sunsetStart'],[-6,'dawn','dusk'],[-12,'nauticalDawn','nauticalDusk'],[-18,'nightEnd','night'],[6,'goldenHourEnd','goldenHour']];SunCalc.addTime=function(angle,riseName,setName){times.push([angle,riseName,setName]);};var J0=0.0009;function julianCycle(d,lw){return Math.round(d-J0-lw/(2*PI));}function approxTransit(Ht,lw,n){return J0+(Ht+lw)/(2*PI)+n;}function solarTransitJ(ds,M,L){return J2000+ds+0.0053*sin(M)-0.0069*sin(2*L);}function hourAngle(h,phi,d){return acos((sin(h)-sin(phi)*sin(d))/(cos(phi)*cos(d)));}function getSetJ(h,lw,phi,dec,n,M,L){var w=hourAngle(h,phi,dec),a=approxTransit(w,lw,n);return solarTransitJ(a,M,L);}SunCalc.getTimes=function(date,lat,lng){var lw=rad*-lng,d=toDays(date),n=julianCycle(d,lw),ds=approxTransit(0,lw,n),M=solarMeanAnomaly(ds),L=eclipticLongitude(M),dec=declination(L,0),Jnoon=solarTransitJ(ds,M,L),i,len,time,Jset,Jrise;var result={solarNoon:fromJulian(Jnoon),nadir:fromJulian(Jnoon-0.5)};for(i=0,len=times.length;i<len;i+=1){time=times[i];Jset=getSetJ(time[0]*rad,lw,rad*lat,dec,n,M,L);Jrise=Jnoon-(Jset-Jnoon);result[time[1]]=fromJulian(Jrise);result[time[2]]=fromJulian(Jset);}return result;};function moonCoords(d){var M=rad*(134.963+13.064993*d),l=rad*(218.316+13.176396*d)+rad*6.289*sin(M),b=rad*5.128*sin(rad*(93.272+13.229350*d)),dt=385001-20905*cos(M);return{ra:rightAscension(l,b),dec:declination(l,b),dist:dt};}SunCalc.getMoonPosition=function(date,lat,lng){var phi=rad*lat,d=toDays(date),c=moonCoords(d),H=siderealTime(d,rad*-lng)-c.ra,h=altitude(H,phi,c.dec),pa=atan(sin(H),tan(phi)*cos(c.dec)-sin(c.dec)*cos(H));h=h+astroRefraction(h);return{azimuth:azimuth(H,phi,c.dec),altitude:h,distance:c.dist,parallacticAngle:pa};};SunCalc.getMoonIllumination=function(date){var d=toDays(date||new Date()),s=sunCoords(d),m=moonCoords(d),sdist=149598000,phi=acos(sin(s.dec)*sin(m.dec)+cos(s.dec)*cos(m.dec)*cos(s.ra-m.ra)),inc=atan(sdist*sin(phi),m.dist-sdist*cos(phi)),angle=atan(cos(s.dec)*sin(s.ra-m.ra),sin(s.dec)*cos(m.dec)-cos(s.dec)*sin(m.dec)*cos(s.ra-m.ra));return{fraction:(1+cos(inc))/2,phase:0.5+0.5*inc*(angle<0?-1:1)/Math.PI,angle:angle};};function hoursLater(date,h){return new Date(date.valueOf()+h*dayMs/24);}SunCalc.getMoonTimes=function(date,lat,lng,inUTC){var t=new Date(date);if(inUTC)t.setUTCHours(0,0,0,0);else t.setHours(0,0,0,0);var hc=0.133*rad,h0=SunCalc.getMoonPosition(t,lat,lng).altitude-hc,h1,h2,rise,set,a,b,xe,ye,d,roots,x1,x2,dx;for(var i=1;i<=24;i+=2){h1=SunCalc.getMoonPosition(hoursLater(t,i),lat,lng).altitude-hc;h2=SunCalc.getMoonPosition(hoursLater(t,i+1),lat,lng).altitude-hc;a=(h0+h2)/2-h1;b=(h2-h0)/2;xe=-b/(2*a);ye=(a*xe+b)*xe+h1;d=b*b-4*a*h1;roots=0;if(d>=0){dx=Math.sqrt(d)/(Math.abs(a)*2);x1=xe-dx;x2=xe+dx;if(Math.abs(x1)<=1)roots++;if(Math.abs(x2)<=1)roots++;if(x1<-1)x1=x2;}if(roots===1){if(h0<0)rise=i+x1;else set=i+x1;}else if(roots===2){rise=i+(ye<0?x2:x1);set=i+(ye<0?x1:x2);}if(rise&&set)break;h0=h2;}var result={};if(rise)result.rise=hoursLater(t,rise);if(set)result.set=hoursLater(t,set);if(!rise&&!set)result[ye>0?'alwaysUp':'alwaysDown']=true;return result;};if(true)module.exports=SunCalc;else {}})();

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license MIT
 * @fileOverview Favico animations
 * @author Miroslav Magda, http://blog.ejci.net
 * @version 0.3.10
 */(function(){var Favico=function(opt){'use strict';opt=opt?opt:{};var _def={bgColor:'#d00',textColor:'#fff',fontFamily:'sans-serif',fontStyle:'bold',type:'circle',position:'down',animation:'slide',elementId:false,dataUrl:false,win:window};var _opt,_orig,_h,_w,_canvas,_context,_img,_ready,_lastBadge,_running,_readyCb,_stop,_browser,_animTimeout,_drawTimeout,_doc;_browser={};_browser.ff=typeof InstallTrigger!='undefined';_browser.chrome=!!window.chrome;_browser.opera=!!window.opera||navigator.userAgent.indexOf('Opera')>=0;_browser.ie=false;_browser.safari=Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor')>0;_browser.supported=_browser.chrome||_browser.ff||_browser.opera;var _queue=[];_readyCb=function(){};_ready=_stop=false;var init=function(){_opt=merge(_def,opt);_opt.bgColor=hexToRgb(_opt.bgColor);_opt.textColor=hexToRgb(_opt.textColor);_opt.position=_opt.position.toLowerCase();_opt.animation=animation.types[''+_opt.animation]?_opt.animation:_def.animation;_doc=_opt.win.document;var isUp=_opt.position.indexOf('up')>-1;var isLeft=_opt.position.indexOf('left')>-1;if(isUp||isLeft){for(var i=0;i<animation.types[''+_opt.animation].length;i++){var step=animation.types[''+_opt.animation][i];if(isUp){if(step.y<0.6){step.y=step.y-0.4;}else{step.y=step.y-2*step.y+(1-step.w);}}if(isLeft){if(step.x<0.6){step.x=step.x-0.4;}else{step.x=step.x-2*step.x+(1-step.h);}}animation.types[''+_opt.animation][i]=step;}}_opt.type=type[''+_opt.type]?_opt.type:_def.type;_orig=link.getIcon();_canvas=document.createElement('canvas');_img=document.createElement('img');if(_orig.hasAttribute('href')){_img.setAttribute('crossOrigin','anonymous');_img.onload=function(){_h=_img.height>0?_img.height:32;_w=_img.width>0?_img.width:32;_canvas.height=_h;_canvas.width=_w;_context=_canvas.getContext('2d');icon.ready();};_img.setAttribute('src',_orig.getAttribute('href'));}else{_img.onload=function(){_h=32;_w=32;_img.height=_h;_img.width=_w;_canvas.height=_h;_canvas.width=_w;_context=_canvas.getContext('2d');icon.ready();};_img.setAttribute('src','');}};var icon={};icon.ready=function(){_ready=true;icon.reset();_readyCb();};icon.reset=function(){if(!_ready){return;}_queue=[];_lastBadge=false;_running=false;_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);link.setIcon(_canvas);window.clearTimeout(_animTimeout);window.clearTimeout(_drawTimeout);};icon.start=function(){if(!_ready||_running){return;}var finished=function(){_lastBadge=_queue[0];_running=false;if(_queue.length>0){_queue.shift();icon.start();}};if(_queue.length>0){_running=true;var run=function(){['type','animation','bgColor','textColor','fontFamily','fontStyle'].forEach(function(a){if(a in _queue[0].options){_opt[a]=_queue[0].options[a];}});animation.run(_queue[0].options,function(){finished();},false);};if(_lastBadge){animation.run(_lastBadge.options,function(){run();},true);}else{run();}}};var type={};var options=function(opt){opt.n=typeof opt.n==='number'?Math.abs(opt.n|0):opt.n;opt.x=_w*opt.x;opt.y=_h*opt.y;opt.w=_w*opt.w;opt.h=_h*opt.h;opt.len=(""+opt.n).length;return opt;};type.circle=function(opt){opt=options(opt);var more=false;if(opt.len===2){opt.x=opt.x-opt.w*0.4;opt.w=opt.w*1.4;more=true;}else if(opt.len>=3){opt.x=opt.x-opt.w*0.65;opt.w=opt.w*1.65;more=true;}_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);_context.beginPath();_context.font=_opt.fontStyle+" "+Math.floor(opt.h*(opt.n>99?0.85:1))+"px "+_opt.fontFamily;_context.textAlign='center';if(more){_context.moveTo(opt.x+opt.w/2,opt.y);_context.lineTo(opt.x+opt.w-opt.h/2,opt.y);_context.quadraticCurveTo(opt.x+opt.w,opt.y,opt.x+opt.w,opt.y+opt.h/2);_context.lineTo(opt.x+opt.w,opt.y+opt.h-opt.h/2);_context.quadraticCurveTo(opt.x+opt.w,opt.y+opt.h,opt.x+opt.w-opt.h/2,opt.y+opt.h);_context.lineTo(opt.x+opt.h/2,opt.y+opt.h);_context.quadraticCurveTo(opt.x,opt.y+opt.h,opt.x,opt.y+opt.h-opt.h/2);_context.lineTo(opt.x,opt.y+opt.h/2);_context.quadraticCurveTo(opt.x,opt.y,opt.x+opt.h/2,opt.y);}else{_context.arc(opt.x+opt.w/2,opt.y+opt.h/2,opt.h/2,0,2*Math.PI);}_context.fillStyle='rgba('+_opt.bgColor.r+','+_opt.bgColor.g+','+_opt.bgColor.b+','+opt.o+')';_context.fill();_context.closePath();_context.beginPath();_context.stroke();_context.fillStyle='rgba('+_opt.textColor.r+','+_opt.textColor.g+','+_opt.textColor.b+','+opt.o+')';if(typeof opt.n==='number'&&opt.n>999){_context.fillText((opt.n>9999?9:Math.floor(opt.n/1000))+'k+',Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.2));}else{_context.fillText(opt.n,Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.15));}_context.closePath();};type.rectangle=function(opt){opt=options(opt);if(opt.len===2){opt.x=opt.x-opt.w*0.4;opt.w=opt.w*1.4;}else if(opt.len>=3){opt.x=opt.x-opt.w*0.65;opt.w=opt.w*1.65;}_context.clearRect(0,0,_w,_h);_context.drawImage(_img,0,0,_w,_h);_context.beginPath();_context.font=_opt.fontStyle+" "+Math.floor(opt.h*(opt.n>99?0.9:1))+"px "+_opt.fontFamily;_context.textAlign='center';_context.fillStyle='rgba('+_opt.bgColor.r+','+_opt.bgColor.g+','+_opt.bgColor.b+','+opt.o+')';_context.fillRect(opt.x,opt.y,opt.w,opt.h);_context.fillStyle='rgba('+_opt.textColor.r+','+_opt.textColor.g+','+_opt.textColor.b+','+opt.o+')';if(typeof opt.n==='number'&&opt.n>999){_context.fillText((opt.n>9999?9:Math.floor(opt.n/1000))+'k+',Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.2));}else{_context.fillText(opt.n,Math.floor(opt.x+opt.w/2),Math.floor(opt.y+opt.h-opt.h*0.15));}_context.closePath();};var badge=function(number,opts){opts=(typeof opts==='string'?{animation:opts}:opts)||{};_readyCb=function(){try{if(typeof number==='number'?number>0:number!==''){var q={type:'badge',options:{n:number}};if('animation'in opts&&animation.types[''+opts.animation]){q.options.animation=''+opts.animation;}if('type'in opts&&type[''+opts.type]){q.options.type=''+opts.type;}['bgColor','textColor'].forEach(function(o){if(o in opts){q.options[o]=hexToRgb(opts[o]);}});['fontStyle','fontFamily'].forEach(function(o){if(o in opts){q.options[o]=opts[o];}});_queue.push(q);if(_queue.length>100){throw new Error('Too many badges requests in queue.');}icon.start();}else{icon.reset();}}catch(e){throw new Error('Error setting badge. Message: '+e.message);}};if(_ready){_readyCb();}};var image=function(imageElement){_readyCb=function(){try{var w=imageElement.width;var h=imageElement.height;var newImg=document.createElement('img');var ratio=w/_w<h/_h?w/_w:h/_h;newImg.setAttribute('crossOrigin','anonymous');newImg.onload=function(){_context.clearRect(0,0,_w,_h);_context.drawImage(newImg,0,0,_w,_h);link.setIcon(_canvas);};newImg.setAttribute('src',imageElement.getAttribute('src'));newImg.height=h/ratio;newImg.width=w/ratio;}catch(e){throw new Error('Error setting image. Message: '+e.message);}};if(_ready){_readyCb();}};var video=function(videoElement){_readyCb=function(){try{if(videoElement==='stop'){_stop=true;icon.reset();_stop=false;return;}videoElement.addEventListener('play',function(){drawVideo(this);},false);}catch(e){throw new Error('Error setting video. Message: '+e.message);}};if(_ready){_readyCb();}};var webcam=function(action){if(!window.URL||!window.URL.createObjectURL){window.URL=window.URL||{};window.URL.createObjectURL=function(obj){return obj;};}if(_browser.supported){var newVideo=false;navigator.getUserMedia=navigator.getUserMedia||navigator.oGetUserMedia||navigator.msGetUserMedia||navigator.mozGetUserMedia||navigator.webkitGetUserMedia;_readyCb=function(){try{if(action==='stop'){_stop=true;icon.reset();_stop=false;return;}newVideo=document.createElement('video');newVideo.width=_w;newVideo.height=_h;navigator.getUserMedia({video:true,audio:false},function(stream){newVideo.src=URL.createObjectURL(stream);newVideo.play();drawVideo(newVideo);},function(){});}catch(e){throw new Error('Error setting webcam. Message: '+e.message);}};if(_ready){_readyCb();}}};function drawVideo(video){if(video.paused||video.ended||_stop){return false;}try{_context.clearRect(0,0,_w,_h);_context.drawImage(video,0,0,_w,_h);}catch(e){}_drawTimeout=setTimeout(function(){drawVideo(video);},animation.duration);link.setIcon(_canvas);}var link={};link.getIcon=function(){var elm=false;var getLink=function(){var link=_doc.getElementsByTagName('head')[0].getElementsByTagName('link');for(var l=link.length,i=l-1;i>=0;i--){if(/(^|\s)icon(\s|$)/i.test(link[i].getAttribute('rel'))){return link[i];}}return false;};if(_opt.element){elm=_opt.element;}else if(_opt.elementId){elm=_doc.getElementById(_opt.elementId);elm.setAttribute('href',elm.getAttribute('src'));}else{elm=getLink();if(elm===false){elm=_doc.createElement('link');elm.setAttribute('rel','icon');_doc.getElementsByTagName('head')[0].appendChild(elm);}}elm.setAttribute('type','image/png');return elm;};link.setIcon=function(canvas){var url=canvas.toDataURL('image/png');if(_opt.dataUrl){_opt.dataUrl(url);}if(_opt.element){_opt.element.setAttribute('href',url);_opt.element.setAttribute('src',url);}else if(_opt.elementId){var elm=_doc.getElementById(_opt.elementId);elm.setAttribute('href',url);elm.setAttribute('src',url);}else{if(_browser.ff||_browser.opera){var old=_orig;_orig=_doc.createElement('link');if(_browser.opera){_orig.setAttribute('rel','icon');}_orig.setAttribute('rel','icon');_orig.setAttribute('type','image/png');_doc.getElementsByTagName('head')[0].appendChild(_orig);_orig.setAttribute('href',url);if(old.parentNode){old.parentNode.removeChild(old);}}else{_orig.setAttribute('href',url);}}};function hexToRgb(hex){hex=hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,function(m,r,g,b){return r+r+g+g+b+b;});var result=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);return result?{r:parseInt(result[1],16),g:parseInt(result[2],16),b:parseInt(result[3],16)}:false;}function merge(def,opt){var mergedOpt={};for(var attrname in def){mergedOpt[attrname]=def[attrname];}for(attrname in opt){mergedOpt[attrname]=opt[attrname];}return mergedOpt;}function isPageHidden(){return _doc.hidden||_doc.msHidden||_doc.webkitHidden||_doc.mozHidden;}var animation={};animation.duration=40;animation.types={};animation.types.fade=[{x:0.4,y:0.4,w:0.6,h:0.6,o:0.0},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.1},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.2},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.3},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.4},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.5},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.6},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.7},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.8},{x:0.4,y:0.4,w:0.6,h:0.6,o:0.9},{x:0.4,y:0.4,w:0.6,h:0.6,o:1.0}];animation.types.none=[{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.pop=[{x:1,y:1,w:0,h:0,o:1},{x:0.9,y:0.9,w:0.1,h:0.1,o:1},{x:0.8,y:0.8,w:0.2,h:0.2,o:1},{x:0.7,y:0.7,w:0.3,h:0.3,o:1},{x:0.6,y:0.6,w:0.4,h:0.4,o:1},{x:0.5,y:0.5,w:0.5,h:0.5,o:1},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.popFade=[{x:0.75,y:0.75,w:0,h:0,o:0},{x:0.65,y:0.65,w:0.1,h:0.1,o:0.2},{x:0.6,y:0.6,w:0.2,h:0.2,o:0.4},{x:0.55,y:0.55,w:0.3,h:0.3,o:0.6},{x:0.50,y:0.50,w:0.4,h:0.4,o:0.8},{x:0.45,y:0.45,w:0.5,h:0.5,o:0.9},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.types.slide=[{x:0.4,y:1,w:0.6,h:0.6,o:1},{x:0.4,y:0.9,w:0.6,h:0.6,o:1},{x:0.4,y:0.9,w:0.6,h:0.6,o:1},{x:0.4,y:0.8,w:0.6,h:0.6,o:1},{x:0.4,y:0.7,w:0.6,h:0.6,o:1},{x:0.4,y:0.6,w:0.6,h:0.6,o:1},{x:0.4,y:0.5,w:0.6,h:0.6,o:1},{x:0.4,y:0.4,w:0.6,h:0.6,o:1}];animation.run=function(opt,cb,revert,step){var animationType=animation.types[isPageHidden()?'none':_opt.animation];if(revert===true){step=typeof step!=='undefined'?step:animationType.length-1;}else{step=typeof step!=='undefined'?step:0;}cb=cb?cb:function(){};if(step<animationType.length&&step>=0){type[_opt.type](merge(opt,animationType[step]));_animTimeout=setTimeout(function(){if(revert){step=step-1;}else{step=step+1;}animation.run(opt,cb,revert,step);},animation.duration);link.setIcon(_canvas);}else{cb();}};init();return{badge:badge,video:video,image:image,webcam:webcam,reset:icon.reset,browser:{supported:_browser.supported}};};if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Favico;}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else {}})();

/***/ }),
/* 108 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAHQElEQVRYR8WXe1BU9xXHP5dld+WxLoKKSEAeGgxqFIVRjAn4BBIVUkzBOoUqDJmojYIZtT7qI2k6VVGZBGOtWlNMpz5wTBFfqIAtAg6klVGCCvHFQ1ieA8qyC3s7966A6JpabZLz1+7vnnvO957f95zf9yfwE5sg5a8RRbGp5cdHMkALMoDSZlFsbmh/cQSCFQprBV2dXSCa+sRRqtTY2gkIVgKGDpGHbfqe5w5ONmYA1xpNYktT74P/FYmVQoG+/SEOjlpUaoHOTpGOdhGlSkB3v5b0r/bSWK9j5uxIJr71Jm0t5lzaAf1eHoC9th/nT2SwOSmOQUNewW/iZPwmvcVY/0mIJpFFEcGorTpxdnbmctE3rN+6h/cWxssg/i8ApDIujoqgtvoewaEh5F3I5m5FGQaDASuFEt+RI8i7lI9CoSB521Z+s24D567UYGNnj7294uU4oFAqMXboCRnnwqpPU4n7MIbGRmiqb6b63g2S4n7B7FnB/HHPXrnkN2/c4FUfH47nlePm6Y2N7SMSvigHbO37UXAxh8VRM8kovMXgIa4YDR1IwAY5K9i9bRc7fvtrzmfn4OHhSUL8Ir6tqCT94hU6jaDpr3w5DgwY2I/NScsoupTLkZx/92G4REylUsHmjxLIOPSl/NtpsCufHczAy8eX9gcvyAEpsEJhLTNcYnzIuOHMjVpI0qa16O4bMHV19TSRVAm1WsH1q9dobW1m5Khx2GnseNCmx0p4rAv+2xzo7mUpcltbF80NOpoadXx3/VvWLI5m484/Exg0HTv7AWgd7bESRPR6gY5282xR29igUIh0dQkYDb0g+8wBKbDEym4zGkEUQaWCu7cqyT17gpyzGdwsLaGtpRHELqwEAZVKjbGzE4OxExs7DV4+owgMmsm0sAhGjhmFSZpNIggCNDe2YG1tzQAnO/lDerqgQi+KNffaOHRgFwW5WTg4DuS92PcZNNiZ1C0byTl9HEetPUFBwQQFB+PrO4phHh5oNBoEQeBBWxu6+nquXb3KxdwccnKyuXWnkjH+gSxb+ykarQPJG1dSUpyPtbWSaW+/y4oNWxnqrjWTsKSuXYwMmkhT7V3CIyKoq60lI/OUXIzAiQGsWr2G0LAwVFI5ntMK8vPZsT2Zo8eOI4omZs2YRmLSCmru32fD+nVoBrnxdV6BGUDc8g3imcO7uVp6Ha1WS3R0NFlZWaSmfk509PznTGnZLf/SJRISElBYW5ObmyvH1+l0uLo4k/zlaTOA4b5+4pK4BSxLTCIyMpIL589TVFyMt7d3b9QbpXDkEEzwh9A5lrPdqYBj6eDnB8Eze3zaHz4kJDSUiooKysrK5K2bGDCeCdMjzQD8Jk0VZ08PZPKUNwkLC6OkpITRo0f3JqmrgdfHINQ1ymviuVMwLaQviEYdjB+HcLfG7HPhTB8QRqMRNzc3wsPD2bF9O06ODvxh3wkzgJS0THHlorkyi+Pj49myZUvf4MUFCAGTe9bE32+CVev7+vzrMsKESb0+H6+HtZv6+Jw5c4Y5c+bg5TEMoZ+WjPwiM4AqURRXxC/nb/tS5DJ5eXn1DW7Qwy/nw+Hj4DsCTp0Gdws+P4+Er0+CpxuczYLhPk9tlcuQwTgM8WTP4ZO4DnMyA7hnMomZ6TmsiouguroaG1tby3ss8cBtGNjYPZuYV4rBwxO0jhZ9Aib4yXu/8uN1dLQ/Ooxud5rEk+kXSIx5m8rKKpycnF6K+d/38shXRxAcEcuyNetkN7kCNx+YxNsVOmaNdeHokUO8+7PIHwTA3Tt38PD05E/H/kHAG2+gVD6mCaWMy3+1gNtXC7l+s9wigJ07dzJlyhT8/f0tPm9paSE1NZUlS5bI/f6kLZgfRU5+MScKrmPo6KK/g6r3ONa3m2TdFjLenQ/ej+ezz1OfChAbG0taWhpRUVHMmDEDby8vlCoVdXV1FBYWcuDAATlxUVGR3OuP28GDacTExLInPZtJQUGWJZmk0fKyc0mInEp83CJ2fbFbPjwet8zMTPbv3y/PitbWVkwmkzyi3d3dmTdvHkuXLn1qZKekpJCYmEjShmTiE5PoVuAWNaG0ePmfeXwYE4Gzo4ZtyTuYGx5useR6vV4+/6WukQ6lJ624uJhVKz/iQnYuG3fsI2rRQpoaDD3SvQfAk3pA42BDQ10DKZ+s5vhf9zPC25OY2BjeeWcOr/n6olarLQKSqlFRXs658+f4Ku0v5OUXEjBlBqt/t5PXxo7q+fLul7/3XiCJEDuNFTdLb3A0bS9Zfz9MfW0Vjg79cXUdiovLUJwGDpQ1gUS+qqpKKquq0dU3YqtxYPLUUKIXfsD4wEC6OpEl2JP2XLJcUjOSen3QauJWeSllJd/wXXkZ1ffu0NLUIMe0te/PK+4euHkMx2f0WEaMfF3W/JKoefwm9EIAul+SRaZKhUoNikfCSbp4dJt09ZL+GwzQoTf20YbPGirP5MAPMoUsBO3hwE95O/4PY9MuHly+U4UAAAAASUVORK5CYII="

/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/lodash-es/_root.js
var _root = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/lodash-es/now.js
var now=function(){return _root["a" /* default */].Date.now();};/* harmony default export */ var lodash_es_now = (now);
// EXTERNAL MODULE: ./node_modules/lodash-es/toNumber.js + 2 modules
var toNumber = __webpack_require__(38);

// CONCATENATED MODULE: ./node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT='Expected a function';var nativeMax=Math.max,nativeMin=Math.min;function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=Object(toNumber["a" /* default */])(wait)||0;if(Object(isObject["a" /* default */])(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(Object(toNumber["a" /* default */])(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){lastInvokeTime=time;timerId=setTimeout(timerExpired,wait);return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=lodash_es_now();if(shouldInvoke(time)){return trailingEdge(time);}timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(lodash_es_now());}function debounced(){var time=lodash_es_now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/* harmony default export */ var lodash_es_debounce = __webpack_exports__["a"] = (debounce);

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports=function(module){if(!module.webpackPolyfill){module.deprecate=function(){};module.paths=[];if(!module.children)module.children=[];Object.defineProperty(module,"loaded",{enumerable:true,get:function(){return module.l;}});Object.defineProperty(module,"id",{enumerable:true,get:function(){return module.i;}});module.webpackPolyfill=1;}return module;};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
const peq=new Uint32Array(0x10000);const myers_32=(a,b)=>{const n=a.length;const m=b.length;const lst=1<<n-1;let pv=-1;let mv=0;let sc=n;let i=n;while(i--){peq[a.charCodeAt(i)]|=1<<i;}for(i=0;i<m;i++){let eq=peq[b.charCodeAt(i)];const xv=eq|mv;eq|=(eq&pv)+pv^pv;mv|=~(eq|pv);pv&=eq;if(mv&lst){sc++;}if(pv&lst){sc--;}mv=mv<<1|1;pv=pv<<1|~(xv|mv);mv&=xv;}i=n;while(i--){peq[a.charCodeAt(i)]=0;}return sc;};const myers_x=(a,b)=>{const n=a.length;const m=b.length;const mhc=[];const phc=[];const hsize=Math.ceil(n/32);const vsize=Math.ceil(m/32);let score=m;for(let i=0;i<hsize;i++){phc[i]=-1;mhc[i]=0;}let j=0;for(;j<vsize-1;j++){let mv=0;let pv=-1;const start=j*32;const end=Math.min(32,m)+start;for(let k=start;k<end;k++){peq[b.charCodeAt(k)]|=1<<k;}score=m;for(let i=0;i<n;i++){const eq=peq[a.charCodeAt(i)];const pb=phc[i/32|0]>>>i&1;const mb=mhc[i/32|0]>>>i&1;const xv=eq|mv;const xh=((eq|mb)&pv)+pv^pv|eq|mb;let ph=mv|~(xh|pv);let mh=pv&xh;if(ph>>>31^pb){phc[i/32|0]^=1<<i;}if(mh>>>31^mb){mhc[i/32|0]^=1<<i;}ph=ph<<1|pb;mh=mh<<1|mb;pv=mh|~(xv|ph);mv=ph&xv;}for(let k=start;k<end;k++){peq[b.charCodeAt(k)]=0;}}let mv=0;let pv=-1;const start=j*32;const end=Math.min(32,m-start)+start;for(let k=start;k<end;k++){peq[b.charCodeAt(k)]|=1<<k;}score=m;for(let i=0;i<n;i++){const eq=peq[a.charCodeAt(i)];const pb=phc[i/32|0]>>>i&1;const mb=mhc[i/32|0]>>>i&1;const xv=eq|mv;const xh=((eq|mb)&pv)+pv^pv|eq|mb;let ph=mv|~(xh|pv);let mh=pv&xh;score+=ph>>>m-1&1;score-=mh>>>m-1&1;if(ph>>>31^pb){phc[i/32|0]^=1<<i;}if(mh>>>31^mb){mhc[i/32|0]^=1<<i;}ph=ph<<1|pb;mh=mh<<1|mb;pv=mh|~(xv|ph);mv=ph&xv;}for(let k=start;k<end;k++){peq[b.charCodeAt(k)]=0;}return score;};const distance=(a,b)=>{if(a.length>b.length){const tmp=b;b=a;a=tmp;}if(a.length===0){return b.length;}if(a.length<=32){return myers_32(a,b);}return myers_x(a,b);};const closest=(str,arr)=>{let min_distance=Infinity;let min_index=0;for(let i=0;i<arr.length;i++){const dist=distance(str,arr[i]);if(dist<min_distance){min_distance=dist;min_index=i;}}return arr[min_index];};module.exports={closest,distance};

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 113 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,n){ true?module.exports=n(__webpack_require__(27)):undefined;}(this,function(e){"use strict";function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e};}var t=n(e),a={s:"ein paar Sekunden",m:["eine Minute","einer Minute"],mm:"%d Minuten",h:["eine Stunde","einer Stunde"],hh:"%d Stunden",d:["ein Tag","einem Tag"],dd:["%d Tage","%d Tagen"],M:["ein Monat","einem Monat"],MM:["%d Monate","%d Monaten"],y:["ein Jahr","einem Jahr"],yy:["%d Jahre","%d Jahren"]};function i(e,n,t){var i=a[t];return Array.isArray(i)&&(i=i[n?0:1]),i.replace("%d",e);}var r={name:"de",weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),months:"Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan_Feb_März_Apr_Mai_Juni_Juli_Aug_Sept_Okt_Nov_Dez".split("_"),ordinal:function(e){return e+".";},weekStart:1,yearStart:4,formats:{LTS:"HH:mm:ss",LT:"HH:mm",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},relativeTime:{future:"in %s",past:"vor %s",s:i,m:i,mm:i,h:i,hh:i,d:i,dd:i,M:i,MM:i,y:i,yy:i}};return t.default.locale(r,null,!0),r;});

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,_){ true?module.exports=_(__webpack_require__(27)):undefined;}(this,function(e){"use strict";function _(e){return e&&"object"==typeof e&&"default"in e?e:{default:e};}var t=_(e),d={name:"el",weekdays:"Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"),weekdaysShort:"Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"),weekdaysMin:"Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"),months:"Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"),monthsShort:"Ιαν_Φεβ_Μαρ_Απρ_Μαι_Ιουν_Ιουλ_Αυγ_Σεπτ_Οκτ_Νοε_Δεκ".split("_"),ordinal:function(e){return e;},weekStart:1,relativeTime:{future:"σε %s",past:"πριν %s",s:"μερικά δευτερόλεπτα",m:"ένα λεπτό",mm:"%d λεπτά",h:"μία ώρα",hh:"%d ώρες",d:"μία μέρα",dd:"%d μέρες",M:"ένα μήνα",MM:"%d μήνες",y:"ένα χρόνο",yy:"%d χρόνια"},formats:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"}};return t.default.locale(d,null,!0),d;});

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,o){ true?module.exports=o(__webpack_require__(27)):undefined;}(this,function(e){"use strict";function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e};}var s=o(e),d={name:"es",monthsShort:"ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),weekdays:"domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),weekdaysShort:"dom._lun._mar._mié._jue._vie._sáb.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_sá".split("_"),months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),weekStart:1,formats:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un día",dd:"%d días",M:"un mes",MM:"%d meses",y:"un año",yy:"%d años"},ordinal:function(e){return e+"º";}};return s.default.locale(d,null,!0),d;});

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

!function(Y,M){ true?module.exports=M(__webpack_require__(27)):undefined;}(this,function(Y){"use strict";function M(Y){return Y&&"object"==typeof Y&&"default"in Y?Y:{default:Y};}var d=M(Y),e={s:"מספר שניות",ss:"%d שניות",m:"דקה",mm:"%d דקות",h:"שעה",hh:"%d שעות",hh2:"שעתיים",d:"יום",dd:"%d ימים",dd2:"יומיים",M:"חודש",MM:"%d חודשים",MM2:"חודשיים",y:"שנה",yy:"%d שנים",yy2:"שנתיים"};function _(Y,M,d){return(e[d+(2===Y?"2":"")]||e[d]).replace("%d",Y);}var l={name:"he",weekdays:"ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"),weekdaysShort:"א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"),weekdaysMin:"א׳_ב׳_ג׳_ד׳_ה׳_ו_ש׳".split("_"),months:"ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"),monthsShort:"ינו_פבר_מרץ_אפר_מאי_יונ_יול_אוג_ספט_אוק_נוב_דצמ".split("_"),relativeTime:{future:"בעוד %s",past:"לפני %s",s:_,m:_,mm:_,h:_,hh:_,d:_,dd:_,M:_,MM:_,y:_,yy:_},ordinal:function(Y){return Y;},format:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [ב]MMMM YYYY",LLL:"D [ב]MMMM YYYY HH:mm",LLLL:"dddd, D [ב]MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [ב]MMMM YYYY",LLL:"D [ב]MMMM YYYY HH:mm",LLLL:"dddd, D [ב]MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"}};return d.default.locale(l,null,!0),l;});

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,o){ true?module.exports=o(__webpack_require__(27)):undefined;}(this,function(e){"use strict";function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e};}var t=o(e),n={name:"it",weekdays:"domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),weekStart:1,monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},relativeTime:{future:"tra %s",past:"%s fa",s:"qualche secondo",m:"un minuto",mm:"%d minuti",h:"un' ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},ordinal:function(e){return e+"º";}};return t.default.locale(n,null,!0),n;});

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,a){ true?module.exports=a(__webpack_require__(27)):undefined;}(this,function(e){"use strict";function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e};}var n=a(e),d={name:"nl",weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),ordinal:function(e){return e+".";},weekStart:1,yearStart:4,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",m:"een minuut",mm:"%d minuten",h:"een uur",hh:"%d uur",d:"een dag",dd:"%d dagen",M:"een maand",MM:"%d maanden",y:"een jaar",yy:"%d jaar"}};return n.default.locale(d,null,!0),d;});

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(27)):undefined;}(this,function(e){"use strict";function t(e){return e&&"object"==typeof e&&"default"in e?e:{default:e};}var i=t(e);function a(e){return e%10<5&&e%10>1&&~~(e/10)%10!=1;}function n(e,t,i){var n=e+" ";switch(i){case"m":return t?"minuta":"minutę";case"mm":return n+(a(e)?"minuty":"minut");case"h":return t?"godzina":"godzinę";case"hh":return n+(a(e)?"godziny":"godzin");case"MM":return n+(a(e)?"miesiące":"miesięcy");case"yy":return n+(a(e)?"lata":"lat");}}var r="stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_"),_="styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"),d=function(e,t){return /D MMMM/.test(t)?r[e.month()]:_[e.month()];};d.s=_,d.f=r;var o={name:"pl",weekdays:"niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"),weekdaysShort:"ndz_pon_wt_śr_czw_pt_sob".split("_"),weekdaysMin:"Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"),months:d,monthsShort:"sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"),ordinal:function(e){return e+".";},weekStart:1,yearStart:4,relativeTime:{future:"za %s",past:"%s temu",s:"kilka sekund",m:n,mm:n,h:n,hh:n,d:"1 dzień",dd:"%d dni",M:"miesiąc",MM:n,y:"rok",yy:n},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"}};return i.default.locale(o,null,!0),o;});

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,o){ true?module.exports=o(__webpack_require__(27)):undefined;}(this,function(e){"use strict";function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e};}var t=o(e),_={name:"pt-br",weekdays:"Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"),weekdaysMin:"Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"),months:"Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),ordinal:function(e){return e+"º";},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [às] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [às] HH:mm"},relativeTime:{future:"em %s",past:"há %s",s:"poucos segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um mês",MM:"%d meses",y:"um ano",yy:"%d anos"}};return t.default.locale(_,null,!0),_;});

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,a){ true?module.exports=a(__webpack_require__(27)):undefined;}(this,function(e){"use strict";function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e};}var o=a(e),t={name:"pt",weekdays:"Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_Sab".split("_"),weekdaysMin:"Do_2ª_3ª_4ª_5ª_6ª_Sa".split("_"),months:"Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),ordinal:function(e){return e+"º";},weekStart:1,yearStart:4,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [às] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [às] HH:mm"},relativeTime:{future:"em %s",past:"há %s",s:"alguns segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um mês",MM:"%d meses",y:"um ano",yy:"%d anos"}};return o.default.locale(t,null,!0),t;});

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

!function(r,e){ true?module.exports=e():undefined;}(this,function(){"use strict";return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o);}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break;}}if(n)return a;var M=s?l.future:l.past;return"function"==typeof M?M(a):M.replace("%s",a);},n.to=function(r,e){return i(r,e,this,!0);},n.from=function(r,e){return i(r,e,this);};var d=function(r){return r.$u?t.utc():t();};n.toNow=function(r){return this.to(d(this),r);},n.fromNow=function(r){return this.from(d(this),r);};};});

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():undefined;}(this,function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,o,n){var r=o.prototype,i=r.format;n.en.formats=e,r.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var o=this.$locale().formats,n=function(t,o){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,function(t,n,r){var i=r&&r.toUpperCase();return n||o[r]||e[r]||o[i].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,function(e,t,o){return t||o.slice(1);});});}(t,void 0===o?{}:o);return i.call(this,n);};};});

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

const compare=__webpack_require__(97);const gt=(a,b,loose)=>compare(a,b,loose)>0;module.exports=gt;

/***/ }),
/* 126 */
/***/ (function(module, exports) {

const numeric=/^[0-9]+$/;const compareIdentifiers=(a,b)=>{const anum=numeric.test(a);const bnum=numeric.test(b);if(anum&&bnum){a=+a;b=+b;}return a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1;};const rcompareIdentifiers=(a,b)=>compareIdentifiers(b,a);module.exports={compareIdentifiers,rcompareIdentifiers};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

const parse=__webpack_require__(128);const eq=__webpack_require__(129);const diff=(version1,version2)=>{if(eq(version1,version2)){return null;}else{const v1=parse(version1);const v2=parse(version2);const hasPre=v1.prerelease.length||v2.prerelease.length;const prefix=hasPre?'pre':'';const defaultResult=hasPre?'prerelease':'';for(const key in v1){if(key==='major'||key==='minor'||key==='patch'){if(v1[key]!==v2[key]){return prefix+key;}}}return defaultResult;}};module.exports=diff;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

const{MAX_LENGTH}=__webpack_require__(95);const{re,t}=__webpack_require__(100);const SemVer=__webpack_require__(98);const parseOptions=__webpack_require__(101);const parse=(version,options)=>{options=parseOptions(options);if(version instanceof SemVer){return version;}if(typeof version!=='string'){return null;}if(version.length>MAX_LENGTH){return null;}const r=options.loose?re[t.LOOSE]:re[t.FULL];if(!r.test(version)){return null;}try{return new SemVer(version,options);}catch(er){return null;}};module.exports=parse;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

const compare=__webpack_require__(97);const eq=(a,b,loose)=>compare(a,b,loose)===0;module.exports=eq;

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// NAMESPACE OBJECT: ./lib/utils/string.js
var string_namespaceObject = {};
__webpack_require__.r(string_namespaceObject);
__webpack_require__.d(string_namespaceObject, "encode", function() { return encode; });
__webpack_require__.d(string_namespaceObject, "escape", function() { return string_escape; });
__webpack_require__.d(string_namespaceObject, "safe", function() { return safe; });
__webpack_require__.d(string_namespaceObject, "areSimilar", function() { return areSimilar; });
__webpack_require__.d(string_namespaceObject, "regexRegex", function() { return regexRegex; });
__webpack_require__.d(string_namespaceObject, "html", function() { return string_html; });
__webpack_require__.d(string_namespaceObject, "_html", function() { return _html; });

// NAMESPACE OBJECT: ./lib/environment/foreground/context.js
var context_namespaceObject = {};
__webpack_require__.r(context_namespaceObject);
__webpack_require__.d(context_namespaceObject, "data", function() { return context_data; });
__webpack_require__.d(context_namespaceObject, "retrieveFromParent", function() { return retrieveFromParent; });

// NAMESPACE OBJECT: ./lib/environment/foreground/messaging.js
var foreground_messaging_namespaceObject = {};
__webpack_require__.r(foreground_messaging_namespaceObject);
__webpack_require__.d(foreground_messaging_namespaceObject, "sendMessage", function() { return sendMessage; });
__webpack_require__.d(foreground_messaging_namespaceObject, "addListener", function() { return addListener; });

// NAMESPACE OBJECT: ./lib/environment/foreground/privateBrowsing.js
var privateBrowsing_namespaceObject = {};
__webpack_require__.r(privateBrowsing_namespaceObject);
__webpack_require__.d(privateBrowsing_namespaceObject, "isPrivateBrowsing", function() { return isPrivateBrowsing; });

// NAMESPACE OBJECT: ./lib/environment/foreground/history.js
var history_namespaceObject = {};
__webpack_require__.r(history_namespaceObject);
__webpack_require__.d(history_namespaceObject, "addURLToHistory", function() { return addURLToHistory; });
__webpack_require__.d(history_namespaceObject, "isURLVisited", function() { return isURLVisited; });

// NAMESPACE OBJECT: ./lib/environment/foreground/xhrCache.js
var xhrCache_namespaceObject = {};
__webpack_require__.r(xhrCache_namespaceObject);
__webpack_require__.d(xhrCache_namespaceObject, "set", function() { return xhrCache_set; });
__webpack_require__.d(xhrCache_namespaceObject, "check", function() { return xhrCache_check; });
__webpack_require__.d(xhrCache_namespaceObject, "delete", function() { return delete_; });
__webpack_require__.d(xhrCache_namespaceObject, "clear", function() { return clear; });

// NAMESPACE OBJECT: ./lib/environment/foreground/ajax.js
var ajax_namespaceObject = {};
__webpack_require__.r(ajax_namespaceObject);
__webpack_require__.d(ajax_namespaceObject, "ajax", function() { return ajax; });

// NAMESPACE OBJECT: ./lib/environment/foreground/download.js
var download_namespaceObject = {};
__webpack_require__.r(download_namespaceObject);
__webpack_require__.d(download_namespaceObject, "download", function() { return download; });

// NAMESPACE OBJECT: ./lib/environment/foreground/id.js
var id_namespaceObject = {};
__webpack_require__.r(id_namespaceObject);
__webpack_require__.d(id_namespaceObject, "getExtensionId", function() { return getExtensionId; });
__webpack_require__.d(id_namespaceObject, "getURL", function() { return getURL; });
__webpack_require__.d(id_namespaceObject, "getOptionsURL", function() { return getOptionsURL; });
__webpack_require__.d(id_namespaceObject, "isOptionsPage", function() { return isOptionsPage; });

// NAMESPACE OBJECT: ./lib/environment/foreground/i18n.js
var i18n_namespaceObject = {};
__webpack_require__.r(i18n_namespaceObject);
__webpack_require__.d(i18n_namespaceObject, "locale", function() { return i18n_locale; });
__webpack_require__.d(i18n_namespaceObject, "_loadI18n", function() { return _loadI18n; });
__webpack_require__.d(i18n_namespaceObject, "i18n", function() { return i18n; });

// NAMESPACE OBJECT: ./lib/environment/foreground/loadScript.js
var loadScript_namespaceObject = {};
__webpack_require__.r(loadScript_namespaceObject);
__webpack_require__.d(loadScript_namespaceObject, "loadScript", function() { return loadScript; });

// NAMESPACE OBJECT: ./lib/environment/foreground/permissions.js
var permissions_namespaceObject = {};
__webpack_require__.r(permissions_namespaceObject);
__webpack_require__.d(permissions_namespaceObject, "has", function() { return permissions_has; });
__webpack_require__.d(permissions_namespaceObject, "request", function() { return request; });

// NAMESPACE OBJECT: ./lib/environment/foreground/auth.js
var auth_namespaceObject = {};
__webpack_require__.r(auth_namespaceObject);
__webpack_require__.d(auth_namespaceObject, "launchAuthFlow", function() { return launchAuthFlow; });

// NAMESPACE OBJECT: ./lib/environment/foreground/multicast.js
var multicast_namespaceObject = {};
__webpack_require__.r(multicast_namespaceObject);
__webpack_require__.d(multicast_namespaceObject, "multicast", function() { return multicast; });

// NAMESPACE OBJECT: ./lib/environment/foreground/tabs.js
var tabs_namespaceObject = {};
__webpack_require__.r(tabs_namespaceObject);
__webpack_require__.d(tabs_namespaceObject, "openNewTab", function() { return openNewTab; });
__webpack_require__.d(tabs_namespaceObject, "openNewTabs", function() { return openNewTabs; });

// NAMESPACE OBJECT: ./lib/environment/foreground/pageAction.js
var pageAction_namespaceObject = {};
__webpack_require__.r(pageAction_namespaceObject);
__webpack_require__.d(pageAction_namespaceObject, "onClick", function() { return pageAction_onClick; });
__webpack_require__.d(pageAction_namespaceObject, "show", function() { return show; });
__webpack_require__.d(pageAction_namespaceObject, "hide", function() { return pageAction_hide; });

// NAMESPACE OBJECT: ./lib/environment/foreground/session.js
var session_namespaceObject = {};
__webpack_require__.r(session_namespaceObject);
__webpack_require__.d(session_namespaceObject, "get", function() { return get; });
__webpack_require__.d(session_namespaceObject, "set", function() { return session_set; });
__webpack_require__.d(session_namespaceObject, "delete_", function() { return session_delete_; });
__webpack_require__.d(session_namespaceObject, "delete", function() { return session_delete_; });
__webpack_require__.d(session_namespaceObject, "has", function() { return session_has; });
__webpack_require__.d(session_namespaceObject, "clear", function() { return session_clear; });

// NAMESPACE OBJECT: ./lib/environment/foreground/storage.js
var storage_namespaceObject = {};
__webpack_require__.r(storage_namespaceObject);
__webpack_require__.d(storage_namespaceObject, "get", function() { return storage_get; });
__webpack_require__.d(storage_namespaceObject, "getAll", function() { return getAll; });
__webpack_require__.d(storage_namespaceObject, "getMultiple", function() { return getMultiple; });
__webpack_require__.d(storage_namespaceObject, "set", function() { return storage_set; });
__webpack_require__.d(storage_namespaceObject, "setMultiple", function() { return setMultiple; });
__webpack_require__.d(storage_namespaceObject, "delete", function() { return storage_delete_; });
__webpack_require__.d(storage_namespaceObject, "deleteMultiple", function() { return deleteMultiple; });
__webpack_require__.d(storage_namespaceObject, "has", function() { return storage_has; });
__webpack_require__.d(storage_namespaceObject, "keys", function() { return storage_keys; });
__webpack_require__.d(storage_namespaceObject, "clear", function() { return storage_clear; });
__webpack_require__.d(storage_namespaceObject, "wrap", function() { return wrap; });
__webpack_require__.d(storage_namespaceObject, "wrapPrefix", function() { return wrapPrefix; });
__webpack_require__.d(storage_namespaceObject, "wrapBlob", function() { return wrapBlob; });

// NAMESPACE OBJECT: ./lib/utils/bodyClasses.js
var bodyClasses_namespaceObject = {};
__webpack_require__.r(bodyClasses_namespaceObject);
__webpack_require__.d(bodyClasses_namespaceObject, "addMissing", function() { return addMissing; });
__webpack_require__.d(bodyClasses_namespaceObject, "add", function() { return bodyClasses_add; });
__webpack_require__.d(bodyClasses_namespaceObject, "remove", function() { return bodyClasses_remove; });
__webpack_require__.d(bodyClasses_namespaceObject, "toggle", function() { return bodyClasses_toggle; });

// NAMESPACE OBJECT: ./lib/utils/browserDetect.js
var browserDetect_namespaceObject = {};
__webpack_require__.r(browserDetect_namespaceObject);
__webpack_require__.d(browserDetect_namespaceObject, "browser", function() { return browser; });
__webpack_require__.d(browserDetect_namespaceObject, "version", function() { return version; });
__webpack_require__.d(browserDetect_namespaceObject, "OS", function() { return OS; });

// NAMESPACE OBJECT: ./lib/utils/createElement.js
var createElement_namespaceObject = {};
__webpack_require__.r(createElement_namespaceObject);
__webpack_require__.d(createElement_namespaceObject, "toggleButton", function() { return toggleButton; });
__webpack_require__.d(createElement_namespaceObject, "icon", function() { return createElement_icon; });
__webpack_require__.d(createElement_namespaceObject, "table", function() { return createElement_table; });
__webpack_require__.d(createElement_namespaceObject, "tabMenuItem", function() { return createElement_tabMenuItem; });
__webpack_require__.d(createElement_namespaceObject, "fancyToggleButton", function() { return fancyToggleButton; });
__webpack_require__.d(createElement_namespaceObject, "sidebarSubscribeButtonWrappers", function() { return sidebarSubscribeButtonWrappers; });

// NAMESPACE OBJECT: ./lib/utils/alert.js
var alert_namespaceObject = {};
__webpack_require__.r(alert_namespaceObject);
__webpack_require__.d(alert_namespaceObject, "open", function() { return alert_open; });
__webpack_require__.d(alert_namespaceObject, "makeButton", function() { return makeButton; });

// NAMESPACE OBJECT: ./lib/utils/selectedThing.js
var selectedThing_namespaceObject = {};
__webpack_require__.r(selectedThing_namespaceObject);
__webpack_require__.d(selectedThing_namespaceObject, "current", function() { return selectedThing_current; });
__webpack_require__.d(selectedThing_namespaceObject, "addListener", function() { return selectedThing_addListener; });
__webpack_require__.d(selectedThing_namespaceObject, "set", function() { return selectedThing_set; });
__webpack_require__.d(selectedThing_namespaceObject, "selectClosestInView", function() { return selectClosestInView; });
__webpack_require__.d(selectedThing_namespaceObject, "refresh", function() { return selectedThing_refresh; });
__webpack_require__.d(selectedThing_namespaceObject, "move", function() { return move; });
__webpack_require__.d(selectedThing_namespaceObject, "setScrollToSelectedThingOnLoad", function() { return setScrollToSelectedThingOnLoad; });

// NAMESPACE OBJECT: ./lib/utils/table.js
var table_namespaceObject = {};
__webpack_require__.r(table_namespaceObject);
__webpack_require__.d(table_namespaceObject, "RESTable", function() { return table_RESTable; });
__webpack_require__.d(table_namespaceObject, "sortByColumn", function() { return sortByColumn; });

// NAMESPACE OBJECT: ./lib/utils/caseBuilder.js
var caseBuilder_namespaceObject = {};
__webpack_require__.r(caseBuilder_namespaceObject);
__webpack_require__.d(caseBuilder_namespaceObject, "drawOptionBuilder", function() { return drawOptionBuilder; });
__webpack_require__.d(caseBuilder_namespaceObject, "drawBuilderBlock", function() { return drawBuilderBlock; });
__webpack_require__.d(caseBuilder_namespaceObject, "readBuilderItem", function() { return readBuilderItem; });
__webpack_require__.d(caseBuilder_namespaceObject, "readBuilderBlock", function() { return readBuilderBlock; });

// NAMESPACE OBJECT: ./lib/core/options/stage.js
var stage_namespaceObject = {};
__webpack_require__.r(stage_namespaceObject);
__webpack_require__.d(stage_namespaceObject, "add", function() { return stageOption; });
__webpack_require__.d(stage_namespaceObject, "commit", function() { return commitStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "reset", function() { return clearStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "isDirty", function() { return hasStagedOptions; });
__webpack_require__.d(stage_namespaceObject, "get", function() { return getStagedOptions; });

// NAMESPACE OBJECT: ./lib/core/options/table.js
var options_table_namespaceObject = {};
__webpack_require__.r(options_table_namespaceObject);
__webpack_require__.d(options_table_namespaceObject, "getMatchingValueOrAdd", function() { return getMatchingValueOrAdd; });

// NAMESPACE OBJECT: ./lib/modules/commandLine.js
var commandLine_namespaceObject = {};
__webpack_require__.r(commandLine_namespaceObject);
__webpack_require__.d(commandLine_namespaceObject, "module", function() { return commandLine_module; });
__webpack_require__.d(commandLine_namespaceObject, "open", function() { return commandLine_open; });
__webpack_require__.d(commandLine_namespaceObject, "toggle", function() { return commandLine_toggle; });
__webpack_require__.d(commandLine_namespaceObject, "registerCommand", function() { return registerCommand; });

// NAMESPACE OBJECT: ./lib/modules/newCommentCount.js
var newCommentCount_namespaceObject = {};
__webpack_require__.r(newCommentCount_namespaceObject);
__webpack_require__.d(newCommentCount_namespaceObject, "module", function() { return newCommentCount_module; });
__webpack_require__.d(newCommentCount_namespaceObject, "hasEntry", function() { return hasEntry; });
__webpack_require__.d(newCommentCount_namespaceObject, "getNewCount", function() { return getNewCount; });

// NAMESPACE OBJECT: ./lib/modules/showImages.js
var showImages_namespaceObject = {};
__webpack_require__.r(showImages_namespaceObject);
__webpack_require__.d(showImages_namespaceObject, "genericHosts", function() { return genericHosts; });
__webpack_require__.d(showImages_namespaceObject, "module", function() { return showImages_module; });
__webpack_require__.d(showImages_namespaceObject, "viewImagesButton", function() { return viewImagesButton; });
__webpack_require__.d(showImages_namespaceObject, "toggleThingExpandos", function() { return toggleThingExpandos; });
__webpack_require__.d(showImages_namespaceObject, "types", function() { return showImages_types; });
__webpack_require__.d(showImages_namespaceObject, "matchesTypes", function() { return matchesTypes; });
__webpack_require__.d(showImages_namespaceObject, "getLinkExpando", function() { return getLinkExpando; });
__webpack_require__.d(showImages_namespaceObject, "Media", function() { return showImages_Media; });
__webpack_require__.d(showImages_namespaceObject, "move", function() { return showImages_move; });
__webpack_require__.d(showImages_namespaceObject, "resize", function() { return resize; });

// NAMESPACE OBJECT: ./lib/modules/filteReddit.js
var filteReddit_namespaceObject = {};
__webpack_require__.r(filteReddit_namespaceObject);
__webpack_require__.d(filteReddit_namespaceObject, "module", function() { return filteReddit_module; });
__webpack_require__.d(filteReddit_namespaceObject, "defaultFilters", function() { return defaultFilters; });
__webpack_require__.d(filteReddit_namespaceObject, "filterlinePromise", function() { return filterlinePromise; });
__webpack_require__.d(filteReddit_namespaceObject, "ensureFilterlineVisible", function() { return ensureFilterlineVisible; });
__webpack_require__.d(filteReddit_namespaceObject, "listFilters", function() { return listFilters; });
__webpack_require__.d(filteReddit_namespaceObject, "addExternalFilter", function() { return addExternalFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "addOndemandCase", function() { return addOndemandCase; });
__webpack_require__.d(filteReddit_namespaceObject, "addCustomFilter", function() { return addCustomFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "updateCustomFilter", function() { return updateCustomFilter; });
__webpack_require__.d(filteReddit_namespaceObject, "saveFilterlineStateAsDefault", function() { return saveFilterlineStateAsDefault; });

// NAMESPACE OBJECT: ./lib/modules/userTagger.js
var userTagger_namespaceObject = {};
__webpack_require__.r(userTagger_namespaceObject);
__webpack_require__.d(userTagger_namespaceObject, "module", function() { return userTagger_module; });
__webpack_require__.d(userTagger_namespaceObject, "applyToUser", function() { return applyToUser; });
__webpack_require__.d(userTagger_namespaceObject, "tags", function() { return tags; });
__webpack_require__.d(userTagger_namespaceObject, "Tag", function() { return userTagger_Tag; });

// NAMESPACE OBJECT: ./lib/modules/filteReddit/postCases/index.js
var postCases_namespaceObject = {};
__webpack_require__.r(postCases_namespaceObject);
__webpack_require__.d(postCases_namespaceObject, "commentCount", function() { return CommentCount_CommentCount; });
__webpack_require__.d(postCases_namespaceObject, "newCommentCount", function() { return NewCommentCount_NewCommentCount; });
__webpack_require__.d(postCases_namespaceObject, "commentsOpened", function() { return CommentsOpened_CommentsOpened; });
__webpack_require__.d(postCases_namespaceObject, "domain", function() { return Domain_Domain; });
__webpack_require__.d(postCases_namespaceObject, "hasExpando", function() { return Expando_Expando; });
__webpack_require__.d(postCases_namespaceObject, "isLocked", function() { return IsLocked_IsLocked; });
__webpack_require__.d(postCases_namespaceObject, "isNSFW", function() { return IsNSFW_IsNSFW; });
__webpack_require__.d(postCases_namespaceObject, "isSpoiler", function() { return IsSpoiler_IsSpoiler; });
__webpack_require__.d(postCases_namespaceObject, "isVisited", function() { return IsVisited_IsVisited; });
__webpack_require__.d(postCases_namespaceObject, "linkFlair", function() { return LinkFlair_LinkFlair; });
__webpack_require__.d(postCases_namespaceObject, "postAfter", function() { return PostAfter_PostAfter; });
__webpack_require__.d(postCases_namespaceObject, "postAge", function() { return PostAge_PostAge; });
__webpack_require__.d(postCases_namespaceObject, "postTitle", function() { return PostTitle_PostTitle; });
__webpack_require__.d(postCases_namespaceObject, "postType", function() { return PostType_PostType; });
__webpack_require__.d(postCases_namespaceObject, "score", function() { return Score_Score; });
__webpack_require__.d(postCases_namespaceObject, "selector", function() { return Selector_Selector; });
__webpack_require__.d(postCases_namespaceObject, "subreddit", function() { return Subreddit_Subreddit; });
__webpack_require__.d(postCases_namespaceObject, "userAttr", function() { return UserAttr_UserAttr; });
__webpack_require__.d(postCases_namespaceObject, "userFlair", function() { return UserFlair_UserFlair; });
__webpack_require__.d(postCases_namespaceObject, "userTag", function() { return UserTag_UserTag; });
__webpack_require__.d(postCases_namespaceObject, "userVoteWeight", function() { return UserVoteWeight_UserVoteWeight; });
__webpack_require__.d(postCases_namespaceObject, "username", function() { return Username_Username; });
__webpack_require__.d(postCases_namespaceObject, "voteType", function() { return VoteType_VoteType; });

// NAMESPACE OBJECT: ./lib/modules/readComments.js
var readComments_namespaceObject = {};
__webpack_require__.r(readComments_namespaceObject);
__webpack_require__.d(readComments_namespaceObject, "module", function() { return readComments_module; });
__webpack_require__.d(readComments_namespaceObject, "add", function() { return readComments_add; });
__webpack_require__.d(readComments_namespaceObject, "isRead", function() { return isRead; });

// NAMESPACE OBJECT: ./lib/modules/filteReddit/commentCases/index.js
var commentCases_namespaceObject = {};
__webpack_require__.r(commentCases_namespaceObject);
__webpack_require__.d(commentCases_namespaceObject, "commentContent", function() { return CommentContent_CommentContent; });
__webpack_require__.d(commentCases_namespaceObject, "commentLength", function() { return CommentLength_CommentLength; });
__webpack_require__.d(commentCases_namespaceObject, "depth", function() { return Depth_Depth; });
__webpack_require__.d(commentCases_namespaceObject, "hasExpando", function() { return Expando_Expando; });
__webpack_require__.d(commentCases_namespaceObject, "isDeleted", function() { return IsDeleted_IsDeleted; });
__webpack_require__.d(commentCases_namespaceObject, "isRead", function() { return IsRead_IsRead; });
__webpack_require__.d(commentCases_namespaceObject, "postAfter", function() { return PostAfter_PostAfter; });
__webpack_require__.d(commentCases_namespaceObject, "postAge", function() { return PostAge_PostAge; });
__webpack_require__.d(commentCases_namespaceObject, "score", function() { return Score_Score; });
__webpack_require__.d(commentCases_namespaceObject, "selector", function() { return Selector_Selector; });
__webpack_require__.d(commentCases_namespaceObject, "subreddit", function() { return Subreddit_Subreddit; });
__webpack_require__.d(commentCases_namespaceObject, "userAttr", function() { return UserAttr_UserAttr; });
__webpack_require__.d(commentCases_namespaceObject, "userFlair", function() { return UserFlair_UserFlair; });
__webpack_require__.d(commentCases_namespaceObject, "userVoteWeight", function() { return UserVoteWeight_UserVoteWeight; });
__webpack_require__.d(commentCases_namespaceObject, "username", function() { return Username_Username; });
__webpack_require__.d(commentCases_namespaceObject, "userTag", function() { return UserTag_UserTag; });
__webpack_require__.d(commentCases_namespaceObject, "voteType", function() { return VoteType_VoteType; });

// NAMESPACE OBJECT: ./lib/modules/filteReddit/browseCases/index.js
var browseCases_namespaceObject = {};
__webpack_require__.r(browseCases_namespaceObject);
__webpack_require__.d(browseCases_namespaceObject, "browsingFrontPage", function() { return BrowsingFrontPage_BrowsingFrontPage; });
__webpack_require__.d(browseCases_namespaceObject, "currentLocation", function() { return CurrentLocation_CurrentLocation; });
__webpack_require__.d(browseCases_namespaceObject, "currentMulti", function() { return CurrentMulti_CurrentMulti; });
__webpack_require__.d(browseCases_namespaceObject, "currentUserProfile", function() { return CurrentUserProfile_CurrentUserProfile; });
__webpack_require__.d(browseCases_namespaceObject, "currentSub", function() { return CurrentSub_CurrentSub; });
__webpack_require__.d(browseCases_namespaceObject, "date", function() { return Date_Date; });
__webpack_require__.d(browseCases_namespaceObject, "dow", function() { return Dow_Dow; });
__webpack_require__.d(browseCases_namespaceObject, "loggedInAs", function() { return LoggedInAs_LoggedInAs; });
__webpack_require__.d(browseCases_namespaceObject, "toggle", function() { return Toggle_Toggle; });

// NAMESPACE OBJECT: ./lib/modules/usernameHider.js
var usernameHider_namespaceObject = {};
__webpack_require__.r(usernameHider_namespaceObject);
__webpack_require__.d(usernameHider_namespaceObject, "module", function() { return usernameHider_module; });
__webpack_require__.d(usernameHider_namespaceObject, "getDisplayText", function() { return getDisplayText; });

// NAMESPACE OBJECT: ./lib/modules/quickMessage.js
var quickMessage_namespaceObject = {};
__webpack_require__.r(quickMessage_namespaceObject);
__webpack_require__.d(quickMessage_namespaceObject, "module", function() { return quickMessage_module; });
__webpack_require__.d(quickMessage_namespaceObject, "messageLinkEventHandler", function() { return messageLinkEventHandler; });
__webpack_require__.d(quickMessage_namespaceObject, "openQuickMessageDialog", function() { return openQuickMessageDialog; });

// NAMESPACE OBJECT: ./lib/modules/commentNavigator.js
var commentNavigator_namespaceObject = {};
__webpack_require__.r(commentNavigator_namespaceObject);
__webpack_require__.d(commentNavigator_namespaceObject, "module", function() { return commentNavigator_module; });
__webpack_require__.d(commentNavigator_namespaceObject, "updateCustomConditions", function() { return updateCustomConditions; });
__webpack_require__.d(commentNavigator_namespaceObject, "updateFromSelected", function() { return updateFromSelected; });
__webpack_require__.d(commentNavigator_namespaceObject, "setCategory", function() { return setCategory; });
__webpack_require__.d(commentNavigator_namespaceObject, "toggle", function() { return commentNavigator_toggle; });
__webpack_require__.d(commentNavigator_namespaceObject, "move", function() { return commentNavigator_move; });

// NAMESPACE OBJECT: ./lib/modules/hideChildComments.js
var hideChildComments_namespaceObject = {};
__webpack_require__.r(hideChildComments_namespaceObject);
__webpack_require__.d(hideChildComments_namespaceObject, "module", function() { return hideChildComments_module; });
__webpack_require__.d(hideChildComments_namespaceObject, "toggleAll", function() { return toggleAll; });
__webpack_require__.d(hideChildComments_namespaceObject, "toggle", function() { return hideChildComments_toggle; });

// NAMESPACE OBJECT: ./lib/modules/neverEndingReddit.js
var neverEndingReddit_namespaceObject = {};
__webpack_require__.r(neverEndingReddit_namespaceObject);
__webpack_require__.d(neverEndingReddit_namespaceObject, "module", function() { return neverEndingReddit_module; });
__webpack_require__.d(neverEndingReddit_namespaceObject, "loadNextPage", function() { return loadNextPage; });
__webpack_require__.d(neverEndingReddit_namespaceObject, "getNextPrevLinks", function() { return getNextPrevLinks; });

// NAMESPACE OBJECT: ./lib/modules/noParticipation.js
var noParticipation_namespaceObject = {};
__webpack_require__.r(noParticipation_namespaceObject);
__webpack_require__.d(noParticipation_namespaceObject, "module", function() { return noParticipation_module; });
__webpack_require__.d(noParticipation_namespaceObject, "isVotingBlocked", function() { return isVotingBlocked; });
__webpack_require__.d(noParticipation_namespaceObject, "nonNpLocation", function() { return nonNpLocation; });
__webpack_require__.d(noParticipation_namespaceObject, "notifyNoVote", function() { return notifyNoVote; });

// NAMESPACE OBJECT: ./lib/modules/saveComments.js
var saveComments_namespaceObject = {};
__webpack_require__.r(saveComments_namespaceObject);
__webpack_require__.d(saveComments_namespaceObject, "module", function() { return saveComments_module; });
__webpack_require__.d(saveComments_namespaceObject, "showEducationalNotification", function() { return showEducationalNotification; });

// NAMESPACE OBJECT: ./lib/modules/showParent.js
var showParent_namespaceObject = {};
__webpack_require__.r(showParent_namespaceObject);
__webpack_require__.d(showParent_namespaceObject, "module", function() { return showParent_module; });
__webpack_require__.d(showParent_namespaceObject, "startHover", function() { return startHover; });

// NAMESPACE OBJECT: ./lib/modules/singleClick.js
var singleClick_namespaceObject = {};
__webpack_require__.r(singleClick_namespaceObject);
__webpack_require__.d(singleClick_namespaceObject, "module", function() { return singleClick_module; });
__webpack_require__.d(singleClick_namespaceObject, "invokeOnPostMap", function() { return invokeOnPostMap; });

// NAMESPACE OBJECT: ./lib/modules/keyboardNav.js
var keyboardNav_namespaceObject = {};
__webpack_require__.r(keyboardNav_namespaceObject);
__webpack_require__.d(keyboardNav_namespaceObject, "module", function() { return keyboardNav_module; });

// NAMESPACE OBJECT: ./lib/modules/backupAndRestore/providers/index.js
var providers_namespaceObject = {};
__webpack_require__.r(providers_namespaceObject);
__webpack_require__.d(providers_namespaceObject, "File", function() { return File_File; });
__webpack_require__.d(providers_namespaceObject, "GoogleDrive", function() { return GoogleDrive_GoogleDrive; });
__webpack_require__.d(providers_namespaceObject, "OneDrive", function() { return OneDrive_OneDrive; });
__webpack_require__.d(providers_namespaceObject, "Dropbox", function() { return Dropbox_Dropbox; });

// NAMESPACE OBJECT: ./lib/modules/subredditManager.js
var subredditManager_namespaceObject = {};
__webpack_require__.r(subredditManager_namespaceObject);
__webpack_require__.d(subredditManager_namespaceObject, "module", function() { return subredditManager_module; });
__webpack_require__.d(subredditManager_namespaceObject, "createShortcutToggleButton", function() { return createShortcutToggleButton; });
__webpack_require__.d(subredditManager_namespaceObject, "getMultiCounts", function() { return getMultiCounts; });
__webpack_require__.d(subredditManager_namespaceObject, "subscribeToSubreddit", function() { return subscribeToSubreddit; });

// NAMESPACE OBJECT: ./lib/modules/dashboard.js
var modules_dashboard_namespaceObject = {};
__webpack_require__.r(modules_dashboard_namespaceObject);
__webpack_require__.d(modules_dashboard_namespaceObject, "module", function() { return dashboard_module; });
__webpack_require__.d(modules_dashboard_namespaceObject, "widgets", function() { return widgets; });
__webpack_require__.d(modules_dashboard_namespaceObject, "createSubredditToggleButton", function() { return createSubredditToggleButton; });

// CONCATENATED MODULE: ./node_modules/file-loader/dist/cjs.js?name=LICENSE!./LICENSE
/* harmony default export */ var cjsname_LICENSE_LICENSE = (__webpack_require__.p + "LICENSE");
// CONCATENATED MODULE: ./lib/constants/urlHashes.js
const RES_DISABLED_HASH = '#res:disabled';
const RES_SETTINGS_HASH = '#res:settings';
const RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH = '#res:settings-redirect-standalone-options-page';
const RES_NER_PAGE_HASH = '#res:ner-page';
// EXTERNAL MODULE: ./node_modules/lodash-es/once.js + 1 modules
var once = __webpack_require__(132);

// EXTERNAL MODULE: ./lib/utils/time.js
var utils_time = __webpack_require__(17);

// EXTERNAL MODULE: ./lib/utils/location.js + 1 modules
var utils_location = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseRest.js
var _baseRest = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/lodash-es/_apply.js
var _apply = __webpack_require__(41);

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayMap.js
var _arrayMap = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayFilter.js
var _arrayFilter = __webpack_require__(84);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseProperty.js
var _baseProperty = __webpack_require__(85);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseTimes.js
var _baseTimes = __webpack_require__(80);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArrayLike.js
var isArrayLike = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/lodash-es/isObjectLike.js
var isObjectLike = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value){return Object(isObjectLike["a" /* default */])(value)&&Object(isArrayLike["a" /* default */])(value);}/* harmony default export */ var lodash_es_isArrayLikeObject = (isArrayLikeObject);
// CONCATENATED MODULE: ./node_modules/lodash-es/unzip.js
var nativeMax=Math.max;function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=Object(_arrayFilter["a" /* default */])(array,function(group){if(lodash_es_isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return Object(_baseTimes["a" /* default */])(length,function(index){return Object(_arrayMap["a" /* default */])(array,Object(_baseProperty["a" /* default */])(index));});}/* harmony default export */ var lodash_es_unzip = (unzip);
// CONCATENATED MODULE: ./node_modules/lodash-es/unzipWith.js
function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=lodash_es_unzip(array);if(iteratee==null){return result;}return Object(_arrayMap["a" /* default */])(result,function(group){return Object(_apply["a" /* default */])(iteratee,undefined,group);});}/* harmony default export */ var lodash_es_unzipWith = (unzipWith);
// CONCATENATED MODULE: ./node_modules/lodash-es/zipWith.js
var zipWith=Object(_baseRest["a" /* default */])(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return lodash_es_unzipWith(arrays,iteratee);});/* harmony default export */ var lodash_es_zipWith = (zipWith);
// EXTERNAL MODULE: ./node_modules/fast-levenshtein/levenshtein.js
var levenshtein = __webpack_require__(103);
var levenshtein_default = /*#__PURE__*/__webpack_require__.n(levenshtein);

// EXTERNAL MODULE: ./lib/utils/flow.js
var flow = __webpack_require__(16);

// CONCATENATED MODULE: ./lib/utils/html.js
const escapeLookups = {
  '&': '&amp;',
  '"': '&quot;',
  "'": '&apos;',
  '<': '&lt;',
  '>': '&gt;',
  '/': '&#47;'
};
function escapeHTML(str) {
  return str ? str.toString().replace(/[&"'<>\/]/g, m => escapeLookups[m]) : '';
}
// CONCATENATED MODULE: ./lib/utils/string.js





function stringTagFunction(valueTransform) {
  return (strings, ...values) => lodash_es_zipWith(strings, values.map(valueTransform), (s, v) => `${s}${v === undefined ? '' : v}`).join('');
}

const encode = stringTagFunction(encodeURIComponent);
const string_escape = stringTagFunction(escapeHTML);
function safe(str) {
  return {
    __safe__: str
  };
}
const MAX_DISTANCE_RATIO = 0.05;
function areSimilar(a, b) {
  return levenshtein_default.a.get(a, b) <= MAX_DISTANCE_RATIO * Math.max(a.length, b.length);
}
const regexRegex = /^\/(.*)\/([sgimu]+)?$/;
const htmlTagFunction = stringTagFunction(x => {
  if (typeof x === 'number') return String(x);
  if (!x) return '';
  if (typeof x === 'string') return escapeHTML(x);
  if (Array.isArray(x)) return x.filter(s => s && typeof s.__safe__ === 'string').map(s => s.__safe__).join('');
  if (x.hasOwnProperty('__safe__')) return x.__safe__;
  throw new TypeError(`Invalid html template interpolation: ${String(x)}`);
});
const string_html = (s, ...values) => {
  const markup = htmlTagFunction(s, ...values);
  const template = document.createElement('div');
  template.innerHTML = markup;

  if (template.childElementCount !== 1) {
    throw new Error(`Html template should have exactly one root node, but had ${template.childElementCount}`);
  }

  const child = Object(flow["a" /* downcast */])(template.firstElementChild, HTMLElement);
  child.remove();
  return child;
};
const _html = (s, ...values) => safe(htmlTagFunction(s, ...values));
// CONCATENATED MODULE: ./lib/utils/user.js





const isLoggedIn = Object(once["a" /* default */])(() => {
  if (loggedInUser()) {
    return true;
  } else if (document.querySelector('header a[href^="/message/inbox"]')) {
    return true;
  }
});
const loggedInUser = Object(once["a" /* default */])(() => documentLoggedInUser(document));
const documentLoggedInUser = document => {
  if (Object(utils_location["i" /* isAppType */])('d2x')) {
    const findFirstTextNode = e => [...e.childNodes].filter(v => v.nodeType === 3).concat(...[...e.children].map(findFirstTextNode));

    const button = document.querySelector('#USER_DROPDOWN_ID > *');
    const username = button && findFirstTextNode(button)[0];
    return username && username.textContent;
  }

  const link = document.querySelector('#header-bottom-right > span.user > a');
  if (!link || link.classList.contains('login-required')) return;
  const profile = utils_location["p" /* regexes */].profile.exec(link.pathname);

  if (profile) {
    return profile[1];
  }
};
const isModeratorAnywhere = Object(once["a" /* default */])(() => !!(document.getElementById('modmail') || document.querySelector('[href="/r/mod/"]')));
const loggedInUserHash = Object(once["a" /* default */])(async () => {
  const hashEle = document.querySelector('[name=uh]');

  if (hashEle instanceof HTMLInputElement) {
    return hashEle.value;
  }

  const userInfo = await loggedInUserInfo();
  return userInfo && userInfo.data && userInfo.data.modhash;
});
const loggedInUserInfo = Object(once["a" /* default */])(() => !isLoggedIn() ? Promise.resolve() : ajax({
  url: '/api/me.json',
  type: 'json'
}).then(data => data.data && data.data.modhash ? data : undefined));
const usernameRE = /(?:u|user)\/([\w\-]{3,20}(?![\w\-]))/;
const usernameSelector = ['.contents .author', 'p.tagline a.author', '#friend-table span.user a', '.sidecontentbox .author', 'div.md a[href^="/u/"]:not([href*="/m/"])', 'div.md a[href*="reddit.com/u/"]:not([href*="/m/"])', '.usertable a.author', '.parent > a.author', '.usertable span.user a', 'div.wiki-page-content .author', '.Post__authorLink'].join(', ');
function getUsernameFromLink(element) {
  if (!(element instanceof HTMLAnchorElement)) return;
  const {
    href,
    origin
  } = element;
  if (!location.origin.endsWith(origin.split('.').slice(-2).join('.'))) return;
  const [, username] = href.match(usernameRE) || [];
  if (username) return username;
}
function getUserInfo(username = loggedInUser()) {
  if (!username) {
    return Promise.reject(new Error('getUserInfo: null/undefined username'));
  }

  return ajax({
    url: encode`/user/${username}/about.json`,
    type: 'json',
    cacheFor: 10 * utils_time["c" /* MINUTE */]
  });
}
// EXTERNAL MODULE: ./lib/utils/pagePhases.js
var pagePhases = __webpack_require__(22);

// EXTERNAL MODULE: ./lib/utils/dom.js + 6 modules
var dom = __webpack_require__(2);

// CONCATENATED MODULE: ./lib/environment/foreground/context.js



const context_data = {
  userHash: null,
  username: null,
  origin: 'https://www.reddit.com',
  pathname: location.pathname
};

if (location.protocol.startsWith('http')) {
  context_data.origin = location.origin;
  pagePhases["contentStart"].then(() => {
    context_data.username = loggedInUser();
    loggedInUserHash().then(hash => {
      context_data.userHash = hash;
    });
  });
}

function retrieveFromParent() {
  if (window === window.parent) return Promise.resolve();
  return Object(dom["r" /* waitForEvent */])(window, 'message').then(({
    data: {
      context
    }
  }) => {
    Object.assign(context_data, context);
  });
}
// CONCATENATED MODULE: ./lib/environment/utils/messaging.js
class MessageHandlerError extends Error {
  constructor(message, stack) {
    super();
    this.message = message;
    this.stack = stack;
  }

}

function createMessageHandler(_sendMessage, errorOnUnrecognizedTypes = false) {
  const listeners = new Map();
  return {
    _handleMessage: function ({
      type,
      data
    }, sendResponse, context) {
      const listener = listeners.get(type);

      if (!listener) {
        if (errorOnUnrecognizedTypes) {
          sendResponse({
            error: {
              message: `Unrecognised message type: ${type}`,
              stack: ''
            }
          });
        }

        return false;
      }

      let response;

      try {
        response = listener(data, context);
      } catch (e) {
        console.error(e);
        sendResponse({
          error: {
            message: e.message,
            stack: e.stack
          }
        });
        return false;
      }

      if (response instanceof Promise) {
        response.then(data => sendResponse({
          data
        }), e => {
          console.error(e);
          sendResponse({
            error: {
              message: e.message,
              stack: e.stack
            }
          });
        });
        return true;
      } else {
        sendResponse({
          data: response
        });
        return false;
      }
    },
    sendMessage: async function (type, data, context) {
      const {
        data: newData,
        error
      } = await _sendMessage({
        type,
        data
      }, context);

      if (error) {
        throw new MessageHandlerError(error.message, `${error.stack}\n    at target's "${type}" handler`);
      } else {
        return newData;
      }
    },
    addListener: function (type, callback) {
      if (listeners.has(type)) {
        throw new Error(`Listener for "${type}" already exists.`);
      }

      listeners.set(type, callback);
    }
  };
}
// CONCATENATED MODULE: ./lib/environment/utils/api.js
function apiToPromise(func) {
  return (...args) => new Promise((resolve, reject) => {
    func(...args, (...results) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else {
        resolve(results.length > 1 ? results : results[0]);
      }
    });
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/messaging.js



const _sendMessage = apiToPromise(chrome.runtime.sendMessage);

const {
  _handleMessage,
  sendMessage,
  addListener
} = createMessageHandler(obj => _sendMessage(obj));
chrome.runtime.onMessage.addListener((obj, sender, sendResponse) => _handleMessage(obj, sendResponse));

// CONCATENATED MODULE: ./lib/environment/foreground/privateBrowsing.js
function isPrivateBrowsing() {
  return chrome.extension.inIncognitoContext;
}
// CONCATENATED MODULE: ./lib/environment/foreground/history.js


async function addURLToHistory(url) {
  if (isPrivateBrowsing()) return;
  await sendMessage('addURLToHistory', url);
}
function isURLVisited(url) {
  return sendMessage('isURLVisited', url);
}
// CONCATENATED MODULE: ./node_modules/lodash-es/fromPairs.js
function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/* harmony default export */ var lodash_es_fromPairs = (fromPairs);
// CONCATENATED MODULE: ./lib/environment/foreground/xhrCache.js

function xhrCache_set(key, value) {
  return sendMessage('XHRCache', ['set', key, value]);
}
function xhrCache_check(key, maxAge) {
  return sendMessage('XHRCache', ['check', key, maxAge]);
}

function delete_(key) {
  return sendMessage('XHRCache', ['delete', key]);
}


function clear() {
  return sendMessage('XHRCache', ['clear']);
}
// CONCATENATED MODULE: ./lib/environment/foreground/ajax.js





class FetchError extends Error {
  constructor(url, status) {
    super(`${url} failed with status ${status}`);
    this.status = void 0;
    this.status = status;
  }

}

async function ajax(options) {
  const {
    method,
    url,
    headers,
    data,
    type,
    cacheFor,
    sameOrigin,
    credentials
  } = buildRequestParams(options);

  if (cacheFor) {
    const cached = await xhrCache_check(url, cacheFor);

    if (cached) {
      return processResponse(cached, type);
    }
  }

  const response = await (sameOrigin ? fetch(url, {
    method,
    headers,
    credentials,
    body: data
  }).then(async r => ({
    ok: r.ok,
    status: r.status,
    headers: lodash_es_fromPairs(Array.from(r.headers.entries())),
    text: await r.text()
  })) : sendMessage('ajax', {
    method,
    url,
    headers,
    data,
    credentials
  }));

  if (!response.ok) {
    throw new FetchError(url, response.status);
  }

  if (cacheFor) {
    xhrCache_set(url, response);
  }

  return processResponse(response, type);
}

ajax.invalidate = options => delete_(buildRequestParams(options).url);

function buildRequestParams({
  method = 'GET',
  url,
  query = {},
  headers = {},
  data,
  type = 'text',
  credentials,
  cacheFor = 0
}) {
  const siteOrigin = new URL(context_data.origin);
  const requestURL = new URL(url, siteOrigin);

  for (const [key, val] of Object.entries(query)) {
    requestURL.searchParams.set(key, String(val));
  }

  const sameSite = requestURL.hostname.split('.').slice(-2).join('.') === siteOrigin.hostname.split('.').slice(-2).join('.');

  if (sameSite) {
    requestURL.searchParams.set('app', 'res');
    if (!credentials) credentials = 'include';

    if (method !== 'GET' && method !== 'HEAD') {
      if (context_data.userHash) headers['X-Modhash'] = context_data.userHash;
    }

    requestURL.hostname = requestURL.hostname.replace(/new\./, 'www.');
  }

  const sameOrigin = siteOrigin.origin === requestURL.origin;

  if (typeof data === 'object') {
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
    data = new URLSearchParams(data).toString();
  }

  return {
    method,
    url: requestURL.href,
    headers,
    data,
    type,
    cacheFor,
    credentials: credentials || 'omit',
    sameOrigin
  };
}

function processResponse(response, type) {
  switch (type) {
    case 'text':
      return response.text;

    case 'json':
      return JSON.parse(response.text);

    case 'raw':
      return response;

    default:
      throw new Error(`Invalid type: ${type}`);
  }
}
// CONCATENATED MODULE: ./lib/environment/foreground/download.js

function download(url, filename) {
  sendMessage('download', {
    url: new URL(url, location.href).href,
    filename
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/id.js
function getExtensionId() {
  return chrome.runtime.id;
}
const getURL = chrome.runtime.getURL;
const getOptionsURL = (hash = '') => new URL(hash, getURL('options.html'));
const isOptionsPage = () => location.origin === getOptionsURL().origin;
// CONCATENATED MODULE: ./lib/constants/localStorage.js
const CACHED_LANG_KEY = 'RES.i18nCachedLang';
const CACHED_MESSAGES_KEY = 'RES.i18nCachedMessages';
const CACHED_MESSAGES_TOKEN_KEY = 'RES.i18nCachedMessagesToken';
// CONCATENATED MODULE: ./node_modules/exec-loader!./build/buildToken.js
/* harmony default export */ var buildToken = ("5.22.5");
// CONCATENATED MODULE: ./lib/environment/foreground/i18n.js



const REDDIT_LANGUAGES = new Set(['en', 'af', 'ar', 'be', 'bg', 'bn-IN', 'bn-bd', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en-us', 'eo', 'es', 'es-ar', 'es-mx', 'et', 'eu', 'fa', 'fi', 'fil', 'fr', 'fr-ca', 'fy-NL', 'ga-ie', 'gd', 'gl', 'he', 'hi', 'hr', 'hu', 'hy', 'id', 'is', 'it', 'ja', 'kn_IN', 'ko', 'la', 'leet', 'lol', 'lt', 'lv', 'ms', 'mt-MT', 'nl', 'nn', 'no', 'pir', 'pl', 'pt', 'pt-pt', 'pt_BR', 'ro', 'ru', 'sk', 'sl', 'sr', 'sr-la', 'sv', 'ta', 'th', 'tr', 'uk', 'vi', 'zh', 'zh-cn']);
const SPECIAL_LANGUAGES = new Set(['leet', 'lol', 'pir']);
let i18n_locale = navigator.language || 'en';

function isValidLocale(localeString) {
  try {
    return typeof 0 .toLocaleString(localeString) === 'string';
  } catch (e) {
    return false;
  }
}

function getRedditLocale() {
  const redditLocale = typeof document !== 'undefined' && document.documentElement.getAttribute('lang');

  if (redditLocale && REDDIT_LANGUAGES.has(redditLocale)) {
    const locale = redditLocale.toLowerCase().replace('_', '-');

    if (isValidLocale(locale)) {
      requestIdleCallback(() => {
        sendMessage('setLastRedditLocale', locale);
      });
      return locale;
    }
  }

  return sendMessage('getLastRedditLocale');
}

let messages;
async function _loadI18n() {
  const redditLocale = await getRedditLocale();
  if (redditLocale && !SPECIAL_LANGUAGES.has(redditLocale)) i18n_locale = redditLocale;

  if (localStorage.getItem(CACHED_LANG_KEY) === redditLocale && localStorage.getItem(CACHED_MESSAGES_TOKEN_KEY) === buildToken) {
    try {
      messages = JSON.parse(localStorage.getItem(CACHED_MESSAGES_KEY) || '');
      return;
    } catch (e) {
      console.error('Failed to parse cached i18n', e);
    }
  }

  messages = await sendMessage('i18n', redditLocale);

  try {
    localStorage.setItem(CACHED_MESSAGES_KEY, JSON.stringify(messages));
    localStorage.setItem(CACHED_LANG_KEY, redditLocale);
    localStorage.setItem(CACHED_MESSAGES_TOKEN_KEY, buildToken);
  } catch (e) {
    console.error('Could not cache i18n - RES will load VERY slowly', e);
    localStorage.removeItem('ads.adserverDownvotePixel');
    localStorage.removeItem('ads.adserverUpvotePixel');
  }
}
function i18n(messageName, ...substitutions) {
  if (!messageName) return '';

  if (!messages) {
    console.error('i18n called too early! key:', messageName);
    return messageName;
  }

  const message = messages[messageName];
  if (!message) return messageName;
  if (substitutions.length === 0) return message;
  return message.replace(/\$(\d)\b(?!\$)/g, (match, number) => substitutions[number - 1]);
}
// EXTERNAL MODULE: ./node_modules/lodash-es/memoize.js
var memoize = __webpack_require__(93);

// CONCATENATED MODULE: ./lib/environment/foreground/loadScript.js


const loadScript = Object(memoize["a" /* default */])(url => sendMessage('loadScript', {
  url
}));
// EXTERNAL MODULE: ./lib/utils/async.js + 5 modules
var utils_async = __webpack_require__(3);

// CONCATENATED MODULE: ./lib/environment/foreground/permissions.js




function filterPerms(perms) {
  const permissions = perms.filter(p => !p.includes('://') && p !== '<all_urls>');
  const origins = perms.filter(p => p.includes('://') || p === '<all_urls>');
  return {
    permissions,
    origins
  };
}

const permissions_has = Object(memoize["a" /* default */])(perms => sendMessage('permissions', {
  operation: 'contains',
  ...filterPerms(perms)
}), perms => perms.join(','));
const request = Object(utils_async["h" /* mutex */])(async perms => {
  if (await permissions_has(perms)) return;
  const {
    permissions,
    origins
  } = filterPerms(perms);
  const granted = await sendMessage('permissions', {
    operation: 'request',
    permissions,
    origins
  });

  if (granted) {
    permissions_has.cache.set(perms.join(','), true);
  } else {
    throw new Error(`Permission not granted for: ${perms.join(', ')}`);
  }
});
// CONCATENATED MODULE: ./lib/environment/foreground/auth.js


async function launchAuthFlow({
  domain,
  clientId,
  scope = '',
  permissions
}, warnUserInteraction) {
  if (permissions.length && !(await permissions_has(permissions))) {
    const resAuth = 'https://redditenhancementsuite.com/oauth';

    if ( true && !(await permissions_has([resAuth]))) {
      permissions.push(resAuth);
    }

    await warnUserInteraction(permissions.includes(resAuth) ? 'You may be redirected to redditenhancementsuite.com to complete the login process.' : '');
    await request(permissions);
  }

  let responseUrl;

  try {
    responseUrl = await sendMessage('authFlow', {
      domain,
      clientId,
      scope,
      interactive: false
    });
  } catch (e) {
    console.error('Noninteractive auth failed:', e);
    responseUrl = await sendMessage('authFlow', {
      domain,
      clientId,
      scope,
      interactive: true
    });
  }

  const hash = new URL(responseUrl).hash.slice(1);
  const token = new URLSearchParams(hash).get('access_token');
  if (!token) throw new Error('No token found in response.');
  return token;
}
// CONCATENATED MODULE: ./lib/environment/foreground/multicast.js

const callbacks = new Map();
addListener('multicast', ({
  name,
  args
}) => {
  const callback = callbacks.get(name);
  if (callback) return callback(...args);
});
function multicast(callback, {
  name,
  local = true,
  crossContext = true
}) {
  if (callbacks.has(name)) {
    throw new Error(`Multicast handler with name "${name}" exists.`);
  }

  callbacks.set(name, callback);

  function localOnly(...args) {
    callback(...args);
  }

  const invoke = (...args) => {
    sendMessage('multicast', {
      name,
      args,
      crossContext
    });

    if (local) {
      localOnly(...args);
    }
  };

  invoke.local = localOnly;
  return invoke;
}
// CONCATENATED MODULE: ./lib/environment/foreground/tabs.js

function openNewTab(url, focus = true) {
  return openNewTabs(focus, url);
}
function openNewTabs(focus, ...urls) {
  let focusIndex;
  if (typeof focus !== 'string') focus = !!focus;

  switch (focus) {
    case 'first':
      focusIndex = 0;
      break;

    case true:
    case 'last':
      focusIndex = urls.length - 1;
      break;

    case false:
    case 'none':
      focusIndex = -1;
      break;

    default:
      throw new Error(`Invalid focus specified: ${focus}`);
  }

  urls = urls.map(url => new URL(url, location.href).href);
  return sendMessage('openNewTabs', {
    urls,
    focusIndex
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/pageAction.js


const clickListeners = [];
function pageAction_onClick(callback) {
  clickListeners.push(callback);
}
addListener('pageActionClick', () => {
  for (const fn of clickListeners) fn();
});
const pageAction_update = Object(utils_async["e" /* frameThrottle */])(value => sendMessage('pageAction', value));
function show(state = false) {
  return pageAction_update({
    operation: 'show',
    state
  });
}
function pageAction_hide() {
  return pageAction_update({
    operation: 'hide'
  });
}
// CONCATENATED MODULE: ./lib/environment/foreground/session.js

function get(key) {
  return sendMessage('session', ['get', key]);
}
function session_set(key, value) {
  return sendMessage('session', ['set', key, value]);
}
function session_delete_(key) {
  return sendMessage('session', ['delete', key]);
}

function session_has(key) {
  return sendMessage('session', ['has', key]);
}
function session_clear() {
  return sendMessage('session', ['clear']);
}
// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayEach.js
var _arrayEach = __webpack_require__(64);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseCreate.js
var _baseCreate = __webpack_require__(33);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseForOwn.js + 2 modules
var _baseForOwn = __webpack_require__(67);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIteratee.js + 9 modules
var _baseIteratee = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/lodash-es/_overArg.js
var _overArg = __webpack_require__(82);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getPrototype.js
var getPrototype=Object(_overArg["a" /* default */])(Object.getPrototypeOf,Object);/* harmony default export */ var _getPrototype = (getPrototype);
// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/lodash-es/isBuffer.js
var isBuffer = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/lodash-es/isFunction.js
var isFunction = __webpack_require__(57);

// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/lodash-es/isTypedArray.js + 1 modules
var isTypedArray = __webpack_require__(48);

// CONCATENATED MODULE: ./node_modules/lodash-es/transform.js
function transform(object,iteratee,accumulator){var isArr=Object(isArray["a" /* default */])(object),isArrLike=isArr||Object(isBuffer["a" /* default */])(object)||Object(isTypedArray["a" /* default */])(object);iteratee=Object(_baseIteratee["a" /* default */])(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(Object(isObject["a" /* default */])(object)){accumulator=Object(isFunction["a" /* default */])(Ctor)?Object(_baseCreate["a" /* default */])(_getPrototype(object)):{};}else{accumulator={};}}(isArrLike?_arrayEach["a" /* default */]:_baseForOwn["a" /* default */])(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/* harmony default export */ var lodash_es_transform = (transform);
// CONCATENATED MODULE: ./lib/utils/object.js
function extendDeep(target, source) {
  for (const key of Object.keys(source)) {
    if (target[key] && source[key] && typeof target[key] === 'object' && typeof source[key] === 'object' && !Array.isArray(source[key]) && !Array.isArray(target[key])) {
      extendDeep(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }

  return target;
}
// CONCATENATED MODULE: ./lib/environment/foreground/storage.js






const __set = apiToPromise((items, callback) => chrome.storage.local.set(items, callback));

const _set = (key, value) => __set({
  [key]: value
});

const __get = apiToPromise((keys, callback) => chrome.storage.local.get(keys, callback));

const _get = async (key, defaultValue = null) => (await __get({
  [key]: defaultValue
}))[key];

const _delete = apiToPromise((keys, callback) => chrome.storage.local.remove(keys, callback));

const _clear = apiToPromise(callback => chrome.storage.local.clear(callback));

const withLockOn = Object(utils_async["g" /* keyedMutex */])((key, fn) => fn());
function storage_get(key) {
  return withLockOn(key, () => _get(key, null));
}
function getAll() {
  return __get(null);
}
function getMultiple(keys) {
  const defaults = {};

  for (const k of keys) {
    defaults[k] = null;
  }

  return __get(defaults);
}
function storage_set(key, value) {
  return withLockOn(key, () => _set(key, value));
}
function setMultiple(valueMap) {
  return __set(valueMap);
}

function compareAndSet(key, defaultValue, oldValue, newValue) {
  return sendMessage('storage-cas', [key, defaultValue, oldValue, newValue]);
}

function patch(key, value) {
  return withLockOn(key, async () => {
    const extended = extendDeep((await _get(key)) || {}, value);
    return _set(key, extended);
  });
}

function patchShallow(key, value) {
  return withLockOn(key, async () => {
    const extended = Object.assign((await _get(key)) || {}, value);
    return _set(key, extended);
  });
}

function deletePaths(key, paths) {
  return withLockOn(key, async () => {
    const stored = await _get(key);
    if (!stored) return;

    for (const path of paths) {
      path.reduce((obj, key, i, {
        length
      }) => {
        if (!obj) return;
        if (i < length - 1) return obj[key];
        delete obj[key];
      }, stored);
    }

    return _set(key, stored);
  });
}

function storage_delete_(key) {
  return withLockOn(key, () => _delete(key));
}


function deleteMultiple(keys) {
  return _delete(keys);
}
function storage_has(key) {
  return withLockOn(key, async () => {
    const sentinel = Math.random();
    return (await _get(key, sentinel)) !== sentinel;
  });
}
async function storage_keys() {
  return Object.keys(await __get(null));
}
function storage_clear() {
  return _clear();
}

class Wrapper {
  constructor(key, def) {
    this._key = void 0;
    this._default = void 0;
    this._key = key;
    this._default = def;
  }

  get() {
    return storage_get(this._key()).then(val => val === null ? this._default : val);
  }

  set(value) {
    return storage_set(this._key(), value);
  }

  patch(value) {
    return patch(this._key(), value);
  }

  compareAndSet(oldValue, newValue) {
    return compareAndSet(this._key(), this._default, oldValue, newValue);
  }

  deletePath(...path) {
    return deletePaths(this._key(), [path]);
  }

  delete() {
    return storage_delete_(this._key());
  }

  has() {
    return storage_has(this._key());
  }

}

function wrap(key, defaultValue) {
  const keyGenerator = typeof key === 'string' ? () => key : Object(once["a" /* default */])(key);
  return new Wrapper(keyGenerator, defaultValue);
}

class storage_PrefixWrapper {
  constructor(prefix, def, keyMapper, batching) {
    this._prefix = void 0;
    this._keyMapper = void 0;
    this._default = void 0;
    this._get = void 0;
    this._prefix = prefix;
    this._default = def;
    this._keyMapper = keyMapper;

    if (batching) {
      this._get = Object(utils_async["a" /* batch */])(async keys => {
        const v = await this.getMultipleNullable(keys);
        return keys.map(key => v[this._keyMapper(key)]);
      }, {
        size: Infinity,
        delay: 0
      });
    } else {
      this._get = key => storage_get(this._keyGen(key));
    }
  }

  _keyGen(key) {
    return this._prefix + this._keyMapper(key);
  }

  get(key) {
    return this._get(key).then(val => val === null ? this._default() : val);
  }

  getNullable(key) {
    return this._get(key);
  }

  async getAll() {
    const everything = await getAll();
    return lodash_es_transform(everything, (acc, v, k) => {
      if (k.startsWith(this._prefix)) {
        acc[k.slice(this._prefix.length)] = v;
      }
    }, {});
  }

  async getMultiple(keys) {
    const rawValues = await getMultiple(keys.map(k => this._keyGen(k)));
    return lodash_es_transform(rawValues, (acc, v, k) => {
      acc[k.slice(this._prefix.length)] = v === null ? this._default() : v;
    }, {});
  }

  async getMultipleNullable(keys) {
    const rawValues = await getMultiple(keys.map(k => this._keyGen(k)));
    return lodash_es_transform(rawValues, (acc, v, k) => {
      acc[k.slice(this._prefix.length)] = v;
    }, {});
  }

  set(key, value) {
    return storage_set(this._keyGen(key), value);
  }

  patch(key, value) {
    return patch(this._keyGen(key), value);
  }

  deletePath(key, ...path) {
    return deletePaths(this._keyGen(key), [path]);
  }

  delete(key) {
    return storage_delete_(this._keyGen(key));
  }

  deleteMultiple(keys) {
    return deleteMultiple(keys.map(k => this._keyGen(k)));
  }

  has(key) {
    return storage_has(this._keyGen(key));
  }

}

function wrapPrefix(prefix, defaultValue, destructiveKeyMapper = x => x, batching = false) {
  return new storage_PrefixWrapper(prefix, defaultValue, destructiveKeyMapper, batching);
}

class storage_BlobWrapper {
  constructor(rootKey, def) {
    this._rootKey = void 0;
    this._default = void 0;
    this._rootKey = rootKey;
    this._default = def;
  }

  get(key) {
    return storage_get(this._rootKey).then(val => val === null || val[key] === undefined ? this._default() : val[key]);
  }

  getNullable(key) {
    return storage_get(this._rootKey).then(val => val === null || val[key] === undefined ? null : val[key]);
  }

  getAll() {
    return storage_get(this._rootKey).then(val => val === null ? {} : val);
  }

  async getMultiple(keys) {
    const rawValues = (await storage_get(this._rootKey)) || {};
    return lodash_es_transform(keys, (acc, key) => {
      acc[key] = rawValues[key] === undefined ? this._default() : rawValues[key];
    }, {});
  }

  async getMultipleNullable(keys) {
    const rawValues = (await storage_get(this._rootKey)) || {};
    return lodash_es_transform(keys, (acc, key) => {
      acc[key] = rawValues[key] === undefined ? null : rawValues[key];
    }, {});
  }

  set(key, value) {
    return patchShallow(this._rootKey, {
      [key]: value
    });
  }

  patch(key, value) {
    return patch(this._rootKey, {
      [key]: value
    });
  }

  deletePath(key, ...path) {
    return deletePaths(this._rootKey, [[key, ...path]]);
  }

  delete(key) {
    return deletePaths(this._rootKey, [[key]]);
  }

  deleteMultiple(keys) {
    return deletePaths(this._rootKey, keys.map(k => [k]));
  }

  has(key) {
    return storage_get(this._rootKey).then(val => val !== null && val[key] !== undefined);
  }

  clear() {
    return storage_delete_(this._rootKey);
  }

}

function wrapBlob(rootKey, defaultValue) {
  return new storage_BlobWrapper(rootKey, defaultValue);
}
// CONCATENATED MODULE: ./lib/environment/index.js





















// CONCATENATED MODULE: ./lib/utils/Cache.js
class LRUCache {
  constructor(capacity) {
    this.map = void 0;
    this.capacity = void 0;
    this.map = new Map();
    this.capacity = capacity;
  }

  get(key, maxAge = Infinity) {
    const now = Date.now();
    const entry = this.map.get(key);

    if (entry && now - entry.createTime < maxAge) {
      entry.hitTime = now;
      return entry.value;
    }
  }

  set(key, value) {
    const now = Date.now();
    this.map.set(key, {
      value,
      createTime: now,
      hitTime: now
    });

    if (this.map.size > this.capacity) {
      Array.from(this.map.entries()).sort(([, a], [, b]) => b.hitTime - a.hitTime).slice(this.capacity / 2 | 0).forEach(([key]) => this.map.delete(key));
    }

    return this;
  }

  delete(key) {
    return this.map.delete(key);
  }

  clear() {
    this.map.clear();
  }

}
// EXTERNAL MODULE: ./lib/utils/Thing.js
var Thing = __webpack_require__(26);

// CONCATENATED MODULE: ./lib/utils/thingMetadata.js


const getPostMetadata = Object(utils_async["a" /* batch */])(async requests => {
  const byId = requests.map(r => r.id).map(id => `t3_${id}`).join(',');
  const {
    data: {
      children
    }
  } = await ajax({
    url: `/by_id/${byId}.json`,
    query: {
      limit: 100,
      raw_json: 1
    },
    type: 'json'
  });
  return children.map(c => c.data);
}, {
  size: 100
});
// EXTERNAL MODULE: ./lib/utils/array.js
var utils_array = __webpack_require__(19);

// EXTERNAL MODULE: ./node_modules/tinycolor2/tinycolor.js
var tinycolor = __webpack_require__(96);
var tinycolor_default = /*#__PURE__*/__webpack_require__.n(tinycolor);

// CONCATENATED MODULE: ./lib/utils/color.js

function colorToArray(colorString) {
  const {
    r,
    g,
    b
  } = tinycolor_default()(colorString).toRgb();
  return [r, g, b];
}
function colorFromArray([r, g, b]) {
  return tinycolor_default()({
    r,
    g,
    b
  }).toHexString();
}
// CONCATENATED MODULE: ./lib/utils/dashboard.js

const initialTabID = location.hash.replace('#', '') || 'dashboardContents';
let selectedTabMenuItem;
function addDashboardTab(tabID, tabName, moduleId, callback) {
  if (!Object(utils_location["l" /* isCurrentSubreddit */])('dashboard')) return;
  bodyClasses_namespaceObject.add('res-dashboard');
  let tabPage;
  const tabMenuItem = createElement_namespaceObject.tabMenuItem({
    text: tabName,
    className: 'res-dashboard-tab',
    order: -1,
    onChange: active => {
      const container = document.querySelector('#siteTable.linklisting');
      if (!container) return;

      if (active) {
        if (selectedTabMenuItem) selectedTabMenuItem.click();
        selectedTabMenuItem = tabMenuItem;
        tabPage = string_namespaceObject.html`<div class="dashboardPane"></div>`;
        container.append(tabPage);
        callback(tabPage);
        location.hash = tabID;
      } else {
        tabPage.remove();
      }
    }
  });

  if (moduleId) {
    tabMenuItem.after(string_namespaceObject.html`<a class="gearIcon" href="#res:settings/${moduleId}"></a>`);
  }

  if (tabID === initialTabID) tabMenuItem.click();
}
// CONCATENATED MODULE: ./lib/utils/floater.js
var _class, _temp, _class2, _temp2, _class3, _temp3, _class4, _temp4;








class floater_Container {
  static isAvailable() {
    return true;
  }

  constructor() {
    this.element = document.createElement('div');
    this.list = string_html`<ul class="res-floater-list"></ul>`;
    if (this.constructor.useList) this.element.append(this.list);
    this.constructor.phase.then(() => this.go());
  }

  go() {}

  add(element, {
    separate,
    order
  }) {
    if (separate || !this.constructor.useList) {
      element.style.order = String(order);
      this.element.append(element);
    } else {
      if (element instanceof HTMLLIElement) {
        this.list.append(element);
      } else {
        const li = string_html`<li style="order: ${order}"></li>`;
        li.append(element);
        this.list.append(li);
      }
    }
  }

}

floater_Container.fallback = void 0;
floater_Container.phase = pagePhases["loadComplete"];
floater_Container.useList = true;
const containers = {
  inNavbar: (_temp = _class = class inNavbar extends floater_Container {
    constructor(...args) {
      super(...args);
      this.updateHeaderWidth = Object(utils_async["e" /* frameThrottle */])(() => {
        const {
          width
        } = this.element.getBoundingClientRect();
        const headerButton = document.querySelector('.header-user-dropdown');
        headerButton.style.marginRight = `${width}px`;
      });
    }

    static isAvailable() {
      return Object(utils_location["i" /* isAppType */])('d2x') && !!document.querySelector('.header-user-dropdown');
    }

    go() {
      this.element.classList.add('res-floater-inNavbar');
      document.body.append(this.element);
      this.updateHeaderWidth();
    }

    add(element, opts) {
      super.add(element, opts);
      this.updateHeaderWidth();
    }

  }, _class.fallback = 'userMenu', _class.phase = pagePhases["contentStart"], _temp),
  userMenu: (_temp2 = _class2 = class userMenu extends floater_Container {
    static isAvailable() {
      return Object(utils_location["i" /* isAppType */])('r2');
    }

    go() {
      const element = document.body.querySelector('#header-bottom-right ul');
      element.append(...this.element.children);
      this.element = element;
    }

    add(element) {
      this.element.append(string_html`<span class="separator">|</span>`, element);
    }

  }, _class2.phase = pagePhases["contentStart"], _class2.useList = false, _temp2),
  belowFixedNavbar: class extends floater_Container {
    static isAvailable() {
      return Object(utils_location["i" /* isAppType */])('d2x');
    }

    go() {
      this.element.classList.add('res-floater-belowNavbar');
      this.element.style.top = `${5 + Object(dom["f" /* getD2xBodyOffset */])()}px`;
      document.body.append(this.element);
    }

  },
  visibleAfterScroll: (_temp3 = _class3 = class visibleAfterScroll extends floater_Container {
    static isAvailable() {
      return !Object(utils_location["i" /* isAppType */])('d2x');
    }

    go() {
      this.element.classList.add('res-floater-visibleAfterScroll');
      document.body.append(this.element);
      this.element.style.top = `${8 + Object(dom["g" /* getHeaderOffset */])(true)}px`;

      if (!document.querySelector('#RESPinnedHeaderSpacer')) {
        this.element.hidden = true;
        new IntersectionObserver(entries => {
          this.element.hidden = entries[0].isIntersecting;
        }).observe(document.querySelector('#header'));
      }
    }

  }, _class3.fallback = 'belowFixedNavbar', _temp3),
  tabMenu: (_temp4 = _class4 = class tabMenu extends floater_Container {
    static isAvailable() {
      return Object(utils_location["i" /* isAppType */])('r2');
    }

    go() {
      let menu = document.querySelector('#header-bottom-left ul.tabmenu');

      if (menu) {} else if (document.querySelector('#header-bottom-left')) {
        menu = string_html`<ul class="tabmenu" />`;
        document.querySelector('#header-bottom-left').append(menu);
      } else {
        return;
      }

      menu.append(...this.element.children);
      this.element = menu;
    }

  }, _class4.fallback = 'belowFixedNavbar', _class4.phase = pagePhases["contentStart"], _class4.useList = false, _temp4),
  inert: floater_Container
};
const getContainer = Object(memoize["a" /* default */])(name => {
  let container;

  if (containers[name].isAvailable()) {
    container = new containers[name]();
  } else if (containers[name].fallback) {
    container = getContainer(containers[name].fallback);
  }

  if (container) {
    return container;
  } else {
    const InertContainer = containers.inert;
    return new InertContainer();
  }
});
function addFloater(element, {
  container: containerName = ['inNavbar', 'belowFixedNavbar', 'visibleAfterScroll'].find(name => containers[name].isAvailable()) || 'inert',
  separate = false,
  order = 0
} = {}) {
  getContainer(containerName).add(element, {
    separate,
    order
  });
}
// EXTERNAL MODULE: ./lib/utils/generator.js
var generator = __webpack_require__(35);

// CONCATENATED MODULE: ./lib/utils/hash.js

const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
function randomHash(len = 5) {
  const arr = new Array(len);

  for (const i of Object(generator["a" /* range */])(0, len)) {
    arr[i] = chars.charAt(Math.random() * chars.length | 0);
  }

  return arr.join('');
}
function hashCode(str) {
  let hash = 0;

  for (const char of str) {
    hash = (hash << 5) - hash + char.charCodeAt(0) | 0;
  }

  return hash;
}
// CONCATENATED MODULE: ./lib/utils/thingHide.js




const hideEndpoint = '/api/hide';
const unhideEndpoint = '/api/unhide';
const [HIDE, UNHIDE] = ['hide', 'unhide'];
const send = async (state, things) => {
  if (!isLoggedIn()) throw new Error('Not logged in');
  const values = Object(utils_array["c" /* filterMap */])(things, thing => {
    const id = thing.getFullname();
    const element = thing.getHideElement();
    return id && element && element.dataset.eventAction === state ? [{
      id,
      element
    }] : undefined;
  });
  if (!values.length) return;

  const updateElements = (action, text) => {
    for (const {
      element
    } of values) {
      if (action) element.dataset.eventAction = action;
      if (element.classList.contains('noCtrlF')) element.dataset.text = text;else element.textContent = text;
    }
  };

  updateElements(state === HIDE ? UNHIDE : HIDE, state === HIDE ? 'hiding...' : 'unhiding...');

  try {
    await ajax({
      method: 'POST',
      url: state === HIDE ? hideEndpoint : unhideEndpoint,
      data: {
        id: values.map(({
          id
        }) => id).join(',')
      },
      type: 'json'
    });
    updateElements(undefined, state === HIDE ? UNHIDE : HIDE);
  } catch (e) {
    updateElements(state, state);
    throw e;
  }
};
const thingHide_hide = Object(utils_async["a" /* batch */])(things => send(HIDE, things), {
  size: 50
});
const unhide = Object(utils_async["a" /* batch */])(things => send(UNHIDE, things), {
  size: 50
});
// CONCATENATED MODULE: ./lib/utils/keycode.js


const NAMED_KEYS = {
  Backspace: 'Backspace',
  Tab: 'Tab',
  Enter: 'Enter',
  Escape: 'Escape',
  Space: ' ',
  PageUp: 'PageUp',
  PageDown: 'PageDown',
  End: 'End',
  Home: 'Home',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Shift: 'Shift',
  Control: 'Control',
  Alt: 'Alt'
};
const keyCodes = {
  '-1': 'none',
  '8': 'backspace',
  '9': 'tab',
  '13': 'enter',
  '16': 'shift',
  '17': 'ctrl',
  '18': 'alt',
  '19': 'pause/break',
  '20': 'caps lock',
  '27': 'escape',
  '33': 'page up',
  '34': 'page down',
  '35': 'end',
  '36': 'home',
  '37': 'left arrow',
  '38': 'up arrow',
  '39': 'right arrow',
  '40': 'down arrow',
  '45': 'insert',
  '46': 'delete',
  '91': 'left window',
  '92': 'right window',
  '93': 'select key',
  '96': 'numpad 0',
  '97': 'numpad 1',
  '98': 'numpad 2',
  '99': 'numpad 3',
  '100': 'numpad 4',
  '101': 'numpad 5',
  '102': 'numpad 6',
  '103': 'numpad 7',
  '104': 'numpad 8',
  '105': 'numpad 9',
  '106': 'multiply',
  '107': 'add',
  '109': 'subtract',
  '110': 'decimal point',
  '111': 'divide',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'num lock',
  '145': 'scroll lock',
  '186': ';',
  '187': '=',
  '188': ',',
  '189': '-',
  '190': '.',
  '191': '/',
  '192': '`',
  '219': '[',
  '220': '\\',
  '221': ']',
  '222': '\''
};
function keycode_niceKeyCode(keyArray) {
  if (!keyArray && isNaN(keyArray)) {
    return '';
  }

  if (typeof keyArray === 'number') {
    keyArray = [keyArray, false, false, false, false];
  } else if (typeof keyArray === 'string') {
    const split = keyArray.split(',');
    const code = parseInt(split[0], 10);
    const modifiers = [...split.slice(1).map(s => s === 'true'), false, false, false, false];
    const [alt, ctrl, shift, meta] = modifiers;
    keyArray = [code, alt, ctrl, shift, meta];
  }

  const [keyCode, ...modifiers] = keyArray;
  const keyCombo = lodash_es_zipWith(modifiers, ['alt-', 'ctrl-', 'shift-', 'command-'], (predicate, name) => predicate && name).filter(x => x).join('');
  const keyName = keyCodes[keyCode] || String.fromCharCode(keyCode);
  return `${keyCombo}${keyName}`;
}
function checkKeysForEvent(event, keyArray) {
  if (typeof keyArray === 'number') {
    keyArray = [keyArray, false, false, false, false];
  } else if (keyArray.length === 4) {
    keyArray.push(false);
  }

  const eventHash = hashKeyEvent(event);
  const arrayHash = hashKeyArray(keyArray);
  return eventHash === arrayHash;
}
function hashKeyEvent(event) {
  const keyArray = [event.keyCode, event.altKey, event.ctrlKey, event.shiftKey, event.metaKey];
  return hashKeyArray(keyArray);
}
function hashKeyArray(keyArray) {
  const length = 5;
  let hash = keyArray[0] * 2 ** length;

  for (const i of Object(generator["a" /* range */])(1, length)) {
    if (keyArray[i]) {
      hash += 2 ** i;
    }
  }

  return hash;
}
// CONCATENATED MODULE: ./lib/utils/localization.js


const Dayjs = Object(once["a" /* default */])(() => {
  const dayjs = __webpack_require__(27);

  const localeCode = i18n_locale.toLowerCase();
  if (localeCode.startsWith('de')) dayjs.locale(__webpack_require__(114));
  if (localeCode.startsWith('el')) dayjs.locale(__webpack_require__(115));
  if (localeCode.startsWith('es')) dayjs.locale(__webpack_require__(116));
  if (localeCode.startsWith('he')) dayjs.locale(__webpack_require__(117));
  if (localeCode.startsWith('it')) dayjs.locale(__webpack_require__(118));
  if (localeCode.startsWith('nl')) dayjs.locale(__webpack_require__(119));
  if (localeCode.startsWith('pl')) dayjs.locale(__webpack_require__(120));
  if (localeCode.startsWith('pt-br')) dayjs.locale(__webpack_require__(121));
  if (localeCode.startsWith('pt')) dayjs.locale(__webpack_require__(122));
  dayjs.extend(__webpack_require__(123));
  dayjs.extend(__webpack_require__(124));
  return dayjs;
});
const localization_dayjs = (...args) => new Dayjs()(...args);
function formatNumber(number) {
  return number.toLocaleString(i18n_locale);
}
function formatDate(date) {
  return localization_dayjs(date).format('L');
}
function formatDateTime(date) {
  return localization_dayjs(date).format('L LTS');
}
function formatDateDiff(from, to) {
  return localization_dayjs(to).from(from, true);
}
function formatRelativeTime(from) {
  return localization_dayjs(from).fromNow();
}
// CONCATENATED MODULE: ./lib/utils/math.js
function numericalCompare(op, a, b) {
  switch (op) {
    case '==':
      return a == b;

    case '!=':
      return a != b;

    case '>':
      return a > b;

    case '<':
      return a < b;

    case '>=':
      return a >= b;

    case '<=':
      return a <= b;

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function inverseOperator(op) {
  switch (op) {
    case '==':
      return '!=';

    case '!=':
      return '==';

    case '>':
      return '<=';

    case '<':
      return '>=';

    case '>=':
      return '<';

    case '<=':
      return '>';

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function prettyOperator(op) {
  switch (op) {
    case '==':
      return '=';

    case '!=':
      return '≠';

    case '>':
      return '>';

    case '<':
      return '<';

    case '>=':
      return '≥';

    case '<=':
      return '≤';

    default:
      throw new Error(`Unhandled operator ${op}`);
  }
}
function interpolate(low, high, frac) {
  return (1 - frac) * low + frac * high;
}
function deinterpolate(low, high, value) {
  if (low === -Infinity && high === Infinity) {
    return 0.5;
  } else if (low === -Infinity) {
    return 1;
  } else if (high === Infinity) {
    return 0;
  }

  return (value - low) / (high - low);
}
function projectInto(fromLow, fromHigh, toLow, toHigh, value) {
  return interpolate(toLow, toHigh, deinterpolate(fromLow, fromHigh, value));
}
function positiveModulo(a, n) {
  return (a % n + n) % n;
}
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseAssignValue.js
var _baseAssignValue = __webpack_require__(30);

// EXTERNAL MODULE: ./node_modules/lodash-es/_createAggregator.js + 2 modules
var _createAggregator = __webpack_require__(66);

// CONCATENATED MODULE: ./node_modules/lodash-es/groupBy.js
var objectProto=Object.prototype;var groupBy_hasOwnProperty=objectProto.hasOwnProperty;var groupBy=Object(_createAggregator["a" /* default */])(function(result,value,key){if(groupBy_hasOwnProperty.call(result,key)){result[key].push(value);}else{Object(_baseAssignValue["a" /* default */])(result,key,[value]);}});/* harmony default export */ var lodash_es_groupBy = (groupBy);
// CONCATENATED MODULE: ./lib/utils/options.js

function indexOptionTable(option, keyIndex, keyTransformer = v => v) {
  const source = option.fields[keyIndex].type === 'list' ? Array.from(function* (nestedArray) {
    for (const arr of nestedArray) {
      for (const subKey of arr[keyIndex].split(',')) {
        yield [...arr.slice(0, keyIndex), subKey, ...arr.slice(keyIndex + 1)];
      }
    }
  }(option.value)) : option.value;
  return lodash_es_groupBy(source, arr => keyTransformer(arr[keyIndex]));
}
// CONCATENATED MODULE: ./lib/utils/pageContextScript.js

function stopPageContextScript(test, _parent, onlyChildrenOfParent) {
  const undo = [];
  let stopped = false;

  (async () => {
    if (_parent instanceof Promise) {
      _parent = await _parent;
    }

    const parent = _parent instanceof HTMLElement ? _parent : document.documentElement.querySelector(_parent) || (await Object(dom["o" /* waitForDescendant */])(document.documentElement, _parent));
    if (stopped) return;
    (onlyChildrenOfParent ? dom["t" /* watchForChildren */] : dom["u" /* watchForDescendants */])(parent, 'script', ele => {
      if (stopped) return;
      const script = Object(flow["a" /* downcast */])(ele, HTMLScriptElement);

      if (test(script)) {
        const origType = script.type;
        script.type = 'javascript/blocked';
        const origSrc = script.src;
        if (origSrc) script.src = '';
        const origContent = script.innerHTML;
        if (origContent) script.innerHTML = '';
        undo.push(() => {
          const ele = document.createElement('script');
          ele.type = origType;
          if (origSrc) ele.src = origSrc;
          if (origContent) ele.innerHTML = origContent;
          script.after(ele);
          return Object(dom["r" /* waitForEvent */])(ele, 'load');
        });
      }
    });
  })();

  return {
    undo: () => {
      stopped = true;
      return Promise.allSettled(undo.map(fn => fn()));
    }
  };
}
// CONCATENATED MODULE: ./lib/utils/profiling.js
let profiling_counter = 0;
function markStart() {
  const tag = (++profiling_counter).toString();
  performance.mark(tag);
  return tag;
}
function markEnd(tag, name) {
  performance.measure(name, tag);
}
// CONCATENATED MODULE: ./lib/utils/storage.js


async function maybePruneOldEntries(id, entryStorage, keepTrackDays = 30) {
  if (!(await shouldPrune(id))) return;
  const now = Date.now();

  for (const [id, data] of Object.entries(await entryStorage.getAll())) {
    const {
      updateTime
    } = data || {};

    if (!updateTime || now - updateTime > utils_time["a" /* DAY */] * keepTrackDays) {
      entryStorage.delete(id);
    }
  }
}
async function shouldPrune(id, interval = utils_time["d" /* WEEK */]) {
  await new Promise(res => {
    setTimeout(() => requestIdleCallback(res), 10000);
  });
  const lastStorage = storage_namespaceObject.wrap(`last_prune.${id}`, 0);
  const now = Date.now();
  if (now - (await lastStorage.get()) < interval) return false;
  lastStorage.set(now);
  return true;
}
// CONCATENATED MODULE: ./lib/utils/subreddits.js
const fakeSubreddits = ['mod', 'friends', 'random', 'myrandom', 'all', 'contrib', 'popular'];
function isFakeSubreddit(subreddit) {
  return fakeSubreddits.some(fakeSubreddit => fakeSubreddit === subreddit.toLowerCase());
}
// CONCATENATED MODULE: ./lib/utils/value.js
function firstValid(...vals) {
  return vals.find(val => val !== undefined && val !== null && (typeof val !== 'number' || !isNaN(val)));
}
// EXTERNAL MODULE: ./lib/utils/watchers.js
var watchers = __webpack_require__(53);

// CONCATENATED MODULE: ./lib/constants/jsapi.js
const JSAPI_CONSUMER_NAME = 'reddit-enhancement-suite';
// CONCATENATED MODULE: ./lib/utils/watchers_d2x.js

const watchers_d2x_callbacks = {
  subreddit: [],
  postAuthor: [],
  post: []
};
function watchForRedditEvents(type, callback) {
  if (!watchers_d2x_callbacks[type]) {
    watchers_d2x_callbacks[type] = [];
  }

  watchers_d2x_callbacks[type].push(callback);
}

function handleRedditEvent(event) {
  const {
    target,
    detail: {
      type,
      data
    }
  } = event;
  const fns = watchers_d2x_callbacks[type];

  if (!fns) {
    return;
  }

  let expandoId = `${type}|`;

  switch (type) {
    case 'postAuthor':
      expandoId += data.post.id;
      break;

    case 'commentAuthor':
      expandoId += data.comment.id;
      break;

    case 'userHovercard':
      expandoId += `${data.contextId}|${data.user.id}`;
      break;

    case 'subreddit':
    case 'post':
    case 'postModTools':
    default:
      expandoId += data.id;
      break;
  }

  const update = target.expando && target.expando._.id === expandoId ? (target.expando._.update || 0) + 1 : 0;
  const expando = { ...data,
    _: {
      id: expandoId,
      type,
      update
    }
  };
  target.expando = expando;
  const ownedTarget = target.querySelector(`[data-name="${JSAPI_CONSUMER_NAME}"]`);

  for (const fn of fns) {
    try {
      fn(ownedTarget, expando);
    } catch (e) {
      console.log(e);
    }
  }
}

function initD2xWatcher() {
  document.addEventListener('reddit', handleRedditEvent, true);
  const meta = document.createElement('meta');
  meta.name = 'jsapi.consumer';
  meta.content = JSAPI_CONSUMER_NAME;
  document.head.appendChild(meta);
  meta.dispatchEvent(new CustomEvent('reddit.ready'));
}
// EXTERNAL MODULE: ./node_modules/lodash-es/_SetCache.js + 2 modules
var _SetCache = __webpack_require__(46);

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayIncludes.js
var _arrayIncludes = __webpack_require__(44);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/* harmony default export */ var _arrayIncludesWith = (arrayIncludesWith);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseUnary.js
var _baseUnary = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/lodash-es/_cacheHas.js
var _cacheHas = __webpack_require__(36);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE=200;function baseDifference(array,values,iteratee,comparator){var index=-1,includes=_arrayIncludes["a" /* default */],isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=Object(_arrayMap["a" /* default */])(values,Object(_baseUnary["a" /* default */])(iteratee));}if(comparator){includes=_arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=_cacheHas["a" /* default */];isCommon=false;values=new _SetCache["a" /* default */](values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/* harmony default export */ var _baseDifference = (baseDifference);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseFlatten.js + 1 modules
var _baseFlatten = __webpack_require__(69);

// CONCATENATED MODULE: ./node_modules/lodash-es/difference.js
var difference=Object(_baseRest["a" /* default */])(function(array,values){return lodash_es_isArrayLikeObject(array)?_baseDifference(array,Object(_baseFlatten["a" /* default */])(values,1,lodash_es_isArrayLikeObject,true)):[];});/* harmony default export */ var lodash_es_difference = (difference);
// CONCATENATED MODULE: ./lib/utils/bodyClasses.js

const classes = new Set();
const addMissing = () => {
  document.body.classList.add(...lodash_es_difference(Array.from(classes), Array.from(document.body.classList)));
};
function bodyClasses_add(...change) {
  for (const cls of change) classes.add(cls);

  if (document.documentElement) document.documentElement.classList.add(...change);
  if (document.body) document.body.classList.add(...change);
}
function bodyClasses_remove(...change) {
  for (const cls of change) classes.delete(cls);

  if (document.documentElement) document.documentElement.classList.remove(...change);
  if (document.body) document.body.classList.remove(...change);
}
function bodyClasses_toggle(state, ...change) {
  if (state) bodyClasses_add(...change);else bodyClasses_remove(...change);
}
// CONCATENATED MODULE: ./lib/utils/browserDetect.js
let versionSearchString;

const searchString = datas => {
  const data = datas.find(data => {
    versionSearchString = data.versionSearch || data.identity;
    return data.string ? data.string.includes(data.subString) : data.prop;
  });
  return data ? data.identity : undefined;
};

const searchVersion = dataString => {
  const index = dataString.indexOf(versionSearchString);

  if (index === -1) {
    return;
  }

  return parseFloat(dataString.substring(index + versionSearchString.length + 1));
};

const hasNavigator = typeof navigator !== 'undefined';
const browser = hasNavigator ? searchString(dataBrowser()) || 'An unknown browser' : 'An unknown browser without `navigator`';
const version = hasNavigator ? searchVersion(navigator.userAgent) || searchVersion(navigator.appVersion) || 'an unknown version' : 'an unknown version without `navigator`';
const OS = hasNavigator ? searchString(dataOS()) || 'an unknown OS' : 'an unknown OS without `navigator`';

function dataBrowser() {
  return [{
    string: navigator.userAgent,
    subString: 'OPR/',
    identity: 'Opera'
  }, {
    string: navigator.userAgent,
    subString: 'Edge',
    identity: 'Edge Spartan'
  }, {
    string: navigator.userAgent,
    subString: 'Edg',
    versionSearch: 'Edg',
    identity: 'Edge'
  }, {
    string: navigator.userAgent,
    subString: 'Chrome',
    identity: 'Chrome'
  }, {
    string: navigator.userAgent,
    subString: 'OmniWeb',
    versionSearch: 'OmniWeb/',
    identity: 'OmniWeb'
  }, {
    string: navigator.vendor,
    subString: 'Apple',
    identity: 'Safari',
    versionSearch: 'Version'
  }, {
    prop: window.opera,
    identity: 'Opera',
    versionSearch: 'Version'
  }, {
    string: navigator.vendor,
    subString: 'iCab',
    identity: 'iCab'
  }, {
    string: navigator.vendor,
    subString: 'KDE',
    identity: 'Konqueror'
  }, {
    string: navigator.userAgent,
    subString: 'Firefox',
    identity: 'Firefox'
  }, {
    string: navigator.vendor,
    subString: 'Camino',
    identity: 'Camino'
  }, {
    string: navigator.userAgent,
    subString: 'Netscape',
    identity: 'Netscape'
  }, {
    string: navigator.userAgent,
    subString: 'MSIE',
    identity: 'Explorer',
    versionSearch: 'MSIE'
  }, {
    string: navigator.userAgent,
    subString: 'Gecko',
    identity: 'Mozilla',
    versionSearch: 'rv'
  }, {
    string: navigator.userAgent,
    subString: 'Mozilla',
    identity: 'Netscape',
    versionSearch: 'Mozilla'
  }];
}

function dataOS() {
  return [{
    string: navigator.platform,
    subString: 'Win',
    identity: 'Windows'
  }, {
    string: navigator.platform,
    subString: 'Mac',
    identity: 'Mac'
  }, {
    string: navigator.userAgent,
    subString: 'iPhone',
    identity: 'iPhone/iPod'
  }, {
    string: navigator.platform,
    subString: 'Linux',
    identity: 'Linux'
  }];
}
// CONCATENATED MODULE: ./lib/utils/createElement.js






function toggleButton(onClick = () => {}, fieldID, enabled = false, onText = i18n('toggleOn'), offText = i18n('toggleOff'), isTable = false, usesBatch = false) {
  const toggle = string_html`
		<div ${fieldID && _html`id="${fieldID}Container"`} class="toggleButton ${enabled && 'enabled'}">
			<span class="toggleThumb"></span>
			<div class="toggleLabel ${usesBatch && 'res-icon'}"
				${onText && _html`data-enabled-text="${onText}"`}
				${offText && _html`data-disabled-text="${offText}"`}
			></div>
			<input id="${fieldID}" name="${fieldID}" type="checkbox" ${enabled && 'checked'}
				${isTable && _html`tableOption="true"`}
			/>
		</div>
	`;
  toggle.addEventListener('click', () => {
    const checkbox = Object(flow["a" /* downcast */])(toggle.querySelector('input[type=checkbox]'), HTMLInputElement);
    const enabling = !checkbox.checked;
    checkbox.checked = enabling;
    toggle.classList.toggle('enabled', enabling);
    onClick(enabling);
  });
  return toggle;
}
function createElement_icon(charCode, tagName = 'span', className = '', title = '') {
  const icon = document.createElement(tagName);
  icon.className = className;
  icon.classList.add('res-icon');
  icon.textContent = String.fromCharCode(charCode);
  icon.setAttribute('title', title);
  return icon;
}
function createElement_table(items, callback) {
  items = [].concat(items);
  const description = [];
  description.push('<table>');

  for (const item of items.map(callback)) {
    if (typeof item === 'string') {
      description.push(item);
    } else if (item) {
      description.push(...item);
    }
  }

  description.push('</table>');
  return description.join('\n');
}
function createElement_tabMenuItem({
  text,
  aftercontent,
  className,
  title,
  checked,
  onChange,
  order
}) {
  const element = string_html`
		<li class="res-tabmenu-button ${checked && 'selected'} ${className}">
			<a
				${title && _html`title="${title}"`}
				${aftercontent && _html`aftercontent="${aftercontent}"`}
			>${text}</a>
		</li>
	`;
  addFloater(element, {
    container: 'tabMenu',
    order
  });
  const a = element.querySelector('a');
  a.addEventListener('click', () => {
    checked = !checked;
    element.classList.toggle('selected', checked);
    onChange(checked);
  });
  return a;
}
function fancyToggleButton(text, title, getState, callback) {
  const element = document.createElement('span');
  element.className = 'res-fancy-toggle-button';
  element.title = title;
  let state;

  const refresh = _state => {
    if (state === _state) return;
    state = _state;

    if (state) {
      element.textContent = `-${text}`;
      element.classList.add('remove');
    } else {
      element.textContent = `+${text}`;
      element.classList.remove('remove');
    }
  };

  element.addEventListener('click', () => {
    callback(!state);
    refresh(!state);
  });
  element.addEventListener('refresh', () => {
    refresh(getState());
  });
  refresh(getState());
  return element;
}
const sidebarSubscribeButtonWrappers = Object(once["a" /* default */])(() => {
  const subreddit = Object(utils_location["d" /* currentSubreddit */])() || '';
  return [...document.querySelectorAll('.side .subscribe-button.fancy-toggle-button')].map(subButton => {
    const thisSubredditFragment = subButton.getAttribute('data-sr_name') || subreddit;
    const isMulti = subreddit.includes('+') || Object(utils_location["l" /* isCurrentSubreddit */])('mod');
    const wrapper = string_html`<div subreddit="${thisSubredditFragment}" class="subButtons" style="margin: 0 !important;"></div>`;
    subButton.replaceWith(wrapper);
    wrapper.append(subButton);
    if (isMulti) wrapper.parentElement.append(wrapper);
    return wrapper;
  });
});
// CONCATENATED MODULE: ./lib/utils/alert.js



const alert_open = Object(utils_async["h" /* mutex */])((content, {
  cancelable = false
} = {}) => new Promise((resolve, reject) => {
  const overlay = string_html`<div id="alert_message_background"></div>`;
  const container = string_html`<div id="alert_message"></div>`;
  const buttons = document.createElement('div');
  container.append(content instanceof HTMLElement ? content : string_html`<div>${safe(content)}</div>`, buttons);
  document.body.append(overlay, container);

  function confirm() {
    resolve();
    close();
  }

  function cancel() {
    reject(new Error('User cancelled alert.'));
    close();
  }

  function close() {
    document.body.removeEventListener('keyup', listenForEscape);
    container.remove();
    overlay.remove();
  }

  function listenForEscape(e) {
    if (e.key === NAMED_KEYS.Escape) {
      if (cancelable) cancel();else confirm();
    }
  }

  document.body.addEventListener('keyup', listenForEscape);

  if (cancelable) {
    buttons.style.float = 'right';
    buttons.append(makeButton('cancel', 'button-right', cancel), makeButton('confirm', 'button-right', confirm, true));
  } else {
    buttons.append(makeButton('ok', undefined, confirm, true));
  }
}));
function makeButton(text, cls, onClick, focus) {
  const btn = document.createElement('input');
  btn.setAttribute('type', 'button');
  btn.setAttribute('value', text);
  if (onClick) btn.addEventListener('click', onClick);
  if (cls) btn.classList.add(cls);
  if (focus) requestAnimationFrame(() => {
    btn.focus();
  });
  return btn;
}
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGet.js
var _baseGet = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseEach.js + 1 modules
var _baseEach = __webpack_require__(90);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMap.js
function baseMap(collection,iteratee){var index=-1,result=Object(isArrayLike["a" /* default */])(collection)?Array(collection.length):[];Object(_baseEach["a" /* default */])(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/* harmony default export */ var _baseMap = (baseMap);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/* harmony default export */ var _baseSortBy = (baseSortBy);
// EXTERNAL MODULE: ./node_modules/lodash-es/isSymbol.js
var isSymbol = __webpack_require__(18);

// CONCATENATED MODULE: ./node_modules/lodash-es/_compareAscending.js
function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=Object(isSymbol["a" /* default */])(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=Object(isSymbol["a" /* default */])(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/* harmony default export */ var _compareAscending = (compareAscending);
// CONCATENATED MODULE: ./node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=_compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}return object.index-other.index;}/* harmony default export */ var _compareMultiple = (compareMultiple);
// EXTERNAL MODULE: ./node_modules/lodash-es/identity.js
var identity = __webpack_require__(28);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=Object(_arrayMap["a" /* default */])(iteratees,function(iteratee){if(Object(isArray["a" /* default */])(iteratee)){return function(value){return Object(_baseGet["a" /* default */])(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else{iteratees=[identity["a" /* default */]];}var index=-1;iteratees=Object(_arrayMap["a" /* default */])(iteratees,Object(_baseUnary["a" /* default */])(_baseIteratee["a" /* default */]));var result=_baseMap(collection,function(value){var criteria=Object(_arrayMap["a" /* default */])(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return _baseSortBy(result,function(object,other){return _compareMultiple(object,other,orders);});}/* harmony default export */ var _baseOrderBy = (baseOrderBy);
// EXTERNAL MODULE: ./node_modules/lodash-es/_isIterateeCall.js
var _isIterateeCall = __webpack_require__(54);

// CONCATENATED MODULE: ./node_modules/lodash-es/sortBy.js
var sortBy_sortBy=Object(_baseRest["a" /* default */])(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&Object(_isIterateeCall["a" /* default */])(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&Object(_isIterateeCall["a" /* default */])(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return _baseOrderBy(collection,Object(_baseFlatten["a" /* default */])(iteratees,1),[]);});/* harmony default export */ var lodash_es_sortBy = (sortBy_sortBy);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!Object(isSymbol["a" /* default */])(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/* harmony default export */ var _baseExtremum = (baseExtremum);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGt.js
function baseGt(value,other){return value>other;}/* harmony default export */ var _baseGt = (baseGt);
// CONCATENATED MODULE: ./node_modules/lodash-es/maxBy.js
function maxBy(array,iteratee){return array&&array.length?_baseExtremum(array,Object(_baseIteratee["a" /* default */])(iteratee,2),_baseGt):undefined;}/* harmony default export */ var lodash_es_maxBy = (maxBy);
// EXTERNAL MODULE: ./node_modules/lodash-es/debounce.js + 1 modules
var debounce = __webpack_require__(109);

// CONCATENATED MODULE: ./node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT='Expected a function';function throttle_throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(Object(isObject["a" /* default */])(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return Object(debounce["a" /* default */])(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/* harmony default export */ var lodash_es_throttle = (throttle_throttle);
// CONCATENATED MODULE: ./lib/constants/sessionStorage.js
const LAST_SELECTED_ENTRY_KEY = 'RES.lastSelectedEntry';
// CONCATENATED MODULE: ./lib/utils/selectedThing.js



let selectedThing_current;
let currentContainer;
let selectedThing_previous;
const listeners = {
  instantly: [],
  beforePaint: [],
  idle: []
};
function selectedThing_addListener(callback, when = 'idle', priority = 0) {
  callback.priority = priority;
  listeners[when].push(callback);
  listeners[when].sort((a, b) => a.priority - b.priority);
}

const runCallbacks = (() => {
  function runListeners(listeners, new_, old, opt) {
    for (const listener of listeners) try {
      listener(new_, old, opt);
    } catch (e) {
      console.error(e);
    }
  }

  function throttle(throttler, listeners) {
    let oldest;
    const throttled = throttler((new_, old, opt) => {
      runListeners(listeners, new_, oldest, opt);
      oldest = null;
    });
    return (new_, old, opt) => {
      if (!oldest) oldest = old;
      throttled(new_, old, opt);
    };
  }

  const runBeforePaint = throttle(utils_async["e" /* frameThrottle */], listeners.beforePaint);
  const runIdle = throttle(utils_async["f" /* idleThrottle */], listeners.idle);
  return (new_, old, opt) => {
    if (listeners.instantly.length) runListeners(listeners.instantly, new_, old, opt);
    if (listeners.beforePaint.length) runBeforePaint(new_, old, opt);
    if (listeners.idle.length) runIdle(new_, old, opt);
  };
})();

function selectedThing_set(_new, options = {
  scrollStyle: 'none'
}, force = false) {
  if (!force && _new === selectedThing_current) return;
  selectedThing_previous = selectedThing_current;
  selectedThing_current = _new;
  currentContainer = selectedThing_current.element.closest('.sitetable');
  const direction = selectedThing_previous && selectedThing_previous.getDirectionOf(selectedThing_current);
  runCallbacks(selectedThing_current, selectedThing_previous, { ...options,
    ...(direction ? {
      direction
    } : undefined)
  });
}
const selectClosestInView = Object(utils_async["d" /* frameDebounce */])(() => {
  if (selectedThing_current && Object(dom["h" /* getPercentageVisibleYAxis */])(selectedThing_current.entry)) return;
  const closestToCurrent = selectedThing_current && selectedThing_current.getClosestVisible();

  if (closestToCurrent && Object(dom["h" /* getPercentageVisibleYAxis */])(closestToCurrent.entry)) {
    selectedThing_set(closestToCurrent);
    return;
  }

  const things = Thing["a" /* Thing */].visibleThings();
  const currentIndex = things.indexOf(selectedThing_current);
  const closestThings = lodash_es_sortBy(things.filter(thing => thing.isVisible()), thing => Math.abs(things.indexOf(thing) - currentIndex));
  const closestVisible = lodash_es_maxBy(closestThings, ({
    entry
  }) => Object(dom["h" /* getPercentageVisibleYAxis */])(entry));
  if (closestVisible) selectedThing_set(closestVisible);
});
function selectedThing_refresh() {
  if (!selectedThing_current || selectedThing_current.isVisible()) return;
  selectClosestInView();
}
const movers = {
  closestVisible: thing => thing.getClosestVisible(),
  up: thing => thing.getNext({
    direction: 'up'
  }),
  down: thing => thing.getNext({
    direction: 'down'
  }),
  top: () => Thing["a" /* Thing */].visibleThings()[0],
  bottom: () => Thing["a" /* Thing */].visibleThings().slice(-1)[0],
  upSibling: thing => thing.getNextSibling({
    direction: 'up'
  }) || thing.parent,
  downSibling: thing => thing.getClosest(thing.getNextSibling, {
    direction: 'down'
  }),
  downParentSibling: thing => (thing.parent || thing).getClosest(thing.getNextSibling, {
    direction: 'down'
  }),
  upThread: thing => thing.getThreadTop().getNextSibling({
    direction: 'up'
  }) || thing.getThreadTop(),
  downThread: thing => thing.getThreadTop().getNextSibling({
    direction: 'down'
  }),
  toTopComment: thing => thing.getThreadTop(),
  toParent: thing => thing.parent,
  previous: () => selectedThing_previous
};
function move(direction, options, fallback) {
  if (!selectedThing_current || !selectedThing_current.element.offsetParent) {
    selectClosestInView();
    return;
  }

  const targetFn = movers[direction];

  if (!selectedThing_current && targetFn.length) {
    if (!fallback || !fallback()) throw new Error('Function only works when an entry is current');
  }

  const target = targetFn(selectedThing_current);

  if (!target) {
    if (fallback && fallback()) return;
    if (selectedThing_current) return selectedThing_set(selectedThing_current, {
      scrollStyle: 'middle'
    });
    throw new Error('Could not find a target');
  } else if (selectedThing_current === target) {
    if (selectedThing_current) return selectedThing_set(selectedThing_current, {
      scrollStyle: 'middle'
    });
    throw new Error('Target already current');
  }

  selectedThing_set(target, options);
}
let selectedThing_anchor;
selectedThing_addListener((current, previous, {
  scrollStyle
}) => {
  if (previous && current !== previous && ['none', 'adopt'].includes(scrollStyle) && (current.element.classList.contains('res-thing-partial') || previous.element.classList.contains('res-thing-partial'))) {
    selectedThing_anchor = {
      to: current.entry.getBoundingClientRect().top,
      from: previous.entry.getBoundingClientRect().top
    };
  } else {
    selectedThing_anchor = undefined;
  }
}, 'instantly', -Infinity);
selectedThing_addListener((current, previous, {
  direction,
  scrollStyle
}) => {
  Object(dom["l" /* scrollToElement */])(current.entry, previous && previous.entry, {
    scrollStyle,
    direction,
    anchor: selectedThing_anchor,
    waitTillVisible: true
  });
}, 'beforePaint', 9);
selectedThing_addListener(current => {
  current.runSurroundingTasks();
}, 'instantly');
Object(watchers["watchForThings"])(['comment'], lodash_es_throttle(thing => {
  if (!selectedThing_current) return;
  if (selectedThing_current && document.contains(selectedThing_current.element)) return;
  if (currentContainer && currentContainer !== thing.element.closest('.sitetable')) return;
  selectedThing_set(thing);
}, 100, {
  leading: true,
  trailing: false
}), {
  immediate: true
});
const lastSelectedKey = `${LAST_SELECTED_ENTRY_KEY}-${location.pathname}`;

const getLastSelectedId = () => sessionStorage[lastSelectedKey];

let scrollToSelectedThingOnLoad = false;
const setScrollToSelectedThingOnLoad = v => {
  scrollToSelectedThingOnLoad = v;
};
const lastSelectedId = getLastSelectedId();
Object(watchers["watchForThings"])(null, thing => {
  if (selectedThing_current) return;
  if (!lastSelectedId) return selectedThing_set(thing);
  if (thing.getFullname() !== lastSelectedId) return;
  if (scrollToSelectedThingOnLoad) history.scrollRestoration = 'manual';
  selectedThing_set(thing, {
    scrollStyle: history.scrollRestoration === 'manual' ? 'legacy' : 'none'
  });
}, {
  immediate: true
});
selectedThing_addListener(current => {
  const id = current.getFullname();
  if (!id) return;
  sessionStorage[lastSelectedKey] = id;
}, 'beforePaint');
selectedThing_addListener((current, previous) => {
  if (previous) {
    previous.entry.classList.remove('res-selected');
    previous.element.classList.remove('res-selected');
  }

  if (current) {
    current.entry.classList.add('res-selected');
    current.element.classList.add('res-selected');
  }
}, 'instantly');
// EXTERNAL MODULE: ./node_modules/lodash-es/toString.js + 1 modules
var lodash_es_toString = __webpack_require__(91);

// CONCATENATED MODULE: ./node_modules/lodash-es/escapeRegExp.js
var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);function escapeRegExp(string){string=Object(lodash_es_toString["a" /* default */])(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/* harmony default export */ var lodash_es_escapeRegExp = (escapeRegExp);
// EXTERNAL MODULE: ./node_modules/lodash-es/pull.js + 3 modules
var pull = __webpack_require__(133);

// CONCATENATED MODULE: ./lib/utils/table.js


const RESTables = new Map();
class table_RESTable {
  constructor(headers, _data, getRow, opts) {
    this._data = void 0;
    this.getRow = void 0;
    this.page = 0;
    this.pageSize = 100;
    this.tbody = void 0;
    this.element = void 0;
    this.columns = [];
    this.filters = [];
    this.onRowsChanges = [];
    this.sortBy = void 0;
    this.sortDirection = 'asc';
    this.data = Object(memoize["a" /* default */])(() => {
      const data = this._data.filter(v => this.filters.every(filter => filter(v)));

      if (this.sortBy) {
        const getValue = Object(memoize["a" /* default */])(r => {
          const v = this.getRow(r)[this.sortBy];
          return v instanceof HTMLElement ? v.hasAttribute('sort-value') ? v.getAttribute('sort-value') : v.textContent : String(v);
        });
        data.sort((a, b) => getValue(a).localeCompare(getValue(b), undefined, {
          numeric: true
        }));
      }

      if (this.sortDirection === 'desc') {
        data.reverse();
      }

      return data;
    });
    this.updatePage = Object(utils_async["e" /* frameThrottle */])(() => {
      this.page = positiveModulo(this.page, Math.ceil(this.data().length / this.pageSize)) || 0;
      const start = this.page * this.pageSize || 0;
      Object(dom["e" /* empty */])(this.tbody);

      for (const rawRow of this.data().slice(start, start + this.pageSize)) {
        const tr = document.createElement('tr');
        this.tbody.append(tr);
        const row = this.getRow(rawRow);

        for (const id of this.columns) {
          const td = document.createElement('td');
          const content = row[id];
          if (content instanceof HTMLElement) td.append(content);else td.textContent = content;
          tr.append(td);
        }
      }

      for (const observer of this.onRowsChanges) observer();
    });
    this._data = _data;
    this.getRow = getRow;
    Object.assign(this, opts);
    const table = this.element = document.createElement('table');
    table.style.width = '100%';
    const thead = document.createElement('thead');
    const tbody = this.tbody = Object(flow["a" /* downcast */])(document.createElement('tbody'), HTMLTableSectionElement);
    table.append(thead, tbody);

    const _tr = document.createElement('tr');

    thead.append(_tr);

    for (const [id, label] of Object.entries(headers)) {
      const th = document.createElement('th');
      th.addEventListener('click', sortByColumn);
      th.style.cursor = 'pointer';
      th.textContent = label;
      this.columns.push(id);

      _tr.append(th);

      if (this.sortBy === id) th.classList.add(`sort-${this.sortDirection}`);
    }

    RESTables.set(table, this);
    this.refresh();
  }

  refresh() {
    this.data.cache.clear();
    this.updatePage();
  }

  start() {
    this.page = 0;
    this.refresh();
  }

  createSearchElement(valueGetter, placeholder, focus = false) {
    const search = document.createElement('input');
    search.setAttribute('placeholder', placeholder);
    if (focus) requestAnimationFrame(() => {
      search.focus();
    });
    let lastFilter;
    search.addEventListener('input', () => {
      let regex;

      if (string_namespaceObject.regexRegex.test(search.value)) {
        const [, str, flags = ''] = string_namespaceObject.regexRegex.exec(search.value);
        regex = new RegExp(str, flags);
      } else {
        regex = new RegExp(lodash_es_escapeRegExp(search.value), 'i');
      }

      if (lastFilter) Object(pull["a" /* default */])(this.filters, lastFilter);
      if (search.value) this.filters.push(lastFilter = data => regex.test(valueGetter(data)));
      this.start();
    });
    return search;
  }

  createSelectFilterElement(filters) {
    const ele = string_namespaceObject.html`<div>
			Show only:
			<select>${filters.map(({
      name,
      initialSelected
    }) => string_namespaceObject._html`<option ${initialSelected ? 'selected' : ''}>${name}</option>`)}</select>
		</div>`;
    const filterSelect = Object(flow["a" /* downcast */])(ele.querySelector('select'), HTMLSelectElement);
    let lastFilter;
    this.filters.push(lastFilter = filters[filterSelect.selectedIndex].filter);
    filterSelect.addEventListener('change', () => {
      Object(pull["a" /* default */])(this.filters, lastFilter);
      const filter = filters[filterSelect.selectedIndex].filter;
      this.filters.push(lastFilter = filter);
      this.start();
    });
    return ele;
  }

  createPaginationElement() {
    const ele = string_namespaceObject.html`<div class="res-step-container">
			<div class="res-step res-step-previous" role="button"></div>
			<div class="res-step-progress">
				<span class="res-step-position"></span> of <span class="res-step-total"></span>
			</div>
			<div class="res-step res-step-next" role="button"></div>
		</div>`;
    ele.querySelector('.res-step-previous').addEventListener('click', () => {
      this.page--;
      this.updatePage();
    });
    ele.querySelector('.res-step-next').addEventListener('click', () => {
      this.page++;
      this.updatePage();
    });
    const position = ele.querySelector('.res-step-position');
    const total = ele.querySelector('.res-step-total');
    this.onRowsChanges.push(() => {
      const pages = Math.ceil(this.data().length / this.pageSize);
      ele.setAttribute('first-piece', String(this.page === 0));
      ele.setAttribute('last-piece', String(this.page === pages - 1));
      position.textContent = String(this.page + 1);
      total.textContent = String(pages || 1);
    });
    return ele;
  }

  sort(by, reverseCurrent) {
    this.sortBy = typeof by === 'number' ? this.columns[by] : by;
    this.sortDirection = reverseCurrent ? this.sortDirection === 'asc' ? 'desc' : 'asc' : 'asc';
    this.start();
  }

}
function sortByColumn({
  target: sortColumn
}) {
  const table = Object(flow["a" /* downcast */])(sortColumn.closest('table'), HTMLTableElement);
  const reverseCurrent = sortColumn.classList.contains('sort-asc') || sortColumn.classList.contains('sort-asc');
  const tableRES = RESTables.get(table);

  if (tableRES) {
    const index = [...Object(flow["a" /* downcast */])(sortColumn.parentElement, HTMLElement).children].indexOf(sortColumn);
    tableRES.sort(index, reverseCurrent);
  } else {
    const tbody = table.querySelector('tbody');
    const columns = Array.from(table.querySelectorAll('thead th'));
    const rows = Array.from(tbody.querySelectorAll('tr'));

    if (reverseCurrent) {
      rows.reverse();
    } else {
      const index = columns.indexOf(sortColumn);
      const getCellValue = Object(memoize["a" /* default */])(row => {
        const cell = row.querySelectorAll('td')[index];
        return cell.textContent;
      });
      rows.sort((rowA, rowB) => getCellValue(rowA).localeCompare(getCellValue(rowB), undefined, {
        numeric: true
      }));
    }

    tbody.append(...rows);
  }

  if (reverseCurrent) {
    sortColumn.classList.toggle('sort-asc');
    sortColumn.classList.toggle('sort-desc');
  } else {
    const previous = table.querySelector('.sort-asc, .sort-desc');
    if (previous) previous.classList.remove('sort-asc');
    if (previous) previous.classList.remove('sort-desc');
    sortColumn.classList.add('sort-asc');
  }
}
// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
var dist_jquery = __webpack_require__(0);
var jquery_default = /*#__PURE__*/__webpack_require__.n(dist_jquery);

// CONCATENATED MODULE: ./node_modules/sortablejs/modular/sortable.core.esm.js
/**!
 * Sortable 1.13.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function(obj){return typeof obj;};}else{_typeof=function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==='function'){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable;}));}ownKeys.forEach(function(key){_defineProperty(target,key,source[key]);});}return target;}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}function _objectWithoutProperties(source,excluded){if(source==null)return{};var target=_objectWithoutPropertiesLoose(source,excluded);var key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(excluded.indexOf(key)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key];}}return target;}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2;}}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)==="[object Arguments]")return Array.from(iter);}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance");}var sortable_core_esm_version="1.13.0";function userAgent(pattern){if(typeof window!=='undefined'&&window.navigator){return!!navigator.userAgent.match(pattern);}}var IE11OrLess=userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);var Edge=userAgent(/Edge/i);var FireFox=userAgent(/firefox/i);var Safari=userAgent(/safari/i)&&!userAgent(/chrome/i)&&!userAgent(/android/i);var IOS=userAgent(/iP(ad|od|hone)/i);var ChromeForAndroid=userAgent(/chrome/i)&&userAgent(/android/i);var captureMode={capture:false,passive:false};function sortable_core_esm_on(el,event,fn){el.addEventListener(event,fn,!IE11OrLess&&captureMode);}function sortable_core_esm_off(el,event,fn){el.removeEventListener(event,fn,!IE11OrLess&&captureMode);}function sortable_core_esm_matches(el,selector){if(!selector)return;selector[0]==='>'&&(selector=selector.substring(1));if(el){try{if(el.matches){return el.matches(selector);}else if(el.msMatchesSelector){return el.msMatchesSelector(selector);}else if(el.webkitMatchesSelector){return el.webkitMatchesSelector(selector);}}catch(_){return false;}}return false;}function getParentOrHost(el){return el.host&&el!==document&&el.host.nodeType?el.host:el.parentNode;}function closest(el,selector,ctx,includeCTX){if(el){ctx=ctx||document;do{if(selector!=null&&(selector[0]==='>'?el.parentNode===ctx&&sortable_core_esm_matches(el,selector):sortable_core_esm_matches(el,selector))||includeCTX&&el===ctx){return el;}if(el===ctx)break;}while(el=getParentOrHost(el));}return null;}var R_SPACE=/\s+/g;function toggleClass(el,name,state){if(el&&name){if(el.classList){el.classList[state?'add':'remove'](name);}else{var className=(' '+el.className+' ').replace(R_SPACE,' ').replace(' '+name+' ',' ');el.className=(className+(state?' '+name:'')).replace(R_SPACE,' ');}}}function css(el,prop,val){var style=el&&el.style;if(style){if(val===void 0){if(document.defaultView&&document.defaultView.getComputedStyle){val=document.defaultView.getComputedStyle(el,'');}else if(el.currentStyle){val=el.currentStyle;}return prop===void 0?val:val[prop];}else{if(!(prop in style)&&prop.indexOf('webkit')===-1){prop='-webkit-'+prop;}style[prop]=val+(typeof val==='string'?'':'px');}}}function matrix(el,selfOnly){var appliedTransforms='';if(typeof el==='string'){appliedTransforms=el;}else{do{var transform=css(el,'transform');if(transform&&transform!=='none'){appliedTransforms=transform+' '+appliedTransforms;}}while(!selfOnly&&(el=el.parentNode));}var matrixFn=window.DOMMatrix||window.WebKitCSSMatrix||window.CSSMatrix||window.MSCSSMatrix;return matrixFn&&new matrixFn(appliedTransforms);}function find(ctx,tagName,iterator){if(ctx){var list=ctx.getElementsByTagName(tagName),i=0,n=list.length;if(iterator){for(;i<n;i++){iterator(list[i],i);}}return list;}return[];}function getWindowScrollingElement(){var scrollingElement=document.scrollingElement;if(scrollingElement){return scrollingElement;}else{return document.documentElement;}}function getRect(el,relativeToContainingBlock,relativeToNonStaticParent,undoScale,container){if(!el.getBoundingClientRect&&el!==window)return;var elRect,top,left,bottom,right,height,width;if(el!==window&&el.parentNode&&el!==getWindowScrollingElement()){elRect=el.getBoundingClientRect();top=elRect.top;left=elRect.left;bottom=elRect.bottom;right=elRect.right;height=elRect.height;width=elRect.width;}else{top=0;left=0;bottom=window.innerHeight;right=window.innerWidth;height=window.innerHeight;width=window.innerWidth;}if((relativeToContainingBlock||relativeToNonStaticParent)&&el!==window){container=container||el.parentNode;if(!IE11OrLess){do{if(container&&container.getBoundingClientRect&&(css(container,'transform')!=='none'||relativeToNonStaticParent&&css(container,'position')!=='static')){var containerRect=container.getBoundingClientRect();top-=containerRect.top+parseInt(css(container,'border-top-width'));left-=containerRect.left+parseInt(css(container,'border-left-width'));bottom=top+elRect.height;right=left+elRect.width;break;}}while(container=container.parentNode);}}if(undoScale&&el!==window){var elMatrix=matrix(container||el),scaleX=elMatrix&&elMatrix.a,scaleY=elMatrix&&elMatrix.d;if(elMatrix){top/=scaleY;left/=scaleX;width/=scaleX;height/=scaleY;bottom=top+height;right=left+width;}}return{top:top,left:left,bottom:bottom,right:right,width:width,height:height};}function isScrolledPast(el,elSide,parentSide){var parent=getParentAutoScrollElement(el,true),elSideVal=getRect(el)[elSide];while(parent){var parentSideVal=getRect(parent)[parentSide],visible=void 0;if(parentSide==='top'||parentSide==='left'){visible=elSideVal>=parentSideVal;}else{visible=elSideVal<=parentSideVal;}if(!visible)return parent;if(parent===getWindowScrollingElement())break;parent=getParentAutoScrollElement(parent,false);}return false;}function getChild(el,childNum,options){var currentChild=0,i=0,children=el.children;while(i<children.length){if(children[i].style.display!=='none'&&children[i]!==Sortable.ghost&&children[i]!==Sortable.dragged&&closest(children[i],options.draggable,el,false)){if(currentChild===childNum){return children[i];}currentChild++;}i++;}return null;}function lastChild(el,selector){var last=el.lastElementChild;while(last&&(last===Sortable.ghost||css(last,'display')==='none'||selector&&!sortable_core_esm_matches(last,selector))){last=last.previousElementSibling;}return last||null;}function sortable_core_esm_index(el,selector){var index=0;if(!el||!el.parentNode){return-1;}while(el=el.previousElementSibling){if(el.nodeName.toUpperCase()!=='TEMPLATE'&&el!==Sortable.clone&&(!selector||sortable_core_esm_matches(el,selector))){index++;}}return index;}function getRelativeScrollOffset(el){var offsetLeft=0,offsetTop=0,winScroller=getWindowScrollingElement();if(el){do{var elMatrix=matrix(el),scaleX=elMatrix.a,scaleY=elMatrix.d;offsetLeft+=el.scrollLeft*scaleX;offsetTop+=el.scrollTop*scaleY;}while(el!==winScroller&&(el=el.parentNode));}return[offsetLeft,offsetTop];}function indexOfObject(arr,obj){for(var i in arr){if(!arr.hasOwnProperty(i))continue;for(var key in obj){if(obj.hasOwnProperty(key)&&obj[key]===arr[i][key])return Number(i);}}return-1;}function getParentAutoScrollElement(el,includeSelf){if(!el||!el.getBoundingClientRect)return getWindowScrollingElement();var elem=el;var gotSelf=false;do{if(elem.clientWidth<elem.scrollWidth||elem.clientHeight<elem.scrollHeight){var elemCSS=css(elem);if(elem.clientWidth<elem.scrollWidth&&(elemCSS.overflowX=='auto'||elemCSS.overflowX=='scroll')||elem.clientHeight<elem.scrollHeight&&(elemCSS.overflowY=='auto'||elemCSS.overflowY=='scroll')){if(!elem.getBoundingClientRect||elem===document.body)return getWindowScrollingElement();if(gotSelf||includeSelf)return elem;gotSelf=true;}}}while(elem=elem.parentNode);return getWindowScrollingElement();}function extend(dst,src){if(dst&&src){for(var key in src){if(src.hasOwnProperty(key)){dst[key]=src[key];}}}return dst;}function isRectEqual(rect1,rect2){return Math.round(rect1.top)===Math.round(rect2.top)&&Math.round(rect1.left)===Math.round(rect2.left)&&Math.round(rect1.height)===Math.round(rect2.height)&&Math.round(rect1.width)===Math.round(rect2.width);}var _throttleTimeout;function sortable_core_esm_throttle(callback,ms){return function(){if(!_throttleTimeout){var args=arguments,_this=this;if(args.length===1){callback.call(_this,args[0]);}else{callback.apply(_this,args);}_throttleTimeout=setTimeout(function(){_throttleTimeout=void 0;},ms);}};}function cancelThrottle(){clearTimeout(_throttleTimeout);_throttleTimeout=void 0;}function scrollBy(el,x,y){el.scrollLeft+=x;el.scrollTop+=y;}function clone(el){var Polymer=window.Polymer;var $=window.jQuery||window.Zepto;if(Polymer&&Polymer.dom){return Polymer.dom(el).cloneNode(true);}else if($){return $(el).clone(true)[0];}else{return el.cloneNode(true);}}function setRect(el,rect){css(el,'position','absolute');css(el,'top',rect.top);css(el,'left',rect.left);css(el,'width',rect.width);css(el,'height',rect.height);}function unsetRect(el){css(el,'position','');css(el,'top','');css(el,'left','');css(el,'width','');css(el,'height','');}var sortable_core_esm_expando='Sortable'+new Date().getTime();function AnimationStateManager(){var animationStates=[],animationCallbackId;return{captureAnimationState:function(){animationStates=[];if(!this.options.animation)return;var children=[].slice.call(this.el.children);children.forEach(function(child){if(css(child,'display')==='none'||child===Sortable.ghost)return;animationStates.push({target:child,rect:getRect(child)});var fromRect=_objectSpread({},animationStates[animationStates.length-1].rect);if(child.thisAnimationDuration){var childMatrix=matrix(child,true);if(childMatrix){fromRect.top-=childMatrix.f;fromRect.left-=childMatrix.e;}}child.fromRect=fromRect;});},addAnimationState:function(state){animationStates.push(state);},removeAnimationState:function(target){animationStates.splice(indexOfObject(animationStates,{target:target}),1);},animateAll:function(callback){var _this=this;if(!this.options.animation){clearTimeout(animationCallbackId);if(typeof callback==='function')callback();return;}var animating=false,animationTime=0;animationStates.forEach(function(state){var time=0,target=state.target,fromRect=target.fromRect,toRect=getRect(target),prevFromRect=target.prevFromRect,prevToRect=target.prevToRect,animatingRect=state.rect,targetMatrix=matrix(target,true);if(targetMatrix){toRect.top-=targetMatrix.f;toRect.left-=targetMatrix.e;}target.toRect=toRect;if(target.thisAnimationDuration){if(isRectEqual(prevFromRect,toRect)&&!isRectEqual(fromRect,toRect)&&(animatingRect.top-toRect.top)/(animatingRect.left-toRect.left)===(fromRect.top-toRect.top)/(fromRect.left-toRect.left)){time=calculateRealTime(animatingRect,prevFromRect,prevToRect,_this.options);}}if(!isRectEqual(toRect,fromRect)){target.prevFromRect=fromRect;target.prevToRect=toRect;if(!time){time=_this.options.animation;}_this.animate(target,animatingRect,toRect,time);}if(time){animating=true;animationTime=Math.max(animationTime,time);clearTimeout(target.animationResetTimer);target.animationResetTimer=setTimeout(function(){target.animationTime=0;target.prevFromRect=null;target.fromRect=null;target.prevToRect=null;target.thisAnimationDuration=null;},time);target.thisAnimationDuration=time;}});clearTimeout(animationCallbackId);if(!animating){if(typeof callback==='function')callback();}else{animationCallbackId=setTimeout(function(){if(typeof callback==='function')callback();},animationTime);}animationStates=[];},animate:function(target,currentRect,toRect,duration){if(duration){css(target,'transition','');css(target,'transform','');var elMatrix=matrix(this.el),scaleX=elMatrix&&elMatrix.a,scaleY=elMatrix&&elMatrix.d,translateX=(currentRect.left-toRect.left)/(scaleX||1),translateY=(currentRect.top-toRect.top)/(scaleY||1);target.animatingX=!!translateX;target.animatingY=!!translateY;css(target,'transform','translate3d('+translateX+'px,'+translateY+'px,0)');this.forRepaintDummy=repaint(target);css(target,'transition','transform '+duration+'ms'+(this.options.easing?' '+this.options.easing:''));css(target,'transform','translate3d(0,0,0)');typeof target.animated==='number'&&clearTimeout(target.animated);target.animated=setTimeout(function(){css(target,'transition','');css(target,'transform','');target.animated=false;target.animatingX=false;target.animatingY=false;},duration);}}};}function repaint(target){return target.offsetWidth;}function calculateRealTime(animatingRect,fromRect,toRect,options){return Math.sqrt(Math.pow(fromRect.top-animatingRect.top,2)+Math.pow(fromRect.left-animatingRect.left,2))/Math.sqrt(Math.pow(fromRect.top-toRect.top,2)+Math.pow(fromRect.left-toRect.left,2))*options.animation;}var plugins=[];var sortable_core_esm_defaults={initializeByDefault:true};var PluginManager={mount:function(plugin){for(var option in sortable_core_esm_defaults){if(sortable_core_esm_defaults.hasOwnProperty(option)&&!(option in plugin)){plugin[option]=sortable_core_esm_defaults[option];}}plugins.forEach(function(p){if(p.pluginName===plugin.pluginName){throw"Sortable: Cannot mount plugin ".concat(plugin.pluginName," more than once");}});plugins.push(plugin);},pluginEvent:function(eventName,sortable,evt){var _this=this;this.eventCanceled=false;evt.cancel=function(){_this.eventCanceled=true;};var eventNameGlobal=eventName+'Global';plugins.forEach(function(plugin){if(!sortable[plugin.pluginName])return;if(sortable[plugin.pluginName][eventNameGlobal]){sortable[plugin.pluginName][eventNameGlobal](_objectSpread({sortable:sortable},evt));}if(sortable.options[plugin.pluginName]&&sortable[plugin.pluginName][eventName]){sortable[plugin.pluginName][eventName](_objectSpread({sortable:sortable},evt));}});},initializePlugins:function(sortable,el,defaults){plugins.forEach(function(plugin){var pluginName=plugin.pluginName;if(!sortable.options[pluginName]&&!plugin.initializeByDefault)return;var initialized=new plugin(sortable,el,sortable.options);initialized.sortable=sortable;initialized.options=sortable.options;sortable[pluginName]=initialized;_extends(defaults,initialized.defaults);});for(var option in sortable.options){if(!sortable.options.hasOwnProperty(option))continue;var modified=this.modifyOption(sortable,option,sortable.options[option]);if(typeof modified!=='undefined'){sortable.options[option]=modified;}}},getEventProperties:function(name,sortable){var eventProperties={};plugins.forEach(function(plugin){if(typeof plugin.eventProperties!=='function')return;_extends(eventProperties,plugin.eventProperties.call(sortable[plugin.pluginName],name));});return eventProperties;},modifyOption:function(sortable,name,value){var modifiedValue;plugins.forEach(function(plugin){if(!sortable[plugin.pluginName])return;if(plugin.optionListeners&&typeof plugin.optionListeners[name]==='function'){modifiedValue=plugin.optionListeners[name].call(sortable[plugin.pluginName],value);}});return modifiedValue;}};function dispatchEvent(_ref){var sortable=_ref.sortable,rootEl=_ref.rootEl,name=_ref.name,targetEl=_ref.targetEl,cloneEl=_ref.cloneEl,toEl=_ref.toEl,fromEl=_ref.fromEl,oldIndex=_ref.oldIndex,newIndex=_ref.newIndex,oldDraggableIndex=_ref.oldDraggableIndex,newDraggableIndex=_ref.newDraggableIndex,originalEvent=_ref.originalEvent,putSortable=_ref.putSortable,extraEventProperties=_ref.extraEventProperties;sortable=sortable||rootEl&&rootEl[sortable_core_esm_expando];if(!sortable)return;var evt,options=sortable.options,onName='on'+name.charAt(0).toUpperCase()+name.substr(1);if(window.CustomEvent&&!IE11OrLess&&!Edge){evt=new CustomEvent(name,{bubbles:true,cancelable:true});}else{evt=document.createEvent('Event');evt.initEvent(name,true,true);}evt.to=toEl||rootEl;evt.from=fromEl||rootEl;evt.item=targetEl||rootEl;evt.clone=cloneEl;evt.oldIndex=oldIndex;evt.newIndex=newIndex;evt.oldDraggableIndex=oldDraggableIndex;evt.newDraggableIndex=newDraggableIndex;evt.originalEvent=originalEvent;evt.pullMode=putSortable?putSortable.lastPutMode:undefined;var allEventProperties=_objectSpread({},extraEventProperties,PluginManager.getEventProperties(name,sortable));for(var option in allEventProperties){evt[option]=allEventProperties[option];}if(rootEl){rootEl.dispatchEvent(evt);}if(options[onName]){options[onName].call(sortable,evt);}}var pluginEvent=function(eventName,sortable){var _ref=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},originalEvent=_ref.evt,data=_objectWithoutProperties(_ref,["evt"]);PluginManager.pluginEvent.bind(Sortable)(eventName,sortable,_objectSpread({dragEl:dragEl,parentEl:parentEl,ghostEl:ghostEl,rootEl:rootEl,nextEl:nextEl,lastDownEl:lastDownEl,cloneEl:cloneEl,cloneHidden:cloneHidden,dragStarted:moved,putSortable:putSortable,activeSortable:Sortable.active,originalEvent:originalEvent,oldIndex:oldIndex,oldDraggableIndex:oldDraggableIndex,newIndex:sortable_core_esm_newIndex,newDraggableIndex:newDraggableIndex,hideGhostForTarget:_hideGhostForTarget,unhideGhostForTarget:_unhideGhostForTarget,cloneNowHidden:function(){cloneHidden=true;},cloneNowShown:function(){cloneHidden=false;},dispatchSortableEvent:function(name){_dispatchEvent({sortable:sortable,name:name,originalEvent:originalEvent});}},data));};function _dispatchEvent(info){dispatchEvent(_objectSpread({putSortable:putSortable,cloneEl:cloneEl,targetEl:dragEl,rootEl:rootEl,oldIndex:oldIndex,oldDraggableIndex:oldDraggableIndex,newIndex:sortable_core_esm_newIndex,newDraggableIndex:newDraggableIndex},info));}var dragEl,parentEl,ghostEl,rootEl,nextEl,lastDownEl,cloneEl,cloneHidden,oldIndex,sortable_core_esm_newIndex,oldDraggableIndex,newDraggableIndex,activeGroup,putSortable,awaitingDragStarted=false,ignoreNextClick=false,sortables=[],tapEvt,touchEvt,lastDx,lastDy,tapDistanceLeft,tapDistanceTop,moved,lastTarget,lastDirection,pastFirstInvertThresh=false,isCircumstantialInvert=false,targetMoveDistance,ghostRelativeParent,ghostRelativeParentInitialScroll=[],_silent=false,savedInputChecked=[];var documentExists=typeof document!=='undefined',PositionGhostAbsolutely=IOS,CSSFloatProperty=Edge||IE11OrLess?'cssFloat':'float',supportDraggable=documentExists&&!ChromeForAndroid&&!IOS&&'draggable'in document.createElement('div'),supportCssPointerEvents=function(){if(!documentExists)return;if(IE11OrLess){return false;}var el=document.createElement('x');el.style.cssText='pointer-events:auto';return el.style.pointerEvents==='auto';}(),_detectDirection=function(el,options){var elCSS=css(el),elWidth=parseInt(elCSS.width)-parseInt(elCSS.paddingLeft)-parseInt(elCSS.paddingRight)-parseInt(elCSS.borderLeftWidth)-parseInt(elCSS.borderRightWidth),child1=getChild(el,0,options),child2=getChild(el,1,options),firstChildCSS=child1&&css(child1),secondChildCSS=child2&&css(child2),firstChildWidth=firstChildCSS&&parseInt(firstChildCSS.marginLeft)+parseInt(firstChildCSS.marginRight)+getRect(child1).width,secondChildWidth=secondChildCSS&&parseInt(secondChildCSS.marginLeft)+parseInt(secondChildCSS.marginRight)+getRect(child2).width;if(elCSS.display==='flex'){return elCSS.flexDirection==='column'||elCSS.flexDirection==='column-reverse'?'vertical':'horizontal';}if(elCSS.display==='grid'){return elCSS.gridTemplateColumns.split(' ').length<=1?'vertical':'horizontal';}if(child1&&firstChildCSS["float"]&&firstChildCSS["float"]!=='none'){var touchingSideChild2=firstChildCSS["float"]==='left'?'left':'right';return child2&&(secondChildCSS.clear==='both'||secondChildCSS.clear===touchingSideChild2)?'vertical':'horizontal';}return child1&&(firstChildCSS.display==='block'||firstChildCSS.display==='flex'||firstChildCSS.display==='table'||firstChildCSS.display==='grid'||firstChildWidth>=elWidth&&elCSS[CSSFloatProperty]==='none'||child2&&elCSS[CSSFloatProperty]==='none'&&firstChildWidth+secondChildWidth>elWidth)?'vertical':'horizontal';},_dragElInRowColumn=function(dragRect,targetRect,vertical){var dragElS1Opp=vertical?dragRect.left:dragRect.top,dragElS2Opp=vertical?dragRect.right:dragRect.bottom,dragElOppLength=vertical?dragRect.width:dragRect.height,targetS1Opp=vertical?targetRect.left:targetRect.top,targetS2Opp=vertical?targetRect.right:targetRect.bottom,targetOppLength=vertical?targetRect.width:targetRect.height;return dragElS1Opp===targetS1Opp||dragElS2Opp===targetS2Opp||dragElS1Opp+dragElOppLength/2===targetS1Opp+targetOppLength/2;},_detectNearestEmptySortable=function(x,y){var ret;sortables.some(function(sortable){if(lastChild(sortable))return;var rect=getRect(sortable),threshold=sortable[sortable_core_esm_expando].options.emptyInsertThreshold,insideHorizontally=x>=rect.left-threshold&&x<=rect.right+threshold,insideVertically=y>=rect.top-threshold&&y<=rect.bottom+threshold;if(threshold&&insideHorizontally&&insideVertically){return ret=sortable;}});return ret;},_prepareGroup=function(options){function toFn(value,pull){return function(to,from,dragEl,evt){var sameGroup=to.options.group.name&&from.options.group.name&&to.options.group.name===from.options.group.name;if(value==null&&(pull||sameGroup)){return true;}else if(value==null||value===false){return false;}else if(pull&&value==='clone'){return value;}else if(typeof value==='function'){return toFn(value(to,from,dragEl,evt),pull)(to,from,dragEl,evt);}else{var otherGroup=(pull?to:from).options.group.name;return value===true||typeof value==='string'&&value===otherGroup||value.join&&value.indexOf(otherGroup)>-1;}};}var group={};var originalGroup=options.group;if(!originalGroup||_typeof(originalGroup)!='object'){originalGroup={name:originalGroup};}group.name=originalGroup.name;group.checkPull=toFn(originalGroup.pull,true);group.checkPut=toFn(originalGroup.put);group.revertClone=originalGroup.revertClone;options.group=group;},_hideGhostForTarget=function(){if(!supportCssPointerEvents&&ghostEl){css(ghostEl,'display','none');}},_unhideGhostForTarget=function(){if(!supportCssPointerEvents&&ghostEl){css(ghostEl,'display','');}};if(documentExists){document.addEventListener('click',function(evt){if(ignoreNextClick){evt.preventDefault();evt.stopPropagation&&evt.stopPropagation();evt.stopImmediatePropagation&&evt.stopImmediatePropagation();ignoreNextClick=false;return false;}},true);}var nearestEmptyInsertDetectEvent=function(evt){if(dragEl){evt=evt.touches?evt.touches[0]:evt;var nearest=_detectNearestEmptySortable(evt.clientX,evt.clientY);if(nearest){var event={};for(var i in evt){if(evt.hasOwnProperty(i)){event[i]=evt[i];}}event.target=event.rootEl=nearest;event.preventDefault=void 0;event.stopPropagation=void 0;nearest[sortable_core_esm_expando]._onDragOver(event);}}};var _checkOutsideTargetEl=function(evt){if(dragEl){dragEl.parentNode[sortable_core_esm_expando]._isOutsideThisEl(evt.target);}};function Sortable(el,options){if(!(el&&el.nodeType&&el.nodeType===1)){throw"Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));}this.el=el;this.options=options=_extends({},options);el[sortable_core_esm_expando]=this;var defaults={group:null,sort:true,disabled:false,store:null,handle:null,draggable:/^[uo]l$/i.test(el.nodeName)?'>li':'>*',swapThreshold:1,invertSwap:false,invertedSwapThreshold:null,removeCloneOnHide:true,direction:function(){return _detectDirection(el,this.options);},ghostClass:'sortable-ghost',chosenClass:'sortable-chosen',dragClass:'sortable-drag',ignore:'a, img',filter:null,preventOnFilter:true,animation:0,easing:null,setData:function(dataTransfer,dragEl){dataTransfer.setData('Text',dragEl.textContent);},dropBubble:false,dragoverBubble:false,dataIdAttr:'data-id',delay:0,delayOnTouchOnly:false,touchStartThreshold:(Number.parseInt?Number:window).parseInt(window.devicePixelRatio,10)||1,forceFallback:false,fallbackClass:'sortable-fallback',fallbackOnBody:false,fallbackTolerance:0,fallbackOffset:{x:0,y:0},supportPointer:Sortable.supportPointer!==false&&'PointerEvent'in window&&!Safari,emptyInsertThreshold:5};PluginManager.initializePlugins(this,el,defaults);for(var name in defaults){!(name in options)&&(options[name]=defaults[name]);}_prepareGroup(options);for(var fn in this){if(fn.charAt(0)==='_'&&typeof this[fn]==='function'){this[fn]=this[fn].bind(this);}}this.nativeDraggable=options.forceFallback?false:supportDraggable;if(this.nativeDraggable){this.options.touchStartThreshold=1;}if(options.supportPointer){sortable_core_esm_on(el,'pointerdown',this._onTapStart);}else{sortable_core_esm_on(el,'mousedown',this._onTapStart);sortable_core_esm_on(el,'touchstart',this._onTapStart);}if(this.nativeDraggable){sortable_core_esm_on(el,'dragover',this);sortable_core_esm_on(el,'dragenter',this);}sortables.push(this.el);options.store&&options.store.get&&this.sort(options.store.get(this)||[]);_extends(this,AnimationStateManager());}Sortable.prototype={constructor:Sortable,_isOutsideThisEl:function(target){if(!this.el.contains(target)&&target!==this.el){lastTarget=null;}},_getDirection:function(evt,target){return typeof this.options.direction==='function'?this.options.direction.call(this,evt,target,dragEl):this.options.direction;},_onTapStart:function(evt){if(!evt.cancelable)return;var _this=this,el=this.el,options=this.options,preventOnFilter=options.preventOnFilter,type=evt.type,touch=evt.touches&&evt.touches[0]||evt.pointerType&&evt.pointerType==='touch'&&evt,target=(touch||evt).target,originalTarget=evt.target.shadowRoot&&(evt.path&&evt.path[0]||evt.composedPath&&evt.composedPath()[0])||target,filter=options.filter;_saveInputCheckedState(el);if(dragEl){return;}if(/mousedown|pointerdown/.test(type)&&evt.button!==0||options.disabled){return;}if(originalTarget.isContentEditable){return;}if(!this.nativeDraggable&&Safari&&target&&target.tagName.toUpperCase()==='SELECT'){return;}target=closest(target,options.draggable,el,false);if(target&&target.animated){return;}if(lastDownEl===target){return;}oldIndex=sortable_core_esm_index(target);oldDraggableIndex=sortable_core_esm_index(target,options.draggable);if(typeof filter==='function'){if(filter.call(this,evt,target,this)){_dispatchEvent({sortable:_this,rootEl:originalTarget,name:'filter',targetEl:target,toEl:el,fromEl:el});pluginEvent('filter',_this,{evt:evt});preventOnFilter&&evt.cancelable&&evt.preventDefault();return;}}else if(filter){filter=filter.split(',').some(function(criteria){criteria=closest(originalTarget,criteria.trim(),el,false);if(criteria){_dispatchEvent({sortable:_this,rootEl:criteria,name:'filter',targetEl:target,fromEl:el,toEl:el});pluginEvent('filter',_this,{evt:evt});return true;}});if(filter){preventOnFilter&&evt.cancelable&&evt.preventDefault();return;}}if(options.handle&&!closest(originalTarget,options.handle,el,false)){return;}this._prepareDragStart(evt,touch,target);},_prepareDragStart:function(evt,touch,target){var _this=this,el=_this.el,options=_this.options,ownerDocument=el.ownerDocument,dragStartFn;if(target&&!dragEl&&target.parentNode===el){var dragRect=getRect(target);rootEl=el;dragEl=target;parentEl=dragEl.parentNode;nextEl=dragEl.nextSibling;lastDownEl=target;activeGroup=options.group;Sortable.dragged=dragEl;tapEvt={target:dragEl,clientX:(touch||evt).clientX,clientY:(touch||evt).clientY};tapDistanceLeft=tapEvt.clientX-dragRect.left;tapDistanceTop=tapEvt.clientY-dragRect.top;this._lastX=(touch||evt).clientX;this._lastY=(touch||evt).clientY;dragEl.style['will-change']='all';dragStartFn=function(){pluginEvent('delayEnded',_this,{evt:evt});if(Sortable.eventCanceled){_this._onDrop();return;}_this._disableDelayedDragEvents();if(!FireFox&&_this.nativeDraggable){dragEl.draggable=true;}_this._triggerDragStart(evt,touch);_dispatchEvent({sortable:_this,name:'choose',originalEvent:evt});toggleClass(dragEl,options.chosenClass,true);};options.ignore.split(',').forEach(function(criteria){find(dragEl,criteria.trim(),_disableDraggable);});sortable_core_esm_on(ownerDocument,'dragover',nearestEmptyInsertDetectEvent);sortable_core_esm_on(ownerDocument,'mousemove',nearestEmptyInsertDetectEvent);sortable_core_esm_on(ownerDocument,'touchmove',nearestEmptyInsertDetectEvent);sortable_core_esm_on(ownerDocument,'mouseup',_this._onDrop);sortable_core_esm_on(ownerDocument,'touchend',_this._onDrop);sortable_core_esm_on(ownerDocument,'touchcancel',_this._onDrop);if(FireFox&&this.nativeDraggable){this.options.touchStartThreshold=4;dragEl.draggable=true;}pluginEvent('delayStart',this,{evt:evt});if(options.delay&&(!options.delayOnTouchOnly||touch)&&(!this.nativeDraggable||!(Edge||IE11OrLess))){if(Sortable.eventCanceled){this._onDrop();return;}sortable_core_esm_on(ownerDocument,'mouseup',_this._disableDelayedDrag);sortable_core_esm_on(ownerDocument,'touchend',_this._disableDelayedDrag);sortable_core_esm_on(ownerDocument,'touchcancel',_this._disableDelayedDrag);sortable_core_esm_on(ownerDocument,'mousemove',_this._delayedDragTouchMoveHandler);sortable_core_esm_on(ownerDocument,'touchmove',_this._delayedDragTouchMoveHandler);options.supportPointer&&sortable_core_esm_on(ownerDocument,'pointermove',_this._delayedDragTouchMoveHandler);_this._dragStartTimer=setTimeout(dragStartFn,options.delay);}else{dragStartFn();}}},_delayedDragTouchMoveHandler:function(e){var touch=e.touches?e.touches[0]:e;if(Math.max(Math.abs(touch.clientX-this._lastX),Math.abs(touch.clientY-this._lastY))>=Math.floor(this.options.touchStartThreshold/(this.nativeDraggable&&window.devicePixelRatio||1))){this._disableDelayedDrag();}},_disableDelayedDrag:function(){dragEl&&_disableDraggable(dragEl);clearTimeout(this._dragStartTimer);this._disableDelayedDragEvents();},_disableDelayedDragEvents:function(){var ownerDocument=this.el.ownerDocument;sortable_core_esm_off(ownerDocument,'mouseup',this._disableDelayedDrag);sortable_core_esm_off(ownerDocument,'touchend',this._disableDelayedDrag);sortable_core_esm_off(ownerDocument,'touchcancel',this._disableDelayedDrag);sortable_core_esm_off(ownerDocument,'mousemove',this._delayedDragTouchMoveHandler);sortable_core_esm_off(ownerDocument,'touchmove',this._delayedDragTouchMoveHandler);sortable_core_esm_off(ownerDocument,'pointermove',this._delayedDragTouchMoveHandler);},_triggerDragStart:function(evt,touch){touch=touch||evt.pointerType=='touch'&&evt;if(!this.nativeDraggable||touch){if(this.options.supportPointer){sortable_core_esm_on(document,'pointermove',this._onTouchMove);}else if(touch){sortable_core_esm_on(document,'touchmove',this._onTouchMove);}else{sortable_core_esm_on(document,'mousemove',this._onTouchMove);}}else{sortable_core_esm_on(dragEl,'dragend',this);sortable_core_esm_on(rootEl,'dragstart',this._onDragStart);}try{if(document.selection){_nextTick(function(){document.selection.empty();});}else{window.getSelection().removeAllRanges();}}catch(err){}},_dragStarted:function(fallback,evt){awaitingDragStarted=false;if(rootEl&&dragEl){pluginEvent('dragStarted',this,{evt:evt});if(this.nativeDraggable){sortable_core_esm_on(document,'dragover',_checkOutsideTargetEl);}var options=this.options;!fallback&&toggleClass(dragEl,options.dragClass,false);toggleClass(dragEl,options.ghostClass,true);Sortable.active=this;fallback&&this._appendGhost();_dispatchEvent({sortable:this,name:'start',originalEvent:evt});}else{this._nulling();}},_emulateDragOver:function(){if(touchEvt){this._lastX=touchEvt.clientX;this._lastY=touchEvt.clientY;_hideGhostForTarget();var target=document.elementFromPoint(touchEvt.clientX,touchEvt.clientY);var parent=target;while(target&&target.shadowRoot){target=target.shadowRoot.elementFromPoint(touchEvt.clientX,touchEvt.clientY);if(target===parent)break;parent=target;}dragEl.parentNode[sortable_core_esm_expando]._isOutsideThisEl(target);if(parent){do{if(parent[sortable_core_esm_expando]){var inserted=void 0;inserted=parent[sortable_core_esm_expando]._onDragOver({clientX:touchEvt.clientX,clientY:touchEvt.clientY,target:target,rootEl:parent});if(inserted&&!this.options.dragoverBubble){break;}}target=parent;}while(parent=parent.parentNode);}_unhideGhostForTarget();}},_onTouchMove:function(evt){if(tapEvt){var options=this.options,fallbackTolerance=options.fallbackTolerance,fallbackOffset=options.fallbackOffset,touch=evt.touches?evt.touches[0]:evt,ghostMatrix=ghostEl&&matrix(ghostEl,true),scaleX=ghostEl&&ghostMatrix&&ghostMatrix.a,scaleY=ghostEl&&ghostMatrix&&ghostMatrix.d,relativeScrollOffset=PositionGhostAbsolutely&&ghostRelativeParent&&getRelativeScrollOffset(ghostRelativeParent),dx=(touch.clientX-tapEvt.clientX+fallbackOffset.x)/(scaleX||1)+(relativeScrollOffset?relativeScrollOffset[0]-ghostRelativeParentInitialScroll[0]:0)/(scaleX||1),dy=(touch.clientY-tapEvt.clientY+fallbackOffset.y)/(scaleY||1)+(relativeScrollOffset?relativeScrollOffset[1]-ghostRelativeParentInitialScroll[1]:0)/(scaleY||1);if(!Sortable.active&&!awaitingDragStarted){if(fallbackTolerance&&Math.max(Math.abs(touch.clientX-this._lastX),Math.abs(touch.clientY-this._lastY))<fallbackTolerance){return;}this._onDragStart(evt,true);}if(ghostEl){if(ghostMatrix){ghostMatrix.e+=dx-(lastDx||0);ghostMatrix.f+=dy-(lastDy||0);}else{ghostMatrix={a:1,b:0,c:0,d:1,e:dx,f:dy};}var cssMatrix="matrix(".concat(ghostMatrix.a,",").concat(ghostMatrix.b,",").concat(ghostMatrix.c,",").concat(ghostMatrix.d,",").concat(ghostMatrix.e,",").concat(ghostMatrix.f,")");css(ghostEl,'webkitTransform',cssMatrix);css(ghostEl,'mozTransform',cssMatrix);css(ghostEl,'msTransform',cssMatrix);css(ghostEl,'transform',cssMatrix);lastDx=dx;lastDy=dy;touchEvt=touch;}evt.cancelable&&evt.preventDefault();}},_appendGhost:function(){if(!ghostEl){var container=this.options.fallbackOnBody?document.body:rootEl,rect=getRect(dragEl,true,PositionGhostAbsolutely,true,container),options=this.options;if(PositionGhostAbsolutely){ghostRelativeParent=container;while(css(ghostRelativeParent,'position')==='static'&&css(ghostRelativeParent,'transform')==='none'&&ghostRelativeParent!==document){ghostRelativeParent=ghostRelativeParent.parentNode;}if(ghostRelativeParent!==document.body&&ghostRelativeParent!==document.documentElement){if(ghostRelativeParent===document)ghostRelativeParent=getWindowScrollingElement();rect.top+=ghostRelativeParent.scrollTop;rect.left+=ghostRelativeParent.scrollLeft;}else{ghostRelativeParent=getWindowScrollingElement();}ghostRelativeParentInitialScroll=getRelativeScrollOffset(ghostRelativeParent);}ghostEl=dragEl.cloneNode(true);toggleClass(ghostEl,options.ghostClass,false);toggleClass(ghostEl,options.fallbackClass,true);toggleClass(ghostEl,options.dragClass,true);css(ghostEl,'transition','');css(ghostEl,'transform','');css(ghostEl,'box-sizing','border-box');css(ghostEl,'margin',0);css(ghostEl,'top',rect.top);css(ghostEl,'left',rect.left);css(ghostEl,'width',rect.width);css(ghostEl,'height',rect.height);css(ghostEl,'opacity','0.8');css(ghostEl,'position',PositionGhostAbsolutely?'absolute':'fixed');css(ghostEl,'zIndex','100000');css(ghostEl,'pointerEvents','none');Sortable.ghost=ghostEl;container.appendChild(ghostEl);css(ghostEl,'transform-origin',tapDistanceLeft/parseInt(ghostEl.style.width)*100+'% '+tapDistanceTop/parseInt(ghostEl.style.height)*100+'%');}},_onDragStart:function(evt,fallback){var _this=this;var dataTransfer=evt.dataTransfer;var options=_this.options;pluginEvent('dragStart',this,{evt:evt});if(Sortable.eventCanceled){this._onDrop();return;}pluginEvent('setupClone',this);if(!Sortable.eventCanceled){cloneEl=clone(dragEl);cloneEl.draggable=false;cloneEl.style['will-change']='';this._hideClone();toggleClass(cloneEl,this.options.chosenClass,false);Sortable.clone=cloneEl;}_this.cloneId=_nextTick(function(){pluginEvent('clone',_this);if(Sortable.eventCanceled)return;if(!_this.options.removeCloneOnHide){rootEl.insertBefore(cloneEl,dragEl);}_this._hideClone();_dispatchEvent({sortable:_this,name:'clone'});});!fallback&&toggleClass(dragEl,options.dragClass,true);if(fallback){ignoreNextClick=true;_this._loopId=setInterval(_this._emulateDragOver,50);}else{sortable_core_esm_off(document,'mouseup',_this._onDrop);sortable_core_esm_off(document,'touchend',_this._onDrop);sortable_core_esm_off(document,'touchcancel',_this._onDrop);if(dataTransfer){dataTransfer.effectAllowed='move';options.setData&&options.setData.call(_this,dataTransfer,dragEl);}sortable_core_esm_on(document,'drop',_this);css(dragEl,'transform','translateZ(0)');}awaitingDragStarted=true;_this._dragStartId=_nextTick(_this._dragStarted.bind(_this,fallback,evt));sortable_core_esm_on(document,'selectstart',_this);moved=true;if(Safari){css(document.body,'user-select','none');}},_onDragOver:function(evt){var el=this.el,target=evt.target,dragRect,targetRect,revert,options=this.options,group=options.group,activeSortable=Sortable.active,isOwner=activeGroup===group,canSort=options.sort,fromSortable=putSortable||activeSortable,vertical,_this=this,completedFired=false;if(_silent)return;function dragOverEvent(name,extra){pluginEvent(name,_this,_objectSpread({evt:evt,isOwner:isOwner,axis:vertical?'vertical':'horizontal',revert:revert,dragRect:dragRect,targetRect:targetRect,canSort:canSort,fromSortable:fromSortable,target:target,completed:completed,onMove:function(target,after){return _onMove(rootEl,el,dragEl,dragRect,target,getRect(target),evt,after);},changed:changed},extra));}function capture(){dragOverEvent('dragOverAnimationCapture');_this.captureAnimationState();if(_this!==fromSortable){fromSortable.captureAnimationState();}}function completed(insertion){dragOverEvent('dragOverCompleted',{insertion:insertion});if(insertion){if(isOwner){activeSortable._hideClone();}else{activeSortable._showClone(_this);}if(_this!==fromSortable){toggleClass(dragEl,putSortable?putSortable.options.ghostClass:activeSortable.options.ghostClass,false);toggleClass(dragEl,options.ghostClass,true);}if(putSortable!==_this&&_this!==Sortable.active){putSortable=_this;}else if(_this===Sortable.active&&putSortable){putSortable=null;}if(fromSortable===_this){_this._ignoreWhileAnimating=target;}_this.animateAll(function(){dragOverEvent('dragOverAnimationComplete');_this._ignoreWhileAnimating=null;});if(_this!==fromSortable){fromSortable.animateAll();fromSortable._ignoreWhileAnimating=null;}}if(target===dragEl&&!dragEl.animated||target===el&&!target.animated){lastTarget=null;}if(!options.dragoverBubble&&!evt.rootEl&&target!==document){dragEl.parentNode[sortable_core_esm_expando]._isOutsideThisEl(evt.target);!insertion&&nearestEmptyInsertDetectEvent(evt);}!options.dragoverBubble&&evt.stopPropagation&&evt.stopPropagation();return completedFired=true;}function changed(){sortable_core_esm_newIndex=sortable_core_esm_index(dragEl);newDraggableIndex=sortable_core_esm_index(dragEl,options.draggable);_dispatchEvent({sortable:_this,name:'change',toEl:el,newIndex:sortable_core_esm_newIndex,newDraggableIndex:newDraggableIndex,originalEvent:evt});}if(evt.preventDefault!==void 0){evt.cancelable&&evt.preventDefault();}target=closest(target,options.draggable,el,true);dragOverEvent('dragOver');if(Sortable.eventCanceled)return completedFired;if(dragEl.contains(evt.target)||target.animated&&target.animatingX&&target.animatingY||_this._ignoreWhileAnimating===target){return completed(false);}ignoreNextClick=false;if(activeSortable&&!options.disabled&&(isOwner?canSort||(revert=!rootEl.contains(dragEl)):putSortable===this||(this.lastPutMode=activeGroup.checkPull(this,activeSortable,dragEl,evt))&&group.checkPut(this,activeSortable,dragEl,evt))){vertical=this._getDirection(evt,target)==='vertical';dragRect=getRect(dragEl);dragOverEvent('dragOverValid');if(Sortable.eventCanceled)return completedFired;if(revert){parentEl=rootEl;capture();this._hideClone();dragOverEvent('revert');if(!Sortable.eventCanceled){if(nextEl){rootEl.insertBefore(dragEl,nextEl);}else{rootEl.appendChild(dragEl);}}return completed(true);}var elLastChild=lastChild(el,options.draggable);if(!elLastChild||_ghostIsLast(evt,vertical,this)&&!elLastChild.animated){if(elLastChild===dragEl){return completed(false);}if(elLastChild&&el===evt.target){target=elLastChild;}if(target){targetRect=getRect(target);}if(_onMove(rootEl,el,dragEl,dragRect,target,targetRect,evt,!!target)!==false){capture();el.appendChild(dragEl);parentEl=el;changed();return completed(true);}}else if(target.parentNode===el){targetRect=getRect(target);var direction=0,targetBeforeFirstSwap,differentLevel=dragEl.parentNode!==el,differentRowCol=!_dragElInRowColumn(dragEl.animated&&dragEl.toRect||dragRect,target.animated&&target.toRect||targetRect,vertical),side1=vertical?'top':'left',scrolledPastTop=isScrolledPast(target,'top','top')||isScrolledPast(dragEl,'top','top'),scrollBefore=scrolledPastTop?scrolledPastTop.scrollTop:void 0;if(lastTarget!==target){targetBeforeFirstSwap=targetRect[side1];pastFirstInvertThresh=false;isCircumstantialInvert=!differentRowCol&&options.invertSwap||differentLevel;}direction=_getSwapDirection(evt,target,targetRect,vertical,differentRowCol?1:options.swapThreshold,options.invertedSwapThreshold==null?options.swapThreshold:options.invertedSwapThreshold,isCircumstantialInvert,lastTarget===target);var sibling;if(direction!==0){var dragIndex=sortable_core_esm_index(dragEl);do{dragIndex-=direction;sibling=parentEl.children[dragIndex];}while(sibling&&(css(sibling,'display')==='none'||sibling===ghostEl));}if(direction===0||sibling===target){return completed(false);}lastTarget=target;lastDirection=direction;var nextSibling=target.nextElementSibling,after=false;after=direction===1;var moveVector=_onMove(rootEl,el,dragEl,dragRect,target,targetRect,evt,after);if(moveVector!==false){if(moveVector===1||moveVector===-1){after=moveVector===1;}_silent=true;setTimeout(_unsilent,30);capture();if(after&&!nextSibling){el.appendChild(dragEl);}else{target.parentNode.insertBefore(dragEl,after?nextSibling:target);}if(scrolledPastTop){scrollBy(scrolledPastTop,0,scrollBefore-scrolledPastTop.scrollTop);}parentEl=dragEl.parentNode;if(targetBeforeFirstSwap!==undefined&&!isCircumstantialInvert){targetMoveDistance=Math.abs(targetBeforeFirstSwap-getRect(target)[side1]);}changed();return completed(true);}}if(el.contains(dragEl)){return completed(false);}}return false;},_ignoreWhileAnimating:null,_offMoveEvents:function(){sortable_core_esm_off(document,'mousemove',this._onTouchMove);sortable_core_esm_off(document,'touchmove',this._onTouchMove);sortable_core_esm_off(document,'pointermove',this._onTouchMove);sortable_core_esm_off(document,'dragover',nearestEmptyInsertDetectEvent);sortable_core_esm_off(document,'mousemove',nearestEmptyInsertDetectEvent);sortable_core_esm_off(document,'touchmove',nearestEmptyInsertDetectEvent);},_offUpEvents:function(){var ownerDocument=this.el.ownerDocument;sortable_core_esm_off(ownerDocument,'mouseup',this._onDrop);sortable_core_esm_off(ownerDocument,'touchend',this._onDrop);sortable_core_esm_off(ownerDocument,'pointerup',this._onDrop);sortable_core_esm_off(ownerDocument,'touchcancel',this._onDrop);sortable_core_esm_off(document,'selectstart',this);},_onDrop:function(evt){var el=this.el,options=this.options;sortable_core_esm_newIndex=sortable_core_esm_index(dragEl);newDraggableIndex=sortable_core_esm_index(dragEl,options.draggable);pluginEvent('drop',this,{evt:evt});parentEl=dragEl&&dragEl.parentNode;sortable_core_esm_newIndex=sortable_core_esm_index(dragEl);newDraggableIndex=sortable_core_esm_index(dragEl,options.draggable);if(Sortable.eventCanceled){this._nulling();return;}awaitingDragStarted=false;isCircumstantialInvert=false;pastFirstInvertThresh=false;clearInterval(this._loopId);clearTimeout(this._dragStartTimer);_cancelNextTick(this.cloneId);_cancelNextTick(this._dragStartId);if(this.nativeDraggable){sortable_core_esm_off(document,'drop',this);sortable_core_esm_off(el,'dragstart',this._onDragStart);}this._offMoveEvents();this._offUpEvents();if(Safari){css(document.body,'user-select','');}css(dragEl,'transform','');if(evt){if(moved){evt.cancelable&&evt.preventDefault();!options.dropBubble&&evt.stopPropagation();}ghostEl&&ghostEl.parentNode&&ghostEl.parentNode.removeChild(ghostEl);if(rootEl===parentEl||putSortable&&putSortable.lastPutMode!=='clone'){cloneEl&&cloneEl.parentNode&&cloneEl.parentNode.removeChild(cloneEl);}if(dragEl){if(this.nativeDraggable){sortable_core_esm_off(dragEl,'dragend',this);}_disableDraggable(dragEl);dragEl.style['will-change']='';if(moved&&!awaitingDragStarted){toggleClass(dragEl,putSortable?putSortable.options.ghostClass:this.options.ghostClass,false);}toggleClass(dragEl,this.options.chosenClass,false);_dispatchEvent({sortable:this,name:'unchoose',toEl:parentEl,newIndex:null,newDraggableIndex:null,originalEvent:evt});if(rootEl!==parentEl){if(sortable_core_esm_newIndex>=0){_dispatchEvent({rootEl:parentEl,name:'add',toEl:parentEl,fromEl:rootEl,originalEvent:evt});_dispatchEvent({sortable:this,name:'remove',toEl:parentEl,originalEvent:evt});_dispatchEvent({rootEl:parentEl,name:'sort',toEl:parentEl,fromEl:rootEl,originalEvent:evt});_dispatchEvent({sortable:this,name:'sort',toEl:parentEl,originalEvent:evt});}putSortable&&putSortable.save();}else{if(sortable_core_esm_newIndex!==oldIndex){if(sortable_core_esm_newIndex>=0){_dispatchEvent({sortable:this,name:'update',toEl:parentEl,originalEvent:evt});_dispatchEvent({sortable:this,name:'sort',toEl:parentEl,originalEvent:evt});}}}if(Sortable.active){if(sortable_core_esm_newIndex==null||sortable_core_esm_newIndex===-1){sortable_core_esm_newIndex=oldIndex;newDraggableIndex=oldDraggableIndex;}_dispatchEvent({sortable:this,name:'end',toEl:parentEl,originalEvent:evt});this.save();}}}this._nulling();},_nulling:function(){pluginEvent('nulling',this);rootEl=dragEl=parentEl=ghostEl=nextEl=cloneEl=lastDownEl=cloneHidden=tapEvt=touchEvt=moved=sortable_core_esm_newIndex=newDraggableIndex=oldIndex=oldDraggableIndex=lastTarget=lastDirection=putSortable=activeGroup=Sortable.dragged=Sortable.ghost=Sortable.clone=Sortable.active=null;savedInputChecked.forEach(function(el){el.checked=true;});savedInputChecked.length=lastDx=lastDy=0;},handleEvent:function(evt){switch(evt.type){case'drop':case'dragend':this._onDrop(evt);break;case'dragenter':case'dragover':if(dragEl){this._onDragOver(evt);_globalDragOver(evt);}break;case'selectstart':evt.preventDefault();break;}},toArray:function(){var order=[],el,children=this.el.children,i=0,n=children.length,options=this.options;for(;i<n;i++){el=children[i];if(closest(el,options.draggable,this.el,false)){order.push(el.getAttribute(options.dataIdAttr)||_generateId(el));}}return order;},sort:function(order,useAnimation){var items={},rootEl=this.el;this.toArray().forEach(function(id,i){var el=rootEl.children[i];if(closest(el,this.options.draggable,rootEl,false)){items[id]=el;}},this);useAnimation&&this.captureAnimationState();order.forEach(function(id){if(items[id]){rootEl.removeChild(items[id]);rootEl.appendChild(items[id]);}});useAnimation&&this.animateAll();},save:function(){var store=this.options.store;store&&store.set&&store.set(this);},closest:function(el,selector){return closest(el,selector||this.options.draggable,this.el,false);},option:function(name,value){var options=this.options;if(value===void 0){return options[name];}else{var modifiedValue=PluginManager.modifyOption(this,name,value);if(typeof modifiedValue!=='undefined'){options[name]=modifiedValue;}else{options[name]=value;}if(name==='group'){_prepareGroup(options);}}},destroy:function(){pluginEvent('destroy',this);var el=this.el;el[sortable_core_esm_expando]=null;sortable_core_esm_off(el,'mousedown',this._onTapStart);sortable_core_esm_off(el,'touchstart',this._onTapStart);sortable_core_esm_off(el,'pointerdown',this._onTapStart);if(this.nativeDraggable){sortable_core_esm_off(el,'dragover',this);sortable_core_esm_off(el,'dragenter',this);}Array.prototype.forEach.call(el.querySelectorAll('[draggable]'),function(el){el.removeAttribute('draggable');});this._onDrop();this._disableDelayedDragEvents();sortables.splice(sortables.indexOf(this.el),1);this.el=el=null;},_hideClone:function(){if(!cloneHidden){pluginEvent('hideClone',this);if(Sortable.eventCanceled)return;css(cloneEl,'display','none');if(this.options.removeCloneOnHide&&cloneEl.parentNode){cloneEl.parentNode.removeChild(cloneEl);}cloneHidden=true;}},_showClone:function(putSortable){if(putSortable.lastPutMode!=='clone'){this._hideClone();return;}if(cloneHidden){pluginEvent('showClone',this);if(Sortable.eventCanceled)return;if(dragEl.parentNode==rootEl&&!this.options.group.revertClone){rootEl.insertBefore(cloneEl,dragEl);}else if(nextEl){rootEl.insertBefore(cloneEl,nextEl);}else{rootEl.appendChild(cloneEl);}if(this.options.group.revertClone){this.animate(dragEl,cloneEl);}css(cloneEl,'display','');cloneHidden=false;}}};function _globalDragOver(evt){if(evt.dataTransfer){evt.dataTransfer.dropEffect='move';}evt.cancelable&&evt.preventDefault();}function _onMove(fromEl,toEl,dragEl,dragRect,targetEl,targetRect,originalEvent,willInsertAfter){var evt,sortable=fromEl[sortable_core_esm_expando],onMoveFn=sortable.options.onMove,retVal;if(window.CustomEvent&&!IE11OrLess&&!Edge){evt=new CustomEvent('move',{bubbles:true,cancelable:true});}else{evt=document.createEvent('Event');evt.initEvent('move',true,true);}evt.to=toEl;evt.from=fromEl;evt.dragged=dragEl;evt.draggedRect=dragRect;evt.related=targetEl||toEl;evt.relatedRect=targetRect||getRect(toEl);evt.willInsertAfter=willInsertAfter;evt.originalEvent=originalEvent;fromEl.dispatchEvent(evt);if(onMoveFn){retVal=onMoveFn.call(sortable,evt,originalEvent);}return retVal;}function _disableDraggable(el){el.draggable=false;}function _unsilent(){_silent=false;}function _ghostIsLast(evt,vertical,sortable){var rect=getRect(lastChild(sortable.el,sortable.options.draggable));var spacer=10;return vertical?evt.clientX>rect.right+spacer||evt.clientX<=rect.right&&evt.clientY>rect.bottom&&evt.clientX>=rect.left:evt.clientX>rect.right&&evt.clientY>rect.top||evt.clientX<=rect.right&&evt.clientY>rect.bottom+spacer;}function _getSwapDirection(evt,target,targetRect,vertical,swapThreshold,invertedSwapThreshold,invertSwap,isLastTarget){var mouseOnAxis=vertical?evt.clientY:evt.clientX,targetLength=vertical?targetRect.height:targetRect.width,targetS1=vertical?targetRect.top:targetRect.left,targetS2=vertical?targetRect.bottom:targetRect.right,invert=false;if(!invertSwap){if(isLastTarget&&targetMoveDistance<targetLength*swapThreshold){if(!pastFirstInvertThresh&&(lastDirection===1?mouseOnAxis>targetS1+targetLength*invertedSwapThreshold/2:mouseOnAxis<targetS2-targetLength*invertedSwapThreshold/2)){pastFirstInvertThresh=true;}if(!pastFirstInvertThresh){if(lastDirection===1?mouseOnAxis<targetS1+targetMoveDistance:mouseOnAxis>targetS2-targetMoveDistance){return-lastDirection;}}else{invert=true;}}else{if(mouseOnAxis>targetS1+targetLength*(1-swapThreshold)/2&&mouseOnAxis<targetS2-targetLength*(1-swapThreshold)/2){return _getInsertDirection(target);}}}invert=invert||invertSwap;if(invert){if(mouseOnAxis<targetS1+targetLength*invertedSwapThreshold/2||mouseOnAxis>targetS2-targetLength*invertedSwapThreshold/2){return mouseOnAxis>targetS1+targetLength/2?1:-1;}}return 0;}function _getInsertDirection(target){if(sortable_core_esm_index(dragEl)<sortable_core_esm_index(target)){return 1;}else{return-1;}}function _generateId(el){var str=el.tagName+el.className+el.src+el.href+el.textContent,i=str.length,sum=0;while(i--){sum+=str.charCodeAt(i);}return sum.toString(36);}function _saveInputCheckedState(root){savedInputChecked.length=0;var inputs=root.getElementsByTagName('input');var idx=inputs.length;while(idx--){var el=inputs[idx];el.checked&&savedInputChecked.push(el);}}function _nextTick(fn){return setTimeout(fn,0);}function _cancelNextTick(id){return clearTimeout(id);}if(documentExists){sortable_core_esm_on(document,'touchmove',function(evt){if((Sortable.active||awaitingDragStarted)&&evt.cancelable){evt.preventDefault();}});}Sortable.utils={on:sortable_core_esm_on,off:sortable_core_esm_off,css:css,find:find,is:function(el,selector){return!!closest(el,selector,el,false);},extend:extend,throttle:sortable_core_esm_throttle,closest:closest,toggleClass:toggleClass,clone:clone,index:sortable_core_esm_index,nextTick:_nextTick,cancelNextTick:_cancelNextTick,detectDirection:_detectDirection,getChild:getChild};Sortable.get=function(element){return element[sortable_core_esm_expando];};Sortable.mount=function(){for(var _len=arguments.length,plugins=new Array(_len),_key=0;_key<_len;_key++){plugins[_key]=arguments[_key];}if(plugins[0].constructor===Array)plugins=plugins[0];plugins.forEach(function(plugin){if(!plugin.prototype||!plugin.prototype.constructor){throw"Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));}if(plugin.utils)Sortable.utils=_objectSpread({},Sortable.utils,plugin.utils);PluginManager.mount(plugin);});};Sortable.create=function(el,options){return new Sortable(el,options);};Sortable.version=sortable_core_esm_version;var autoScrolls=[],scrollEl,scrollRootEl,scrolling=false,lastAutoScrollX,lastAutoScrollY,touchEvt$1,pointerElemChangedInterval;function AutoScrollPlugin(){function AutoScroll(){this.defaults={scroll:true,scrollSensitivity:30,scrollSpeed:10,bubbleScroll:true};for(var fn in this){if(fn.charAt(0)==='_'&&typeof this[fn]==='function'){this[fn]=this[fn].bind(this);}}}AutoScroll.prototype={dragStarted:function(_ref){var originalEvent=_ref.originalEvent;if(this.sortable.nativeDraggable){sortable_core_esm_on(document,'dragover',this._handleAutoScroll);}else{if(this.options.supportPointer){sortable_core_esm_on(document,'pointermove',this._handleFallbackAutoScroll);}else if(originalEvent.touches){sortable_core_esm_on(document,'touchmove',this._handleFallbackAutoScroll);}else{sortable_core_esm_on(document,'mousemove',this._handleFallbackAutoScroll);}}},dragOverCompleted:function(_ref2){var originalEvent=_ref2.originalEvent;if(!this.options.dragOverBubble&&!originalEvent.rootEl){this._handleAutoScroll(originalEvent);}},drop:function(){if(this.sortable.nativeDraggable){sortable_core_esm_off(document,'dragover',this._handleAutoScroll);}else{sortable_core_esm_off(document,'pointermove',this._handleFallbackAutoScroll);sortable_core_esm_off(document,'touchmove',this._handleFallbackAutoScroll);sortable_core_esm_off(document,'mousemove',this._handleFallbackAutoScroll);}clearPointerElemChangedInterval();clearAutoScrolls();cancelThrottle();},nulling:function(){touchEvt$1=scrollRootEl=scrollEl=scrolling=pointerElemChangedInterval=lastAutoScrollX=lastAutoScrollY=null;autoScrolls.length=0;},_handleFallbackAutoScroll:function(evt){this._handleAutoScroll(evt,true);},_handleAutoScroll:function(evt,fallback){var _this=this;var x=(evt.touches?evt.touches[0]:evt).clientX,y=(evt.touches?evt.touches[0]:evt).clientY,elem=document.elementFromPoint(x,y);touchEvt$1=evt;if(fallback||Edge||IE11OrLess||Safari){autoScroll(evt,this.options,elem,fallback);var ogElemScroller=getParentAutoScrollElement(elem,true);if(scrolling&&(!pointerElemChangedInterval||x!==lastAutoScrollX||y!==lastAutoScrollY)){pointerElemChangedInterval&&clearPointerElemChangedInterval();pointerElemChangedInterval=setInterval(function(){var newElem=getParentAutoScrollElement(document.elementFromPoint(x,y),true);if(newElem!==ogElemScroller){ogElemScroller=newElem;clearAutoScrolls();}autoScroll(evt,_this.options,newElem,fallback);},10);lastAutoScrollX=x;lastAutoScrollY=y;}}else{if(!this.options.bubbleScroll||getParentAutoScrollElement(elem,true)===getWindowScrollingElement()){clearAutoScrolls();return;}autoScroll(evt,this.options,getParentAutoScrollElement(elem,false),false);}}};return _extends(AutoScroll,{pluginName:'scroll',initializeByDefault:true});}function clearAutoScrolls(){autoScrolls.forEach(function(autoScroll){clearInterval(autoScroll.pid);});autoScrolls=[];}function clearPointerElemChangedInterval(){clearInterval(pointerElemChangedInterval);}var autoScroll=sortable_core_esm_throttle(function(evt,options,rootEl,isFallback){if(!options.scroll)return;var x=(evt.touches?evt.touches[0]:evt).clientX,y=(evt.touches?evt.touches[0]:evt).clientY,sens=options.scrollSensitivity,speed=options.scrollSpeed,winScroller=getWindowScrollingElement();var scrollThisInstance=false,scrollCustomFn;if(scrollRootEl!==rootEl){scrollRootEl=rootEl;clearAutoScrolls();scrollEl=options.scroll;scrollCustomFn=options.scrollFn;if(scrollEl===true){scrollEl=getParentAutoScrollElement(rootEl,true);}}var layersOut=0;var currentParent=scrollEl;do{var el=currentParent,rect=getRect(el),top=rect.top,bottom=rect.bottom,left=rect.left,right=rect.right,width=rect.width,height=rect.height,canScrollX=void 0,canScrollY=void 0,scrollWidth=el.scrollWidth,scrollHeight=el.scrollHeight,elCSS=css(el),scrollPosX=el.scrollLeft,scrollPosY=el.scrollTop;if(el===winScroller){canScrollX=width<scrollWidth&&(elCSS.overflowX==='auto'||elCSS.overflowX==='scroll'||elCSS.overflowX==='visible');canScrollY=height<scrollHeight&&(elCSS.overflowY==='auto'||elCSS.overflowY==='scroll'||elCSS.overflowY==='visible');}else{canScrollX=width<scrollWidth&&(elCSS.overflowX==='auto'||elCSS.overflowX==='scroll');canScrollY=height<scrollHeight&&(elCSS.overflowY==='auto'||elCSS.overflowY==='scroll');}var vx=canScrollX&&(Math.abs(right-x)<=sens&&scrollPosX+width<scrollWidth)-(Math.abs(left-x)<=sens&&!!scrollPosX);var vy=canScrollY&&(Math.abs(bottom-y)<=sens&&scrollPosY+height<scrollHeight)-(Math.abs(top-y)<=sens&&!!scrollPosY);if(!autoScrolls[layersOut]){for(var i=0;i<=layersOut;i++){if(!autoScrolls[i]){autoScrolls[i]={};}}}if(autoScrolls[layersOut].vx!=vx||autoScrolls[layersOut].vy!=vy||autoScrolls[layersOut].el!==el){autoScrolls[layersOut].el=el;autoScrolls[layersOut].vx=vx;autoScrolls[layersOut].vy=vy;clearInterval(autoScrolls[layersOut].pid);if(vx!=0||vy!=0){scrollThisInstance=true;autoScrolls[layersOut].pid=setInterval(function(){if(isFallback&&this.layer===0){Sortable.active._onTouchMove(touchEvt$1);}var scrollOffsetY=autoScrolls[this.layer].vy?autoScrolls[this.layer].vy*speed:0;var scrollOffsetX=autoScrolls[this.layer].vx?autoScrolls[this.layer].vx*speed:0;if(typeof scrollCustomFn==='function'){if(scrollCustomFn.call(Sortable.dragged.parentNode[sortable_core_esm_expando],scrollOffsetX,scrollOffsetY,evt,touchEvt$1,autoScrolls[this.layer].el)!=='continue'){return;}}scrollBy(autoScrolls[this.layer].el,scrollOffsetX,scrollOffsetY);}.bind({layer:layersOut}),24);}}layersOut++;}while(options.bubbleScroll&&currentParent!==winScroller&&(currentParent=getParentAutoScrollElement(currentParent,false)));scrolling=scrollThisInstance;},30);var drop=function(_ref){var originalEvent=_ref.originalEvent,putSortable=_ref.putSortable,dragEl=_ref.dragEl,activeSortable=_ref.activeSortable,dispatchSortableEvent=_ref.dispatchSortableEvent,hideGhostForTarget=_ref.hideGhostForTarget,unhideGhostForTarget=_ref.unhideGhostForTarget;if(!originalEvent)return;var toSortable=putSortable||activeSortable;hideGhostForTarget();var touch=originalEvent.changedTouches&&originalEvent.changedTouches.length?originalEvent.changedTouches[0]:originalEvent;var target=document.elementFromPoint(touch.clientX,touch.clientY);unhideGhostForTarget();if(toSortable&&!toSortable.el.contains(target)){dispatchSortableEvent('spill');this.onSpill({dragEl:dragEl,putSortable:putSortable});}};function Revert(){}Revert.prototype={startIndex:null,dragStart:function(_ref2){var oldDraggableIndex=_ref2.oldDraggableIndex;this.startIndex=oldDraggableIndex;},onSpill:function(_ref3){var dragEl=_ref3.dragEl,putSortable=_ref3.putSortable;this.sortable.captureAnimationState();if(putSortable){putSortable.captureAnimationState();}var nextSibling=getChild(this.sortable.el,this.startIndex,this.options);if(nextSibling){this.sortable.el.insertBefore(dragEl,nextSibling);}else{this.sortable.el.appendChild(dragEl);}this.sortable.animateAll();if(putSortable){putSortable.animateAll();}},drop:drop};_extends(Revert,{pluginName:'revertOnSpill'});function Remove(){}Remove.prototype={onSpill:function(_ref4){var dragEl=_ref4.dragEl,putSortable=_ref4.putSortable;var parentSortable=putSortable||this.sortable;parentSortable.captureAnimationState();dragEl.parentNode&&dragEl.parentNode.removeChild(dragEl);parentSortable.animateAll();},drop:drop};_extends(Remove,{pluginName:'removeOnSpill'});var OnSpill=[Remove,Revert];var lastSwapEl;function SwapPlugin(){function Swap(){this.defaults={swapClass:'sortable-swap-highlight'};}Swap.prototype={dragStart:function(_ref){var dragEl=_ref.dragEl;lastSwapEl=dragEl;},dragOverValid:function(_ref2){var completed=_ref2.completed,target=_ref2.target,onMove=_ref2.onMove,activeSortable=_ref2.activeSortable,changed=_ref2.changed,cancel=_ref2.cancel;if(!activeSortable.options.swap)return;var el=this.sortable.el,options=this.options;if(target&&target!==el){var prevSwapEl=lastSwapEl;if(onMove(target)!==false){toggleClass(target,options.swapClass,true);lastSwapEl=target;}else{lastSwapEl=null;}if(prevSwapEl&&prevSwapEl!==lastSwapEl){toggleClass(prevSwapEl,options.swapClass,false);}}changed();completed(true);cancel();},drop:function(_ref3){var activeSortable=_ref3.activeSortable,putSortable=_ref3.putSortable,dragEl=_ref3.dragEl;var toSortable=putSortable||this.sortable;var options=this.options;lastSwapEl&&toggleClass(lastSwapEl,options.swapClass,false);if(lastSwapEl&&(options.swap||putSortable&&putSortable.options.swap)){if(dragEl!==lastSwapEl){toSortable.captureAnimationState();if(toSortable!==activeSortable)activeSortable.captureAnimationState();swapNodes(dragEl,lastSwapEl);toSortable.animateAll();if(toSortable!==activeSortable)activeSortable.animateAll();}}},nulling:function(){lastSwapEl=null;}};return _extends(Swap,{pluginName:'swap',eventProperties:function(){return{swapItem:lastSwapEl};}});}function swapNodes(n1,n2){var p1=n1.parentNode,p2=n2.parentNode,i1,i2;if(!p1||!p2||p1.isEqualNode(n2)||p2.isEqualNode(n1))return;i1=sortable_core_esm_index(n1);i2=sortable_core_esm_index(n2);if(p1.isEqualNode(p2)&&i1<i2){i2++;}p1.insertBefore(n2,p1.children[i1]);p2.insertBefore(n1,p2.children[i2]);}var multiDragElements=[],multiDragClones=[],lastMultiDragSelect,multiDragSortable,initialFolding=false,folding=false,dragStarted=false,dragEl$1,clonesFromRect,clonesHidden;function MultiDragPlugin(){function MultiDrag(sortable){for(var fn in this){if(fn.charAt(0)==='_'&&typeof this[fn]==='function'){this[fn]=this[fn].bind(this);}}if(sortable.options.supportPointer){sortable_core_esm_on(document,'pointerup',this._deselectMultiDrag);}else{sortable_core_esm_on(document,'mouseup',this._deselectMultiDrag);sortable_core_esm_on(document,'touchend',this._deselectMultiDrag);}sortable_core_esm_on(document,'keydown',this._checkKeyDown);sortable_core_esm_on(document,'keyup',this._checkKeyUp);this.defaults={selectedClass:'sortable-selected',multiDragKey:null,setData:function(dataTransfer,dragEl){var data='';if(multiDragElements.length&&multiDragSortable===sortable){multiDragElements.forEach(function(multiDragElement,i){data+=(!i?'':', ')+multiDragElement.textContent;});}else{data=dragEl.textContent;}dataTransfer.setData('Text',data);}};}MultiDrag.prototype={multiDragKeyDown:false,isMultiDrag:false,delayStartGlobal:function(_ref){var dragged=_ref.dragEl;dragEl$1=dragged;},delayEnded:function(){this.isMultiDrag=~multiDragElements.indexOf(dragEl$1);},setupClone:function(_ref2){var sortable=_ref2.sortable,cancel=_ref2.cancel;if(!this.isMultiDrag)return;for(var i=0;i<multiDragElements.length;i++){multiDragClones.push(clone(multiDragElements[i]));multiDragClones[i].sortableIndex=multiDragElements[i].sortableIndex;multiDragClones[i].draggable=false;multiDragClones[i].style['will-change']='';toggleClass(multiDragClones[i],this.options.selectedClass,false);multiDragElements[i]===dragEl$1&&toggleClass(multiDragClones[i],this.options.chosenClass,false);}sortable._hideClone();cancel();},clone:function(_ref3){var sortable=_ref3.sortable,rootEl=_ref3.rootEl,dispatchSortableEvent=_ref3.dispatchSortableEvent,cancel=_ref3.cancel;if(!this.isMultiDrag)return;if(!this.options.removeCloneOnHide){if(multiDragElements.length&&multiDragSortable===sortable){insertMultiDragClones(true,rootEl);dispatchSortableEvent('clone');cancel();}}},showClone:function(_ref4){var cloneNowShown=_ref4.cloneNowShown,rootEl=_ref4.rootEl,cancel=_ref4.cancel;if(!this.isMultiDrag)return;insertMultiDragClones(false,rootEl);multiDragClones.forEach(function(clone){css(clone,'display','');});cloneNowShown();clonesHidden=false;cancel();},hideClone:function(_ref5){var _this=this;var sortable=_ref5.sortable,cloneNowHidden=_ref5.cloneNowHidden,cancel=_ref5.cancel;if(!this.isMultiDrag)return;multiDragClones.forEach(function(clone){css(clone,'display','none');if(_this.options.removeCloneOnHide&&clone.parentNode){clone.parentNode.removeChild(clone);}});cloneNowHidden();clonesHidden=true;cancel();},dragStartGlobal:function(_ref6){_ref6.sortable;if(!this.isMultiDrag&&multiDragSortable){multiDragSortable.multiDrag._deselectMultiDrag();}multiDragElements.forEach(function(multiDragElement){multiDragElement.sortableIndex=sortable_core_esm_index(multiDragElement);});multiDragElements=multiDragElements.sort(function(a,b){return a.sortableIndex-b.sortableIndex;});dragStarted=true;},dragStarted:function(_ref7){var _this2=this;var sortable=_ref7.sortable;if(!this.isMultiDrag)return;if(this.options.sort){sortable.captureAnimationState();if(this.options.animation){multiDragElements.forEach(function(multiDragElement){if(multiDragElement===dragEl$1)return;css(multiDragElement,'position','absolute');});var dragRect=getRect(dragEl$1,false,true,true);multiDragElements.forEach(function(multiDragElement){if(multiDragElement===dragEl$1)return;setRect(multiDragElement,dragRect);});folding=true;initialFolding=true;}}sortable.animateAll(function(){folding=false;initialFolding=false;if(_this2.options.animation){multiDragElements.forEach(function(multiDragElement){unsetRect(multiDragElement);});}if(_this2.options.sort){removeMultiDragElements();}});},dragOver:function(_ref8){var target=_ref8.target,completed=_ref8.completed,cancel=_ref8.cancel;if(folding&&~multiDragElements.indexOf(target)){completed(false);cancel();}},revert:function(_ref9){var fromSortable=_ref9.fromSortable,rootEl=_ref9.rootEl,sortable=_ref9.sortable,dragRect=_ref9.dragRect;if(multiDragElements.length>1){multiDragElements.forEach(function(multiDragElement){sortable.addAnimationState({target:multiDragElement,rect:folding?getRect(multiDragElement):dragRect});unsetRect(multiDragElement);multiDragElement.fromRect=dragRect;fromSortable.removeAnimationState(multiDragElement);});folding=false;insertMultiDragElements(!this.options.removeCloneOnHide,rootEl);}},dragOverCompleted:function(_ref10){var sortable=_ref10.sortable,isOwner=_ref10.isOwner,insertion=_ref10.insertion,activeSortable=_ref10.activeSortable,parentEl=_ref10.parentEl,putSortable=_ref10.putSortable;var options=this.options;if(insertion){if(isOwner){activeSortable._hideClone();}initialFolding=false;if(options.animation&&multiDragElements.length>1&&(folding||!isOwner&&!activeSortable.options.sort&&!putSortable)){var dragRectAbsolute=getRect(dragEl$1,false,true,true);multiDragElements.forEach(function(multiDragElement){if(multiDragElement===dragEl$1)return;setRect(multiDragElement,dragRectAbsolute);parentEl.appendChild(multiDragElement);});folding=true;}if(!isOwner){if(!folding){removeMultiDragElements();}if(multiDragElements.length>1){var clonesHiddenBefore=clonesHidden;activeSortable._showClone(sortable);if(activeSortable.options.animation&&!clonesHidden&&clonesHiddenBefore){multiDragClones.forEach(function(clone){activeSortable.addAnimationState({target:clone,rect:clonesFromRect});clone.fromRect=clonesFromRect;clone.thisAnimationDuration=null;});}}else{activeSortable._showClone(sortable);}}}},dragOverAnimationCapture:function(_ref11){var dragRect=_ref11.dragRect,isOwner=_ref11.isOwner,activeSortable=_ref11.activeSortable;multiDragElements.forEach(function(multiDragElement){multiDragElement.thisAnimationDuration=null;});if(activeSortable.options.animation&&!isOwner&&activeSortable.multiDrag.isMultiDrag){clonesFromRect=_extends({},dragRect);var dragMatrix=matrix(dragEl$1,true);clonesFromRect.top-=dragMatrix.f;clonesFromRect.left-=dragMatrix.e;}},dragOverAnimationComplete:function(){if(folding){folding=false;removeMultiDragElements();}},drop:function(_ref12){var evt=_ref12.originalEvent,rootEl=_ref12.rootEl,parentEl=_ref12.parentEl,sortable=_ref12.sortable,dispatchSortableEvent=_ref12.dispatchSortableEvent,oldIndex=_ref12.oldIndex,putSortable=_ref12.putSortable;var toSortable=putSortable||this.sortable;if(!evt)return;var options=this.options,children=parentEl.children;if(!dragStarted){if(options.multiDragKey&&!this.multiDragKeyDown){this._deselectMultiDrag();}toggleClass(dragEl$1,options.selectedClass,!~multiDragElements.indexOf(dragEl$1));if(!~multiDragElements.indexOf(dragEl$1)){multiDragElements.push(dragEl$1);dispatchEvent({sortable:sortable,rootEl:rootEl,name:'select',targetEl:dragEl$1,originalEvt:evt});if(evt.shiftKey&&lastMultiDragSelect&&sortable.el.contains(lastMultiDragSelect)){var lastIndex=sortable_core_esm_index(lastMultiDragSelect),currentIndex=sortable_core_esm_index(dragEl$1);if(~lastIndex&&~currentIndex&&lastIndex!==currentIndex){var n,i;if(currentIndex>lastIndex){i=lastIndex;n=currentIndex;}else{i=currentIndex;n=lastIndex+1;}for(;i<n;i++){if(~multiDragElements.indexOf(children[i]))continue;toggleClass(children[i],options.selectedClass,true);multiDragElements.push(children[i]);dispatchEvent({sortable:sortable,rootEl:rootEl,name:'select',targetEl:children[i],originalEvt:evt});}}}else{lastMultiDragSelect=dragEl$1;}multiDragSortable=toSortable;}else{multiDragElements.splice(multiDragElements.indexOf(dragEl$1),1);lastMultiDragSelect=null;dispatchEvent({sortable:sortable,rootEl:rootEl,name:'deselect',targetEl:dragEl$1,originalEvt:evt});}}if(dragStarted&&this.isMultiDrag){if((parentEl[sortable_core_esm_expando].options.sort||parentEl!==rootEl)&&multiDragElements.length>1){var dragRect=getRect(dragEl$1),multiDragIndex=sortable_core_esm_index(dragEl$1,':not(.'+this.options.selectedClass+')');if(!initialFolding&&options.animation)dragEl$1.thisAnimationDuration=null;toSortable.captureAnimationState();if(!initialFolding){if(options.animation){dragEl$1.fromRect=dragRect;multiDragElements.forEach(function(multiDragElement){multiDragElement.thisAnimationDuration=null;if(multiDragElement!==dragEl$1){var rect=folding?getRect(multiDragElement):dragRect;multiDragElement.fromRect=rect;toSortable.addAnimationState({target:multiDragElement,rect:rect});}});}removeMultiDragElements();multiDragElements.forEach(function(multiDragElement){if(children[multiDragIndex]){parentEl.insertBefore(multiDragElement,children[multiDragIndex]);}else{parentEl.appendChild(multiDragElement);}multiDragIndex++;});if(oldIndex===sortable_core_esm_index(dragEl$1)){var update=false;multiDragElements.forEach(function(multiDragElement){if(multiDragElement.sortableIndex!==sortable_core_esm_index(multiDragElement)){update=true;}});if(update){dispatchSortableEvent('update');}}}multiDragElements.forEach(function(multiDragElement){unsetRect(multiDragElement);});toSortable.animateAll();}multiDragSortable=toSortable;}if(rootEl===parentEl||putSortable&&putSortable.lastPutMode!=='clone'){multiDragClones.forEach(function(clone){clone.parentNode&&clone.parentNode.removeChild(clone);});}},nullingGlobal:function(){this.isMultiDrag=dragStarted=false;multiDragClones.length=0;},destroyGlobal:function(){this._deselectMultiDrag();sortable_core_esm_off(document,'pointerup',this._deselectMultiDrag);sortable_core_esm_off(document,'mouseup',this._deselectMultiDrag);sortable_core_esm_off(document,'touchend',this._deselectMultiDrag);sortable_core_esm_off(document,'keydown',this._checkKeyDown);sortable_core_esm_off(document,'keyup',this._checkKeyUp);},_deselectMultiDrag:function(evt){if(typeof dragStarted!=="undefined"&&dragStarted)return;if(multiDragSortable!==this.sortable)return;if(evt&&closest(evt.target,this.options.draggable,this.sortable.el,false))return;if(evt&&evt.button!==0)return;while(multiDragElements.length){var el=multiDragElements[0];toggleClass(el,this.options.selectedClass,false);multiDragElements.shift();dispatchEvent({sortable:this.sortable,rootEl:this.sortable.el,name:'deselect',targetEl:el,originalEvt:evt});}},_checkKeyDown:function(evt){if(evt.key===this.options.multiDragKey){this.multiDragKeyDown=true;}},_checkKeyUp:function(evt){if(evt.key===this.options.multiDragKey){this.multiDragKeyDown=false;}}};return _extends(MultiDrag,{pluginName:'multiDrag',utils:{select:function(el){var sortable=el.parentNode[sortable_core_esm_expando];if(!sortable||!sortable.options.multiDrag||~multiDragElements.indexOf(el))return;if(multiDragSortable&&multiDragSortable!==sortable){multiDragSortable.multiDrag._deselectMultiDrag();multiDragSortable=sortable;}toggleClass(el,sortable.options.selectedClass,true);multiDragElements.push(el);},deselect:function(el){var sortable=el.parentNode[sortable_core_esm_expando],index=multiDragElements.indexOf(el);if(!sortable||!sortable.options.multiDrag||!~index)return;toggleClass(el,sortable.options.selectedClass,false);multiDragElements.splice(index,1);}},eventProperties:function(){var _this3=this;var oldIndicies=[],newIndicies=[];multiDragElements.forEach(function(multiDragElement){oldIndicies.push({multiDragElement:multiDragElement,index:multiDragElement.sortableIndex});var newIndex;if(folding&&multiDragElement!==dragEl$1){newIndex=-1;}else if(folding){newIndex=sortable_core_esm_index(multiDragElement,':not(.'+_this3.options.selectedClass+')');}else{newIndex=sortable_core_esm_index(multiDragElement);}newIndicies.push({multiDragElement:multiDragElement,index:newIndex});});return{items:_toConsumableArray(multiDragElements),clones:[].concat(multiDragClones),oldIndicies:oldIndicies,newIndicies:newIndicies};},optionListeners:{multiDragKey:function(key){key=key.toLowerCase();if(key==='ctrl'){key='Control';}else if(key.length>1){key=key.charAt(0).toUpperCase()+key.substr(1);}return key;}}});}function insertMultiDragElements(clonesInserted,rootEl){multiDragElements.forEach(function(multiDragElement,i){var target=rootEl.children[multiDragElement.sortableIndex+(clonesInserted?Number(i):0)];if(target){rootEl.insertBefore(multiDragElement,target);}else{rootEl.appendChild(multiDragElement);}});}function insertMultiDragClones(elementsInserted,rootEl){multiDragClones.forEach(function(clone,i){var target=rootEl.children[clone.sortableIndex+(elementsInserted?Number(i):0)];if(target){rootEl.insertBefore(clone,target);}else{rootEl.appendChild(clone);}});}function removeMultiDragElements(){multiDragElements.forEach(function(multiDragElement){if(multiDragElement===dragEl$1)return;multiDragElement.parentNode&&multiDragElement.parentNode.removeChild(multiDragElement);});}/* harmony default export */ var sortable_core_esm = (Sortable);
// CONCATENATED MODULE: ./lib/vendor/index.js

sortable_core_esm.mount(new AutoScrollPlugin());

// CONCATENATED MODULE: ./lib/utils/caseBuilder.js




function drawOptionBuilder(options, mod, optionName) {
  const option = options[optionName];
  const $addRowButton = jquery_default()('<button class="addRowButton">');
  const $itemContainer = jquery_default()('<div class="optionBuilder">');
  $itemContainer.attr({
    'data-module-id': mod.moduleID,
    'data-option-name': optionName
  });
  $addRowButton.text(i18n(option.addItemText) || '+add item').on('click', function () {
    const $newBody = drawBuilderItem(option.defaultTemplate(), option.customOptionsFields, option.cases);
    jquery_default()(this).siblings('.optionBuilder:first').trigger('change').append($newBody);
    const firstText = $newBody.find('input[type=text], textarea')[0];

    if (firstText) {
      setTimeout(() => firstText.focus(), 200);
    }
  });
  option.value.forEach(item => drawBuilderItem(item, option.customOptionsFields, option.cases).appendTo($itemContainer));
  sortable_core_esm.create($itemContainer.get(0), {
    handle: '.handle'
  });
  return jquery_default()('<div>').append($itemContainer, $addRowButton)[0];
}

function drawBuilderItem(data, customOptionsFields = [], cases) {
  const $editButton = jquery_default()('<div>').addClass('res-icon-button res-icon builderControls builderTrailingControls').html('&#xF061;').attr('title', 'copy and share, or update your settings with a new version').on('click', function () {
    const $item = jquery_default()(this).closest('.builderItem');
    const data = readBuilderItem($item, customOptionsFields, cases);
    const json = prompt('Copy this and share it, or paste a new version and update your settings', JSON.stringify(data));

    if (json !== null) {
      const newData = JSON.parse(json);
      $item.trigger('change').replaceWith(drawBuilderItem(newData, customOptionsFields, cases));
    }
  });
  const $deleteButton = drawDeleteButton().addClass('builderTrailingControls').on('click', function () {
    if (confirm('Are you sure you want remove this filter?')) {
      jquery_default()(this).trigger('change');
      jquery_default()(this).closest('.builderItem').trigger('change').remove();
    }
  });
  const customOptions = string_namespaceObject.html`<ul class="builderCustomOptions"></ul>`;

  for (const fields of customOptionsFields) {
    const li = document.createElement('li');
    jquery_default()(li).append(drawFields(fields, data.opts || {}));
    customOptions.append(li);
  }

  const $header = jquery_default()('<div class="builderItemControls">').append(drawHandle(), jquery_default()('<input type="hidden" name="version">').val(data.ver), jquery_default()('<input type="hidden" name="id">').val(data.id), customOptions, jquery_default()('<textarea name="builderNote" style="margin-left: 10px" rows="1" cols="40" placeholder="Write a description/note for this">').val(data.note), jquery_default()('<div>').css({
    'margin-left': 'auto'
  }).append($editButton, $deleteButton));
  const $body = drawBuilderBlock(data.body, cases, false);
  return jquery_default()('<div class="builderItem">').append($header, $body);
}

function drawHandle() {
  return jquery_default()('<div>').addClass('res-icon-button res-icon handle builderControls').html('&#xF0AA;').attr('title', 'drag and drop to move this condition');
}

function drawDeleteButton() {
  return jquery_default()('<div>').addClass('res-icon-button res-icon builderControls').html('&#xF056;').attr('title', 'remove this condition');
}

function drawBuilderBlock(data, cases, addBaseControls = true) {
  if (!cases.hasOwnProperty(data.type)) {
    console.error(`Case type ${data.type} is not available. Ignoring block.`, data);
    return jquery_default()();
  }

  const $block = jquery_default()('<div class="builderBlock">').attr('data-type', data.type).append(drawFields(cases[data.type].fields, data, cases));
  if (!addBaseControls) return $block;
  const $deleteButton = drawDeleteButton().addClass('builderTrailingControls').on('click', function () {
    if (confirm('Are you sure you want to delete this condition?')) {
      jquery_default()(this).trigger('change');
      jquery_default()(this).closest('.builderWrap').parent('li').remove();
    }
  });
  return jquery_default()('<div class="builderWrap">').append(drawHandle(), $block, $deleteButton);
}
function readBuilderItem(item, customOptionsFields = [], cases) {
  const $firstBlock = jquery_default()(item).find('> .builderBlock');
  const $header = jquery_default()(item).find('.builderItemControls');
  return {
    note: $header.find('textarea[name=builderNote]').val(),
    ver: parseInt($header.find('input[name=version]').val(), 10),
    id: $header.find('input[name=id]').val(),
    body: readBuilderBlock($firstBlock, cases),
    opts: readFields($header.find('.builderCustomOptions li'), customOptionsFields.flat(Infinity), cases)
  };
}
function readBuilderBlock($element, cases) {
  const type = $element.attr('data-type');
  const BlockClass = cases[type];
  const data = {
    type,
    ...readFields($element, BlockClass.fields, cases)
  };
  const multiType = BlockClass.fields.find(({
    type
  }) => type === 'multi');

  if (!multiType) {
    try {
      BlockClass.validate(data);
      $element.removeClass('builderBlock-error');
    } catch (e) {
      $element.attr('error', e.message).addClass('builderBlock-error');
      throw e;
    }
  }

  return data;
}

function readFields($element, fields, cases) {
  return fields.reduce((acc, field) => {
    if (typeof field === 'string') return acc;
    const $fieldElem = $element.find(`> [name=${field.id}]`);
    const fieldModule = builderFields[field.type];

    if (fieldModule && typeof fieldModule.read === 'function') {
      acc[field.id] = fieldModule.read($fieldElem, field, cases);
    } else {
      acc[field.id] = $fieldElem.val();
    }

    return acc;
  }, {});
}

function drawFields(fields, data, cases) {
  return fields.map(field => {
    if (typeof field === 'string') return field;
    const fieldModule = builderFields[field.type];

    if (fieldModule) {
      return fieldModule.draw(data, field, cases);
    } else {
      return jquery_default()(`<input type="${field.type}">`).attr('name', field.id).val(data[field.id]);
    }
  });
}

const builderFields = {
  multi: {
    draw(data, field, cases = {}) {
      const $rowWrapper = jquery_default()('<ul class="builderMulti">').attr('name', field.id);

      const addItem = itemData => drawBuilderBlock(itemData, cases).appendTo($rowWrapper).wrap('<li>');

      const items = data[field.id];
      items.forEach(addItem);
      const addCaseSelect = Object(flow["a" /* downcast */])(string_namespaceObject.html`
				<select class="addBuilderBlock">
					<option>+ add a condition</option>
					${Object.entries(cases).map(([key, {
        text
      }]) => string_namespaceObject._html`
						<option value="${key}">${text}</option>
					`)}
				</select>
			`, HTMLSelectElement);
      addCaseSelect.addEventListener('change', () => {
        const type = addCaseSelect.value;

        if (type !== '' && cases.hasOwnProperty(type)) {
          addItem({
            type,
            ...cases[type].defaultConditions
          }).find('input[type=text], input[type=number], textarea').focus();
        }

        addCaseSelect.selectedIndex = 0;
      });
      sortable_core_esm.create($rowWrapper.get(0), {
        group: 'block',
        handle: '.handle'
      });
      return $rowWrapper.add(addCaseSelect);
    },

    read($elem, fields, cases) {
      return $elem.find('> li > .builderWrap > .builderBlock').map(function () {
        return readBuilderBlock(jquery_default()(this), cases);
      }).get();
    }

  },
  hidden: {
    draw(data, field) {
      const id = field.id;
      return jquery_default()('<input type="hidden">').attr('name', id).val(data[id]);
    }

  },
  number: {
    draw(data, field) {
      const id = field.id;
      return jquery_default()('<input type="number">').attr('name', id).val(data[id]);
    },

    read($elem) {
      return parseInt($elem.val(), 10);
    }

  },
  check: {
    draw(data, field) {
      const id = field.id;
      const $input = jquery_default()('<input type="checkbox">').prop('checked', data[id]);
      return jquery_default()('<label>').attr('name', id).text(field.label).prepend($input);
    },

    read($elem) {
      return $elem.find('input').get(0).checked;
    }

  },
  checkset: {
    uid: 0,

    draw(data, field) {
      const id = field.id;
      const prefixId = this.uid++;
      const $wrap = jquery_default()('<span class="checkset">').attr('name', field.id);
      field.items.forEach((e, idx) => {
        const itemId = `checkset-${prefixId}-${idx}X`;
        const $box = jquery_default()('<input type="checkbox" />').attr('id', itemId).attr('name', e);

        if (data.hasOwnProperty(id) && data[id].includes(e)) {
          $box.prop('checked', true);
        }

        const $label = jquery_default()('<label>').attr('for', itemId).text(e);
        $wrap.append($box, $label);
      });
      return $wrap;
    },

    read($elem, fields) {
      return fields.items.filter(e => $elem.children(`[name="${e}"]`).prop('checked'));
    }

  },
  duration: {
    draw(data, field) {
      let durr = data[field.id];
      durr /= 60 * 1000;
      const minutes = durr % 60;
      durr = (durr - minutes) / 60;
      const hours = durr % 24;
      durr = (durr - hours) / 24;
      const days = durr;
      return jquery_default()('<span class="durationField">').attr('name', field.id).append([jquery_default()('<input type="number" name="days" />').val(days), ' days ', jquery_default()('<input type="number" name="hours" />').val(hours), ' hours ', jquery_default()('<input type="number" name="minutes" />').val(minutes), ' minutes ']);
    },

    read($elem) {
      const days = parseFloat($elem.children('[name=days]').val()) || 0;
      const hours = parseFloat($elem.children('[name=hours]').val()) || 0;
      const minutes = parseFloat($elem.children('[name=minutes]').val()) || 0;
      let duration = 0;
      duration += days * 24 * 60 * 60;
      duration += hours * 60 * 60;
      duration += minutes * 60;
      duration *= 1000;
      return duration;
    }

  },
  select: {
    draw(data, field) {
      const value = data[field.id];
      let entries = field.options;

      if (typeof entries === 'string') {
        entries = this.getPredefinedChoices(entries);
      }

      const $dropdown = jquery_default()('<select>').attr('name', field.id);
      entries.forEach(row => {
        let label, value;

        if (typeof row === 'string') {
          label = value = row;
        } else {
          label = row[0];
          value = row[1];
        }

        jquery_default()('<option>').text(label).val(value).appendTo($dropdown);
      });
      $dropdown.val(value);
      return $dropdown;
    },

    getPredefinedChoices(name) {
      if (name === 'COMPARISON') {
        return [['exactly', '=='], ['not', '!='], ['more than', '>'], ['less than', '<'], ['at least', '>='], ['at most', '<=']];
      } else {
        throw new Error(`Option set "${name}" is not defined`);
      }
    }

  }
};
// CONCATENATED MODULE: ./lib/utils/index.js















































// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIsEqual.js + 6 modules
var _baseIsEqual = __webpack_require__(65);

// CONCATENATED MODULE: ./node_modules/lodash-es/isEqual.js
function isEqual(value,other){return Object(_baseIsEqual["a" /* default */])(value,other);}/* harmony default export */ var lodash_es_isEqual = (isEqual);
// CONCATENATED MODULE: ./lib/core/module.js
class Module {
  constructor(moduleID) {
    this.moduleID = void 0;
    this.moduleName = void 0;
    this.category = '';
    this.description = '';
    this.descriptionRaw = false;
    this.keywords = [];
    this.bodyClass = false;
    this.options = {};
    this.include = [];
    this.exclude = [];

    this.shouldRun = () => true;

    this.onToggle = () => {};

    this.onSaveSettings = () => {};

    this.hidden = false;
    this.disabledByDefault = false;
    this.alwaysEnabled = false;
    this.sort = 0;
    this.onInit = undefined;
    this.beforeLoad = undefined;
    this.contentStart = undefined;
    this.go = undefined;
    this.afterLoad = undefined;
    this.always = undefined;
    this.permissions = {
      requiredPermissions: []
    };
    this.moduleID = moduleID;
    this.moduleName = moduleID;
  }

}
function getModuleId(opaqueId) {
  if (!opaqueId) {
    throw new TypeError(`Expected module, moduleID, or namespace; found: ${opaqueId}`);
  }

  if (typeof opaqueId === 'string') {
    return opaqueId;
  } else if (opaqueId.module) {
    return opaqueId.module.moduleID;
  } else {
    return opaqueId.moduleID;
  }
}
// CONCATENATED MODULE: ./lib/core/modules/storage.js

const storage_storage = storage_namespaceObject.wrapBlob('RES.modulePrefs', () => {
  throw new Error('Default module enabled state should never be accessed');
});
function setEnabled(moduleId, enable) {
  return storage_storage.set(moduleId, enable);
}
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseClamp.js
function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/* harmony default export */ var _baseClamp = (baseClamp);
// EXTERNAL MODULE: ./node_modules/lodash-es/toNumber.js + 2 modules
var toNumber = __webpack_require__(38);

// CONCATENATED MODULE: ./node_modules/lodash-es/clamp.js
function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=Object(toNumber["a" /* default */])(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=Object(toNumber["a" /* default */])(lower);lower=lower===lower?lower:0;}return _baseClamp(Object(toNumber["a" /* default */])(number),lower,upper);}/* harmony default export */ var lodash_es_clamp = (clamp);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseRandom.js
var nativeFloor=Math.floor,nativeRandom=Math.random;function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/* harmony default export */ var _baseRandom = (baseRandom);
// EXTERNAL MODULE: ./node_modules/lodash-es/toFinite.js
var toFinite = __webpack_require__(73);

// CONCATENATED MODULE: ./node_modules/lodash-es/random.js
var freeParseFloat=parseFloat;var nativeMin=Math.min,random_nativeRandom=Math.random;function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&Object(_isIterateeCall["a" /* default */])(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=Object(toFinite["a" /* default */])(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=Object(toFinite["a" /* default */])(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=random_nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return _baseRandom(lower,upper);}/* harmony default export */ var lodash_es_random = (random);
// CONCATENATED MODULE: ./lib/vendor/guiders.js

const guiders = {};

(() => {
  guiders.version = "2.0.0";
  guiders._defaultSettings = {
    attachTo: null,
    autoFocus: false,
    buttons: [{
      name: "Close"
    }],
    buttonCustomHTML: "",
    classString: null,
    closeOnEscape: false,
    description: "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    highlight: null,
    isHashable: true,
    maxWidth: null,
    offset: {
      top: null,
      left: null
    },
    onClose: null,
    onHide: null,
    onShow: null,
    overlay: false,
    position: 0,
    shouldSkip: function () {},
    title: "Sample title goes here",
    width: 400,
    xButton: false
  };
  guiders._htmlSkeleton = ["<div class='guider'>", "  <div class='guiders_content'>", "    <h1 class='guiders_title'></h1>", "    <div class='guiders_close'></div>", "    <p class='guiders_description'></p>", "    <div class='guiders_buttons_container'>", "    </div>", "  </div>", "  <div class='guiders_arrow'>", "  </div>", "</div>"].join("");
  guiders._arrowSize = 42;
  guiders._backButtonTitle = "Back";
  guiders._buttonAttributes = {
    "href": "javascript:void(0);"
  };
  guiders._buttonClassName = "guiders_button";
  guiders._buttonClickEvent = "click touch";
  guiders._buttonElement = "<a></a>";
  guiders._closeButtonTitle = "Close";
  guiders._currentGuiderID = null;
  guiders._fixedOrAbsolute = "fixed";
  guiders._guiders = {};
  guiders._lastCreatedGuiderID = null;
  guiders._nextButtonTitle = "Next";
  guiders._offsetNameMapping = {
    "topLeft": 11,
    "top": 12,
    "topRight": 1,
    "rightTop": 2,
    "right": 3,
    "rightBottom": 4,
    "bottomRight": 5,
    "bottom": 6,
    "bottomLeft": 7,
    "leftBottom": 8,
    "left": 9,
    "leftTop": 10
  };
  guiders._windowHeight = 0;
  var ieBrowserMatch = navigator.userAgent.match(/MSIE\s([\d.]+)/);
  guiders._isIE = ieBrowserMatch && ieBrowserMatch.length > 1;
  guiders._ieVersion = ieBrowserMatch && ieBrowserMatch.length > 1 ? Number(ieBrowserMatch[1]) : -1;

  guiders._addButtons = function (myGuider) {
    var guiderButtonsContainer = myGuider.elem.find(".guiders_buttons_container");

    if (myGuider.buttons === null || myGuider.buttons.length === 0) {
      guiderButtonsContainer.remove();
      return;
    }

    for (var i = myGuider.buttons.length - 1; i >= 0; i--) {
      var thisButton = myGuider.buttons[i];
      var thisButtonElem = jquery_default()(guiders._buttonElement, jquery_default.a.extend({
        "class": guiders._buttonClassName,
        "html": thisButton.name
      }, guiders._buttonAttributes, thisButton.html || {}));

      if (typeof thisButton.classString !== "undefined" && thisButton.classString !== null) {
        thisButtonElem.addClass(thisButton.classString);
      }

      guiderButtonsContainer.append(thisButtonElem);
      var thisButtonName = thisButton.name.toLowerCase();

      if (thisButton.onclick) {
        thisButtonElem.bind(guiders._buttonClickEvent, thisButton.onclick);
      } else {
        switch (thisButtonName) {
          case guiders._closeButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              guiders.hideAll();

              if (myGuider.onClose) {
                myGuider.onClose(myGuider, false);
              }

              jquery_default()("body").trigger("guidersClose");
            });
            break;

          case guiders._nextButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              !myGuider.elem.data("locked") && guiders.next();
            });
            break;

          case guiders._backButtonTitle.toLowerCase():
            thisButtonElem.bind(guiders._buttonClickEvent, function () {
              !myGuider.elem.data("locked") && guiders.prev();
            });
            break;
        }
      }
    }

    if (myGuider.buttonCustomHTML !== "") {
      var myCustomHTML = jquery_default()(myGuider.buttonCustomHTML);
      myGuider.elem.find(".guiders_buttons_container").append(myCustomHTML);
    }

    if (myGuider.buttons.length === 0) {
      guiderButtonsContainer.remove();
    }
  };

  guiders._addXButton = function (myGuider) {
    var xButtonContainer = myGuider.elem.find(".guiders_close");
    var xButton = jquery_default()("<div></div>", {
      "class": "guiders_x_button",
      "role": "button"
    });
    xButtonContainer.append(xButton);
    xButton.click(function () {
      guiders.hideAll();

      if (myGuider.onClose) {
        myGuider.onClose(myGuider, true);
      }

      jquery_default()("body").trigger("guidersClose");
    });
  };

  guiders._attach = function (myGuider) {
    if (typeof myGuider !== 'object') {
      return;
    }

    var attachTo = jquery_default()(myGuider.attachTo);
    var myHeight = myGuider.elem.innerHeight();
    var myWidth = myGuider.elem.innerWidth();

    if (myGuider.position === 0 || attachTo.length === 0) {
      var fixedOrAbsolute = "fixed";

      if (guiders._isIE && guiders._ieVersion < 9) {
        fixedOrAbsolute = "absolute";
      }

      myGuider.elem.css("position", fixedOrAbsolute);
      myGuider.elem.css("top", (jquery_default()(window).height() - myHeight) / 3 + "px");
      myGuider.elem.css("left", (jquery_default()(window).width() - myWidth) / 2 + "px");
      return;
    }

    var base = attachTo.offset();
    var top = base.top;
    var left = base.left;
    var topMarginOfBody = jquery_default()("body").outerHeight(true) - jquery_default()("body").outerHeight(false);
    top -= topMarginOfBody;

    if (guiders._offsetNameMapping[myGuider.position]) {
      myGuider.position = guiders._offsetNameMapping[myGuider.position];
    }

    var attachToHeight = attachTo.innerHeight();
    var attachToWidth = attachTo.innerWidth();
    var bufferOffset = 0.9 * guiders._arrowSize;
    var offset = {
      1: [-bufferOffset - myHeight, attachToWidth - myWidth],
      2: [0, bufferOffset + attachToWidth],
      3: [attachToHeight / 2 - myHeight / 2, bufferOffset + attachToWidth],
      4: [attachToHeight - myHeight, bufferOffset + attachToWidth],
      5: [bufferOffset + attachToHeight, attachToWidth - myWidth],
      6: [bufferOffset + attachToHeight, attachToWidth / 2 - myWidth / 2],
      7: [bufferOffset + attachToHeight, 0],
      8: [attachToHeight - myHeight, -myWidth - bufferOffset],
      9: [attachToHeight / 2 - myHeight / 2, -myWidth - bufferOffset],
      10: [0, -myWidth - bufferOffset],
      11: [-bufferOffset - myHeight, 0],
      12: [-bufferOffset - myHeight, attachToWidth / 2 - myWidth / 2]
    }[myGuider.position];
    top += offset[0];
    left += offset[1];
    var positionType = "absolute";

    if (attachTo.css("position") === "fixed" && guiders._fixedOrAbsolute === "fixed") {
      positionType = "fixed";
      top -= jquery_default()(window).scrollTop();
      left -= jquery_default()(window).scrollLeft();
    }

    if (myGuider.offset.top !== null) {
      top += myGuider.offset.top;
    }

    if (myGuider.offset.left !== null) {
      left += myGuider.offset.left;
    }

    guiders._styleArrow(myGuider);

    myGuider.elem.css({
      "position": positionType,
      "top": top,
      "left": left
    });
    return myGuider;
  };

  guiders._dehighlightElement = function (selector) {
    jquery_default()(selector).removeClass('guiders_highlight');
  };

  guiders._hideOverlay = function () {
    jquery_default()("#guiders_overlay").fadeOut("fast");
  };

  guiders._highlightElement = function (selector) {
    jquery_default()(selector).addClass('guiders_highlight');
  };

  guiders._initializeOverlay = function () {
    if (jquery_default()("#guiders_overlay").length === 0) {
      jquery_default()("<div id='guiders_overlay'></div>").hide().appendTo("body");
    }
  };

  guiders._showOverlay = function () {
    jquery_default()("#guiders_overlay").fadeIn("fast", function () {
      if (this.style.removeAttribute) {
        this.style.removeAttribute("filter");
      }
    });

    if (guiders._isIE) {
      jquery_default()("#guiders_overlay").css("position", "absolute");
    }
  };

  guiders._styleArrow = function (myGuider) {
    var position = myGuider.position || 0;

    if (!position) {
      return;
    }

    var myGuiderArrow = jquery_default()(myGuider.elem.find(".guiders_arrow"));
    myGuiderArrow.addClass({
      1: "guiders_arrow_down",
      2: "guiders_arrow_left",
      3: "guiders_arrow_left",
      4: "guiders_arrow_left",
      5: "guiders_arrow_up",
      6: "guiders_arrow_up",
      7: "guiders_arrow_up",
      8: "guiders_arrow_right",
      9: "guiders_arrow_right",
      10: "guiders_arrow_right",
      11: "guiders_arrow_down",
      12: "guiders_arrow_down"
    }[position]);
    var myHeight = myGuider.elem.innerHeight();
    var myWidth = myGuider.elem.innerWidth();
    var arrowOffset = guiders._arrowSize / 2;
    var position = {
      1: ["right", arrowOffset],
      2: ["top", arrowOffset],
      3: ["top", myHeight / 2 - arrowOffset],
      4: ["bottom", arrowOffset],
      5: ["right", arrowOffset],
      6: ["left", myWidth / 2 - arrowOffset],
      7: ["left", arrowOffset],
      8: ["bottom", arrowOffset],
      9: ["top", myHeight / 2 - arrowOffset],
      10: ["top", arrowOffset],
      11: ["left", arrowOffset],
      12: ["left", myWidth / 2 - arrowOffset]
    }[myGuider.position];
    myGuiderArrow.css(position[0], position[1] + "px");
  };

  guiders._showIfHashed = function (myGuider) {
    var GUIDER_HASH_TAG = "guider=";
    var hashIndex = window.location.hash.indexOf(GUIDER_HASH_TAG);

    if (hashIndex !== -1) {
      var hashGuiderId = window.location.hash.substr(hashIndex + GUIDER_HASH_TAG.length);

      if (myGuider.id.toLowerCase() === hashGuiderId.toLowerCase()) {
        guiders.show(myGuider.id);
      }
    }
  };

  guiders._updatePositionOnResize = function () {
    var _resizing = undefined;
    jquery_default()(window).resize(function () {
      if (typeof _resizing !== "undefined") {
        clearTimeout(_resizing);
      }

      _resizing = setTimeout(function () {
        _resizing = undefined;
        guiders.reposition();
      }, 20);
    });
  };

  guiders._updatePositionOnResize();

  guiders._unwireEscape = function () {
    jquery_default()(document).unbind("keydown");
  };

  guiders._wireEscape = function (myGuider) {
    jquery_default()(document).keydown(function (event) {
      if (event.keyCode == 27 || event.which == 27) {
        guiders.hideAll();

        if (myGuider.onClose) {
          myGuider.onClose(myGuider, true);
        }

        jquery_default()("body").trigger("guidersClose");
        return false;
      }
    });
  };

  guiders.createGuider = function (passedSettings) {
    if (passedSettings === null || passedSettings === undefined) {
      passedSettings = {};
    }

    var myGuider = jquery_default.a.extend({}, guiders._defaultSettings, passedSettings);
    myGuider.id = myGuider.id || "guider_random_" + String(Math.floor(Math.random() * 1000));
    var guiderElement = jquery_default()("#" + myGuider.id);

    if (!guiderElement.length) {
      guiderElement = jquery_default()(guiders._htmlSkeleton);
    }

    myGuider.elem = guiderElement;

    if (typeof myGuider.classString !== "undefined" && myGuider.classString !== null) {
      myGuider.elem.addClass(myGuider.classString);
    }

    if (Number(myGuider.width) === myGuider.width) {
      myGuider.width = String(myGuider.width) + "px";
    }

    if (Number(myGuider.maxWidth) === myGuider.maxWidth) {
      myGuider.maxWidth = String(myGuider.maxWidth) + "px";
    }

    myGuider.elem.css("width", myGuider.width);
    myGuider.elem.css("maxWidth", myGuider.maxWidth);
    var guiderTitleContainer = guiderElement.find(".guiders_title");
    guiderTitleContainer.html(myGuider.title);
    guiderElement.find(".guiders_description").html(myGuider.description);

    guiders._addButtons(myGuider);

    if (myGuider.xButton) {
      guiders._addXButton(myGuider);
    }

    guiderElement.hide();
    guiderElement.appendTo("body");
    guiderElement.attr("id", myGuider.id);

    if (typeof myGuider.attachTo !== "undefined" && myGuider !== null) {
      guiders._attach(myGuider);
    }

    guiders._initializeOverlay();

    guiders._guiders[myGuider.id] = myGuider;

    if (guiders._lastCreatedGuiderID != null) {
      myGuider.prev = guiders._lastCreatedGuiderID;
    }

    guiders._lastCreatedGuiderID = myGuider.id;

    if (myGuider.isHashable) {
      guiders._showIfHashed(myGuider);
    }

    return guiders;
  };

  guiders.get = function (id) {
    if (typeof guiders._guiders[id] === "undefined") {
      return null;
    }

    return guiders._guiders[id] || null;
  };

  guiders.getCurrentGuider = function () {
    return guiders._guiders[guiders._currentGuiderID] || null;
  };

  guiders.hideAll = function (omitHidingOverlay, next) {
    next = next || false;
    jquery_default()(".guider:visible").each(function (index, elem) {
      var myGuider = guiders.get(jquery_default()(elem).attr('id'));

      if (myGuider.onHide) {
        myGuider.onHide(myGuider, next);
      }
    });
    jquery_default()(".guider").fadeOut("fast");
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (currentGuider && currentGuider.highlight) {
      guiders._dehighlightElement(currentGuider.highlight);
    }

    if (!(typeof omitHidingOverlay !== "undefined" && omitHidingOverlay === true)) {
      guiders._hideOverlay();
    }

    return guiders;
  };

  guiders.next = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return null;
    }

    currentGuider.elem.data("locked", true);
    var nextGuiderId = currentGuider.next || null;

    if (nextGuiderId !== null && nextGuiderId !== "") {
      var nextGuider = guiders.get(nextGuiderId);
      var omitHidingOverlay = nextGuider.overlay ? true : false;
      guiders.hideAll(omitHidingOverlay, true);

      if (currentGuider && currentGuider.highlight) {
        guiders._dehighlightElement(currentGuider.highlight);
      }

      if (nextGuider.shouldSkip && nextGuider.shouldSkip()) {
        guiders._currentGuiderID = nextGuider.id;
        guiders.next();
        return guiders.getCurrentGuider();
      } else {
        guiders.show(nextGuiderId);
        return guiders.getCurrentGuider();
      }
    }
  };

  guiders.prev = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return null;
    }

    if (currentGuider.prev === null) {
      return null;
    }

    var prevGuider = guiders._guiders[currentGuider.prev];
    prevGuider.elem.data("locked", true);
    var prevGuiderId = prevGuider.id || null;

    if (prevGuiderId !== null && prevGuiderId !== "") {
      var myGuider = guiders.get(prevGuiderId);
      var omitHidingOverlay = myGuider.overlay ? true : false;
      guiders.hideAll(omitHidingOverlay, true);

      if (prevGuider && prevGuider.highlight) {
        guiders._dehighlightElement(prevGuider.highlight);
      }

      guiders.show(prevGuiderId);
      return myGuider;
    }
  };

  guiders.reposition = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    guiders._attach(currentGuider);
  };

  guiders.scrollToCurrent = function () {
    var currentGuider = guiders._guiders[guiders._currentGuiderID];

    if (typeof currentGuider === "undefined") {
      return;
    }

    var windowHeight = guiders._windowHeight;
    jquery_default()(window).scrollTop();
    var guiderOffset = currentGuider.elem.offset();
    var guiderElemHeight = currentGuider.elem.height();
    var scrollToHeight = Math.round(Math.max(guiderOffset.top + guiderElemHeight / 2 - windowHeight / 2, 0));
    window.scrollTo(0, scrollToHeight);
  };

  guiders.show = function (id) {
    if (!id && guiders._lastCreatedGuiderID) {
      id = guiders._lastCreatedGuiderID;
    }

    var myGuider = guiders.get(id);

    if (myGuider.overlay) {
      guiders._showOverlay(myGuider);

      if (myGuider.highlight && myGuider.attachTo) {
        guiders._highlightElement(myGuider.attachTo);
      }
    }

    if (myGuider.closeOnEscape) {
      guiders._wireEscape(myGuider);
    } else {
      guiders._unwireEscape(myGuider);
    }

    if (myGuider.onShow) {
      myGuider.onShow(myGuider);
    }

    guiders._attach(myGuider);

    myGuider.elem.fadeIn("fast").data("locked", false);
    guiders._currentGuiderID = id;
    var windowHeight = guiders._windowHeight = jquery_default()(window).height();
    var scrollHeight = jquery_default()(window).scrollTop();
    var guiderOffset = myGuider.elem.offset();
    var guiderElemHeight = myGuider.elem.height();
    var isGuiderBelow = scrollHeight + windowHeight < guiderOffset.top + guiderElemHeight;
    var isGuiderAbove = guiderOffset.top < scrollHeight;

    if (myGuider.autoFocus && (isGuiderBelow || isGuiderAbove)) {
      setTimeout(guiders.scrollToCurrent, 10);
    }

    jquery_default()(myGuider.elem).trigger("guiders.show");
    return guiders;
  };
})();
// CONCATENATED MODULE: ./lib/core/options/storage.js


const options_storage_storage = storage_namespaceObject.wrapPrefix('RESoptions.', () => ({}), undefined, true);
const loadRaw = moduleId => options_storage_storage.get(moduleId);
async function options_storage_get(opaqueId, optionKey) {
  const options = await options_storage_storage.get(getModuleId(opaqueId));
  return options && options[optionKey];
}
async function storage_getValue(opaqueId, optionKey) {
  const option = await options_storage_get(getModuleId(opaqueId), optionKey);
  return option && option.value;
}
function options_storage_set(opaqueId, optionKey, value) {
  if (/_[\d]+$/.test(optionKey)) {
    optionKey = optionKey.replace(/_[\d]+$/, '');
  }

  return options_storage_storage.patch(getModuleId(opaqueId), {
    [optionKey]: {
      value
    }
  });
}
// CONCATENATED MODULE: ./node_modules/lodash-es/negate.js
var negate_FUNC_ERROR_TEXT='Expected a function';function negate(predicate){if(typeof predicate!='function'){throw new TypeError(negate_FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/* harmony default export */ var lodash_es_negate = (negate);
// EXTERNAL MODULE: ./node_modules/lodash-es/_basePickBy.js + 1 modules
var _basePickBy = __webpack_require__(92);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGetAllKeys.js
var _baseGetAllKeys = __webpack_require__(81);

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayPush.js
var _arrayPush = __webpack_require__(58);

// EXTERNAL MODULE: ./node_modules/lodash-es/_getSymbols.js
var _getSymbols = __webpack_require__(63);

// EXTERNAL MODULE: ./node_modules/lodash-es/stubArray.js
var stubArray = __webpack_require__(83);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols=Object.getOwnPropertySymbols;var getSymbolsIn=!nativeGetSymbols?stubArray["a" /* default */]:function(object){var result=[];while(object){Object(_arrayPush["a" /* default */])(result,Object(_getSymbols["a" /* default */])(object));object=_getPrototype(object);}return result;};/* harmony default export */ var _getSymbolsIn = (getSymbolsIn);
// EXTERNAL MODULE: ./node_modules/lodash-es/keysIn.js + 2 modules
var keysIn = __webpack_require__(47);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object){return Object(_baseGetAllKeys["a" /* default */])(object,keysIn["a" /* default */],_getSymbolsIn);}/* harmony default export */ var _getAllKeysIn = (getAllKeysIn);
// CONCATENATED MODULE: ./node_modules/lodash-es/pickBy.js
function pickBy(object,predicate){if(object==null){return{};}var props=Object(_arrayMap["a" /* default */])(_getAllKeysIn(object),function(prop){return[prop];});predicate=Object(_baseIteratee["a" /* default */])(predicate);return Object(_basePickBy["a" /* default */])(object,props,function(value,path){return predicate(value,path[0]);});}/* harmony default export */ var lodash_es_pickBy = (pickBy);
// CONCATENATED MODULE: ./node_modules/lodash-es/omitBy.js
function omitBy(object,predicate){return lodash_es_pickBy(object,lodash_es_negate(Object(_baseIteratee["a" /* default */])(predicate)));}/* harmony default export */ var lodash_es_omitBy = (omitBy);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseKeys.js + 1 modules
var _baseKeys = __webpack_require__(89);

// EXTERNAL MODULE: ./node_modules/lodash-es/_getTag.js + 2 modules
var _getTag = __webpack_require__(25);

// EXTERNAL MODULE: ./node_modules/lodash-es/isArguments.js + 1 modules
var isArguments = __webpack_require__(49);

// EXTERNAL MODULE: ./node_modules/lodash-es/_isPrototype.js
var _isPrototype = __webpack_require__(42);

// CONCATENATED MODULE: ./node_modules/lodash-es/isEmpty.js
var mapTag='[object Map]',setTag='[object Set]';var isEmpty_objectProto=Object.prototype;var isEmpty_hasOwnProperty=isEmpty_objectProto.hasOwnProperty;function isEmpty(value){if(value==null){return true;}if(Object(isArrayLike["a" /* default */])(value)&&(Object(isArray["a" /* default */])(value)||typeof value=='string'||typeof value.splice=='function'||Object(isBuffer["a" /* default */])(value)||Object(isTypedArray["a" /* default */])(value)||Object(isArguments["a" /* default */])(value))){return!value.length;}var tag=Object(_getTag["a" /* default */])(value);if(tag==mapTag||tag==setTag){return!value.size;}if(Object(_isPrototype["a" /* default */])(value)){return!Object(_baseKeys["a" /* default */])(value).length;}for(var key in value){if(isEmpty_hasOwnProperty.call(value,key)){return false;}}return true;}/* harmony default export */ var lodash_es_isEmpty = (isEmpty);
// CONCATENATED MODULE: ./lib/core/options/modified.js




function getModified() {
  return Object(utils_array["c" /* filterMap */])(modules_all(), module => {
    const {
      moduleID,
      options
    } = module;
    const enabledByDefault = !module.disabledByDefault;
    const isEnabled = modules_isEnabled(module);
    const moduleStatusChanged = enabledByDefault !== isEnabled;
    const modifiedOptions = isEnabled ? lodash_es_omitBy(options, v => lodash_es_isEqual(v.value, v.default)) : {};

    if (!lodash_es_isEmpty(modifiedOptions) || moduleStatusChanged) {
      return [{
        moduleID,
        modifiedOptions,
        moduleStatus: moduleStatusChanged ? `${enabledByDefault ? 'on' : 'off'} → ${isEnabled ? 'on' : 'off'}` : ''
      }];
    }
  });
}

function getModifiedText(censorOptions = ['backupAndRestore/googleAccount']) {
  const lines = [];
  let optionMaxLength = 0;
  let moduleMaxLength = 0;

  for (const {
    moduleID,
    modifiedOptions,
    moduleStatus
  } of getModified()) {
    moduleMaxLength = Math.max(moduleMaxLength, moduleID.length);
    optionMaxLength = Math.max(optionMaxLength, ...Object.keys(modifiedOptions).map(v => v.length));
    lines.push(() => [`    ${moduleID.padEnd(moduleMaxLength)} ${moduleStatus}`, ...Object.entries(modifiedOptions).map(([key, {
      value: _current,
      default: _default,
      type
    }]) => {
      const asText = v => ['text', 'boolean', 'enum', 'select', 'color'].includes(type) ? JSON.stringify(v) : ['list', 'table', 'builder'].includes(type) ? v.length : ['keycode'].includes(type) ? keycode_niceKeyCode(v) : '***UNKNOWN TYPE***';

      const defaultText = asText(_default);
      const currentText = censorOptions.includes(`${moduleID}/${key}`) ? '***CENSORED***' : asText(_current);
      return `      ${key.padEnd(optionMaxLength)}\t${defaultText} → ${currentText}`;
    })]);
  }

  return lines.map(v => v()).flat(2).join('\n');
}
// CONCATENATED MODULE: ./lib/core/options/stage.js



let stagedOptions;
clearStagedOptions();


function stageOption(moduleID, optionName, optionValue) {
  const mod = modules_get(moduleID);
  stagedOptions[moduleID] = stagedOptions[moduleID] || {};

  if (!lodash_es_isEqual(mod.options[optionName].value, optionValue)) {
    stagedOptions[moduleID][optionName] = {
      value: optionValue
    };
  } else {
    delete stagedOptions[moduleID][optionName];
  }

  if (lodash_es_isEmpty(stagedOptions[moduleID])) {
    delete stagedOptions[moduleID];
  }
}



function commitStagedOptions() {
  for (const [modId, options] of Object.entries(stagedOptions)) {
    const module = modules_get(modId);

    for (const [optionName, option] of Object.entries(options)) {
      const _option = module.options[optionName];
      _option.value = option.value;
      options_save(_option);
    }

    module.onSaveSettings(options);
  }

  clearStagedOptions();
}



function clearStagedOptions() {
  stagedOptions = {};
}



function hasStagedOptions() {
  return !lodash_es_isEmpty(stagedOptions);
}



function getStagedOptions(moduleID) {
  return stagedOptions[moduleID];
}
// CONCATENATED MODULE: ./lib/core/options/table.js



function getMatchingValueOrAdd(opaqueId, optionKey, valueIdentifier, _default) {
  const module = modules_get(opaqueId);
  const option = module.options[optionKey];

  if (option.type !== 'table') {
    throw new Error(`Tried to save table value to non-table option: modules.${module.moduleID}.options.${optionKey}`);
  }

  let row = option.value.find(value => option.fields.every((field, i) => !valueIdentifier.hasOwnProperty(field.key) || value[i] === valueIdentifier[field.key]));

  if (!row) {
    const value = { ...valueIdentifier,
      ..._default
    };
    row = option.fields.map(field => firstValid(value[field.key], field.value));
    option.value.push(row);
    options_storage_set(module, optionKey, option.value);
  }

  return option.fields.reduce((acc, field, i) => {
    Object.defineProperty(acc, field.key, {
      enumerable: true,
      get: () => row[i],
      set: v => {
        row[i] = v;
        options_storage_set(module, optionKey, option.value);
      }
    });
    return acc;
  }, {});
}
// CONCATENATED MODULE: ./lib/core/options/index.js







// CONCATENATED MODULE: ./lib/modules/hover.js




const hover_module = new Module('hover');
hover_module.moduleName = 'hoverName';
hover_module.category = 'coreCategory';
hover_module.description = 'hoverDesc';
hover_module.alwaysEnabled = true;
hover_module.options = {
  instances: {
    description: 'hoverInstancesDesc',
    title: 'hoverInstancesTitle',
    type: 'table',
    value: [],
    fields: [{
      key: 'id',
      name: 'hoverInstancesName',
      type: 'text'
    }, {
      key: 'enabled',
      name: 'hoverInstancesEnabled',
      type: 'boolean',
      value: true
    }]
  },
  openDelay: {
    type: 'text',
    value: '500',
    description: 'hoverOpenDelayDesc',
    title: 'hoverOpenDelayTitle'
  },
  fadeDelay: {
    type: 'text',
    value: '500',
    description: 'hoverFadeDelayDesc',
    title: 'hoverFadeDelayTitle'
  },
  fadeSpeed: {
    noconfig: true,
    type: 'text',
    value: '0.7',
    description: 'hoverFadeSpeedDesc',
    title: 'hoverFadeSpeedTitle'
  },
  width: {
    type: 'text',
    value: '512',
    description: 'hoverWidthDesc',
    title: 'hoverWidthTitle'
  },
  closeOnMouseOut: {
    type: 'boolean',
    value: true,
    description: 'hoverCloseOnMouseOutDesc',
    title: 'hoverCloseOnMouseOutTitle'
  }
};

hover_module.beforeLoad = () => {
  hover_Hover._defaultOptions = {
    openDelay: parseFloat(hover_module.options.openDelay.value),
    fadeDelay: parseFloat(hover_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(hover_module.options.fadeSpeed.value),
    width: parseFloat(hover_module.options.width.value),
    closeOnMouseOut: hover_module.options.closeOnMouseOut.value,
    enabled: true
  };
};

const instances = {};

const getInstance = (TypeClass, id) => instances[id] || (instances[id] = new TypeClass(id));

const infocard = name => getInstance(hover_HoverInfoCard, name);
const dropdownList = name => getInstance(hover_HoverDropdownList, name);

function getFixedParent(e) {
  const p = e.parentElement;
  return p && (window.getComputedStyle(p).position === 'fixed' && e || getFixedParent(p));
}

const pin = {
  bottom: 'bottom',
  right: 'right'
};

class hover_Hover {
  constructor(id) {
    this.template = `
		<div class="RESHover">
			<div data-hover-element="0" />
			<div data-hover-element="1" />
			<div data-hover-element="2" />
			<div data-hover-element="3" />
		</div>
	`;
    this._options = hover_Hover._defaultOptions;
    this.instanceID = void 0;
    this.visible = false;
    this._hideTimer = null;
    this._showTimer = null;
    this._closeFadeTimer = null;
    this._target = void 0;
    this._callback = void 0;
    this._container = void 0;
    this._fixedPosition = false;
    this._closePromise = void 0;
    this._closePromiseResolve = void 0;
    this._checkMouseLeave = Object(utils_async["e" /* frameThrottle */])(({
      target
    }) => {
      if (this.visible && this._options.closeOnMouseOut && !this.getCheckedTarget().contains(target) && !Object.values(instances).some(instance => instance._container && instance._container.contains(target))) this._startHideTimer();
    });

    this._startShowTimer = () => {
      if (this._showTimer) return;

      this._cancelHideTimer();

      Object(dom["r" /* waitForEvent */])(this.getCheckedTarget(), 'mouseleave').then(this._cancelShowTimer);
      this._showTimer = setTimeout(() => this.open(), this._options.openDelay);
    };

    this._cancelShowTimer = () => {
      if (!this._showTimer) return;
      clearTimeout(this._showTimer);
      this._showTimer = null;
    };

    this._startHideTimer = () => {
      if (this._hideTimer || this._closeFadeTimer) return;

      this._cancelShowTimer();

      this._hideTimer = setTimeout(() => this.close(true), this._options.fadeDelay);
    };

    this._cancelHideTimer = () => {
      if (!this._hideTimer) return;
      clearTimeout(this._hideTimer);
      this._hideTimer = null;
    };

    this.instanceID = id;
  }

  options(options, persistent = true) {
    const persistentOptions = persistent ? options_table_namespaceObject.getMatchingValueOrAdd(hover_module, 'instances', {
      id: this.instanceID
    }, {
      enabled: true
    }) : undefined;
    this._options = { ...this._options,
      ...options,
      ...persistentOptions
    };
    return this;
  }

  target(element) {
    if (this._target && this._target !== element) {
      this.close();
    }

    this._target = element;
    return this;
  }

  getCheckedTarget() {
    if (!this._target || !this._target.offsetParent) {
      this.close();
      throw new Error('Cannot show hover without target; closing hover.');
    }

    return this._target;
  }

  populateWith(callback) {
    this._callback = callback;
    return this;
  }

  getContainer() {
    const container = this._container = this._container || this._render();

    if (!document.body.contains(container)) {
      document.body.append(container);
    }

    return container;
  }

  _render() {
    const ele = jquery_default()(this.template).get(0);

    this._addContainerHandlers(ele);

    if (this._options.className) ele.classList.add(this._options.className);
    return ele;
  }

  _addContainerHandlers(ele) {
    jquery_default()(ele).on('mouseenter', () => {
      this._cancelHideTimer();

      this._clearCloseFade();
    }).on('mouseleave', this._checkMouseLeave).on('click', '.RESCloseButton', () => this.close()).on('keyup', e => {
      if (e.key === NAMED_KEYS.Escape) this.close();
      e.stopImmediatePropagation();
    });
  }

  begin() {
    if (!this._options.enabled) return false;

    if (this._options.openDelay) {
      this._startShowTimer();
    } else {
      this.open();
    }
  }

  watch(selector) {
    jquery_default()(document.body).on('mouseenter', selector, ({
      currentTarget
    }) => {
      this.target(currentTarget).begin();
    });
  }

  open() {
    if (!this._options.enabled) return false;

    this._cancelShowTimer();

    this._cancelHideTimer();

    this._clearCloseFade();

    const callback = this._callback;
    if (!callback) throw new Error();
    if (this._closePromiseResolve) this._closePromiseResolve();
    this._closePromise = new Promise(res => {
      this._closePromiseResolve = res;
    });

    this._displayLoadIndicator();

    (async () => {
      try {
        this.populate(await callback(this));
      } catch (e) {
        this.close();
        throw e;
      }
    })();

    Object(dom["q" /* waitForDetach */])(this.getCheckedTarget(), this._closePromise).then(() => {
      this.close();
    }).catch(() => {});

    if (this._options.closeOnMouseOut) {
      document.body.addEventListener('mousemove', this._checkMouseLeave);
      document.body.addEventListener('mouseover', this._checkMouseLeave);
    }

    this.visible = true;
  }

  _displayLoadIndicator() {}

  async refresh() {
    const callback = this._callback;
    if (callback) this.populate(await callback(this));
  }

  populate(items) {
    if (!this._options.enabled) return false;
    const container = this.getContainer();
    items.forEach((item, i) => {
      if (!item) return;
      const $element = jquery_default()(container).find(`[data-hover-element="${i}"]`);
      $element.children().detach();
      $element.empty().append(item);
    });
    const fixedParent = getFixedParent(this.getCheckedTarget());

    if (fixedParent) {
      this._fixedPosition = true;

      const onScroll = () => {
        this.close(false);
        fixedParent.removeEventListener('scroll', onScroll, true);
      };

      fixedParent.addEventListener('scroll', onScroll, true);
    }

    this._updatePosition();
  }

  _positionContainer({
    top = 'auto',
    right = 'auto',
    bottom = 'auto',
    left = 'auto'
  }) {
    jquery_default()(this.getContainer()).css({
      position: this._fixedPosition ? 'fixed' : 'absolute',
      top: top !== 'auto' ? top + (this._fixedPosition ? 0 : window.scrollY) : 'auto',
      right: right !== 'auto' ? right + (this._fixedPosition ? 0 : window.scrollX) : 'auto',
      bottom: bottom !== 'auto' ? bottom + (this._fixedPosition ? 0 : window.scrollY) : 'auto',
      left: left !== 'auto' ? left + (this._fixedPosition ? 0 : window.scrollX) : 'auto'
    });
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left
    } = target.getBoundingClientRect();

    this._positionContainer({
      top,
      left
    });
  }

  resetShowTimer() {
    if (this._showTimer) {
      this._cancelShowTimer();

      this._startShowTimer();
    }
  }

  _startCloseFade() {
    if (this._closeFadeTimer) return;
    this._closeFadeTimer = setTimeout(() => {
      this.remove();
    }, this._options.fadeSpeed * 1000);
    this.getContainer().style.transitionDuration = `${this._options.fadeSpeed}s`;
    this.getContainer().classList.add('transitionToTransparent');
  }

  _clearCloseFade() {
    if (!this._closeFadeTimer) return;
    clearTimeout(this._closeFadeTimer);
    this.getContainer().style.transitionDuration = '';
    this.getContainer().classList.remove('transitionToTransparent');
    this._closeFadeTimer = null;
  }

  close(fade = false) {
    if (!this._options.enabled) return false;

    this._cancelShowTimer();

    this._cancelHideTimer();

    if (fade) this._startCloseFade();else this.remove();
  }

  remove() {
    this._clearCloseFade();

    this.getContainer().remove();
    if (this._closePromiseResolve) this._closePromiseResolve();
    this.visible = false;

    if (this._options.closeOnMouseOut) {
      document.body.removeEventListener('mousemove', this._checkMouseLeave);
      document.body.removeEventListener('mouseover', this._checkMouseLeave);
    }
  }

}

hover_Hover._defaultOptions = {};

class hover_HoverInfoCard extends hover_Hover {
  constructor(...args) {
    super(...args);
    this.template = `
		<div class="RESHover RESHoverInfoCard RESDialogSmall">
			<h3 class="RESHoverTitle" data-hover-element="0"></h3>
			<div class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESHoverBody RESDialogContents" data-hover-element="1"></div>
		</div>
	`;
    this._loadIndicator = '<div class="RESCenteredLoadIndicator"><span class="RESLoadingSpinner"></span></div>';
  }

  _displayLoadIndicator() {
    this.populate(['…', this._loadIndicator]);
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left,
      bottom,
      right
    } = target.getBoundingClientRect();
    const $container = jquery_default()(this.getContainer()).removeClass('right below');
    const tooltipWidth = this._options.width;
    let tooltipLeft, tooltipTop;

    if (!this._options.pin && right + tooltipWidth + 25 < Object(dom["i" /* getViewportSize */])().width) {
      tooltipTop = top - 14;
      tooltipLeft = right + 25;
    } else if (this._options.pin === pin.bottom || left - tooltipWidth - 30 < 0) {
      $container.addClass('below');
      tooltipTop = bottom + 10;
      tooltipLeft = Math.min(Math.max(Object(dom["i" /* getViewportSize */])().width - tooltipWidth, 0), left);
    } else {
      $container.addClass('right');
      tooltipTop = top - 14;
      tooltipLeft = left - tooltipWidth - 30;
    }

    $container.get(0).style.width = `${tooltipWidth}px`;

    this._positionContainer({
      left: tooltipLeft,
      top: tooltipTop
    });
  }

}

class hover_HoverDropdownList extends hover_Hover {
  constructor(...args) {
    super(...args);
    this.template = `
		<div class="RESHover RESHoverDropdownList RESDropdownList">
			<ul class="RESDropdownOptions" data-hover-element="0"></ul>
		</div>
	`;
    this._options = { ...hover_Hover._defaultOptions,
      pin: pin.bottom,
      offsetWidth: 0,
      offsetHeight: 2,
      bottomPadding: 10
    };
  }

  _updatePosition() {
    const target = this.getCheckedTarget();
    const {
      top,
      left,
      height,
      width
    } = target.getBoundingClientRect();
    const $container = jquery_default()(this.getContainer());

    switch (this._options.pin) {
      case pin.right:
        const bottomAlign = top + $container.height() + this._options.bottomPadding > Object(dom["i" /* getViewportSize */])().height;

        if (bottomAlign) {
          this._positionContainer({
            left: left + width,
            bottom: this._options.bottomPadding
          });
        } else {
          this._positionContainer({
            left: left + width,
            top: top + this._options.offsetHeight
          });
        }

        break;

      case pin.bottom:
      default:
        const leftAlign = left + $container.outerWidth() < Object(dom["i" /* getViewportSize */])().width;

        if (leftAlign) {
          this._positionContainer({
            left,
            top: top + height + this._options.offsetHeight
          });
        } else {
          this._positionContainer({
            right: Object(dom["i" /* getViewportSize */])().width - left - width + this._options.offsetWidth,
            top: top + height + this._options.offsetHeight
          });
        }

        break;
    }
  }

}
// CONCATENATED MODULE: ./node_modules/dompurify/dist/purify.es.js
/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.2.2/LICENSE */function purify_es_toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}var purify_es_hasOwnProperty=Object.hasOwnProperty,setPrototypeOf=Object.setPrototypeOf,isFrozen=Object.isFrozen,getPrototypeOf=Object.getPrototypeOf,getOwnPropertyDescriptor=Object.getOwnPropertyDescriptor;var freeze=Object.freeze,seal=Object.seal,create=Object.create;var _ref=typeof Reflect!=='undefined'&&Reflect,apply=_ref.apply,construct=_ref.construct;if(!apply){apply=function(fun,thisValue,args){return fun.apply(thisValue,args);};}if(!freeze){freeze=function(x){return x;};}if(!seal){seal=function(x){return x;};}if(!construct){construct=function(Func,args){return new(Function.prototype.bind.apply(Func,[null].concat(purify_es_toConsumableArray(args))))();};}var arrayForEach=unapply(Array.prototype.forEach);var arrayPop=unapply(Array.prototype.pop);var arrayPush=unapply(Array.prototype.push);var stringToLowerCase=unapply(String.prototype.toLowerCase);var stringMatch=unapply(String.prototype.match);var stringReplace=unapply(String.prototype.replace);var stringIndexOf=unapply(String.prototype.indexOf);var stringTrim=unapply(String.prototype.trim);var regExpTest=unapply(RegExp.prototype.test);var typeErrorCreate=unconstruct(TypeError);function unapply(func){return function(thisArg){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}return apply(func,thisArg,args);};}function unconstruct(func){return function(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}return construct(func,args);};}function addToSet(set,array){if(setPrototypeOf){setPrototypeOf(set,null);}var l=array.length;while(l--){var element=array[l];if(typeof element==='string'){var lcElement=stringToLowerCase(element);if(lcElement!==element){if(!isFrozen(array)){array[l]=lcElement;}element=lcElement;}}set[element]=true;}return set;}function purify_es_clone(object){var newObject=create(null);var property=void 0;for(property in object){if(apply(purify_es_hasOwnProperty,object,[property])){newObject[property]=object[property];}}return newObject;}function lookupGetter(object,prop){while(object!==null){var desc=getOwnPropertyDescriptor(object,prop);if(desc){if(desc.get){return unapply(desc.get);}if(typeof desc.value==='function'){return unapply(desc.value);}}object=getPrototypeOf(object);}return function(element){console.warn('fallback value for',element);return null;};}var purify_es_html=freeze(['a','abbr','acronym','address','area','article','aside','audio','b','bdi','bdo','big','blink','blockquote','body','br','button','canvas','caption','center','cite','code','col','colgroup','content','data','datalist','dd','decorator','del','details','dfn','dialog','dir','div','dl','dt','element','em','fieldset','figcaption','figure','font','footer','form','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','i','img','input','ins','kbd','label','legend','li','main','map','mark','marquee','menu','menuitem','meter','nav','nobr','ol','optgroup','option','output','p','picture','pre','progress','q','rp','rt','ruby','s','samp','section','select','shadow','small','source','spacer','span','strike','strong','style','sub','summary','sup','table','tbody','td','template','textarea','tfoot','th','thead','time','tr','track','tt','u','ul','var','video','wbr']);var svg=freeze(['svg','a','altglyph','altglyphdef','altglyphitem','animatecolor','animatemotion','animatetransform','circle','clippath','defs','desc','ellipse','filter','font','g','glyph','glyphref','hkern','image','line','lineargradient','marker','mask','metadata','mpath','path','pattern','polygon','polyline','radialgradient','rect','stop','style','switch','symbol','text','textpath','title','tref','tspan','view','vkern']);var svgFilters=freeze(['feBlend','feColorMatrix','feComponentTransfer','feComposite','feConvolveMatrix','feDiffuseLighting','feDisplacementMap','feDistantLight','feFlood','feFuncA','feFuncB','feFuncG','feFuncR','feGaussianBlur','feMerge','feMergeNode','feMorphology','feOffset','fePointLight','feSpecularLighting','feSpotLight','feTile','feTurbulence']);var svgDisallowed=freeze(['animate','color-profile','cursor','discard','fedropshadow','feimage','font-face','font-face-format','font-face-name','font-face-src','font-face-uri','foreignobject','hatch','hatchpath','mesh','meshgradient','meshpatch','meshrow','missing-glyph','script','set','solidcolor','unknown','use']);var mathMl=freeze(['math','menclose','merror','mfenced','mfrac','mglyph','mi','mlabeledtr','mmultiscripts','mn','mo','mover','mpadded','mphantom','mroot','mrow','ms','mspace','msqrt','mstyle','msub','msup','msubsup','mtable','mtd','mtext','mtr','munder','munderover']);var mathMlDisallowed=freeze(['maction','maligngroup','malignmark','mlongdiv','mscarries','mscarry','msgroup','mstack','msline','msrow','semantics','annotation','annotation-xml','mprescripts','none']);var purify_es_text=freeze(['#text']);var html$1=freeze(['accept','action','align','alt','autocapitalize','autocomplete','autopictureinpicture','autoplay','background','bgcolor','border','capture','cellpadding','cellspacing','checked','cite','class','clear','color','cols','colspan','controls','controlslist','coords','crossorigin','datetime','decoding','default','dir','disabled','disablepictureinpicture','disableremoteplayback','download','draggable','enctype','enterkeyhint','face','for','headers','height','hidden','high','href','hreflang','id','inputmode','integrity','ismap','kind','label','lang','list','loading','loop','low','max','maxlength','media','method','min','minlength','multiple','muted','name','noshade','novalidate','nowrap','open','optimum','pattern','placeholder','playsinline','poster','preload','pubdate','radiogroup','readonly','rel','required','rev','reversed','role','rows','rowspan','spellcheck','scope','selected','shape','size','sizes','span','srclang','start','src','srcset','step','style','summary','tabindex','title','translate','type','usemap','valign','value','width','xmlns','slot']);var svg$1=freeze(['accent-height','accumulate','additive','alignment-baseline','ascent','attributename','attributetype','azimuth','basefrequency','baseline-shift','begin','bias','by','class','clip','clippathunits','clip-path','clip-rule','color','color-interpolation','color-interpolation-filters','color-profile','color-rendering','cx','cy','d','dx','dy','diffuseconstant','direction','display','divisor','dur','edgemode','elevation','end','fill','fill-opacity','fill-rule','filter','filterunits','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','fx','fy','g1','g2','glyph-name','glyphref','gradientunits','gradienttransform','height','href','id','image-rendering','in','in2','k','k1','k2','k3','k4','kerning','keypoints','keysplines','keytimes','lang','lengthadjust','letter-spacing','kernelmatrix','kernelunitlength','lighting-color','local','marker-end','marker-mid','marker-start','markerheight','markerunits','markerwidth','maskcontentunits','maskunits','max','mask','media','method','mode','min','name','numoctaves','offset','operator','opacity','order','orient','orientation','origin','overflow','paint-order','path','pathlength','patterncontentunits','patterntransform','patternunits','points','preservealpha','preserveaspectratio','primitiveunits','r','rx','ry','radius','refx','refy','repeatcount','repeatdur','restart','result','rotate','scale','seed','shape-rendering','specularconstant','specularexponent','spreadmethod','startoffset','stddeviation','stitchtiles','stop-color','stop-opacity','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke','stroke-width','style','surfacescale','systemlanguage','tabindex','targetx','targety','transform','text-anchor','text-decoration','text-rendering','textlength','type','u1','u2','unicode','values','viewbox','visibility','version','vert-adv-y','vert-origin-x','vert-origin-y','width','word-spacing','wrap','writing-mode','xchannelselector','ychannelselector','x','x1','x2','xmlns','y','y1','y2','z','zoomandpan']);var mathMl$1=freeze(['accent','accentunder','align','bevelled','close','columnsalign','columnlines','columnspan','denomalign','depth','dir','display','displaystyle','encoding','fence','frame','height','href','id','largeop','length','linethickness','lspace','lquote','mathbackground','mathcolor','mathsize','mathvariant','maxsize','minsize','movablelimits','notation','numalign','open','rowalign','rowlines','rowspacing','rowspan','rspace','rquote','scriptlevel','scriptminsize','scriptsizemultiplier','selection','separator','separators','stretchy','subscriptshift','supscriptshift','symmetric','voffset','width','xmlns']);var xml=freeze(['xlink:href','xml:id','xlink:title','xml:space','xmlns:xlink']);var MUSTACHE_EXPR=seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);var ERB_EXPR=seal(/<%[\s\S]*|[\s\S]*%>/gm);var DATA_ATTR=seal(/^data-[\-\w.\u00B7-\uFFFF]/);var ARIA_ATTR=seal(/^aria-[\-\w]+$/);var IS_ALLOWED_URI=seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);var IS_SCRIPT_OR_DATA=seal(/^(?:\w+script|data):/i);var ATTR_WHITESPACE=seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);var purify_es_typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};function _toConsumableArray$1(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}var getGlobal=function(){return typeof window==='undefined'?null:window;};var _createTrustedTypesPolicy=function(trustedTypes,document){if((typeof trustedTypes==='undefined'?'undefined':purify_es_typeof(trustedTypes))!=='object'||typeof trustedTypes.createPolicy!=='function'){return null;}var suffix=null;var ATTR_NAME='data-tt-policy-suffix';if(document.currentScript&&document.currentScript.hasAttribute(ATTR_NAME)){suffix=document.currentScript.getAttribute(ATTR_NAME);}var policyName='dompurify'+(suffix?'#'+suffix:'');try{return trustedTypes.createPolicy(policyName,{createHTML:function(html$$1){return html$$1;}});}catch(_){console.warn('TrustedTypes policy '+policyName+' could not be created.');return null;}};function createDOMPurify(){var window=arguments.length>0&&arguments[0]!==undefined?arguments[0]:getGlobal();var DOMPurify=function(root){return createDOMPurify(root);};DOMPurify.version='2.2.8';DOMPurify.removed=[];if(!window||!window.document||window.document.nodeType!==9){DOMPurify.isSupported=false;return DOMPurify;}var originalDocument=window.document;var document=window.document;var DocumentFragment=window.DocumentFragment,HTMLTemplateElement=window.HTMLTemplateElement,Node=window.Node,Element=window.Element,NodeFilter=window.NodeFilter,_window$NamedNodeMap=window.NamedNodeMap,NamedNodeMap=_window$NamedNodeMap===undefined?window.NamedNodeMap||window.MozNamedAttrMap:_window$NamedNodeMap,Text=window.Text,Comment=window.Comment,DOMParser=window.DOMParser,trustedTypes=window.trustedTypes;var ElementPrototype=Element.prototype;var cloneNode=lookupGetter(ElementPrototype,'cloneNode');var getNextSibling=lookupGetter(ElementPrototype,'nextSibling');var getChildNodes=lookupGetter(ElementPrototype,'childNodes');var getParentNode=lookupGetter(ElementPrototype,'parentNode');if(typeof HTMLTemplateElement==='function'){var template=document.createElement('template');if(template.content&&template.content.ownerDocument){document=template.content.ownerDocument;}}var trustedTypesPolicy=_createTrustedTypesPolicy(trustedTypes,originalDocument);var emptyHTML=trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(''):'';var _document=document,implementation=_document.implementation,createNodeIterator=_document.createNodeIterator,createDocumentFragment=_document.createDocumentFragment;var importNode=originalDocument.importNode;var documentMode={};try{documentMode=purify_es_clone(document).documentMode?document.documentMode:{};}catch(_){}var hooks={};DOMPurify.isSupported=typeof getParentNode==='function'&&implementation&&typeof implementation.createHTMLDocument!=='undefined'&&documentMode!==9;var MUSTACHE_EXPR$$1=MUSTACHE_EXPR,ERB_EXPR$$1=ERB_EXPR,ATTR_WHITESPACE$$1=ATTR_WHITESPACE;var IS_ALLOWED_URI$$1=IS_ALLOWED_URI;var ALLOWED_TAGS=null;var DEFAULT_ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray$1(purify_es_html),_toConsumableArray$1(svg),_toConsumableArray$1(svgFilters),_toConsumableArray$1(mathMl),_toConsumableArray$1(purify_es_text)));var ALLOWED_ATTR=null;var DEFAULT_ALLOWED_ATTR=addToSet({},[].concat(_toConsumableArray$1(html$1),_toConsumableArray$1(svg$1),_toConsumableArray$1(mathMl$1),_toConsumableArray$1(xml)));var FORBID_TAGS=null;var FORBID_ATTR=null;var ALLOW_ARIA_ATTR=true;var ALLOW_DATA_ATTR=true;var ALLOW_UNKNOWN_PROTOCOLS=false;var SAFE_FOR_TEMPLATES=false;var WHOLE_DOCUMENT=false;var SET_CONFIG=false;var FORCE_BODY=false;var RETURN_DOM=false;var RETURN_DOM_FRAGMENT=false;var RETURN_DOM_IMPORT=true;var RETURN_TRUSTED_TYPE=false;var SANITIZE_DOM=true;var KEEP_CONTENT=true;var IN_PLACE=false;var USE_PROFILES={};var FORBID_CONTENTS=addToSet({},['annotation-xml','audio','colgroup','desc','foreignobject','head','iframe','math','mi','mn','mo','ms','mtext','noembed','noframes','noscript','plaintext','script','style','svg','template','thead','title','video','xmp']);var DATA_URI_TAGS=null;var DEFAULT_DATA_URI_TAGS=addToSet({},['audio','video','img','source','image','track']);var URI_SAFE_ATTRIBUTES=null;var DEFAULT_URI_SAFE_ATTRIBUTES=addToSet({},['alt','class','for','id','label','name','pattern','placeholder','summary','title','value','style','xmlns']);var MATHML_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var NAMESPACE=HTML_NAMESPACE;var CONFIG=null;var formElement=document.createElement('form');var _parseConfig=function(cfg){if(CONFIG&&CONFIG===cfg){return;}if(!cfg||(typeof cfg==='undefined'?'undefined':purify_es_typeof(cfg))!=='object'){cfg={};}cfg=purify_es_clone(cfg);ALLOWED_TAGS='ALLOWED_TAGS'in cfg?addToSet({},cfg.ALLOWED_TAGS):DEFAULT_ALLOWED_TAGS;ALLOWED_ATTR='ALLOWED_ATTR'in cfg?addToSet({},cfg.ALLOWED_ATTR):DEFAULT_ALLOWED_ATTR;URI_SAFE_ATTRIBUTES='ADD_URI_SAFE_ATTR'in cfg?addToSet(purify_es_clone(DEFAULT_URI_SAFE_ATTRIBUTES),cfg.ADD_URI_SAFE_ATTR):DEFAULT_URI_SAFE_ATTRIBUTES;DATA_URI_TAGS='ADD_DATA_URI_TAGS'in cfg?addToSet(purify_es_clone(DEFAULT_DATA_URI_TAGS),cfg.ADD_DATA_URI_TAGS):DEFAULT_DATA_URI_TAGS;FORBID_TAGS='FORBID_TAGS'in cfg?addToSet({},cfg.FORBID_TAGS):{};FORBID_ATTR='FORBID_ATTR'in cfg?addToSet({},cfg.FORBID_ATTR):{};USE_PROFILES='USE_PROFILES'in cfg?cfg.USE_PROFILES:false;ALLOW_ARIA_ATTR=cfg.ALLOW_ARIA_ATTR!==false;ALLOW_DATA_ATTR=cfg.ALLOW_DATA_ATTR!==false;ALLOW_UNKNOWN_PROTOCOLS=cfg.ALLOW_UNKNOWN_PROTOCOLS||false;SAFE_FOR_TEMPLATES=cfg.SAFE_FOR_TEMPLATES||false;WHOLE_DOCUMENT=cfg.WHOLE_DOCUMENT||false;RETURN_DOM=cfg.RETURN_DOM||false;RETURN_DOM_FRAGMENT=cfg.RETURN_DOM_FRAGMENT||false;RETURN_DOM_IMPORT=cfg.RETURN_DOM_IMPORT!==false;RETURN_TRUSTED_TYPE=cfg.RETURN_TRUSTED_TYPE||false;FORCE_BODY=cfg.FORCE_BODY||false;SANITIZE_DOM=cfg.SANITIZE_DOM!==false;KEEP_CONTENT=cfg.KEEP_CONTENT!==false;IN_PLACE=cfg.IN_PLACE||false;IS_ALLOWED_URI$$1=cfg.ALLOWED_URI_REGEXP||IS_ALLOWED_URI$$1;NAMESPACE=cfg.NAMESPACE||NAMESPACE;if(SAFE_FOR_TEMPLATES){ALLOW_DATA_ATTR=false;}if(RETURN_DOM_FRAGMENT){RETURN_DOM=true;}if(USE_PROFILES){ALLOWED_TAGS=addToSet({},[].concat(_toConsumableArray$1(purify_es_text)));ALLOWED_ATTR=[];if(USE_PROFILES.html===true){addToSet(ALLOWED_TAGS,purify_es_html);addToSet(ALLOWED_ATTR,html$1);}if(USE_PROFILES.svg===true){addToSet(ALLOWED_TAGS,svg);addToSet(ALLOWED_ATTR,svg$1);addToSet(ALLOWED_ATTR,xml);}if(USE_PROFILES.svgFilters===true){addToSet(ALLOWED_TAGS,svgFilters);addToSet(ALLOWED_ATTR,svg$1);addToSet(ALLOWED_ATTR,xml);}if(USE_PROFILES.mathMl===true){addToSet(ALLOWED_TAGS,mathMl);addToSet(ALLOWED_ATTR,mathMl$1);addToSet(ALLOWED_ATTR,xml);}}if(cfg.ADD_TAGS){if(ALLOWED_TAGS===DEFAULT_ALLOWED_TAGS){ALLOWED_TAGS=purify_es_clone(ALLOWED_TAGS);}addToSet(ALLOWED_TAGS,cfg.ADD_TAGS);}if(cfg.ADD_ATTR){if(ALLOWED_ATTR===DEFAULT_ALLOWED_ATTR){ALLOWED_ATTR=purify_es_clone(ALLOWED_ATTR);}addToSet(ALLOWED_ATTR,cfg.ADD_ATTR);}if(cfg.ADD_URI_SAFE_ATTR){addToSet(URI_SAFE_ATTRIBUTES,cfg.ADD_URI_SAFE_ATTR);}if(KEEP_CONTENT){ALLOWED_TAGS['#text']=true;}if(WHOLE_DOCUMENT){addToSet(ALLOWED_TAGS,['html','head','body']);}if(ALLOWED_TAGS.table){addToSet(ALLOWED_TAGS,['tbody']);delete FORBID_TAGS.tbody;}if(freeze){freeze(cfg);}CONFIG=cfg;};var MATHML_TEXT_INTEGRATION_POINTS=addToSet({},['mi','mo','mn','ms','mtext']);var HTML_INTEGRATION_POINTS=addToSet({},['foreignobject','desc','title','annotation-xml']);var ALL_SVG_TAGS=addToSet({},svg);addToSet(ALL_SVG_TAGS,svgFilters);addToSet(ALL_SVG_TAGS,svgDisallowed);var ALL_MATHML_TAGS=addToSet({},mathMl);addToSet(ALL_MATHML_TAGS,mathMlDisallowed);var _checkValidNamespace=function(element){var parent=getParentNode(element);if(!parent||!parent.tagName){parent={namespaceURI:HTML_NAMESPACE,tagName:'template'};}var tagName=stringToLowerCase(element.tagName);var parentTagName=stringToLowerCase(parent.tagName);if(element.namespaceURI===SVG_NAMESPACE){if(parent.namespaceURI===HTML_NAMESPACE){return tagName==='svg';}if(parent.namespaceURI===MATHML_NAMESPACE){return tagName==='svg'&&(parentTagName==='annotation-xml'||MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);}return Boolean(ALL_SVG_TAGS[tagName]);}if(element.namespaceURI===MATHML_NAMESPACE){if(parent.namespaceURI===HTML_NAMESPACE){return tagName==='math';}if(parent.namespaceURI===SVG_NAMESPACE){return tagName==='math'&&HTML_INTEGRATION_POINTS[parentTagName];}return Boolean(ALL_MATHML_TAGS[tagName]);}if(element.namespaceURI===HTML_NAMESPACE){if(parent.namespaceURI===SVG_NAMESPACE&&!HTML_INTEGRATION_POINTS[parentTagName]){return false;}if(parent.namespaceURI===MATHML_NAMESPACE&&!MATHML_TEXT_INTEGRATION_POINTS[parentTagName]){return false;}var commonSvgAndHTMLElements=addToSet({},['title','style','font','a','script']);return!ALL_MATHML_TAGS[tagName]&&(commonSvgAndHTMLElements[tagName]||!ALL_SVG_TAGS[tagName]);}return false;};var _forceRemove=function(node){arrayPush(DOMPurify.removed,{element:node});try{node.parentNode.removeChild(node);}catch(_){try{node.outerHTML=emptyHTML;}catch(_){node.remove();}}};var _removeAttribute=function(name,node){try{arrayPush(DOMPurify.removed,{attribute:node.getAttributeNode(name),from:node});}catch(_){arrayPush(DOMPurify.removed,{attribute:null,from:node});}node.removeAttribute(name);if(name==='is'&&!ALLOWED_ATTR[name]){if(RETURN_DOM||RETURN_DOM_FRAGMENT){try{_forceRemove(node);}catch(_){}}else{try{node.setAttribute(name,'');}catch(_){}}}};var _initDocument=function(dirty){var doc=void 0;var leadingWhitespace=void 0;if(FORCE_BODY){dirty='<remove></remove>'+dirty;}else{var matches=stringMatch(dirty,/^[\r\n\t ]+/);leadingWhitespace=matches&&matches[0];}var dirtyPayload=trustedTypesPolicy?trustedTypesPolicy.createHTML(dirty):dirty;if(NAMESPACE===HTML_NAMESPACE){try{doc=new DOMParser().parseFromString(dirtyPayload,'text/html');}catch(_){}}if(!doc||!doc.documentElement){doc=implementation.createDocument(NAMESPACE,'template',null);doc.documentElement.innerHTML=dirtyPayload;}var body=doc.body||doc.documentElement;if(dirty&&leadingWhitespace){body.insertBefore(document.createTextNode(leadingWhitespace),body.childNodes[0]||null);}return WHOLE_DOCUMENT?doc.documentElement:body;};var _createIterator=function(root){return createNodeIterator.call(root.ownerDocument||root,root,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT,function(){return NodeFilter.FILTER_ACCEPT;},false);};var _isClobbered=function(elm){if(elm instanceof Text||elm instanceof Comment){return false;}if(typeof elm.nodeName!=='string'||typeof elm.textContent!=='string'||typeof elm.removeChild!=='function'||!(elm.attributes instanceof NamedNodeMap)||typeof elm.removeAttribute!=='function'||typeof elm.setAttribute!=='function'||typeof elm.namespaceURI!=='string'||typeof elm.insertBefore!=='function'){return true;}return false;};var _isNode=function(object){return(typeof Node==='undefined'?'undefined':purify_es_typeof(Node))==='object'?object instanceof Node:object&&(typeof object==='undefined'?'undefined':purify_es_typeof(object))==='object'&&typeof object.nodeType==='number'&&typeof object.nodeName==='string';};var _executeHook=function(entryPoint,currentNode,data){if(!hooks[entryPoint]){return;}arrayForEach(hooks[entryPoint],function(hook){hook.call(DOMPurify,currentNode,data,CONFIG);});};var _sanitizeElements=function(currentNode){var content=void 0;_executeHook('beforeSanitizeElements',currentNode,null);if(_isClobbered(currentNode)){_forceRemove(currentNode);return true;}if(stringMatch(currentNode.nodeName,/[\u0080-\uFFFF]/)){_forceRemove(currentNode);return true;}var tagName=stringToLowerCase(currentNode.nodeName);_executeHook('uponSanitizeElement',currentNode,{tagName:tagName,allowedTags:ALLOWED_TAGS});if(!_isNode(currentNode.firstElementChild)&&(!_isNode(currentNode.content)||!_isNode(currentNode.content.firstElementChild))&&regExpTest(/<[/\w]/g,currentNode.innerHTML)&&regExpTest(/<[/\w]/g,currentNode.textContent)){_forceRemove(currentNode);return true;}if(!ALLOWED_TAGS[tagName]||FORBID_TAGS[tagName]){if(KEEP_CONTENT&&!FORBID_CONTENTS[tagName]){var parentNode=getParentNode(currentNode)||currentNode.parentNode;var childNodes=getChildNodes(currentNode)||currentNode.childNodes;if(childNodes&&parentNode){var childCount=childNodes.length;for(var i=childCount-1;i>=0;--i){parentNode.insertBefore(cloneNode(childNodes[i],true),getNextSibling(currentNode));}}}_forceRemove(currentNode);return true;}if(currentNode instanceof Element&&!_checkValidNamespace(currentNode)){_forceRemove(currentNode);return true;}if((tagName==='noscript'||tagName==='noembed')&&regExpTest(/<\/no(script|embed)/i,currentNode.innerHTML)){_forceRemove(currentNode);return true;}if(SAFE_FOR_TEMPLATES&&currentNode.nodeType===3){content=currentNode.textContent;content=stringReplace(content,MUSTACHE_EXPR$$1,' ');content=stringReplace(content,ERB_EXPR$$1,' ');if(currentNode.textContent!==content){arrayPush(DOMPurify.removed,{element:currentNode.cloneNode()});currentNode.textContent=content;}}_executeHook('afterSanitizeElements',currentNode,null);return false;};var _isValidAttribute=function(lcTag,lcName,value){if(SANITIZE_DOM&&(lcName==='id'||lcName==='name')&&(value in document||value in formElement)){return false;}if(ALLOW_DATA_ATTR&&regExpTest(DATA_ATTR,lcName));else if(ALLOW_ARIA_ATTR&&regExpTest(ARIA_ATTR,lcName));else if(!ALLOWED_ATTR[lcName]||FORBID_ATTR[lcName]){return false;}else if(URI_SAFE_ATTRIBUTES[lcName]);else if(regExpTest(IS_ALLOWED_URI$$1,stringReplace(value,ATTR_WHITESPACE$$1,'')));else if((lcName==='src'||lcName==='xlink:href'||lcName==='href')&&lcTag!=='script'&&stringIndexOf(value,'data:')===0&&DATA_URI_TAGS[lcTag]);else if(ALLOW_UNKNOWN_PROTOCOLS&&!regExpTest(IS_SCRIPT_OR_DATA,stringReplace(value,ATTR_WHITESPACE$$1,'')));else if(!value);else{return false;}return true;};var _sanitizeAttributes=function(currentNode){var attr=void 0;var value=void 0;var lcName=void 0;var l=void 0;_executeHook('beforeSanitizeAttributes',currentNode,null);var attributes=currentNode.attributes;if(!attributes){return;}var hookEvent={attrName:'',attrValue:'',keepAttr:true,allowedAttributes:ALLOWED_ATTR};l=attributes.length;while(l--){attr=attributes[l];var _attr=attr,name=_attr.name,namespaceURI=_attr.namespaceURI;value=stringTrim(attr.value);lcName=stringToLowerCase(name);hookEvent.attrName=lcName;hookEvent.attrValue=value;hookEvent.keepAttr=true;hookEvent.forceKeepAttr=undefined;_executeHook('uponSanitizeAttribute',currentNode,hookEvent);value=hookEvent.attrValue;if(hookEvent.forceKeepAttr){continue;}_removeAttribute(name,currentNode);if(!hookEvent.keepAttr){continue;}if(regExpTest(/\/>/i,value)){_removeAttribute(name,currentNode);continue;}if(SAFE_FOR_TEMPLATES){value=stringReplace(value,MUSTACHE_EXPR$$1,' ');value=stringReplace(value,ERB_EXPR$$1,' ');}var lcTag=currentNode.nodeName.toLowerCase();if(!_isValidAttribute(lcTag,lcName,value)){continue;}try{if(namespaceURI){currentNode.setAttributeNS(namespaceURI,name,value);}else{currentNode.setAttribute(name,value);}arrayPop(DOMPurify.removed);}catch(_){}}_executeHook('afterSanitizeAttributes',currentNode,null);};var _sanitizeShadowDOM=function _sanitizeShadowDOM(fragment){var shadowNode=void 0;var shadowIterator=_createIterator(fragment);_executeHook('beforeSanitizeShadowDOM',fragment,null);while(shadowNode=shadowIterator.nextNode()){_executeHook('uponSanitizeShadowNode',shadowNode,null);if(_sanitizeElements(shadowNode)){continue;}if(shadowNode.content instanceof DocumentFragment){_sanitizeShadowDOM(shadowNode.content);}_sanitizeAttributes(shadowNode);}_executeHook('afterSanitizeShadowDOM',fragment,null);};DOMPurify.sanitize=function(dirty,cfg){var body=void 0;var importedNode=void 0;var currentNode=void 0;var oldNode=void 0;var returnNode=void 0;if(!dirty){dirty='<!-->';}if(typeof dirty!=='string'&&!_isNode(dirty)){if(typeof dirty.toString!=='function'){throw typeErrorCreate('toString is not a function');}else{dirty=dirty.toString();if(typeof dirty!=='string'){throw typeErrorCreate('dirty is not a string, aborting');}}}if(!DOMPurify.isSupported){if(purify_es_typeof(window.toStaticHTML)==='object'||typeof window.toStaticHTML==='function'){if(typeof dirty==='string'){return window.toStaticHTML(dirty);}if(_isNode(dirty)){return window.toStaticHTML(dirty.outerHTML);}}return dirty;}if(!SET_CONFIG){_parseConfig(cfg);}DOMPurify.removed=[];if(typeof dirty==='string'){IN_PLACE=false;}if(IN_PLACE);else if(dirty instanceof Node){body=_initDocument('<!---->');importedNode=body.ownerDocument.importNode(dirty,true);if(importedNode.nodeType===1&&importedNode.nodeName==='BODY'){body=importedNode;}else if(importedNode.nodeName==='HTML'){body=importedNode;}else{body.appendChild(importedNode);}}else{if(!RETURN_DOM&&!SAFE_FOR_TEMPLATES&&!WHOLE_DOCUMENT&&dirty.indexOf('<')===-1){return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(dirty):dirty;}body=_initDocument(dirty);if(!body){return RETURN_DOM?null:emptyHTML;}}if(body&&FORCE_BODY){_forceRemove(body.firstChild);}var nodeIterator=_createIterator(IN_PLACE?dirty:body);while(currentNode=nodeIterator.nextNode()){if(currentNode.nodeType===3&&currentNode===oldNode){continue;}if(_sanitizeElements(currentNode)){continue;}if(currentNode.content instanceof DocumentFragment){_sanitizeShadowDOM(currentNode.content);}_sanitizeAttributes(currentNode);oldNode=currentNode;}oldNode=null;if(IN_PLACE){return dirty;}if(RETURN_DOM){if(RETURN_DOM_FRAGMENT){returnNode=createDocumentFragment.call(body.ownerDocument);while(body.firstChild){returnNode.appendChild(body.firstChild);}}else{returnNode=body;}if(RETURN_DOM_IMPORT){returnNode=importNode.call(originalDocument,returnNode,true);}return returnNode;}var serializedHTML=WHOLE_DOCUMENT?body.outerHTML:body.innerHTML;if(SAFE_FOR_TEMPLATES){serializedHTML=stringReplace(serializedHTML,MUSTACHE_EXPR$$1,' ');serializedHTML=stringReplace(serializedHTML,ERB_EXPR$$1,' ');}return trustedTypesPolicy&&RETURN_TRUSTED_TYPE?trustedTypesPolicy.createHTML(serializedHTML):serializedHTML;};DOMPurify.setConfig=function(cfg){_parseConfig(cfg);SET_CONFIG=true;};DOMPurify.clearConfig=function(){CONFIG=null;SET_CONFIG=false;};DOMPurify.isValidAttribute=function(tag,attr,value){if(!CONFIG){_parseConfig({});}var lcTag=stringToLowerCase(tag);var lcName=stringToLowerCase(attr);return _isValidAttribute(lcTag,lcName,value);};DOMPurify.addHook=function(entryPoint,hookFunction){if(typeof hookFunction!=='function'){return;}hooks[entryPoint]=hooks[entryPoint]||[];arrayPush(hooks[entryPoint],hookFunction);};DOMPurify.removeHook=function(entryPoint){if(hooks[entryPoint]){arrayPop(hooks[entryPoint]);}};DOMPurify.removeHooks=function(entryPoint){if(hooks[entryPoint]){hooks[entryPoint]=[];}};DOMPurify.removeAllHooks=function(){hooks={};};return DOMPurify;}var purify=createDOMPurify();/* harmony default export */ var purify_es = (purify);
// CONCATENATED MODULE: ./lib/modules/commandLine.js






const commandLine_module = new Module('commandLine');
commandLine_module.moduleName = 'commandLineName';
commandLine_module.description = 'commandLineDesc';
commandLine_module.category = 'coreCategory';
commandLine_module.options = {
  launch: {
    title: 'commandLineLaunchTitle',
    type: 'button',
    text: 'Launch',
    description: 'commandLineLaunchDesc',

    callback() {
      commandLine_open();
    }

  },
  menuItem: {
    title: 'commandLineMenuItemTitle',
    type: 'boolean',
    description: 'commandLineMenuItemDesc',
    value: false
  }
};

commandLine_module.contentStart = () => {
  if (commandLine_module.options.menuItem.value) {
    addMenuItem();
  }
};

function addMenuItem() {
  menu_addMenuItem(() => string_namespaceObject.html`<div>command line <span class="RESMenuItemButton res-icon">\uF060</span></div>`, () => commandLine_open());
}

const commandLine = Object(once["a" /* default */])(() => {
  const widget = string_namespaceObject.html`
		<div id="keyCommandLineWidget" hidden>
			<div id="keyCommandForm">
				<input id="keyCommandInput" type="text" autocomplete="off">
				type a command, ? for help, esc to close
				<div id="keyCommandInputTip"></div>
				<div id="keyCommandInputError"></div>
			</div>
		</div>
	`;
  document.body.append(widget);
  const input = Object(flow["a" /* downcast */])(widget.querySelector('#keyCommandInput'), HTMLInputElement);
  const tip = widget.querySelector('#keyCommandInputTip');
  const error = widget.querySelector('#keyCommandInputError');

  const setTip = str => {
    tip.innerHTML = purify_es.sanitize(str);
  };

  const clearTip = () => Object(dom["e" /* empty */])(tip);

  const setError = str => {
    error.innerHTML = purify_es.sanitize(str);
  };

  const clearError = () => Object(dom["e" /* empty */])(error);

  input.addEventListener('blur', () => {
    if (!input.value.length) {
      commandLine_close();
    } else {
      setError('click into the text input and press escape to close the command line');
    }
  });
  document.addEventListener('keyup', e => {
    if (!widget.hidden && e.key === NAMED_KEYS.Escape) {
      commandLine_close();
      e.stopImmediatePropagation();
    }
  });
  input.addEventListener('input', async () => {
    clearTip();
    clearError();
    const tip = await commandLine_getTip(commandLine_parse(input.value));
    if (tip) setTip(tip);
  });
  const commandLineForm = widget.querySelector('#keyCommandForm');
  commandLineForm.addEventListener('keydown', async e => {
    if (e.key === NAMED_KEYS.Enter) {
      const error = await commandLine_executeCommand(commandLine_parse(input.value), e);

      if (error) {
        setError(error);
      } else if (error !== false) {
        commandLine_close();
      }
    }
  });
  return {
    widget,
    input
  };
});
function commandLine_open(initialCmd = '') {
  commandLine().widget.hidden = false;
  commandLine().input.focus();
  commandLine().input.value = initialCmd;
  commandLine().input.dispatchEvent(new Event('input'));
}

function commandLine_close() {
  commandLine().input.blur();
  commandLine().widget.hidden = true;
}

function commandLine_toggle() {
  if (commandLine().widget.hidden) commandLine_open();else commandLine_close();
}

function navigateTo(url, e) {
  if (e.shiftKey) {
    openNewTab(url, !e.altKey);
  } else {
    location.href = url;
  }
}

const commands = [];
function registerCommand(commandPredicate, description, getTip, executeCommand) {
  commands.push({
    commandPredicate,
    description,
    getTip,
    executeCommand
  });
}

function getCommandSpec(command, val) {
  let result;
  commands.some(commandSpec => {
    let predicateResult;

    if (typeof commandSpec.commandPredicate.exec === 'function') {
      predicateResult = commandSpec.commandPredicate.exec(command);
    } else if (typeof commandSpec.commandPredicate === 'string') {
      predicateResult = commandSpec.commandPredicate === command;
    } else if (typeof commandSpec.commandPredicate === 'function') {
      predicateResult = commandSpec.commandPredicate(command, val);
    }

    if (predicateResult) {
      result = { ...commandSpec,
        predicateResult
      };
      return true;
    }
  });
  return result;
}

function commandLine_parse(input) {
  const splitWords = input.split(' ');
  const command = splitWords[0];
  const value = splitWords.slice(1).join(' ');
  return {
    command,
    value
  };
}

function commandLine_getTip({
  command,
  value
}) {
  const matchingCommandSpec = getCommandSpec(command, value);

  if (matchingCommandSpec) {
    return matchingCommandSpec.getTip(command, value, matchingCommandSpec.predicateResult) || matchingCommandSpec.description;
  }
}

function commandLine_executeCommand({
  command,
  value
}, event) {
  const matchingCommandSpec = getCommandSpec(command, value);

  if (matchingCommandSpec) {
    return matchingCommandSpec.executeCommand(command, value, matchingCommandSpec.predicateResult, event);
  } else {
    return 'unknown command - type ? for help';
  }
}

registerCommand(/^\/?r\/(.*)/, 'r/[subreddit] - navigates to subreddit', (command, val, match) => `navigate to subreddit: ${match[1]}`, (command, val, match, e) => {
  navigateTo(`/r/${match[1]}`, e);
});
registerCommand(/^\/?m\/(.*)/, 'm/[multi] - view your multi-reddit [multi]', (command, val, match) => `navigate to multi-reddit: /me/m/${match[1]}`, (command, val, match, e) => {
  navigateTo(`/me/m/${match[1]}`, e);
});
registerCommand('m', 'm - go to inbox', () => 'View messages', (command, value, match, e) => {
  navigateTo('/message/inbox/', e);
});
registerCommand('mm', 'mm - go to moderator mail', () => 'View moderator mail', (command, value, match, e) => {
  navigateTo('/message/moderator/', e);
});
registerCommand('front', 'front - go to frontpage', () => 'Go to frontpage', (command, value, match, e) => {
  navigateTo('/', e);
});
registerCommand(/^XHR/, 'XHRCache clear - manipulate the XHR cache', () => 'clear - clear the cache (use if inline images aren\'t loading properly)', (command, value) => {
  if (/^\s*$/.test(value)) {
    return 'Operation required [clear]';
  }

  switch (value) {
    case 'clear':
      xhrCache_namespaceObject.clear();
      break;

    default:
      return 'The only accepted operation is <tt>clear</tt>';
  }
});
registerCommand(/^user$|^u$|^\/?u(?:ser)?\/(\w*((?!\/m\/).)*)$/, 'user [username] or u/[username] - view profile for [username]', (command, val, match) => {
  val = val || match[1];

  if (!val && loggedInUser()) {
    return 'go to profile';
  } else if (!val) {
    return false;
  } else {
    return `go to profile for: ${val}`;
  }
}, (command, val, match, e) => {
  val = val || match[1] || loggedInUser();

  if (!val) {
    return 'not logged in';
  }

  navigateTo(`/u/${val}`, e);
});
registerCommand(/^\/?u(?:ser)?\/(\w+)\/m(?:\/(.+))?/, 'u/[username]/m/[multi] - view the multireddit [multi] curated by [username]', (command, val, match) => `navigate to multi-reddit: /u/${match[1]}/m/${match[2] || ''}`, (command, val, match, e) => {
  if (!match[1]) {
    return 'no multi-reddit specified';
  }

  navigateTo(`/u/${match[1]}/m/${match[2]}`, e);
});
registerCommand(/^\/?me(?:\/?(.*))$/, ['me - view profile for current user', 'me/saved or me/s - view current user\'s saved links', 'me/saved#comments or me/sc - view current user\'s saved comments', 'me/submitted or me/sub - view current user\'s submitted content', 'me/comments or me/c - view current user\'s comments', 'me/gilded or me/g - view current user\'s gilded content', 'me/liked or me/l - view current user\'s liked content ', 'me/disliked or me/d - view current user\'s disliked content', 'me/hidden or me/h - view current user\'s hidden content'], (command, val, match) => {
  const loggedIn = loggedInUser();

  if (!loggedIn) {
    return 'not logged in';
  }

  let str;

  switch (match[1]) {
    case '':
      str = `navigate to user profile: ${loggedIn}`;
      break;

    case 'saved':
    case 's':
      str = 'navigate to current user\'s saved content';
      break;

    case 'saved#comments':
    case 'sc':
      str = 'navigate to current RES\'s saved comments';
      break;

    case 'submitted':
    case 'sub':
      str = 'navigate to current user\'s submitted content';
      break;

    case 'comments':
    case 'c':
      str = 'navigate to current user\'s comments';
      break;

    case 'gilded':
    case 'g':
      str = 'navigate to current user\'s gilded content';
      break;

    case 'liked':
    case 'l':
      str = 'navigate to current user\'s liked content';
      break;

    case 'disliked':
    case 'd':
      str = 'navigate to current user\'s disliked content';
      break;

    case 'hidden':
    case 'h':
      str = 'navigate to current user\'s hidden content';
      break;

    default:
      str = 'navigate to [s]aved, [s]aved[c]omments, [sub]mitted, [c]omments, [g]ilded, [l]iked, [d]isliked, [h]idden';
      break;
  }

  return str;
}, (command, val, match, e) => {
  const currentUser = loggedInUser();

  if (!currentUser) {
    return 'not logged in';
  }

  switch (match[1]) {
    case '':
      navigateTo(`/user/${currentUser}`, e);
      break;

    case 'saved':
    case 's':
      navigateTo(`/user/${currentUser}/saved`, e);
      break;

    case 'saved#comments':
    case 'sc':
      navigateTo(`/user/${currentUser}/saved#comments`, e);
      break;

    case 'submitted':
    case 'sub':
      navigateTo(`/user/${currentUser}/submitted`, e);
      break;

    case 'comments':
    case 'c':
      navigateTo(`/user/${currentUser}/comments`, e);
      break;

    case 'gilded':
    case 'g':
      navigateTo(`/user/${currentUser}/gilded`, e);
      break;

    case 'liked':
    case 'l':
      navigateTo(`/user/${currentUser}/liked`, e);
      break;

    case 'disliked':
    case 'd':
      navigateTo(`/user/${currentUser}/disliked`, e);
      break;

    case 'hidden':
    case 'h':
      navigateTo(`/user/${currentUser}/hidden`, e);
      break;

    default:
      return 'unknown command - type ? for help';
  }
});
registerCommand('userinfo', false, () => {}, (command, val) => {
  if (val.length <= 1) {
    return 'No username specified.';
  } else {
    ajax({
      url: string_namespaceObject.encode`/user/${val}/about.json`
    }).then(alert_namespaceObject.open);
  }
});
registerCommand('userbadge', false, () => {}, (command, val) => {
  if (val.length <= 1) {
    return 'No username specified.';
  } else {
    ajax({
      url: string_namespaceObject.encode`/user/${val}/about.json`,
      type: 'json'
    }).then(({
      data
    }) => alert_namespaceObject.open(`, .id-t2_${data.id}::before`));
  }
});
{
  function sanitizeStorageKey(key) {
    let match;

    if (match = /(?:RES)?opt(?:ion)?s?[\.\s]+(.*)/i.exec(key)) {
      key = `RESoptions.${match[1]}`;
    } else if (match = /(?:RES)?mod(?:ule)?s?[\.\s]+(.*)/i.exec(key)) {
      key = `RESmodules.${match[1]}`;
    }

    return key;
  }

  function executeCommand(command, key, value) {
    if (command === 'get') {
      storage_namespaceObject.get(key).then(value => alert_namespaceObject.open(string_namespaceObject.escape`Value of RESStorage[${key}]: <br><br><textarea rows="5" cols="50">${JSON.stringify(value)}</textarea>`));
    } else if (command === 'update') {
      storage_namespaceObject.get(key).then(value => {
        const element = string_namespaceObject.html`<div>Value of RESStorage[${key}]: <br><br><textarea rows="5" cols="50">${JSON.stringify(value)}</textarea></div>`;
        alert_namespaceObject.open(element, {
          cancelable: true
        }).then(() => storage_namespaceObject.set(key, JSON.parse(Object(flow["a" /* downcast */])(element.querySelector('textarea'), HTMLTextAreaElement).value)));
      });
    } else if (command === 'remove') {
      storage_namespaceObject.delete(key);
      alert_namespaceObject.open(string_namespaceObject.escape`RESStorage[${key}] deleted`);
    } else if (command === 'set') {
      storage_namespaceObject.set(key, JSON.parse(value));
      alert_namespaceObject.open(string_namespaceObject.escape`RESStorage[${key}] set to:<br><br><textarea rows="5" cols="50">${value}</textarea>`);
    } else {
      return 'You must specify either "get [key]" or "set [key] [value]"';
    }
  }

  registerCommand(/(?:RES)?stor(?:e|age)?/i, 'RESStorage [get|set|update|remove] [key] [value] - For debug use only, you shouldn\'t mess with this unless you know what you\'re doing.', () => {}, (command, val) => {
    const splitWords = val.split(' ');

    if (splitWords.length < 2) {
      return 'You must specify "get [key]", "update [key]" or "set [key] [value]"';
    } else {
      const key = sanitizeStorageKey(splitWords[1]);
      const value = splitWords.slice(2).join(' ');
      return executeCommand(splitWords[0], key, value);
    }
  });
}
const sortTypes = {
  n: 'new',
  t: 'top',
  h: 'hot',
  r: 'rising',
  c: 'controversial',
  g: 'gilded',
  p: 'ads'
};

const sortTypeRecognizesPeriod = sortType => sortTypes.t === sortType || sortTypes.c === sortType;

const periods = ['hour', 'day', 'week', 'month', 'year', 'all'];

const getPeriod = val => val && periods.find(period => period.startsWith(val));

registerCommand(/^\/([nthrcgp])?/, '/n, /t, /h, /r, /c, /g, or /p - goes to new, top, hot, rising, controversial, gilded, or promoted sort of current subreddit, multireddit or user page', (command, val, match) => {
  const sortType = sortTypes[match[1]];

  if (sortType) {
    return sortTypeRecognizesPeriod(sortType) ? `sort by ${sortType} [(${periods.map(period => getPeriod(val) === period ? `<b>${period}</b>` : period).join('|')})]` : `sort by ${sortType}`;
  } else {
    return 'sort by ([n]ew, [t]op, [h]ot, [r]ising, [c]ontroversial, [g]ilded, [p]romoted)';
  }
}, (command, val, match, e) => {
  const sortType = sortTypes[match[1]];

  if (!sortType) {
    return 'invalid sort command - must be one of [n]ew, [t]op, [h]ot, [r]ising, [c]ontroversial, [g]ilded, [p]romoted';
  }

  function _navigateTo(v) {
    const url = new URL(v, location.href);
    const period = getPeriod(val);

    if (sortTypeRecognizesPeriod(sortType) && period) {
      url.searchParams.append('t', period);
    }

    navigateTo(url.href, e);
  }

  const currentUser = Object(utils_location["e" /* currentUserProfile */])();

  if (currentUser) {
    if (sortType === 'gilded') {
      _navigateTo(`/user/${currentUser}/${sortType}`);
    } else if (sortType === 'ads' || sortType === 'rising') {
      return `invalid sort command - "${sortType}" is not supported on profile pages`;
    } else {
      _navigateTo(`/user/${currentUser}?sort=${sortType}`);
    }

    return;
  }

  const subreddit = Object(utils_location["d" /* currentSubreddit */])();

  if (subreddit) {
    _navigateTo(`/r/${subreddit}/${sortType}`);

    return;
  }

  const multi = Object(utils_location["c" /* currentMultireddit */])();

  if (multi) {
    _navigateTo(`/${multi}/${sortType}`);
  } else {
    _navigateTo(`/${sortType}`);
  }
});
registerCommand(cmd => ['s', 'search'].includes(cmd), 's[earch] [query] - searches the current subreddit (if any) or all of Reddit', (command, val) => {
  const subreddit = Object(utils_location["d" /* currentSubreddit */])();

  if (!subreddit) {
    return `Search all of Reddit: ${val}`;
  }

  return `Search /r/${subreddit}: ${val}`;
}, (command, val, match, e) => {
  const subreddit = Object(utils_location["d" /* currentSubreddit */])();

  if (!subreddit) {
    navigateTo(string_namespaceObject.encode`/search?q=${val}`, e);
    return;
  }

  navigateTo(string_namespaceObject.encode`/r/${subreddit}/search?q=${val}&restrict_sr=on`, e);
});
registerCommand('sr', 'sr [query] - searches all of Reddit', (command, val) => `Search all of Reddit: ${val}`, (command, val, match, e) => {
  navigateTo(string_namespaceObject.encode`/search?q=${val}`, e);
});
registerCommand('?', false, () => {
  const descriptions = commands.map(command => command.description).reduce((a, b) => b ? a.concat(b) : a, []);

  if (descriptions.length) {
    return `<ul><li>${descriptions.join('</li><li>')}</li></ul>`;
  }
}, () => false);
// CONCATENATED MODULE: ./lib/modules/menu.js







const menu_module = new Module('RESMenu');
menu_module.moduleName = 'menuName';
menu_module.category = 'coreCategory';
menu_module.description = 'The <span class="gearIcon"></span> dropdown menu to manage RES settings and quick options';
menu_module.descriptionRaw = true;
menu_module.alwaysEnabled = true;
menu_module.options = {
  gearIconClickAction: {
    title: 'menuGearIconClickActionTitle',
    type: 'enum',
    values: [{
      name: 'menuGearIconClickActionOpenSettings',
      value: 'openSettings'
    }, {
      name: 'menuGearIconClickActionOpenCommandLine',
      value: 'openCommandLine'
    }, {
      name: 'menuGearIconClickActionToggleMenu',
      value: 'toggleMenu'
    }, {
      name: 'menuGearIconClickActionToggleMenuNoHover',
      value: 'toggleMenuNoHover'
    }],
    value: 'toggleMenuNoHover',
    description: 'menuGearIconClickActionDesc',
    bodyClass: true,
    advanced: true
  }
};
const menu_items = [];
let gear;

menu_module.contentStart = () => {
  gear = string_namespaceObject.html`<span id="RESSettingsButton" style="cursor: pointer" title="${i18n('RESSettings')}" class="gearIcon"></span>`;

  if (menu_module.options.gearIconClickAction.value !== 'toggleMenuNoHover') {
    gear.addEventListener('mouseenter', () => {
      showDropdown(200);
    });
  }

  gear.addEventListener('click', () => {
    if (menu_module.options.gearIconClickAction.value === 'openCommandLine' && isRunning(commandLine_namespaceObject)) {
      commandLine_toggle();
      hideDropdown();
    } else if (menu_module.options.gearIconClickAction.value === 'openSettings') {
      settingsNavigation_open();
      hideDropdown();
    } else {
      showDropdown(0);
    }
  });
  addFloater(gear, {
    order: 5,
    container: 'inNavbar'
  });
};

menu_module.afterLoad = () => {
  requestAnimationFrame(addLegacyStyling);
};

function showDropdown(openDelay) {
  dropdownList(menu_module.moduleID).options({
    openDelay,
    fadeDelay: 200,
    fadeSpeed: 0.2
  }, false).populateWith(() => {
    const f = document.createDocumentFragment();
    f.append(...menu_items.sort(({
      order: a
    }, {
      order: b
    }) => a - b).map(buildItem));
    return [f];
  }).target(gear).begin();
}

function hideDropdown() {
  dropdownList(menu_module.moduleID).close(true);
}

function menu_addMenuItem(getElement, onClick = () => {}, order = 0) {
  menu_items.push({
    getElement,
    onClick,
    order
  });
}

function buildItem({
  getElement,
  onClick
}) {
  const li = document.createElement('li');
  li.addEventListener('click', onClick, true);
  li.addEventListener('click', hideDropdown);
  li.append(getElement());
  return li;
}

function addLegacyStyling() {
  const {
    backgroundImage
  } = window.getComputedStyle(gear);

  if (backgroundImage && backgroundImage !== 'none') {
    gear.classList.add('res-gearIcon-legacy');
  }
}
// CONCATENATED MODULE: ./lib/modules/settingsNavigation.js







const settingsNavigation_module = new Module('settingsNavigation');
settingsNavigation_module.moduleName = 'settingsNavName';
settingsNavigation_module.category = 'coreCategory';
settingsNavigation_module.description = 'settingsNavDesc';
settingsNavigation_module.hidden = true;
settingsNavigation_module.alwaysEnabled = true;
settingsNavigation_module.options = {
  showAllOptions: {
    title: 'settingsNavigationShowAllOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'settingsNavigationShowAllOptionsDesc',
    noconfig: true
  }
};

settingsNavigation_module.beforeLoad = () => {
  menu_addMenuItem(() => string_namespaceObject.html`<div id="SettingsConsole">
			${i18n('RESSettingsConsole')}
			<span module="search" class="RESMenuItemButton res-icon" title="search settings">\uF094</span>
		</div>`, e => settingsNavigation_open(e.target.getAttribute('module')), -10);
  registerCommand(/^set(?:t?ings?)?$/, 'settings [words to search for]- search RES settings console', (command, val) => `Search RES settings ${val && val.length ? ` for: ${val}` : ''}`, (command, val) => settingsNavigation_open('search', val));
};

settingsNavigation_module.contentStart = () => {
  function findModules(val) {
    return modules_all().filter(v => !v.hidden).map(v => v.moduleID).filter(id => id.toLowerCase().match(val.toLowerCase())).sort();
  }

  registerCommand(/^mod(?:ule?)?$/, 'module [name of module] - open module settings', (command, val) => {
    const matches = findModules(val);
    return matches.length ? `Open module ${matches[0]}` : 'Could not find any matching module.';
  }, (command, val) => settingsNavigation_open(findModules(val)[0]));
  window.addEventListener('popstate', () => {
    settingsNavigation_update();
  });
  settingsNavigation_update();
  document.body.addEventListener('click', e => {
    if (e.ctrlKey) return;
    const url = e.target instanceof HTMLAnchorElement && new URL(e.target.href, location.origin);

    if (url && isSettingsUrl(url.href)) {
      settingsNavigation_update(url);
      e.stopImmediatePropagation();
      e.preventDefault();
    }
  }, true);
};

function makeUrlHashLink(moduleID, optionKey, displayText, cssClass) {
  const mod = getUnchecked(moduleID);

  if (!displayText) {
    if (mod && optionKey) {
      displayText = i18n(mod.options[optionKey].title);
    } else if (mod) {
      displayText = i18n(mod.moduleName);
    } else {
      displayText = 'Settings';
    }
  }

  let title = ['RES Settings'];

  if (mod) {
    title.push(i18n(mod.moduleName));
  }

  if (optionKey) {
    title.push(optionKey);
  }

  title = title.join(' &gt; ');
  const hash = makeUrlHash(moduleID, optionKey);
  return `<a class="${cssClass || ''}" href="${hash}" title="${title}">${displayText}</a>`;
}
function parseHash(hash) {
  const params = hash.match(/\/(?:\w|\s|%20)+/g);
  return {
    moduleID: params && params[0] && params[0].substring(1).replace('%20', ' ') || undefined,
    optionKey: params && params[1] && params[1].substring(1).replace('%20', ' ') || undefined
  };
}
function makeUrlHash(moduleID, optionKey) {
  const hashComponents = [RES_SETTINGS_HASH];

  if (moduleID) {
    hashComponents.push(moduleID);
  }

  if (moduleID && optionKey) {
    hashComponents.push(optionKey);
  }

  return hashComponents.join('/');
}
function isSettingsUrl(href) {
  const {
    origin,
    hash
  } = new URL(href, location.origin);
  const sameSite = origin === getOptionsURL().origin || origin.split('.').slice(-2).join('.') === context_data.origin.split('.').slice(-2).join('.');
  if (!sameSite) return false;
  return hash.startsWith(RES_SETTINGS_HASH) || hash.startsWith('#!settings');
}
function setHash(hash) {
  if (window.top === window) {
    if (parseHash(location.hash).moduleID === parseHash(hash).moduleID) {
      history.replaceState(null, '', hash);
    } else {
      history.pushState(null, '', hash);
    }
  } else {
    window.parent.postMessage({
      hash
    }, '*');
  }
}
let iframe;
function settingsNavigation_update(url = location) {
  if (isSettingsUrl(url.href)) {
    const {
      moduleID,
      optionKey
    } = parseHash(url.hash);
    settingsNavigation_open(moduleID, optionKey);
  } else if (iframe) {
    iframe.contentWindow.postMessage({
      close: true
    }, '*');
  }
}

function listener({
  origin,
  data
}) {
  if (origin !== getOptionsURL().origin) return;
  const {
    failedToLoad,
    hash,
    closing
  } = data;
  if (failedToLoad) handleEmbedFailure();
  if (hash) setHash(hash);
  if (closing) settingsNavigation_close();
}

function handleEmbedFailure() {
  console.warn('Embed failed. Opening RES settings console in new tab');
  if (iframe) openNewTab(iframe.src, true);
  settingsNavigation_close();
}

function settingsNavigation_open(moduleID, optionKey) {
  if (iframe || isOptionsPage()) {
    (iframe && iframe.contentWindow || window).postMessage({
      load: {
        moduleID,
        optionKey
      }
    }, '*');
  } else {
    iframe = document.createElement('iframe');
    iframe.id = 'console-container';
    iframe.src = getOptionsURL(makeUrlHash(moduleID, optionKey)).href;
    window.addEventListener('message', listener);
    iframe.addEventListener('load', () => {
      if (iframe) iframe.contentWindow.postMessage({
        context: context_data
      }, '*');
      let success;
      window.addEventListener('message', ({
        origin,
        data
      }) => {
        if (origin === getOptionsURL().origin && data.loadSuccess) success = true;
      });
      setTimeout(() => {
        if (!success) handleEmbedFailure();
      }, 3000);
    });
    document.body.append(iframe);
    document.body.classList.add('res-console-open');
  }
}
function settingsNavigation_close() {
  if (isOptionsPage()) {
    window.parent.postMessage({
      closing: true
    }, '*');
    window.close();
  } else {
    window.removeEventListener('message', listener);
    if (!iframe) return;
    iframe.remove();
    iframe = null;
    document.body.classList.remove('res-console-open');
    if (isSettingsUrl(location.href)) history.pushState(null, '', location.pathname + location.search);
  }
}
// CONCATENATED MODULE: ./lib/modules/notifications.js








const notifications_module = new Module('notifications');
notifications_module.moduleName = 'notificationsName';
notifications_module.category = 'coreCategory';
notifications_module.description = 'notificationsDesc';
notifications_module.options = {
  sticky: {
    description: 'notificationStickyDesc',
    title: 'notificationStickyTitle',
    type: 'enum',
    value: 'notificationType',
    values: [{
      name: 'notificationsPerNotificationType',
      value: 'notificationType'
    }, {
      name: 'notificationsAlwaysSticky',
      value: 'all'
    }, {
      name: 'notificationsNeverSticky',
      value: 'none'
    }]
  },
  closeDelay: {
    type: 'text',
    value: '3000',
    description: 'notificationCloseDelayDesc',
    title: 'notificationCloseDelayTitle'
  },
  fadeOutLength: {
    type: 'text',
    value: '3000',
    description: 'notificationFadeOutLengthDesc',
    title: 'notificationFadeOutLengthTitle',
    advanced: true
  },
  notificationTypes: {
    description: 'notificationNotificationTypesDesc',
    title: 'notificationNotificationTypesTitle',
    type: 'table',
    advanced: true,
    addRowText: 'notificationsAddNotificationType',
    fields: [{
      key: 'id',
      name: 'notificationsNotificationID',
      type: 'text'
    }, {
      key: 'enabled',
      name: 'notificationsEnabled',
      type: 'boolean',
      value: true
    }, {
      key: 'sticky',
      name: 'notificationsSticky',
      type: 'boolean',
      value: false
    }],
    value: []
  }
};
const notificationsContainer = string_namespaceObject.html`<div id="RESNotifications"></div>`;
const lastShownStorage = storage_namespaceObject.wrapBlob('notifications.lastShown', () => 0);

notifications_module.go = () => {
  document.body.append(notificationsContainer);
};

const activeNotifications = new Set();
function notifications_showNotification(opts, _delay) {
  const data = typeof opts === 'string' ? {
    message: opts
  } : opts;
  const id = `${String(firstValid(data.moduleID, '--'))}-${String(firstValid(data.notificationID, data.optionKey, data.header, hashCode(data.message instanceof HTMLElement ? data.message.outerHTML : data.message)))}`;
  const mod = data.moduleID && getUnchecked(data.moduleID);
  const element = string_namespaceObject.html`
		<div class="RESNotification" data-id="${id}">
			<div class="RESNotificationHeader">
				<h3>${data.header || (mod ? i18n(mod.moduleName) : '') || ''}</h3>
				${mod && !mod.hidden ? string_namespaceObject.safe(makeUrlHashLink(mod.moduleID, data.optionKey, ' ', 'gearIcon')) : ''}
				<div class="RESCloseButton"></div>
			</div>
			<div class="RESNotificationContent"></div>
			<div class="RESNotificationFooter" ${data.noDisable ? 'hidden' : ''}>
				<label class="RESNotificationToggle" title="Show notifications from ${id}">
					<input type="checkbox" checked> Always show this type of notification
				</label>
			</div>
		</div>
	`;
  jquery_default()(element.querySelector('.RESNotificationContent')).append(data.message);
  const inner = element.innerHTML;
  const existing = [...activeNotifications.values()].find(({
    element
  }) => element.innerHTML === inner);

  if (existing) {
    existing.element.dispatchEvent(new CustomEvent('notification-reset'));
    return existing;
  }

  const close = Object(once["a" /* default */])(() => {
    activeNotifications.delete(notification);
    element.remove();
  });
  const notification = {
    element,
    close
  };
  activeNotifications.add(notification);
  const storage = options_table_namespaceObject.getMatchingValueOrAdd(notifications_module, 'notificationTypes', {
    id
  }, data);
  element.querySelector('.RESNotificationToggle input').addEventListener('change', e => {
    storage.enabled = e.currentTarget.checked;
  });
  element.querySelector('.RESCloseButton').addEventListener('click', () => {
    close();
  });
  const isSticky = notifications_module.options.sticky.value === 'all' || notifications_module.options.sticky.value === 'notificationType' && storage.sticky;
  const delay = +firstValid(_delay, data.closeDelay, parseInt(notifications_module.options.closeDelay.value, 10), notifications_module.options.closeDelay.default);
  const fadeDuration = +firstValid(parseInt(notifications_module.options.fadeOutLength.value, 10), notifications_module.options.fadeOutLength.default);

  async function resetCloseTimer() {
    await new Promise(requestAnimationFrame);
    if (element.matches(':hover')) await Object(dom["r" /* waitForEvent */])(element, 'mouseleave');
    let fadeTimer;
    const hideTimer = setTimeout(() => {
      element.classList.add('transitionToTransparent');
      element.style.transitionDuration = `${fadeDuration / 1000}s`;
      fadeTimer = setTimeout(() => close(), fadeDuration);
    }, delay);
    await Object(dom["r" /* waitForEvent */])(element, 'mouseenter', 'notification-reset');
    element.classList.remove('transitionToTransparent');
    if (fadeTimer) clearTimeout(fadeTimer);
    if (hideTimer) clearTimeout(hideTimer);
    resetCloseTimer();
  }

  (async () => {
    if (!storage.enabled || !isRunning(notifications_module)) return;

    if (data.cooldown) {
      if (data.cooldown > Date.now() - (await lastShownStorage.get(id))) return;
      lastShownStorage.set(id, Date.now());
    }

    requestAnimationFrame(() => {
      if (window.getComputedStyle(element).maxHeight === 'initial') return;
      element.style.maxHeight = '100vh';
    });
    notificationsContainer.prepend(element);
    if (!isSticky && delay !== Infinity) resetCloseTimer();
  })();

  return notification;
}
// CONCATENATED MODULE: ./lib/modules/penaltyBox.js








const penaltyBox_module = new Module('penaltyBox');
const MIN_PENALTY = 1;
const MAX_PENALTY = 100;
penaltyBox_module.moduleName = 'penaltyBoxName';
penaltyBox_module.category = 'coreCategory';
penaltyBox_module.description = 'penaltyBoxDesc';
penaltyBox_module.options = {
  delayFeatures: {
    type: 'boolean',
    value: true,
    description: 'penaltyBoxDelayFeaturesDesc',
    title: 'penaltyBoxDelayFeaturesTitle'
  },
  suspendFeatures: {
    type: 'boolean',
    value: false,
    description: 'penaltyBoxSuspendFeaturesDesc',
    title: 'penaltyBoxSuspendFeaturesTitle'
  },
  features: {
    description: 'penaltyBoxFeaturesDesc',
    title: 'penaltyBoxFeaturesTitle',
    type: 'table',
    advanced: true,
    addRowText: 'penaltyBoxFeaturesAddRowText',
    fields: [{
      key: 'moduleID',
      name: 'moduleID',
      type: 'text'
    }, {
      key: 'optionKey',
      name: 'optionKey',
      type: 'text'
    }, {
      key: 'monitoring',
      name: 'penaltyBoxFeaturesMonitoring',
      type: 'boolean',
      value: true
    }, {
      key: 'penalty',
      name: 'penaltyBoxFeaturesPenalty',
      type: 'text',
      value: '0'
    }],
    value: []
  }
};
function alterFeaturePenalty(moduleID, optionKey, valueDelta) {
  if (isNaN(parseInt(valueDelta, 10))) {
    console.warn('Could not alter penalty for', moduleID, optionKey, ' - bad value:', valueDelta);
    return MIN_PENALTY;
  }

  if (!modules_isEnabled(penaltyBox_module)) {
    return MIN_PENALTY;
  }

  const value = getOrAddFeatures(moduleID, optionKey);
  if (!value.monitoring) return MIN_PENALTY;
  value.penalty = lodash_es_clamp(value.penalty + valueDelta, MIN_PENALTY, MAX_PENALTY);
  options_save(penaltyBox_module.options.features);

  if (value.penalty >= MAX_PENALTY) {
    suspendFeature(moduleID, optionKey);
  }

  return value.penalty;
}

function stopMonitoringFeature(moduleID, optionKey) {
  const value = getOrAddFeatures(moduleID, optionKey);
  value.monitoring = false;
  value.penalty = MIN_PENALTY;
  options_save(penaltyBox_module.options.features);
}

function getFeaturePenalty(moduleID, optionKey) {
  if (!modules_isEnabled(penaltyBox_module)) {
    return MIN_PENALTY;
  }

  if (!penaltyBox_module.options.delayFeatures.value) {
    return MIN_PENALTY;
  }

  const value = getOrAddFeatures(moduleID, optionKey);

  if (!value.monitoring) {
    return MIN_PENALTY;
  }

  if (!value.penalty || MIN_PENALTY >= value.penalty) {
    return MIN_PENALTY;
  }

  return value.penalty;
}
function penalizedDelay(moduleID, optionKey, delayOption) {
  const penalty = getFeaturePenalty(moduleID, optionKey);

  if (!penalty || penalty === MIN_PENALTY) {
    return parseInt(delayOption.value, 10);
  }

  const max = parseInt(delayOption.penalizedValue || delayOption.value, 10) * 6;
  const initial = parseInt(delayOption.default, 10);
  return Math.min(max, (max - initial) * (penalty / 100) + initial);
}

const getOrAddFeatures = (moduleID, optionKey) => options_table_namespaceObject.getMatchingValueOrAdd(penaltyBox_module, 'features', {
  moduleID,
  optionKey
}, {
  penalty: 0
});

function suspendFeature(moduleID, optionKey) {
  const featureModule = modules_get(moduleID);
  const option = featureModule.options[optionKey];

  if (!option) {
    console.warn('Could not find option', moduleID, optionKey);
    return;
  }

  if (option.type !== 'boolean') {
    console.warn(`${penaltyBox_module.moduleID} could not disable option`, moduleID, optionKey);
    return;
  }

  const oldValue = option.value;
  const newValue = !option.value;
  options_storage_set(moduleID, optionKey, newValue);
  stopMonitoringFeature(moduleID, optionKey);
  const featureOptionLink = makeUrlHashLink(moduleID, optionKey);
  const notification = notifications_showNotification({
    moduleID: penaltyBox_module.moduleID,
    optionKey: 'suspendFeatures',
    header: i18n('penaltyBoxSuspendFeaturesNotificationHeader'),
    message: `
			${i18n('penaltyBoxSuspendFeaturesNotificationMessage', featureOptionLink)}
			<p><a class="RESNotificationButtonBlue" id="penaltyBoxEnableFeature" href="#">
				${i18n('penaltyBoxSuspendFeaturesUndoButton')}
			</a></p>
		`.trim()
  });
  jquery_default()(notification.element).on('click', '#penaltyBoxEnableFeature', e => {
    e.preventDefault();
    notification.close();
    pardonSuspendedFeature(moduleID, optionKey, oldValue);
  });
}

function pardonSuspendedFeature(moduleID, optionKey, oldValue) {
  options_storage_set(moduleID, optionKey, oldValue);
  stopMonitoringFeature(moduleID, optionKey);
  const featureOptionLink = makeUrlHashLink(moduleID, optionKey);
  notifications_showNotification({
    moduleID: penaltyBox_module.moduleID,
    optionKey: 'suspendFeatures',
    header: i18n('penaltyBoxSuspendFeaturesRevertNotificationHeader'),
    message: i18n('penaltyBoxSuspendFeaturesRevertNotificationMessage', featureOptionLink)
  });
}
// CONCATENATED MODULE: ./node_modules/lodash-es/without.js
var without=Object(_baseRest["a" /* default */])(function(array,values){return lodash_es_isArrayLikeObject(array)?_baseDifference(array,values):[];});/* harmony default export */ var lodash_es_without = (without);
// CONCATENATED MODULE: ./lib/modules/filteReddit/Case.js



class Case_Case {
  static async getSelectedEntryValue() {
    const selected = selectedThing_namespaceObject.current;
    if (!selected) throw new Error('No entry is currently selected.');
    let conditions;

    if (this.defaultConditions) {
      if (!this.thingToCriterion) throw Error('Case does not have method `thingToCriterion`');
      conditions = this.criterionToConditions(await this.thingToCriterion(selected));
    }

    const cased = this.fromConditions(conditions);
    const state = await cased.evaluate(selected);
    if (typeof state !== 'boolean') throw new Error('Could not evaluate case against selected thing');
    return {
      conditions,
      state
    };
  }

  static criterionToConditions(criterion) {
    const parse = this.parseCriterion && this.parseCriterion.bind(this);

    if (!parse) {
      throw new Error('Does not accept criterion');
    }

    if (!criterion && this.pattern && !this.pattern.startsWith('[')) {
      throw new Error('Requires criterion');
    }

    const parts = criterion.split(' & ');

    if (this.criterionOperators && criterion && parts.length > 1) {
      return getGroup('all', parts.map(v => cases_getConditions(this.type, parse(v))));
    } else {
      return parse(criterion);
    }
  }

  static fromConditions(from, propagateError = false) {
    let cased;
    const conditions = cases_getConditions(from && from.type || this.type, from);
    const type = conditions.type;

    try {
      const CaseClass = cases_get(type);
      if (CaseClass.disabled) throw new Error(`${CaseClass.type} is disabled`);
      cased = new CaseClass(conditions);
    } catch (e) {
      if (propagateError) throw e;
      console.error(`Could not build case: ${e.message}. Ignoring.`, e);
      cased = new cases_Inert(conditions);
    }

    return cased;
  }

  static buildRegex(val, {
    fullMatch = true
  } = {}) {
    if (!val) throw new Error('Pattern cannot be empty');

    if (string_namespaceObject.regexRegex.test(val)) {
      const [, str, flags] = string_namespaceObject.regexRegex.exec(val);
      return new RegExp(str, flags);
    } else {
      const patt = lodash_es_escapeRegExp(val);
      return new RegExp(fullMatch ? `^${patt}$` : patt, 'i');
    }
  }

  static get disabled() {
    return false;
  }

  static validate(conditions) {
    const cased = Case_Case.fromConditions(conditions, true);
    if (!cased.isValid()) throw new Error('Invalid conditions');
    return true;
  }

  static getCustomFilter() {
    if (this._customFilter) return this._customFilter;
    throw new Error('Source not found');
  }

  constructor(conditions) {
    this.trueText = void 0;
    this.falseText = void 0;
    this.conditions = void 0;
    this.value = void 0;
    this.observers = new Set();
    this.conditions = this.value = conditions;
  }

  isValid() {
    return true;
  }

  isEvaluatable() {
    return !(this instanceof cases_Inert || this.constructor.disabled);
  }

  hasType(type) {
    return this.constructor.type === type;
  }

  evaluate() {
    throw new Error('evaluate() must be implemented for all Case subclasses');
  }

  onObserve() {}

  observe(observer) {
    if (!this.observers.has(observer) && this.onObserve()) {
      this.observers.add(observer);
      return true;
    }
  }

  refresh(thing) {
    for (const o of this.observers) o.refresh(thing);
  }

}
Case_Case.type = void 0;
Case_Case.text = void 0;
Case_Case.thingToCriterion = void 0;
Case_Case.parseCriterion = void 0;
Case_Case.defaultConditions = void 0;
Case_Case.fields = void 0;
Case_Case.slow = 0;
Case_Case.reconcile = void 0;
Case_Case.contexts = void 0;
Case_Case.unique = false;
Case_Case.variant = 'basic';
Case_Case.pattern = '';
Case_Case.criterionOperators = false;
Case_Case._customFilter = void 0;
class Case_PatternCase extends Case_Case {
  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  static reconcile(values) {
    const variants = [];

    for (const v of values) {
      let variant;

      variantLoop: for (const possibleVariant of variants) {
        for (const key of Object.keys(v)) {
          if (key === 'patt') continue;
          if (possibleVariant[key] !== v[key]) continue variantLoop;
        }

        variant = possibleVariant;
        break;
      }

      if (!variant) {
        variant = { ...v,
          patt: []
        };
        variants.push(variant);
      }

      variant.patt.push(v.patt);
    }

    return variants;
  }

  build(fullMatchDefault, pattIfEmpty) {
    const {
      patt,
      fullMatch = fullMatchDefault
    } = this.conditions;
    const raw = Array.isArray(patt) ? patt : [patt];
    const plain = new Set();
    const variants = {};

    for (let _patt of raw) {
      if (!_patt) {
        if (typeof pattIfEmpty === 'string') _patt = pattIfEmpty;else if (raw.length === 1) throw new Error('Pattern cannot be empty');else continue;
      }

      if (string_namespaceObject.regexRegex.test(_patt)) {
        const [, str, flags = ''] = string_namespaceObject.regexRegex.exec(_patt);
        if (!variants[flags]) variants[flags] = [];
        variants[flags].push(str);
      } else {
        plain.add(lodash_es_escapeRegExp(_patt));
      }
    }

    if (plain.size) {
      const str = Array.from(plain).join('|');
      if (!variants.i) variants.i = [];
      variants.i.push(fullMatch ? `^(${str})$` : str);
    }

    return Object.entries(variants).map(([flags, sources]) => new RegExp(sources.join('|'), flags));
  }

}
Case_PatternCase.defaultConditions = {
  patt: ''
};
Case_PatternCase.pattern = 'RegEx';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/CommentCount.js


class CommentCount_CommentCount extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `comment count ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `comment count ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getCommentCount() || 0);
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const commentCount = thing.getCommentCount();
    if (isNaN(commentCount)) return null;
    return numericalCompare(this.value.op, commentCount, this.value.val);
  }

}
CommentCount_CommentCount.text = 'Comment count';
CommentCount_CommentCount.defaultConditions = {
  op: '>',
  val: 0
};
CommentCount_CommentCount.fields = ['post has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' comments'];
CommentCount_CommentCount.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/newCommentCount.js






const newCommentCount_module = new Module('newCommentCount');
newCommentCount_module.moduleName = 'newCommentCountName';
newCommentCount_module.category = 'submissionsCategory';
newCommentCount_module.description = 'newCommentCountDesc';
newCommentCount_module.options = {
  hideWhenUnchanged: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountHideWhenUnchangedDesc',
    title: 'newCommentCountHideWhenUnchangedTitle'
  },
  cleanComments: {
    type: 'text',
    value: '30',
    description: 'newCommentCountCleanCommentsDesc',
    title: 'newCommentCountCleanCommentsTitle',
    advanced: true
  },
  subscriptionLength: {
    type: 'text',
    value: '2',
    description: 'newCommentCountSubscriptionLengthDesc',
    title: 'newCommentCountSubscriptionLengthTitle'
  },
  showSubscribeButton: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountShowSubscribeButtonDesc',
    title: 'newCommentCountShowSubscribeButtonTitle'
  },
  notifyEditedPosts: {
    dependsOn: options => options.showSubscribeButton.value,
    type: 'boolean',
    value: false,
    description: 'newCommentCountNotifyEditedPostsDesc',
    title: 'newCommentCountNotifyEditedPostsTitle',
    advanced: true
  },
  monitorPostsVisited: {
    type: 'boolean',
    value: true,
    description: 'newCommentCountMonitorPostsVisitedDesc',
    title: 'newCommentCountMonitorPostsVisitedTitle',
    advanced: true
  },
  monitorPostsVisitedIncognito: {
    dependsOn: options => options.monitorPostsVisited.value,
    type: 'boolean',
    value: false,
    description: 'newCommentCountMonitorPostsVisitedIncognitoDesc',
    title: 'newCommentCountMonitorPostsVisitedIncognitoTitle',
    advanced: true
  }
};
const newCommentCount_entryStorage = storage_namespaceObject.wrapPrefix('newCommentCount.', () => {
  throw new Error('Default value should never be retrieved');
}, undefined, true);
const subscriptionStorage = storage_namespaceObject.wrapBlob('RESmodules.newCommentCount.subscriptions', () => {
  throw new Error('Subscription not found');
});

newCommentCount_module.beforeLoad = () => {
  Object(watchers["watchForThings"])(['post'], getNewCount, {
    immediate: true
  });
  Object(watchers["watchForThings"])(['post'], displayNewCommentCount);
};

newCommentCount_module.contentStart = () => {
  const id = (utils_location["f" /* execRegexes */].comments(location.pathname) || [])[2];

  if (id && newCommentCount_module.options.showSubscribeButton.value) {
    addSubscriptionButton(id);
  }

  addDashboardTab('newCommentsContents', 'My Subscriptions', newCommentCount_module.moduleID, addDashboardFunctionality);
};

let listingThing;
let currentCommentCount;

newCommentCount_module.afterLoad = () => {
  if (!document.hidden) {
    checkSubscriptions();
  }

  if (Object(utils_location["n" /* isPageType */])('comments')) {
    listingThing = Thing["a" /* Thing */].from(document.querySelector('#siteTable a.comments'));

    if (listingThing) {
      currentCommentCount = listingThing.getCommentCount();

      if (typeof currentCommentCount === 'number') {
        setEntry(getId(listingThing), currentCommentCount);
        Object(watchers["watchForThings"])(['comment'], updateCurrentCommentCountFromMyComment);
      }
    }
  }

  maybePruneOldEntries('newCommentCount', newCommentCount_entryStorage, parseInt(newCommentCount_module.options.cleanComments.value, 10));
};

const getId = thing => thing.getFullname().split('_').slice(-1)[0];

const hasEntry = thing => newCommentCount_entryStorage.has(getId(thing));

function setEntry(id, newCommentCount) {
  if (!newCommentCount_module.options.monitorPostsVisited.value) return false;
  if (!newCommentCount_module.options.monitorPostsVisitedIncognito.value && isPrivateBrowsing()) return false;
  newCommentCount_entryStorage.set(id, {
    count: newCommentCount,
    updateTime: Date.now()
  });
}

const getNewCount = Object(memoize["a" /* default */])(async thing => {
  const currentCount = thing.getCommentCount();
  if (typeof currentCount !== 'number') return;
  const {
    count: lastOpenedCount
  } = (await newCommentCount_entryStorage.getNullable(getId(thing))) || {};
  if (typeof lastOpenedCount !== 'number') return;
  return Math.max(currentCount - lastOpenedCount, 0);
});

async function displayNewCommentCount(thing) {
  const newCount = await getNewCount(thing);
  if (typeof newCount !== 'number') return;
  if (!newCount && newCommentCount_module.options.hideWhenUnchanged.value) return;
  if (newCount) thing.element.classList.add('res-hasNewComments');
  jquery_default()(thing.getCommentCountElement()).append(`<span class="newComments">&nbsp;(${newCount} new)</span>`);
}

function updateCurrentCommentCountFromMyComment(thing) {
  const timestamp = thing.getTimestamp();
  const isRecent = timestamp && Date.now() - timestamp.getTime() < 10000;
  const isMine = loggedInUser() === thing.getAuthor();

  if (isRecent && isMine && listingThing && typeof currentCommentCount === 'number') {
    setEntry(getId(listingThing), ++currentCommentCount);
  }
}

const addSubscriptionButton = id => {
  const button = string_namespaceObject.html`<span id="REScommentSubToggle" class="RESSubscriptionButton"></span>`;
  const refresh = Object(utils_async["h" /* mutex */])(async () => {
    if (await subscriptionStorage.has(id)) {
      jquery_default()(button).html('<span class="res-icon">&#xF038;</span> unsubscribe').attr('title', 'stop receiving notifications').addClass('unsubscribe');
      Object(dom["r" /* waitForEvent */])(button, 'click').then(async () => {
        await unsubscribe(id);
        notifications_showNotification({
          notificationID: 'newCommentCountUnsubscribe',
          moduleID: 'newCommentCount',
          message: 'You are now unsubscribed from this thread.'
        }, 3000);
      }).then(refresh);
    } else {
      jquery_default()(button).html('<span class="res-icon">&#xF03B;</span> subscribe').attr('title', 'notify me of new comments').removeClass('unsubscribe');
      Object(dom["r" /* waitForEvent */])(button, 'click').then(async () => {
        await newCommentCount_subscribe(id, currentCommentCount || 0, listingThing && listingThing.getPostEditTimestamp() || 0);
        notifications_showNotification({
          notificationID: 'newCommentCountSubscribe',
          moduleID: 'newCommentCount',
          optionKey: 'subscriptionLength',
          message: `
						<p>
							You are now subscribed to this thread for ${newCommentCount_module.options.subscriptionLength.value} days.
							When new comments are posted you'll receive a notification.
						</p>
						<p><a href="/r/Dashboard#newCommentsContents">Manage subscriptions</a></p>
					`
        }, 5000);
      }).then(refresh);
    }
  });
  refresh();
  new Promise(requestAnimationFrame).then(() => Object(dom["o" /* waitForDescendant */])(document.body, '.commentarea .panestack-title, .menuarea')).then(e => {
    e.append(button);
  });
};

function newCommentCount_subscribe(id, newCommentCount, newEditedTime) {
  const now = Date.now();
  return subscriptionStorage.set(id, {
    count: newCommentCount,
    subscriptionDate: now,
    updateTime: now,
    editedTime: newEditedTime,
    url: location.href.replace(location.hash, ''),
    title: document.title
  });
}

function unsubscribe(id) {
  return subscriptionStorage.delete(id);
}

async function checkSubscriptions() {
  const now = Date.now();

  for (const [id, subscription] of Object.entries(await subscriptionStorage.getAll())) {
    const {
      subscriptionDate,
      updateTime
    } = subscription;

    if (now - subscriptionDate > utils_time["a" /* DAY */] * parseInt(newCommentCount_module.options.subscriptionLength.value, 10)) {
      unsubscribe(id);
    } else if (now - updateTime > 5 * utils_time["c" /* MINUTE */]) {
      subscriptionStorage.patch(id, {
        updateTime: now
      });
      checkThread(id, subscription);
    }
  }
}

async function checkThread(id, subscription) {
  const {
    num_comments: newCount,
    edited: newEditedTime
  } = await getPostMetadata({
    id
  });
  const {
    count,
    editedTime,
    url,
    title
  } = subscription;

  if (newCount > count) {
    subscriptionStorage.patch(id, {
      count: newCount
    });
    const notification = notifications_showNotification({
      header: 'New comments',
      notificationID: 'newCommentCount',
      moduleID: 'newCommentCount',
      noDisable: true,
      message: `<p><a href="${url}">${escapeHTML(title)}</a></p>`
    }, Infinity);
    jquery_default()(notification.element).find('.RESNotificationContent').append(createButton(id, 'unsubscribe', notification.close));
  }

  if (newCommentCount_module.options.notifyEditedPosts.value && newEditedTime > editedTime) {
    subscriptionStorage.patch(id, {
      editedTime: newEditedTime
    });
    const notification = notifications_showNotification({
      header: 'Post edited',
      notificationID: 'newCommentCount',
      moduleID: 'newCommentCount',
      optionKey: 'notifyEditedPosts',
      noDisable: true,
      message: `<p><a href="${url}">${escapeHTML(title)}</a></p>`
    }, 10000);
    jquery_default()(notification.element).find('.RESNotificationContent').append(createButton(id, 'unsubscribe', notification.close));
  }
}

function createButton(id, type, onClick) {
  const $button = jquery_default()('<span class="RESSubscriptionButton">');
  let action;

  switch (type) {
    case 'unsubscribe':
      $button.html('<span class="res-icon">&#xF038;</span> unsubscribe').attr('title', 'stop receiving notifications').addClass('unsubscribe');

      action = () => unsubscribe(id);

      break;

    case 'renew':
      $button.html('<span class="res-icon">&#xF03B;</span> renew').attr('title', `renew for ${newCommentCount_module.options.subscriptionLength.value} days`);

      action = async () => {
        await subscriptionStorage.patch(id, {
          subscriptionDate: Date.now()
        });
        notifications_showNotification({
          notificationID: 'newCommentCountRenew',
          moduleID: 'newCommentCount',
          optionKey: 'subscriptionLength',
          message: `Subscription renewed for ${newCommentCount_module.options.subscriptionLength.value} days.`
        });
      };

      break;

    default:
      break;
  }

  const button = $button.get(0);
  Object(dom["r" /* waitForEvent */])(button, 'click').then(action).then(onClick);
  return button;
}

async function addDashboardFunctionality(tabPage) {
  const subscriptions = Object.entries(await subscriptionStorage.getAll());
  const rows = subscriptions.map(([id, {
    subscriptionDate,
    updateTime,
    url,
    title
  }]) => {
    const [, subreddit] = url && new URL(url).pathname.match(utils_location["p" /* regexes */].subreddit) || [];
    if (!subreddit) return;
    const updated = new Date(updateTime);
    const expires = new Date(subscriptionDate + utils_time["a" /* DAY */] * parseInt(newCommentCount_module.options.subscriptionLength.value, 10));
    return string_namespaceObject._html`
				<tr subscription-id="${id}">
					<td><a href="${url}">${escapeHTML(title)}</a></td>
					<td><a href="/r/${subreddit}">/r/${subreddit}</a></td>
					<td><abbr title="${formatDateTime(updated)}">${formatRelativeTime(updated)}</abbr></td>
					<td><abbr title="${formatDateTime(expires)}">${formatRelativeTime(expires)}</abbr></td>
					<td></td>
				</tr>
			`;
  });
  const ele = string_namespaceObject.html`<div>
			<a href="/by_id/${subscriptions.map(([id]) => `t3_${id}`).join(',')}">as reddit link listing</a>
			<table id="newCommentsTable">
				<thead>
					<tr>
						<th>Submission</th>
						<th>Subreddit</th>
						<th>Last viewed</th>
						<th>Expires in</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					${rows.length ? rows : string_namespaceObject._html`<td colspan="5">You are currently not subscribed to any threads. To subscribe to a thread, click the "subscribe" button found near the top of the comments page.</td>`}
				</tbody>
			</table>
		</div>`;
  jquery_default()(ele).on('click', 'th', table_namespaceObject.sortByColumn);

  for (const row of ele.querySelectorAll('[subscription-id]')) {
    const id = row.getAttribute('subscription-id');
    row.querySelector('td:last-of-type').append(createButton(id, 'unsubscribe', () => addDashboardFunctionality(tabPage)), createButton(id, 'renew', () => addDashboardFunctionality(tabPage)));
  }

  Object(dom["e" /* empty */])(tabPage);
  tabPage.append(ele);
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/NewCommentCount.js




class NewCommentCount_NewCommentCount extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `new comments ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `new comments ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static async thingToCriterion(thing) {
    return String(((await hasEntry(thing)) ? await getNewCount(thing) : thing.getCommentCount()) || 0);
  }

  static get disabled() {
    return !modules_isEnabled(newCommentCount_namespaceObject);
  }

  isValid() {
    return parseInt(this.value.val, 10) >= 0;
  }

  async evaluate(thing) {
    const newCount = await getNewCount(thing);
    const count = typeof newCount === 'number' ? newCount : thing.getCommentCount();
    return numericalCompare(this.value.op, count, this.value.val);
  }

}
NewCommentCount_NewCommentCount.text = 'New comment count';
NewCommentCount_NewCommentCount.defaultConditions = {
  op: '>',
  val: 0
};
NewCommentCount_NewCommentCount.fields = ['has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' new comments'];
NewCommentCount_NewCommentCount.slow = 1;
NewCommentCount_NewCommentCount.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/CommentsOpened.js



class CommentsOpened_CommentsOpened extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'comments opened';
  }

  async evaluate(thing) {
    if (await hasEntry(thing)) return true;
    const link = thing.getCommentsLink();
    if (!link) return null;
    return isURLVisited(link.href);
  }

}
CommentsOpened_CommentsOpened.text = 'Comments opened';
CommentsOpened_CommentsOpened.fields = ['comments page has been visited'];
CommentsOpened_CommentsOpened.slow = 2;
CommentsOpened_CommentsOpened.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Domain.js

class Domain_Domain extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `domain ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getPostDomain();
  }

  evaluate(thing) {
    const domain = thing.getPostDomain();
    if (!domain) return null;
    return this.value.some(v => v.test(domain));
  }

}
Domain_Domain.text = 'Link domain name';
Domain_Domain.fields = ['post links to the domain ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./node_modules/file-loader/dist/cjs.js?name=dash.mediaplayer.min.js!./node_modules/dashjs/dist/dash.mediaplayer.min.js
/* harmony default export */ var dash_mediaplayer_min = (__webpack_require__.p + "dash.mediaplayer.min.js");
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIntersection.js
var _baseIntersection_nativeMin=Math.min;function baseIntersection(arrays,iteratee,comparator){var includes=comparator?_arrayIncludesWith:_arrayIncludes["a" /* default */],length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=Object(_arrayMap["a" /* default */])(array,Object(_baseUnary["a" /* default */])(iteratee));}maxLength=_baseIntersection_nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new _SetCache["a" /* default */](othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?Object(_cacheHas["a" /* default */])(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?Object(_cacheHas["a" /* default */])(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/* harmony default export */ var _baseIntersection = (baseIntersection);
// CONCATENATED MODULE: ./node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value){return lodash_es_isArrayLikeObject(value)?value:[];}/* harmony default export */ var _castArrayLikeObject = (castArrayLikeObject);
// CONCATENATED MODULE: ./node_modules/lodash-es/intersection.js
var intersection=Object(_baseRest["a" /* default */])(function(arrays){var mapped=Object(_arrayMap["a" /* default */])(arrays,_castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?_baseIntersection(mapped):[];});/* harmony default export */ var lodash_es_intersection = (intersection);
// CONCATENATED MODULE: ./lib/core/host.js
class Host {
  constructor(moduleID, {
    name,
    domains,
    permissions,
    logo,
    landingPage,
    attribution = true,
    options,
    detect,
    handleLink,
    getVideoData
  }) {
    this.moduleID = void 0;
    this.name = void 0;
    this.domains = void 0;
    this.permissions = void 0;
    this.logo = void 0;
    this.landingPage = void 0;
    this.attribution = void 0;
    this.options = void 0;
    this.detect = void 0;
    this.handleLink = void 0;
    this.getVideoData = void 0;
    this.moduleID = moduleID;
    this.name = name;
    this.domains = domains;
    this.permissions = permissions;
    this.logo = logo;
    this.landingPage = landingPage;
    this.attribution = attribution;
    this.options = options;
    this.detect = detect;
    this.handleLink = handleLink;
    this.getVideoData = getVideoData;
  }

}
// CONCATENATED MODULE: ./lib/modules/showImages/templates.js


const audioTemplate = ({
  loop,
  sources
}) => string_namespaceObject.html`
	<div>
		<audio controls ${loop && 'loop'}>
			${sources.map(({
  file,
  type
}) => string_namespaceObject._html`
				<source src="${file}" type="${type}">
			`)}
		</audio>
	</div>
`;
const galleryTemplate = ({
  title,
  caption,
  credits,
  src
}) => string_namespaceObject.html`
	<div class="res-gallery">
		${title && string_namespaceObject._html`
		<h3 class="res-title res-gallery-title">${title}</h3>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption res-gallery-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<div class="res-step-container">
			<div class="res-step res-step-previous" role="button"></div>
			<div class="res-step-progress">
				<span class="res-step-position">1</span> of ${src.length}
			</div>
			<div class="res-step res-step-next" role="button"></div>
			<div class="res-gallery-to-filmstrip" title="View as filmstrip" role="button"></div>
		</div>
		<div class="res-gallery-pieces"></div>
		<div class="res-gallery-below">
			<div>
				<div class="res-expando-siteAttribution"></div>
				<div class="res-gallery-increase-concurrent"></div>
			</div>
		</div>
	</div>
`;
const imageTemplate = ({
  title,
  caption,
  credits,
  src,
  href,
  openInNewWindow
}) => string_namespaceObject.html`
	<div class="res-image">
		${title && string_namespaceObject._html`
		<h4 class="res-title">${title}</h4>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<a class="res-expando-link noKeyNav" href="${href}" ${openInNewWindow && string_namespaceObject._html`target="_blank" rel="noopener noreferrer"`}>
			<img class="res-image-media" src="${src}">
		</a>
	</div>
`;
const iframeTemplate = ({
  url,
  width,
  height
}) => string_namespaceObject.html`
	<div class="res-iframe-expando">
		<div>
			<iframe src="${url}" style="width: ${width}; height: ${height}" allowFullscreen="true"></iframe>
			<div class="res-iframe-expando-drag-handle">
				<div class="res-icon"></div>
				<div class="res-expando-siteAttribution"></div>
			</div>
		</div>
	</div>
`;
const textTemplate = ({
  title,
  credits,
  src
}) => string_namespaceObject.html`
	<div class="res-text usertext-body">
		${title && string_namespaceObject._html`
		<h3 class="res-title">${title}</h3>
		`}
		<div class="res-text-media md">${string_namespaceObject.safe(src)}</div>
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
	</div>
`;
const videoTemplate = ({
  title,
  caption,
  credits,
  source,
  poster,
  hasAudio,
  loop,
  reversable,
  formattedPlaybackRate
}) => string_namespaceObject.html`
	<div class="res-video">
		${title && string_namespaceObject._html`
		<h4 class="res-title">${title}</h4>
		`}
		${caption && string_namespaceObject._html`
		<div class="res-caption">${string_namespaceObject.safe(caption)}</div>
		`}
		${credits && string_namespaceObject._html`
		<div class="res-credits">${string_namespaceObject.safe(credits)}</div>
		`}
		<div class="res-video-container">
			<video ${!hasAudio && 'muted'} ${loop && 'loop'} poster="${poster}"></video>
			<div hidden class="res-video-error"></div>
			<div class="res-video-interface">
				<div class="res-video-progress">
					<div class="res-video-position"></div>
					<div class="res-video-position-thumb"></div>
				</div>
				<div class="res-video-main">
					<div class="res-video-controls" hidden>
						<div title="Toggle pause" class="res-icon res-video-button res-video-toggle-pause"></div>
						${reversable && string_namespaceObject._html`
						<div title="Reverse video" class="res-icon res-video-button res-video-reverse"></div>
						`}
						${hasAudio && string_namespaceObject._html`
							<div title="Adjust volume" class="res-icon res-video-button res-video-volume">
								<div class="res-video-volume-level">
									<div class="res-video-volume-percentage"></div>
								</div>
							</div>
						`}
						<div class="res-video-controls-group res-video-current-time">
							<div title="Select previous frame" class="res-icon res-video-button res-video-time-decrease"></div>
							<div class="res-video-time">0.00s</div>
							<div title="Select next frame" class="res-icon res-video-button res-video-time-increase"></div>
						</div>
						<div class="res-video-controls-group res-video-playback-rate">
							<div title="Decrease speed by 10%" class="res-icon res-video-button res-video-speed-decrease"></div>
							<div class="res-video-speed">${string_namespaceObject.safe(formattedPlaybackRate)}</div>
							<div title="Increase speed by 10%" class="res-icon res-video-button res-video-speed-increase"></div>
						</div>
					</div>
					<div class="res-video-info">
						<a class="res-video-link res-video-source" href="${source}" rel="noopener noreferrer">source</a>
						<div class="res-expando-siteAttribution"></div>
					</div>
				</div>
			</div>
		</div>
	</div>
`;
const mediaControlsTemplate = ({
  x,
  y,
  downloadUrl,
  lookupUrl,
  clippy
}) => string_namespaceObject.html`
	<div class="res-media-with-controls-wrapper">
		<div class="res-media-controls res-media-controls-${x} res-media-controls-${y}">
			<button class="res-icon gearIcon" title="Settings" data-action="showImageSettings"></button>
			<button class="res-media-controls-rotate res-media-controls-rotate-left res-icon" title="Rotate image counter-clockwise" data-action="rotateLeft"></button>
			<button class="res-media-controls-rotate res-media-controls-rotate-right res-icon" title="Rotate image clockwise" data-action="rotateRight"></button>
			${downloadUrl && string_namespaceObject._html`
			<button class="res-media-controls-download res-icon title="Download image" data-action="download"></button>
			`}
			${lookupUrl && string_namespaceObject._html`
			<button class="res-media-controls-lookup res-icon" title="Reverse image search" data-action="imageLookup"></button>
			`}
			${clippy && string_namespaceObject._html`
			<button class="res-media-controls-clippy" title="Show educational info" data-action="clippy"></button>
			`}
		</div>
	</div>
`;
const siteAttributionTemplate = ({
  url,
  name,
  logoUrl,
  settingsLink
}) => string_namespaceObject.html`
	<cite class="res-expando-siteAttribution">
		<a href="${url}" target="_blank" rel="noopener noreferer">
			${logoUrl && string_namespaceObject._html`<img src="${logoUrl}" alt="Hosted on ${name}" title="Hosted on ${name}" />`}
			<span>hosted on ${name}</span>
			<a href="${settingsLink}" class="gearIcon" title="Disable or change settings for ${name}"></a>
		</a>
	</cite>
`;
const crosspostMetadataTemplate = data => string_namespaceObject.html`
	<div class="crosspost-preview res-crosspost-preview">
		<div class="crosspost-preview-header">
			<a href="${data.url}" class="content-link may-blank" data-event-action="title" tabindex="1"></a>
			<div class="text-content">
				<p class="title">${data.crosspostRootTitle}</p>
				<div class="crosspost-preview-tagline tagline">
					<span>${i18n('numPoints', parseInt(data.crosspostRootScore, 10))}</span>
					<span class="dot">•</span>
					<a href="/r/${data.crosspostRootSubreddit}/comments/${(data.targetParentFullname || '').slice(3)}" class="comments may-blank">${i18n('numComments', parseInt(data.crosspostRootNumComments, 10))}</a>
					<span class="dot">•</span>
					${i18n('submittedAtTime')} <time>${data.crosspostRootTime}</time>
					${i18n('submittedByAuthor')} <a href="/user/${data.crosspostRootAuthor}/" class="author may-blank">${data.crosspostRootAuthor}</a>
					${i18n('submittedToSubreddit')} <a href="/r/${data.crosspostRootSubreddit}/" class="subreddit hover may-blank">r/${data.crosspostRootSubreddit}</a>
				</div>
			</div>
		</div>
	</div>
`;
// CONCATENATED MODULE: ./node_modules/lodash-es/compact.js
function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/* harmony default export */ var lodash_es_compact = (compact);
// CONCATENATED MODULE: ./lib/modules/showImages/expando.js


const expando_expandos = new Map();
const activeExpandos = new Set();
const opened = new Set();
class expando_Expando {
  static getEntryExpandoFrom(thing) {
    if (!thing) return null;
    const button = thing.entry.querySelector('.expando-button');
    if (!button) return null;
    let expando = expando_expandos.get(button);

    if (!expando) {
      const box = thing.entry.querySelector('.expando');
      if (!box) return null;
      const buttonPlaceholder = document.createElement('span');
      const boxPlaceholder = document.createElement('span');
      expando = {
        button,

        get open() {
          return button.classList.contains('expanded');
        },

        collapse() {
          if (this.open) this.toggle();
        },

        expand() {
          if (!this.open) this.toggle();
        },

        toggle() {
          Object(dom["c" /* click */])(button);
        },

        detach() {
          button.replaceWith(buttonPlaceholder);
          box.replaceWith(boxPlaceholder);
        },

        reattach() {
          buttonPlaceholder.replaceWith(button);
          boxPlaceholder.replaceWith(box);
        },

        types: ['native', button.classList.contains('selftext') ? 'selftext' : (box.dataset.cachedhtml || '').match(/\bvideo-player\b/) ? ['video', 'non-muted'] : (box.dataset.cachedhtml || '').match(/\<iframe\b/) ? ['iframe', 'non-muted'] : ['image', 'muted']].flat().filter(Boolean),
        ready: true
      };
      expando_expandos.set(button, expando);
    }

    return expando;
  }

  static getTextExpandosFrom(thing) {
    if (!thing) return [];
    const md = thing.entry.querySelector('.md');
    if (!md) return [];
    return Object(utils_array["c" /* filterMap */])(Array.from(md.querySelectorAll(expando_Expando.expandoSelector)), v => {
      const exp = expando_expandos.get(v);
      if (exp) return [exp];
    });
  }

  static getAllExpandosFrom(thing) {
    return lodash_es_compact([...expando_Expando.getTextExpandosFrom(thing), expando_Expando.getEntryExpandoFrom(thing)]);
  }

  constructor(href) {
    this.href = void 0;
    this.inText = void 0;
    this.ready = false;
    this.lock = null;
    this.box = void 0;
    this.button = void 0;
    this.open = false;
    this.expandWanted = false;
    this.expandCallbacks = [];
    this.media = void 0;
    this.generateMedia = void 0;
    this.types = [];
    this.buttonInfo = {
      title: 'Expando is not yet ready',
      mediaClass: ''
    };
    this.href = href;
    this.box = document.createElement('div');
    this.box.classList.add('res-expando-box');
    this.box.hidden = true;
    this.button = document.createElement('a');
    this.button.addEventListener('click', () => this.toggle());
    this.updateButton();
    new MutationObserver(() => {
      this.updateButton();
    }).observe(this.button, {
      attributes: true
    });
    expando_expandos.set(this.button, this);
  }

  onExpand(callback) {
    this.expandCallbacks.push(callback);
  }

  updateButton() {
    let {
      mediaClass,
      title
    } = this.buttonInfo;

    if (this.lock) {
      mediaClass = 'expando-button-requires-permission';
      title = 'Click to request required permissions';
    }

    const classList = ['expando-button', ...(mediaClass.split(' ') || ['expando-button-loading']), this.open || this.expandWanted ? 'expanded' : 'collapsed'].filter(Boolean);

    if (!this.expandWanted && !this.open && opened.has(this.href)) {
      classList.push('expando-button-duplicate');
      title += ' (link has already been opened)';
    }

    const btn = this.button;

    for (const v of btn.classList) if (!classList.includes(v)) btn.classList.remove(v);

    for (const v of classList) if (!btn.classList.contains(v)) btn.classList.add(v);

    if (btn.title !== title) btn.title = title;
  }

  initialize(options) {
    this.generateMedia = options.generateMedia;
    this.buttonInfo = options.buttonInfo;
    this.types = options.types;
    this.ready = true;
    if (this.expandWanted) this.expand();else this.updateButton();
  }

  getDuplicates() {
    return Array.from(expando_expandos.values()).filter(v => v !== this && v.href === this.href && document.contains(v.button));
  }

  async setLock(lock) {
    this.lock = lock;
    this.updateButton();
    await lock.promise;
    this.lock = null;
    this.updateButton();
  }

  toggle() {
    if (this.open) this.collapse();else this.expand();
  }

  expand() {
    if (this.lock || !this.ready) {
      this.expandWanted = true;
      if (this.lock) this.lock.open();
      this.updateButton();
      return;
    }

    this.box.hidden = false;
    this.attachMedia();
    if (this.media) this.media.expand();
    this.open = true;
    this.expandWanted = false;
    this.updateButton();

    for (const callback of this.expandCallbacks) callback();

    opened.add(this.href);

    for (const duplicate of this.getDuplicates()) duplicate.updateButton();
  }

  collapse() {
    this.box.hidden = true;
    this.open = false;
    this.expandWanted = false;
    this.updateButton();

    if (this.media) {
      this.media.collapse();
    }
  }

  attachMedia() {
    const wrapper = this.box.firstElementChild || document.createElement('div');
    if (!this.generateMedia) throw new Error('Cannot attach media without `generateMedia`');
    this.media = this.media || this.generateMedia();
    wrapper.append(this.media.element);
    wrapper.classList.add('res-expando-box-inner');
    this.box.append(wrapper);
    if (this.media.onAttach) this.media.onAttach();
    activeExpandos.add(this);
  }

  isAttached() {
    return document.body.contains(this.button) && document.body.contains(this.box);
  }

  destroy() {
    if (this.box) {
      this.box.remove();
      delete this.box;
    }

    if (this.button) {
      expando_expandos.delete(this.button);
      this.button.remove();
      delete this.button;
    }

    this.empty();
  }

  empty() {
    if (this.media) {
      this.media.element.remove();
      delete this.media;
    }

    if (this.button) {
      if (this.open) this.collapse();else this.updateButton();
    }

    activeExpandos.delete(this);
  }

}
expando_Expando.expandoSelector = '.expando-button, .search-expando-button';
// CONCATENATED MODULE: ./lib/modules/hosts/vreddit.js



/* harmony default export */ var vreddit = (new Host('vreddit', {
  name: 'v.redd.it',
  domains: ['v.redd.it'],
  permissions: ['https://*.redd.it/*'],
  attribution: false,
  options: {
    forceReplaceNativeExpando: {
      title: 'showImagesForceReplaceNativeExpandoTitle',
      description: 'showImagesForceReplaceNativeExpandoDesc',
      value: false,
      type: 'boolean'
    },
    minimumVideoBandwidth: {
      title: 'showImagesVredditMinimumVideoBandwidthTitle',
      description: 'showImagesVredditMinimumVideoBandwidthDesc',
      value: '3000',
      type: 'text',
      advanced: true
    }
  },
  detect: ({
    pathname
  }) => pathname.slice(1),

  async handleLink(href, id) {
    const originalPlaylistUrl = `https://v.redd.it/${id}/DASHPlaylist.mpd`;
    const mpd = await ajax({
      url: originalPlaylistUrl
    });
    const manifest = new DOMParser().parseFromString(mpd, 'text/xml');
    const minBandwidth = parseInt(this.options.minimumVideoBandwidth.value, 10) * 1000;
    const reps = Array.from(manifest.querySelectorAll('Representation[frameRate]'));
    const videoSourcesByBandwidth = lodash_es_sortBy(reps, rep => parseInt(rep.getAttribute('bandwidth'), 10)).reverse().filter((rep, i, arr) => {
      const bandwidth = parseInt(rep.getAttribute('bandwidth'), 10);
      return rep === arr[0] || bandwidth >= minBandwidth;
    });

    for (const rep of lodash_es_difference(reps, videoSourcesByBandwidth)) rep.remove();

    for (const rep of manifest.querySelectorAll('Representation')) {
      const baseURLElement = rep.querySelector('BaseURL');
      baseURLElement.textContent = new URL(baseURLElement.textContent, originalPlaylistUrl).href;
    }

    const muted = !manifest.querySelector('AudioChannelConfiguration');
    if (!videoSourcesByBandwidth.length) throw new Error('Video has no valid sources');
    const sources = muted && id ? videoSourcesByBandwidth.map(rep => ({
      source: rep.querySelector('BaseURL').textContent,
      type: 'video/mp4'
    })) : [{
      source: URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(manifest)], {
        type: 'application/dash+xml'
      })),
      type: 'application/dash+xml'
    }];
    return {
      type: 'VIDEO',
      loop: true,
      muted,
      sources
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/aarli.js



/* harmony default export */ var aarli = (new Host('aarli', {
  name: 'AAR Library',
  domains: ['aar.li'],
  logo: 'https://aar.li/favicon.ico',
  detect: ({
    pathname
  }) => /^\/a\/(\w+)/i.exec(pathname),

  async handleLink(href, [, aarId]) {
    const info = await ajax({
      url: 'https://aar.li/api.php',
      query: {
        aarId
      },
      type: 'json'
    });

    if (info.errors) {
      throw new Error(info.errors);
    }

    return {
      type: 'GALLERY',
      title: info.title,
      caption: info.description + (info.previousurl ? string_namespaceObject.escape`<br/><a href="${info.previousurl}">Previous part.</a>` : ''),
      credits: string_namespaceObject.escape`AAR by <a href="${info.authorurl}">${info.author}</a>`,
      src: info.slides.map(({
        desc,
        imglink
      }) => ({
        type: 'IMAGE',
        caption: desc,
        src: imglink
      }))
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/adultswim.js

/* harmony default export */ var adultswim = (new Host('adultswim', {
  name: 'Adult Swim',
  domains: ['adultswim.com'],
  logo: 'https://www.adultswim.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/videos\/([^\/]+\/[^\/]+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, path]) {
    return {
      type: 'IFRAME',
      embed: `https://www.adultswim.com/utilities/embed/${path}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/archilogic.js

/* harmony default export */ var archilogic = (new Host('archilogic', {
  name: 'archilogic',
  domains: ['spaces.archilogic.com'],
  logo: 'https://about.archilogic.com/wp-content/uploads/2017/01/favicon-96x96.png',
  detect: ({
    pathname
  }) => /^\/(3d|model)/.exec(pathname),

  handleLink(href) {
    const formattedUrl = href.replace('/model/', '/3d/').replace('http:', 'https:');
    return {
      type: 'IFRAME',
      embed: formattedUrl
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/archiveis.js

/* harmony default export */ var archiveis = (new Host('archive.is', {
  name: 'archive.is',
  domains: ['archive.is'],
  logo: 'https://archive.is/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(\w+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, code]) {
    return {
      type: 'IMAGE',
      src: `https://archive.fo/${code}/scr.png`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/bime.js

/* harmony default export */ var bime = (new Host('bime', {
  name: 'Bime Analytics Dashboards',
  domains: ['bime.io'],
  logo: 'https://a.bime.io/assets/favicons/favicon.ico',
  detect: ({
    href
  }) => /https?:\/\/([^.]+)\.bime\.io(?:\/([a-z0-9_-]+))+/i.exec(href),
  handleLink: (href, [, user, dashboardId]) => ({
    type: 'IFRAME',
    embed: `https://${user}.bime.io/dashboard/${dashboardId}`,
    expandoClass: 'selftext',
    width: '960px',
    height: '540px'
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/clyp.js

/* harmony default export */ var clyp = (new Host('clyp', {
  name: 'clyp',
  domains: ['clyp.it'],
  logo: 'https://d2cjvbryygm0lr.cloudfront.net/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(playlist\/)?([A-Za-z0-9]+)/i.exec(pathname),

  handleLink(href, [, playlist, id]) {
    return {
      type: 'IFRAME',
      embed: `https://clyp.it/${playlist ? 'playlist/' : ''}${id}/widget`,
      height: '160px',
      width: '600px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/codepen.js

/* harmony default export */ var codepen = (new Host('codepen', {
  name: 'CodePen',
  domains: ['codepen.io'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?!anon)([a-z0-9_-]+)\/(?:pen|full|details|debug)\/([a-z]+)\b/i.exec(pathname),

  handleLink(href, [, user, hash]) {
    return {
      type: 'IFRAME',
      muted: true,
      height: '500px',
      width: '700px',
      expandoClass: 'selftext',
      embed: `https://codepen.io/${user}/embed/${hash}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/coub.js

/* harmony default export */ var coub = (new Host('coub', {
  name: 'Coub',
  domains: ['coub.com'],
  detect: ({
    pathname
  }) => /^\/(?:view|embed)\/(\w+)(\.gifv)?/i.exec(pathname),

  handleLink(href, [, hash, isGifv]) {
    const src = isGifv ? `https://coub.com/view/${hash}.gifv?res=true` : `https://coub.com/embed/${hash}?autoplay=true&res=true`;
    return {
      type: 'IFRAME',
      muted: !!isGifv,
      embed: src,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/dailymotion.js

/* harmony default export */ var dailymotion = (new Host('dailymotion', {
  name: 'dailymotion',
  domains: ['dailymotion.com'],
  logo: 'https://static1.dmcdn.net/images/favicons/favicon-32x32.png.vb5b47df6329123929',
  detect: ({
    href
  }) => /^https?:\/\/(?:(?:www|touch)\.)?dailymotion.com[\w\-\/:#]+video[\/=]([a-z0-9]+)/i.exec(href),

  handleLink(href, [, hash]) {
    const embed = `https://www.dailymotion.com/embed/video/${hash}?api=postMessage`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}&autoplay=1`,
      pause: 'pause',
      play: 'play',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/default.js

/* harmony default export */ var hosts_default = (new Host('default', {
  name: 'default',
  domains: [],
  detect: ({
    pathname
  }) => /\.(webp|gif|jpe?g|png|svg)$/i.test(pathname),

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/defaultAudio.js

/* harmony default export */ var defaultAudio = (new Host('defaultAudio', {
  name: 'defaultAudio',
  domains: [],
  detect: ({
    pathname
  }) => /\.(opus|weba|ogg|wav|mp3|flac)$/i.exec(pathname),

  handleLink(href, [, extension]) {
    if (extension === 'weba') extension = 'webm';
    if (extension === 'opus') extension = 'ogg';
    const format = `audio/${extension}`;
    return {
      type: 'AUDIO',
      autoplay: true,
      loop: false,
      sources: [{
        file: href,
        type: format
      }]
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/defaultVideo.js

/* harmony default export */ var defaultVideo = (new Host('defaultVideo', {
  name: 'defaultVideo',
  domains: [],
  detect: ({
    pathname
  }) => /\.(webm|mp4|ogv|3gp|mkv)$/i.exec(pathname),

  handleLink(href, [, extension]) {
    if (extension === 'ogv') extension = 'ogg';
    const format = `video/${extension}`;
    return {
      type: 'VIDEO',
      sources: [{
        source: href,
        type: format
      }]
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/lodash-es/keyBy.js
var keyBy=Object(_createAggregator["a" /* default */])(function(result,value,key){Object(_baseAssignValue["a" /* default */])(result,key,value);});/* harmony default export */ var lodash_es_keyBy = (keyBy);
// CONCATENATED MODULE: ./lib/modules/hosts/derpibooru.js




/* harmony default export */ var derpibooru = (new Host('derpibooru', {
  name: 'Derpibooru',
  logo: 'https://derpibooru.org/favicon.ico',
  domains: ['derpibooru.org', 'trixiebooru.org', 'derpiboo.ru', 'derpicdn.net'],
  detect: ({
    hostname,
    pathname
  }) => hostname === 'derpicdn.net' ? /^\/img\/view\/\d+\/\d+\/\d+\/(\d+)[._]/i.exec(pathname) : /^\/(?:images\/)?(\d+)$/i.exec(pathname),
  handleLink: (() => {
    const fetchInfo = Object(utils_async["a" /* batch */])(async requests => {
      const maxDepth = 10;
      const {
        images
      } = await ajax({
        url: 'https://derpibooru.org/api/v2/images/show.json',
        query: {
          ids: requests.map(r => r.id).join(',')
        },
        type: 'json'
      });
      const responseById = lodash_es_keyBy(images, img => img.id);
      return requests.map(({
        id,
        depth = 0
      }) => {
        const result = responseById[id];

        if (!result) {
          return new Error('No result');
        } else if (result.duplicate_of) {
          if (depth > maxDepth) {
            return new Error(`Exceeded max duplicate depth: ${maxDepth}`);
          }

          return fetchInfo({
            id: result.duplicate_of,
            depth: depth + 1
          });
        } else if (result.image) {
          return result;
        } else {
          return new Error('Image deleted or other error');
        }
      });
    }, {
      size: 50
    });
    return async (href, [, id]) => {
      const {
        image,
        description,
        source_url: source
      } = await fetchInfo({
        id
      });
      return {
        type: 'IMAGE',
        src: image,
        caption: description,
        credits: source ? string_namespaceObject.escape`Source: <a href="${source}">${source}</a>` : undefined
      };
    };
  })()
}));
// CONCATENATED MODULE: ./lib/modules/hosts/deviantart.js


/* harmony default export */ var deviantart = (new Host('deviantart', {
  name: 'deviantART',
  logo: 'https://i.deviantart.net/icons/da_favicon.ico',
  domains: ['deviantart.com', 'fav.me', 'sta.sh'],
  permissions: ['https://backend.deviantart.com/oembed'],
  detect: ({
    href
  }) => /^https?:\/\/(?:fav\.me\/.*|sta\.sh.*|(?:.+\.)?deviantart\.com\/(?:(?:[\w-]+\/)?art\/.*|[^#]*#\/d.*))$/i.test(href),

  async handleLink(href) {
    const info = await ajax({
      url: 'https://backend.deviantart.com/oembed',
      query: {
        url: href
      },
      type: 'json'
    });

    switch (info.type) {
      case 'photo':
      case 'link':
        let src;

        if (info.fullsize_url) {
          src = info.fullsize_url;
        } else if (/\.(jpg|jpeg|gif|png)/i.test(info.url)) {
          src = info.url;
        } else {
          src = info.thumbnail_url;
        }

        return {
          type: 'IMAGE',
          title: info.title,
          credits: `Art by: <a href="${info.author_url}">${info.author_name}</a> @ deviantART`,
          src
        };

      case 'rich':
        return {
          type: 'TEXT',
          title: info.title,
          src: info.html + (/[^\s\.]\s*$/.test(info.html) ? '...' : ''),
          credits: `<a href="${href}">Click here to read the full text</a> - Written By: <a href="${info.author_url}">${info.author_name}</a> @ deviantART`
        };

      default:
        throw new Error(`Unsupported deviantART post type: ${info.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/dropbox.js


/* harmony default export */ var dropbox = (new Host('dropbox', {
  name: 'dropbox',
  domains: ['dropbox.com'],
  logo: 'https://cfl.dropboxstatic.com/static/images/favicon-vflk5FiAC.ico',

  detect(url) {
    for (const host of genericHosts) {
      const result = host.detect(url);
      if (result) return [host.handleLink, result];
    }
  },

  handleLink(href, [handler, result]) {
    const originalURL = new URL(href);
    return handler(`${originalURL.origin}${originalURL.pathname}?raw=1`, result);
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/facebookvideo.js

/* harmony default export */ var facebookvideo = (new Host('facebookvideo', {
  name: 'facebookvideo',
  domains: ['facebook.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/([a-z0-9]+)\/(?:videos)\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, channel, id]) {
    return {
      type: 'IFRAME',
      embed: `https://www.facebook.com/plugins/video.php?href=https://www.facebook.com/${channel}/videos/${id}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/fiveHundredPx.js

/* harmony default export */ var fiveHundredPx = (new Host('fiveHundredPx', {
  name: 'fiveHundredPx',
  domains: ['500px.org', '500px.net', '500px.com'],
  logo: 'https://assetcdn.500px.org/assets/favicon-1e8257b93fb787f8ceb66b5522ee853c.ico',
  detect: ({
    href
  }) => /^https?:\/\/\w*cdn\.500px\.(?:net|com|org)\/(?:photo\/)?([0-9]+)\//.exec(href),

  handleLink(href, [, photoId]) {
    return {
      type: 'IMAGE',
      src: href.replace(/\/[0-9]+\.jpg$/, '/5.jpg'),
      credits: `View original and details at: <a href="https://500px.com/photo/${photoId}">500px.com</a>`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/flickr.js



function base58Encode(num) {
  let enc = '';
  let acc = num;

  do {
    const div = Math.floor(acc / 58);
    const mod = acc - 58 * div;
    enc = `${'123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'[mod]}${enc}`;
    acc = div;
  } while (acc);

  return enc;
}

/* harmony default export */ var flickr = (new Host('flickr', {
  name: 'flickr',
  domains: ['flickr.com', 'flic.kr', 'staticflickr.com'],
  permissions: ['https://www.flickr.com/services/oembed'],
  logo: 'https://s.yimg.com/pw/favicon.ico',

  detect({
    origin,
    href,
    pathname
  }) {
    if (origin.endsWith('staticflickr.com')) {
      const [, id] = /(?:.+\/)?\d{4}\/(\d{10,})_/i.exec(pathname) || [];
      if (id) return `https://flic.kr/p/${base58Encode(parseInt(id, 10))}`;
    } else {
      return href;
    }
  },

  async handleLink(href, oembedTarget) {
    const info = await ajax({
      url: 'https://www.flickr.com/services/oembed',
      query: {
        format: 'json',
        url: oembedTarget
      },
      type: 'json'
    });
    const validSuffix = /\.(jpg|jpeg|gif|png)/i;
    const src = validSuffix.test(oembedTarget) ? oembedTarget : validSuffix.test(info.url) ? info.url : validSuffix.test(info.thumbnail_url) ? info.thumbnail_url : undefined;

    if (!src) {
      throw new Error('No image found.');
    }

    return {
      type: 'IMAGE',
      title: info.title,
      credits: `Picture by: <a href="${info.author_url}">${info.author_name}</a> @ Flickr`,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gamerdvr.js

/* harmony default export */ var gamerdvr = (new Host('gamerdvr', {
  name: 'GamerDVR',
  domains: ['gamerdvr.com'],
  logo: 'https://gamerdvr.com/assets/favicon-240671aabcbf14dcaa1f3f2b406091d2.png',
  detect: ({
    pathname
  }) => /^\/(gamer\/[^\/]+\/\w+\/\d+)(?:\/|$)/.exec(pathname),

  handleLink(href, [, path]) {
    return {
      type: 'IFRAME',
      embed: `https://gamerdvr.com/${path}/embed`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/getyarn.js

/* harmony default export */ var getyarn = (new Host('getyarn', {
  name: 'getyarn.io',
  logo: 'https://getyarn.io/favicon.ico',
  domains: ['getyarn.io'],
  detect: ({
    pathname
  }) => /\/yarn-clip\/(?:embed\/)?([\w\-]+)/i.exec(pathname),

  handleLink(href, [, code]) {
    const embed = `https://getyarn.io/yarn-clip/embed/${code}`;
    return {
      type: 'IFRAME',
      embed: `${embed}?autoplay=false`,
      embedAutoplay: `${embed}?autoplay=true`,
      height: '600px',
      width: '768px',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gfycat.js



/* harmony default export */ var gfycat = (new Host('gfycat', {
  name: 'gfycat',
  domains: ['gfycat.com'],
  logo: 'https://gfycat.com/favicon.ico',
  options: {
    useMobileGfycat: {
      title: 'gfycatUseMobileGfycatTitle',
      description: 'gfycatUseMobileGfycatDesc',
      value: false,
      type: 'boolean'
    }
  },
  detect: ({
    pathname
  }) => /^\/(?:(?:ifr|gifs\/detail)\/)?(\w+)(?:\.gif)?/i.exec(pathname),

  async handleLink(href, [, id]) {
    const isMobileResolution = this.options.useMobileGfycat.value;
    const info = (await ajax({
      url: string_namespaceObject.encode`https://api.gfycat.com/v1/gfycats/${id}`,
      type: 'json',
      cacheFor: utils_time["a" /* DAY */]
    })).gfyItem;
    return {
      type: 'VIDEO',
      frameRate: info.frameRate,
      loop: true,
      muted: !info.hasAudio,
      playbackRate: +(href.match(/[?|&]speed=([\d\.]+)/i) || [undefined, 1])[1],
      poster: isMobileResolution ? info.mobilePosterUrl : info.posterUrl,
      sources: [isMobileResolution && {
        source: info.mobileUrl,
        type: 'video/mp4'
      }, {
        source: info.webmUrl,
        type: 'video/webm'
      }, {
        source: info.mp4Url,
        type: 'video/mp4'
      }].filter(x => x),
      time: +(href.match(/[?|&]frameNum=([\d]+)/i) || [undefined, 0])[1] / info.frameRate
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gifyoutube.js



/* harmony default export */ var gifyoutube = (new Host('gifs', {
  name: 'gifs.com',
  domains: ['gifs.com', 'gifyoutube.com', 'gifyt.com'],
  logo: 'https://cdn.gifs.com/resources/favicon.png',
  detect: ({
    href
  }) => /^https?:\/\/(?:beta\.|www\.)?(?:gifyoutube|gifyt)\.com\/gif\/(\w+)\.?/i.exec(href) || /^https?:\/\/share\.gifyoutube\.com\/(\w+)\.gif/i.exec(href),

  async handleLink(href, [, id]) {
    const {
      sauce
    } = await ajax({
      url: `https://gifs.com/api/${id}`,
      type: 'json',
      cacheFor: utils_time["a" /* DAY */]
    });
    return {
      type: 'VIDEO',
      loop: true,
      fallback: `https://share.gifyoutube.com/${id}.gif`,
      muted: true,
      source: sauce,
      sources: [{
        source: `https://share.gifyoutube.com/${id}.webm`,
        type: 'video/webm'
      }, {
        source: `https://share.gifyoutube.com/${id}.mp4`,
        type: 'video/mp4'
      }]
    };
  }

}));
// EXTERNAL MODULE: ./lib/images/hosts/giphy-logo.png
var giphy_logo = __webpack_require__(104);
var giphy_logo_default = /*#__PURE__*/__webpack_require__.n(giphy_logo);

// CONCATENATED MODULE: ./lib/modules/hosts/giphy.js



/* harmony default export */ var giphy = (new Host('giphy', {
  name: 'giphy',
  domains: ['giphy.com'],
  logo: giphy_logo_default.a,
  detect: ({
    pathname
  }) => /^(?:\/gifs|\/media|)\/(?:\w+-)*([^/.]+)(?:\/|\.gif|$)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      data
    } = await ajax({
      url: `https://api.giphy.com/v1/gifs/${id}`,
      query: {
        api_key: 'dc6zaTOxFJmzC'
      },
      type: 'json'
    });
    return {
      type: 'VIDEO',
      fallback: data.images.original.url,
      loop: true,
      muted: true,
      sources: [{
        source: data.images.original.mp4,
        type: 'video/mp4'
      }]
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/snudown-js/dist/snudown_es.js
function n(A){snudown_es_c=A,new Int8Array(A),new Int16Array(A),snudown_es_r=new Int32Array(A),o=new Uint8Array(A),new Uint16Array(A),new Uint32Array(A),new Float32Array(A),new Float64Array(A);}function w(A){var r=1+(A.length<<2),i=snudown_es_b(r),f=o,e=i;if(0<r){r=e+r-1;for(var a=0;a<A.length;++a){var n=A.charCodeAt(a);if(55296<=n&&n<=57343&&(n=65536+((1023&n)<<10)|1023&A.charCodeAt(++a)),n<=127){if(r<=e)break;f[e++]=n;}else{if(n<=2047){if(r<=e+1)break;f[e++]=192|n>>6;}else{if(n<=65535){if(r<=e+2)break;f[e++]=224|n>>12;}else{if(r<=e+3)break;f[e++]=240|n>>18,f[e++]=128|n>>12&63;}f[e++]=128|n>>6&63;}f[e++]=128|63&n;}}f[e]=0;}return i;}function snudown_es_i(A,r,i){"string"!=typeof r&&(r="");for(var f=w(r),e=0,a=0;a<r.length;++a){var n=r.charCodeAt(a);55296<=n&&n<=57343&&(n=65536+((1023&n)<<10)|1023&r.charCodeAt(++a)),n<=127?++e:e=n<=2047?e+2:n<=65535?e+3:e+4;}if("object"==typeof i&&null!==i||(i={}),A=A(f,a=e,n=i.nofollow?1:0,r="string"==typeof i.target?w(i.target):0,e="string"==typeof i.tocIdPrefix?w(i.tocIdPrefix):0,i.enableToc?1:0)){for(a=(i=A)+NaN,n="";!(a<=i);){var k,c,b=o[i++];if(!b)break;128&b?(k=63&o[i++],192==(224&b)?n+=String.fromCharCode((31&b)<<6|k):(c=63&o[i++],(b=224==(240&b)?(15&b)<<12|k<<6|c:(7&b)<<18|k<<12|c<<6|63&o[i++])<65536?n+=String.fromCharCode(b):n+=String.fromCharCode(55296|(b-=65536)>>10,56320|1023&b))):n+=String.fromCharCode(b);}i=n;}else i="";return snudown_es_t(A),snudown_es_t(e),snudown_es_t(r),snudown_es_t(f),i;}var snudown_es_r,o,f={Memory:function(A){return{buffer:new ArrayBuffer(65536*A.A),grow:function(A){return J(A);}};},Table:function(A){var i=Array(A.A);return i.grow=function(){if(43<=i.length)throw"Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.";i.push(null);},i.set=function(A,r){i[A]=r;},i.get=function(A){return i[A];},i;},Module:function(){return{};},Instance:function(){return{exports:function(A,r,i){function f(A,r,i){for(var f,e=0,a=r,n=i.length,k=r+(3*n>>2)-("="==i[n-2])-("="==i[n-1]);e<n;e+=4)r=c[i.charCodeAt(e+1)],f=c[i.charCodeAt(e+2)],A[a++]=c[i.charCodeAt(e)]<<2|r>>4,a<k&&(A[a++]=r<<4|f>>2),a<k&&(A[a++]=f<<6|c[i.charCodeAt(e+3)]);}for(var c=new Uint8Array(123),e=25;0<=e;--e)c[48+e]=52+e,c[65+e]=e,c[97+e]=26+e;return c[43]=62,c[47]=63,f(e=new Uint8Array(r.buffer),1024,"Y29sc3BhbgByb3dzcGFuAGNlbGxzcGFjaW5nAGNlbGxwYWRkaW5nAHNjb3BlAHRyAHRoAHRkAHRib2R5AHRoZWFkAHRmb290AGNhcHRpb24AIHJlbD0ibm9mb2xsb3ciACB0YXJnZXQ9IgAAAAAAAIQHAACoBAAAsQQAALgEAADCBAAAxAQAAMsEAADUBAAA2wQAAOMEAADtBAAA9AQAAPwEAAAJBQAAaHR0cHM6Ly8AZnRwOi8vAG1haWx0bzovLwAvAGdpdDovLwBzdGVhbTovLwBpcmM6Ly8AbmV3czovLwBtdW1ibGU6Ly8Ac3NoOi8vAGlyY3M6Ly8AdHMzc2VydmVyOi8vACMAd3d3LgAuKy1fAGFsbC0AcmVkZGl0LmNvbQB0Og=="),f(e,1328,"nBkAAMwFAADOBQAA0QUAANUFAADaBQAAnBkAAOAFAADjBQAA5wUAAOwFAAD3BQAA/gUAAAEGAACcGQAACgYAAJwZAAANBgAAEAYAAJwZAACcGQAAFAYAABsGAAAeBgAAnBkAAOgLAAAnBgAALgYAADEGAACcGQAAnBkAAJwZAAA1BgAAnBkAAJwZAACcGQAAnBkAADgGAAA7BgAAcABkbABkaXYAbWF0aAB0YWJsZQB1bABkZWwAZm9ybQBibG9ja3F1b3RlAGZpZ3VyZQBvbABmaWVsZHNldABoMQBoNgBwcmUAc2NyaXB0AGg1AG5vc2NyaXB0AGlmcmFtZQBoNABpbnMAaDMAaDIAc3BhbgAmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJggeGRQPCiYmJiYmJiYmJiYAJgAmBQUFDwAmJgAPCgAmJg8ABSYmJiYmJiYmJiYmJgAmACYFBQUPACYmAA8KACYmDwAFJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJu+7vw=="),f(e,1876,"AgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAAaHR0cDovLwBcYCpfe31bXSgpIystLiE6fCY8Pi9efgAAAQAAQAAAAAAAAAACAgICAgICAgIAAAICAAICAgICAgICAgICAgICAgICAgABAAEBAQAAAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE="),f(e,2224,"JiN4Mjc7"),f(e,2240,"MDEyMzQ1Njc4OUFCQ0RFRg=="),f(e,2272,"BwcHBwcHBwcHAAAHBwAHBwcHBwcHBwcHBwcHBwcHBwcAAAEAAAACAwAAAAAAAAAE"),f(e,2332,"BQAG"),f(e,2528,"nBkAAEgdAAABGgAAAAoAAAYKAABXGgAA0B0AAJwZAAAmIzM5OwAmIzQ3Ow=="),f(e,2588,"Dg=="),f(e,2624,"DwAAABAAAAARAAAAEg=="),f(e,2648,"EwAAAAAAAAAUAAAAFQAAABY="),f(e,2680,"FwAAADwvbGk+CjwvdWw+CgA8L2Rpdj4KADxzdXA+ADwvc3VwPgA8ZGVsPgA8L2RlbD4APHN0cm9uZz48ZW0+ADwvZW0+PC9zdHJvbmc+ADxlbT4APC9lbT4APHN0cm9uZz4APC9zdHJvbmc+ADxzcGFuIGNsYXNzPSJtZC1zcG9pbGVyLXRleHQiPgA8L3NwYW4+ADxjb2RlPgA8L2NvZGU+ADxkaXYgY2xhc3M9InRvYyI+CgA8dWw+CjxsaT4KADwvbGk+CgA8L3VsPgo8L2xpPgoAPGxpPgoAPC9saT4KPGxpPgoAPGEgaHJlZj0iIwB0b2NfACI+ADwvYT4KABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAPAAAAEAAAABEAAAASAAAAJQAAACYAAAAnAAAAKAAAABQAAAAVAAAAFgAAAAAAAAApAAAAAAAAACoAAABzdHlsZQBhAGltZwA9IgA8YSBocmVmPSIAIiB0aXRsZT0iADwvYT4APGJyPgoAPGJyLz4KADxpbWcgc3JjPSIAIiBhbHQ9IgAiLz4AbWFpbHRvOgA8dGgAPHRkACBjb2xzcGFuPSIAIiAAIGFsaWduPSJjZW50ZXIiPgAgYWxpZ249ImxlZnQiPgAgYWxpZ249InJpZ2h0Ij4APgA8L3RoPgoAPC90ZD4KADx0cj4KADwvdHI+CgA8dGFibGU+PHRoZWFkPgoAPC90aGVhZD48dGJvZHk+CgA8L3Rib2R5PjwvdGFibGU+CgA8cD4APC9wPgoAPGxpPgA8b2w+CgA8dWw+CgA8L29sPgoAPC91bD4KADxocj4KADxoci8+CgA8aAAgaWQ9IgA8L2gAPgoAPGJsb2NrcXVvdGUgY2xhc3M9Im1kLXNwb2lsZXItdGV4dCI+CgA8L2Jsb2NrcXVvdGU+CgA8YmxvY2txdW90ZT4KADxwcmU+PGNvZGUgY2xhc3M9IgA8cHJlPjxjb2RlPgA8L2NvZGU+PC9wcmU+CgAAAAAAAAAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACdGQAAohkAAJwZAACcGQAAnBkAAJwZAACoGQAAnBkAAJwZAACcGQAAnBkAAK4ZAAC0GQAAuxkAAJwZAACcGQAAwxkAAJwZAACcGQAAnBkAAJwZAADJGQAAzxkAAJwZAACcGQAAnBkAANYZAADcGQAA4xkAAOsZAACcGQAA9BkAAJwZAACcGQAAnBkAAJwZAACcGQAA+hkAAJwZAACcGQAAnBkAAAEaAACcGQAAnBkAAJwZAACcGQAABxoAAJwZAACcGQAAnBkAAJwZAACcGQAADRoAAJwZAACcGQAAFBoAAB4aAACcGQAAnBkAAJwZAACcGQAAJBoAACoaAACcGQAAnBkAADEaAAA2GgAAPBoAAJwZAACcGQAAQxoAAJwZAABIGgAATxoAAJwZAABXGgAAXBoAAJwZAABiGgAAnBkAAJwZAABqGgAAcBoAAJwZAAB3GgAAnBkAAIAaAACGGgAAjRoAAJUaAACcGQAAnBkAAJ4aAACcGQAAoxoAAKwaAAC2GgAAvBoAAMEaAACcGQAAyRoAAJwZAADOGgAA0xoAAJwZAACcGQAA2xoAAOEaAADoGgAAnBkAAJwZAADwGgAAnBkAAPsaAACcGQAAnBkAAJwZAAADGwAAChsAAJwZAACcGQAAEhsAABgbAAAfGwAAnBkAAJwZAACcGQAAJxsAAC4bAACcGQAAnBkAAJwZAAA2GwAAPRsAAJwZAACcGQAARRsAAEsbAABQGwAAWBsAAJwZAABhGwAAZxsAAG4bAAB2GwAAnBkAAH8bAACGGwAAjRsAAJwZAACcGQAAlRsAAJwbAACjGwAAqxsAAJwZAACyGwAAnBkAALgbAACcGQAAnBkAAMAbAADHGwAAnBkAAJwZAACcGQAAzhsAANQbAADZGwAA4RsAAJwZAACcGQAA6hsAAJwZAADxGwAAnBkAAPobAAABHAAACBwAAA4cAACcGQAAFxwAAJwZAAAdHAAAnBkAAJwZAACcGQAAnBkAAJwZAAAlHAAAnBkAAJwZAACcGQAALhwAADYcAACcGQAAnBkAAD8cAABGHAAAThwAAFccAACcGQAAXBwAAGMcAABrHAAAnBkAAHQcAAB6HAAAgRwAAIkcAACcGQAAnBkAAJwZAACSHAAAmhwAAKMcAACcGQAAnBkAAKscAACzHAAAnBkAAJwZAACcGQAAnBkAAJwZAAC8HAAAnBkAAJwZAACcGQAAwxwAAMwcAADRHAAA1xwAAN4cAADkHAAAnBkAAJwZAADtHAAA9BwAAPwcAACcGQAAnBkAAAUdAAAMHQAAnBkAAJwZAACcGQAAFB0AABsdAAAjHQAAnBkAACwdAAA0HQAAOx0AAEEdAABIHQAATx0AAFcdAABeHQAAZh0AAJwZAACcGQAAbx0AAHYdAAB+HQAAhx0AAIwdAACUHQAAmx0AAJwZAACcGQAAox0AAKsdAACcGQAAsh0AALsdAADDHQAAyR0AAJwZAACcGQAA0B0AANUdAADbHQAA4h0AAJwZAADsHQAA9B0AAP0dAAAEHgAADB4AAJwZAAAVHgAAHh4AACceAACcGQAAMR4AADkeAAA/HgAARh4AAE4eAABXHgAAnBkAAF8eAACcGQAAaB4AAJwZAACcGQAAcR4AAHoeAACcGQAAnBkAAIIeAACKHgAAnBkAAJMeAACcGQAAnB4AAKQeAACrHgAAsx4AALweAADDHgAAyx4AANIeAADaHgAAnBkAAOAeAADoHgAA7x4AAPceAACcGQAAAB8AAAgfAAAPHwAAFx8AAJwZAACcGQAAIB8AACcfAAAvHwAAnBkAAJwZAAA4HwAAQR8AAEkfAACcGQAAnBkAAFIfAABZHwAAYR8AAJwZAACcGQAAaB8AAG8fAAB3HwAAnBkAAIAfAACIHwAAjx8AAJkfAACcGQAAnBkAAKIfAACpHwAAsR8AAJwZAAC6HwAAnBkAAMEfAACcGQAAnBkAAJwZAACcGQAAyR8AANEfAACcGQAAnBkAAJwZAADaHwAAnBkAAJwZAACcGQAAnBkAAOIfAADsHwAAnBkAAJwZAAD1HwAAnBkAAPwfAACcGQAAnBkAAJwZAACcGQAABSAAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAADiAAAJwZAACcGQAAnBkAAJwZAACcGQAAFCAAAJwZAACcGQAAnBkAAJwZAAAbIAAAJCAAAJwZAACcGQAAnBkAACwgAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAAA1IAAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAAA8IAAAnBkAAJwZAABEIAAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAE0gAACcGQAAnBkAAJwZAABWIAAAXiAAAJwZAACcGQAAnBkAAJwZAABnIAAAnBkAAHAgAACcGQAAnBkAAJwZAACcGQAAnBkAAHggAACcGQAAfSAAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAIYgAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAI0gAACcGQAAnBkAAJwZAACcGQAAkyAAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACZIAAAnBkAAJwZAACcGQAAnBkAAKEgAACpIAAAnBkAAJwZAACcGQAAnBkAAJwZAACxIAAAuiAAAJwZAACcGQAAnBkAAMIgAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAADLIAAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAA1CAAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAADdIAAAnBkAAJwZAACcGQAA5SAAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAA7iAAAPcgAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAA/yAAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAAghAACcGQAAnBkAAJwZAACcGQAAnBkAABEhAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAACcGQAAnBkAAJwZAAAbIQAAACZvcjsAJm5vdDsAJmludDsAJnBzaTsAJmlzaW47ACZub3RpbjsAJlJobzsAJnBoaTsAJnByb3A7ACZyaG87ACZuYnNwOwAmdGhvcm47ACZ0aGluc3A7ACZjaGk7ACZwcm9kOwAmYW1wOwAmUHNpOwAmaW90YTsAJm9taWNyb247ACZQaGk7ACZhbmQ7ACZzZG90OwAmbnU7ACZDaGk7ACZlbXNwOwAmTXU7ACZlbnNwOwAmb2NpcmM7ACZsdDsAJnVtbDsAJmljaXJjOwAmc3VwOwAmc3VwMTsAJlNjYXJvbjsAJmNhcDsAJnBhcnQ7ACZwb3VuZDsAJnNjYXJvbjsAJm5pOwAmbG93YXN0OwAmT21pY3JvbjsAJmN1cDsAJlhpOwAmY3JhcnI7ACZOdTsAJnBpOwAmdGhldGE7ACZ0YXU7ACZuc3ViOwAmYWNpcmM7ACZ0aGV0YXN5bTsAJk9jaXJjOwAmcmFycjsAJnVjaXJjOwAmbG96OwAmZGFycjsAJnRyYWRlOwAmcGFyYTsAJmVjaXJjOwAmbGFycjsAJnJhZGljOwAmc3ViOwAmUGk7ACZrYXBwYTsAJmlxdWVzdDsAJmV0YTsAJnN1cGU7ACZyY2VpbDsAJnRoZXJlNDsAJnJBcnI7ACZ1YXJyOwAmS2FwcGE7ACZkQXJyOwAmZXVybzsAJlRoZXRhOwAmY2lyYzsAJlRhdTsAJmxjZWlsOwAmbEFycjsAJm9yZG07ACZscm07ACZ4aTsAJmFjdXRlOwAmY2NlZGlsOwAmc3VwMzsAJm50aWxkZTsAJnVBcnI7ACZzdXAyOwAmcGl2OwAmb3RpbGRlOwAmc2h5OwAmQWNpcmM7ACZjdXJyZW47ACZVY2lyYzsAJm9hY3V0ZTsAJnN1YmU7ACZuYWJsYTsAJmlhY3V0ZTsAJm11OwAmYnVsbDsAJm9saW5lOwAmQ2NlZGlsOwAmc3VtOwAmY29weTsAJmVxdWl2OwAmTnRpbGRlOwAmcHJpbWU7ACZhdGlsZGU7ACZ0aWxkZTsAJkVjaXJjOwAmT3RpbGRlOwAmYXBvczsAJmFhY3V0ZTsAJm5lOwAmRXRhOwAmbWFjcjsAJnNpbTsAJk9hY3V0ZTsAJklvdGE7ACZlbXB0eTsAJnVhY3V0ZTsAJm91bWw7ACZleGlzdDsAJml1bWw7ACZQcmltZTsAJmVhY3V0ZTsAJnJzcXVvOwAmY2VudDsAJnp3ajsAJnp3bmo7ACZxdW90OwAmc2JxdW87ACZzZWN0OwAmaW5maW47ACZvdGltZXM7ACZjb25nOwAmSWNpcmM7ACZicnZiYXI7ACZsZTsAJmxzcXVvOwAmb3JkZjsAJmNsdWJzOwAmb3BsdXM7ACZwZXJwOwAmWWFjdXRlOwAmbWljcm87ACZhbmc7ACZhdW1sOwAmZ3Q7ACZybG07ACZPdW1sOwAmdXBzaWxvbjsAJm1pbnVzOwAmbWlkZG90OwAmdXVtbDsAJmFyaW5nOwAmQXRpbGRlOwAmZGl2aWRlOwAmcnNhcXVvOwAmZXBzaWxvbjsAJnRpbWVzOwAmRVRIOwAmZXVtbDsAJnN6bGlnOwAmZnJhYzE0OwAmZGlhbXM7ACZvc2xhc2g7ACZBYWN1dGU7ACZsc2FxdW87ACZEZWx0YTsAJnJkcXVvOwAmc3BhZGVzOwAmVWFjdXRlOwAmcmFxdW87ACZyYW5nOwAmZnJhc2w7ACZyZmxvb3I7ACZoYXJyOwAmbmRhc2g7ACZZdW1sOwAmY2VkaWw7ACZldGg7ACZsZHF1bzsAJnJlYWw7ACZUSE9STjsAJnBsdXNtbjsAJmxhcXVvOwAmbGFuZzsAJmRlbHRhOwAmbGZsb29yOwAmYmV0YTsAJm9tZWdhOwAmRWFjdXRlOwAmT3NsYXNoOwAmaW1hZ2U7ACZ3ZWllcnA7ACZaZXRhOwAmT0VsaWc7ACZoQXJyOwAmQXVtbDsAJmFzeW1wOwAmTGFtYmRhOwAmYmRxdW87ACZ6ZXRhOwAmVXBzaWxvbjsAJmxhbWJkYTsAJlV1bWw7ACZBcmluZzsAJnlhY3V0ZTsAJkJldGE7ACZHYW1tYTsAJmlleGNsOwAmZm9yYWxsOwAmT21lZ2E7ACZFcHNpbG9uOwAmSWFjdXRlOwAmRXVtbDsAJmZyYWMzNDsAJmZyYWMxMjsAJnllbjsAJnl1bWw7ACZvZ3JhdmU7ACZBRWxpZzsAJmlncmF2ZTsAJkl1bWw7ACZhbHBoYTsAJnBlcm1pbDsAJmFncmF2ZTsAJm1kYXNoOwAmT2dyYXZlOwAmdWdyYXZlOwAmdXBzaWg7ACZnZTsAJmVncmF2ZTsAJmZub2Y7ACZyZWc7ACZkZWc7ACZTaWdtYTsAJnNpZ21hOwAmQWxwaGE7ACZoZWFydHM7ACZvZWxpZzsAJkFncmF2ZTsAJlVncmF2ZTsAJmhlbGxpcDsAJmFlbGlnOwAmRWdyYXZlOwAmSWdyYXZlOwAmZ2FtbWE7ACZEYWdnZXI7ACZkYWdnZXI7ACZhbGVmc3ltOwAmc2lnbWFmOw=="),f(e,8496,"AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAF8AWgAAAAMDAwMDAwMDAwMDAwAAAwMDAwMDAwMDA3MAXgA3AAAAlgAZAAAAHgDDAAMDHgAeAAUAIwAtAC0AAwMKAAAAMgB9AAMDAwMFAFUASwADAwMDAwMDAwMDAwMoAEEAFAAZADwA8ADwAN8ACgBmABQAIwCHAAAABQAKALcAFAAFAAAAMgBLAAoASwCvAFUADwADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw=="),f(e,9024,"/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAQIEBwMGBQ=="),f(e,9296,"LgQAADEEAAA0BAAA2gUAADcEAAA9BAAAQwQAAEkE"),f(e,9345,"BAAACAQAABAEAAAcBAAAKAQ="),function(f,A,k){function a(A,r){if(!A)return w(r);if(!r)return ir(A),0;var i=8<r>>>0?r+3&-4:8,f=i+8|0,e=A+-4|0,a=mr[e>>2],n=a+e|0,k=mr[n>>2],c=k+n|0;A:{r:{if(mr[c+-4>>2]!=(0|k)){if(16+(r=f+e|0)>>>0<=c>>>0)return mr[(i=mr[n+4>>2])+8>>2]=mr[n+8>>2],mr[mr[n+8>>2]+4>>2]=i,mr[r>>2]=n=c-r|0,mr[(r+(-4&n)|0)-4>>2]=-1^n,(a=mr[(k=r)>>2]+-8|0)>>>0<=127?n=(a>>>3|0)-1|0:(n=110+((a>>>29-(c=rA(a))^4)-(c<<2)|0)|0,a>>>0<=4095||(n=(n=71+((a>>>30-c^2)-(c<<1)|0)|0)>>>0<63?n:63)),mr[k+4>>2]=10032+(i=n<<4),mr[r+8>>2]=mr[(i=i+10040|0)>>2],mr[i>>2]=r,mr[mr[r+8>>2]+4>>2]=r,a=mr[2767],i=31&n,k=32<=(63&n)>>>0?(n=1<<i,0):(n=(1<<i)-1&1>>>32-i,1<<i),mr[2766]|=k,mr[2767]=n|a,mr[e>>2]=f,mr[r+-4>>2]=f,A;if(c>>>0<r>>>0)break r;return mr[(r=mr[n+4>>2])+8>>2]=mr[n+8>>2],mr[mr[n+8>>2]+4>>2]=r,mr[e>>2]=r=a+k|0,mr[(e+(-4&r)|0)-4>>2]=r,A;}if(i+24>>>0<=a>>>0)return mr[e>>2]=f,mr[(r=f+e|0)>>2]=n=a-f|0,mr[r+-4>>2]=f,mr[(r+(-4&n)|0)-4>>2]=-1^n,(f=mr[(k=r)>>2]+-8|0)>>>0<=127?n=(f>>>3|0)-1|0:(n=110+((f>>>29-(e=rA(f))^4)-(e<<2)|0)|0,f>>>0<=4095||(n=(n=71+((f>>>30-e^2)-(e<<1)|0)|0)>>>0<63?n:63)),mr[k+4>>2]=10032+(i=n<<4),mr[r+8>>2]=mr[(i=i+10040|0)>>2],mr[i>>2]=r,mr[mr[r+8>>2]+4>>2]=r,i=mr[2767],r=31&n,r=32<=(63&n)>>>0?(n=1<<r,0):(n=(1<<r)-1&1>>>32-r,1<<r),mr[2766]|=r,mr[2767]=n|i,A;if(f>>>0<=a>>>0)break A;}if(!(r=w(i)))return 0;t(r,A,i>>>0<(n=mr[e>>2]+-8|0)>>>0?i:n),ir(A),A=r;}return A;}function _A(A,r,i,f,e){var a,n=0;Mr=a=Mr-16|0,mr[12+a>>2]=0,mr[4+a>>2]=0;A:if(!(60!=Dr[(mr[8+a>>2]=0)|(mr[a>>2]=i)]|f>>>0<2)){var k=1;r:{i:{for(;;){if((0|f)==(0|k))break i;var c=Dr[i+k|0];if(32==(0|c)|62==(0|c))break;k=k+1|0;}c=i+1|0;var b=0;f:if(!(9<(k=k+-1|0)-1>>>0)){if(!(37<(b=Dr[Dr[0|c]+1600|0]+(1!=(0|k)?Dr[Dr[c+1|0]+1601|0]+k|0:1)|0)>>>0||223&(Dr[0|(b=mr[1328+(b<<2)>>2])]^Dr[0|c])||l(c,b,k)||Dr[k+b|0]))break f;b=0;}if(c=b)break r;}i:{if(!(f>>>0<6)){if(33!=(0|(k=Dr[i+1|0])))break i;if(45!=Dr[i+2|0]|45!=Dr[i+3|0])break A;k=5;f:{for(;k>>>0<f>>>0;){if(!(45!=Dr[(c=i+k|0)-2|0]|45!=Dr[c+-1|0])){if(k=k+1|0,62!=Dr[0|c])continue;break f;}k=k+1|0;}k=k+1|0;}if(!(f>>>0<=k>>>0)&&(c=Jr(i+k|0,f-k|0))){if(mr[4+a>>2]=n=k+c|0,!e)break A;if(!(i=mr[r+12>>2]))break A;Qr[i](A,a,mr[r+112>>2]),n=mr[4+a>>2];break A;}}if(f>>>0<5)break A;k=Dr[i+1|0];}if(104!=(255&(32|k))|114!=(32|Dr[i+2|0]))break A;for(k=3;;){if((0|f)==(0|k))b=f+1|0;else if(c=i+k|0,k=b=k+1|0,62!=Dr[0|c])continue;break;}if(f>>>0<=b>>>0)break A;if(!(i=Jr(i+b|0,f-b|0)))break A;if(mr[4+a>>2]=n=i+b|0,!e)break A;if(!(i=mr[r+12>>2]))break A;Qr[i](A,a,mr[r+112>>2]),n=mr[4+a>>2];break A;}if(!(k=s(c,i,f,1))){if(!y(c,1585))break A;if(!y(c,1507))break A;if(!(k=s(c,i,f,0)))break A;}mr[4+a>>2]=k,e&&(i=mr[r+12>>2])&&Qr[i](A,a,mr[r+112>>2]),n=k;}return Mr=16+a|0,n;}function w(A){var r;A:{for(;;){var i,f=r=mr[2767],e=c=mr[2766];(A=8<A>>>0?A+3&-4:8)>>>0<=127?i=(A>>>3|0)-1|0:(i=110+((A>>>29-(b=rA(A))^4)-(b<<2)|0)|0,A>>>0<=4095||(i=(b=71+((A>>>30-b^2)-(b<<1)|0)|0)>>>0<63?b:63));var a=31&(b=i);if(a=32<=(63&b)>>>0?r>>>a|(b=0):(b=r>>>a|0,((1<<a)-1&r)<<32-a|e>>>a),(r=b)|a){for(;;){if(a=31&(b=c=(b=f=a)|(a=r)?(e=a+-1|0,(c=b+-1|0)>>>0<4294967295&&(e=e+1|0),c=rA(b^c)+32|0,b=rA(a^e),eA=0-(63<(b=32==(0|b)?c:b)>>>0)|0,63-b|0):(eA=0,64)),f=32<=(63&b)>>>0?r>>>a|(b=0):(b=r>>>a|0,((1<<a)-1&r)<<32-a|f>>>a),r=b,(0|(b=mr[10040+(c=(i=i+c|0)<<4)>>2]))!=(0|(e=c+10032|0))){if(a=B(b,A))break A;mr[(a=mr[b+4>>2])+8>>2]=mr[b+8>>2],mr[mr[b+8>>2]+4>>2]=a,mr[b+8>>2]=e,mr[b+4>>2]=mr[(a=c+10036|0)>>2],mr[a>>2]=b,mr[mr[b+4>>2]+8>>2]=b,i=i+1|0,a=(1&r)<<31|f>>>1,r=r>>>1|0;}else{var n,k,c,b=mr[2767],a=mr[2766],w=31&(e=n=63&(c=i)),w=-2&(32<=e>>>0?-1>>>w|(e=0):(e=-1>>>w|0,(1<<w)-1<<32-w|-1>>>w)),o=31&n,t=32<=n>>>0?(e=w<<o,0):(e=(1<<o)-1&w>>>32-o|e<<o,w<<o);w=e,c=31&(e=k=0-c&63),o=-2&(c=32<=e>>>0?(e=-1<<c,0):(e=(1<<c)-1&-1>>>32-c|-1<<c,-1<<c)),n=31&k,e=32<=k>>>0?e>>>n|(c=0):(c=e>>>n|0,((1<<n)-1&e)<<32-n|o>>>n),eA=c|w,mr[2766]=a&=e|t,mr[2767]=eA&b,a=1^f;}if(!(a|r))break;}c=mr[2766],f=mr[2767];}b=10032+(r=63-(32==(0|(r=rA(f)))?rA(c)+32|0:r)<<4)|0,r=mr[r+10040>>2];r:if(!(!f&c>>>0<1073741824|f>>>0<0)&&(i=99,(0|b)!=(0|r))){for(;;){if(!i)break r;if(a=B(r,A))break A;if(i=i+-1|0,(0|b)==(0|(r=mr[r+8>>2])))break;}r=b;}if(!u(A+48|0))break;}if((0|b)!=(0|r))for(;;){if(a=B(r,A))break A;if((0|b)==(0|(r=mr[r+8>>2])))break;}a=0;}return a;}function o(A,r,i){var e=1;A:{r:{i:for(;;){if(r>>>0<=e>>>0)break A;for(;;){if((0|r)==(0|e))break A;var a=A+e|0;if((0|(k=Dr[0|a]))==(0|i)|91==(0|k)|96==(0|k))break;e=e+1|0;}if(!(r>>>0<=e>>>0|60!=(0|i)|60!=(0|k))&&(k=60,33==Dr[a+-1|0]))break r;if((0|i)==(0|k))break r;if(e){if(92==Dr[a+-1|0]){e=e+1|0;continue;}}else e=0;f:{e:{if(96!=(0|k)){if(91!=(0|k))continue;for(var n=((a=e+1|0)>>>0<r>>>0?r:a)+-1|0,k=0;;){if(r>>>0<=(a=e+1|0)>>>0){e=n;break e;}var c=Dr[A+a|0];if(93==(0|c))break e;k=k||((0|i)==(0|c)?a:0),e=a;}}for(a=r>>>(k=0)<(a=r-e|0)>>>0?0:a,c=0;;){if((0|a)==(0|c))break f;if(96!=Dr[A+e|0]){for(n=0;!(r>>>0<=e>>>0|c>>>0<=n>>>0);)n=96==(0|(a=Dr[A+e|0]))?n+1|0:0,k=k||((0|i)==(0|a)?e:0),e=e+1|0;if(e>>>0<r>>>0)continue i;break f;}c=c+1|0,e=e+1|0;}}for(e=e+2|0;;){if(r>>>0<=e>>>0)break f;if(32!=(0|(a=Dr[A+e|0]))&&10!=(0|a))break;e=e+1|0;}e:{if(40!=(0|a)){if(n=93,91==(0|a))break e;if(!k)continue;break f;}n=41;}for(;;){if(r>>>0<=(a=e+1|0)>>>0)break f;if((0|(c=Dr[A+a|0]))==(0|n))break;k=k||((0|i)==(0|c)?a:0),e=a;}e=e+2|0;continue;}break;}return k;}return e;}return 0;}function t(A,r,i){if(512<=i>>>0)return iA(0|A,0|r,0|i),A;var f=A+i|0;if(3&(A^r)){if(f>>>0<4)i=A;else{var e=f-4|0;if(e>>>0<A>>>0)i=A;else for(i=A;_[0|i]=Dr[0|r],_[i+1|0]=Dr[r+1|0],_[i+2|0]=Dr[r+2|0],_[i+3|0]=Dr[r+3|0],r=r+4|0,(i=i+4|0)>>>0<=e>>>0;);}}else{A:if((0|i)<1)i=A;else if(3&A)for(i=A;;){if(_[0|i]=Dr[0|r],r=r+1|0,f>>>0<=(i=i+1|0)>>>0)break A;if(!(3&i))break;}else i=A;if(!((e=-4&f)>>>0<64)){var a=e+-64|0;if(!(a>>>0<i>>>0))for(;mr[i>>2]=mr[r>>2],mr[i+4>>2]=mr[r+4>>2],mr[i+8>>2]=mr[r+8>>2],mr[i+12>>2]=mr[r+12>>2],mr[i+16>>2]=mr[r+16>>2],mr[i+20>>2]=mr[r+20>>2],mr[i+24>>2]=mr[r+24>>2],mr[i+28>>2]=mr[r+28>>2],mr[i+32>>2]=mr[r+32>>2],mr[i+36>>2]=mr[r+36>>2],mr[i+40>>2]=mr[r+40>>2],mr[i+44>>2]=mr[r+44>>2],mr[i+48>>2]=mr[r+48>>2],mr[i+52>>2]=mr[r+52>>2],mr[i+56>>2]=mr[r+56>>2],mr[i+60>>2]=mr[r+60>>2],r=r- -64|0,(i=i- -64|0)>>>0<=a>>>0;);}if(!(e>>>0<=i>>>0))for(;mr[i>>2]=mr[r>>2],r=r+4|0,(i=i+4|0)>>>0<e>>>0;);}if(i>>>0<f>>>0)for(;_[0|i]=Dr[0|r],r=r+1|0,(0|f)!=(0|(i=i+1|0)););return A;}function J(A,r,i,f){var e,a,n=0;Mr=a=Mr-16|0;A:if(e=N(64)){O(e,i),mr[f+140>>2]=0,mr[f+144>>2]=0,mr[f+132>>2]=0,mr[f+136>>2]=0,mr[f+124>>2]=0,mr[f+128>>2]=0,mr[f+116>>2]=0,3<=i>>>(mr[f+120>>2]=0)&&(n=E(r,1857,3)?0:3);var k=f+116|0;r:for(;;){i:{if(n>>>0<i>>>0){var c,b=r,w=n,o=i,t=12+a|0,J=k,u=0,Z=0;f:if(!(o>>>0<=(G=w+3|0)>>>0)){if(32==Dr[0|(C=b+w|0)]&&32==Dr[C+(u=1)|0]&&32==Dr[C+(u=2)|0]&&(u=3,32==Dr[b+G|0]))break f;if(91==Dr[(w=w+u|0)+b|0]){for(w=c=w+1|0;;){if(o>>>0<=w>>>0)break f;e:{a:{switch((u=Dr[b+w|0])+-10|0){case 0:case 3:break f;case 1:case 2:break a;}if(93==(0|u))break e;}w=w+1|0;continue;}break;}if(!(o>>>0<=(u=w+1|0)>>>0|58!=Dr[b+u|0])){u=w+2|0;e:{for(;;){if((0|o)==(0|u)){u=o;break e;}a:{if(32!=(0|(G=Dr[b+u|0])))switch(G+-10|0){case 0:case 3:break a;default:break e;}u=u+1|0;continue;}break;}u=o>>>0<=(C=u+1|0)>>>0|13!=Dr[b+C|0]||10!=(0|G)?C:u+2|0;}for(C=o>>>0<u>>>0?u:o;;){if((0|u)==(0|C))break f;if(32!=(0|(G=Dr[b+u|0])))break;u=u+1|0;}for(var B=(60==(0|G))+u|0,C=B>>>0<o>>>0?o:B,u=B;;){e:{if((0|u)!=(0|C)){a:{switch((G=Dr[b+u|0])+-10|0){case 0:case 3:break e;case 1:case 2:break a;}if(32==(0|G))break e;}u=u+1|0;continue;}u=C;}break;}var s=62==Dr[b+(C=u+-1|0)|0]?C:u;C=o>>>0<u>>>0?u:o;e:{for(;;){a:{if((0|u)!=(0|C)){n:{switch((G=Dr[b+u|0])+-32|0){case 1:case 3:case 4:case 5:case 6:break f;case 2:case 7:case 8:break e;case 0:break n;}switch(G+-10|0){case 0:case 3:break a;default:break f;}}u=u+1|0;continue;}u=C;}break;}Z=u;}var G,v=u+1|0;if(G=10!=Dr[b+u|0]|o>>>0<=v>>>0||13!=Dr[b+v|0]?Z:v){for(Z=(C=(u=G+1|0)>>>0<o>>>0?o:u)+-1|0,u=G;;){if((0|u)==(0|Z))u=C;else if(32==Dr[(u=u+1|0)+b|0])continue;break;}v=u+1|0;}e:if(o>>>(Z=0)<=v>>>0||6<(u=Dr[b+u|0]+-34|0)>>>0|!(1<<u&97))o=v=0;else{for(var Q=o>>>0<v>>>0?v:o,C=v;;){a:if(u=C,(0|Q)==(0|u))C=o+1|0,u=o;else switch(C=u+1|0,Dr[b+u|0]+-10|0){case 0:case 3:break a;default:continue;}break;}for((13!=Dr[b+C|0]||10!=Dr[b+u|0]|o>>>0<=C>>>0)&&(C=u);;){if((u=u+-1|0)>>>0<=v>>>0){o=C;break e;}o=C;a:switch(Dr[b+u|0]+-32|0){case 0:continue;case 2:case 7:case 9:break a;default:break e;}break;}o=u,G=C;}if(!(!G|(0|B)==(0|s))){if(t&&(mr[t>>2]=G),J){if(t=J,J=b+c|0,c=w-c|0,(w=sr(1,16))?(J=X(J,c),mr[w>>2]=J,mr[w+12>>2]=mr[(t=((7&J)<<2)+t|0)>>2],mr[t>>2]=w):w=0,!w)break f;J=N(t=s-B|0),mr[w+4>>2]=J,ur(J,b+B|0,t),o>>>0<=v>>>0||(t=w,o=N(w=o-v|0),mr[t+8>>2]=o,ur(o,b+v|0,w));}Z=1;}}}}if(Z){n=mr[12+a>>2];continue;}for(b=i>>>0<n>>>0?n:i,v=n;;){if((0|v)==(0|b)){v=b;break i;}switch(Dr[r+v|0]+-10|0){case 0:case 3:break i;}v=v+1|0;}}if(O(A,(n=mr[e+4>>2])+(n>>>1|0)|0),(r=mr[f+104>>2])&&(Qr[r](A,mr[f+112>>2]),n=mr[e+4>>2]),n){f:{switch(Dr[((v=mr[e>>2])+n|0)-1|0]+-10|0){case 0:case 3:break f;}Zr(e,10),n=mr[e+4>>2],v=mr[e>>2];}$A(A,f,v,n);}for((r=mr[f+108>>2])&&Qr[r](A,mr[f+112>>2]),L(e),A=k,i=0;8!=(0|i);){for(r=mr[(i<<2)+A>>2];r;)f=mr[r+12>>2],L(mr[r+4>>2]),L(mr[r+8>>2]),ir(r),r=f;i=i+1|0;}break A;}if(n>>>0<(mr[12+a>>2]=v)>>>0){i:for(b=e,o=r+n|0,n=v-n|0,B=Z=0;;){f:{if(B>>>0<n>>>0){for(s=(n+Z|0)-B|0,v=B;;){if((0|Z)==(0|s))v=n,Z=s;else if(9!=Dr[o+v|0]){Z=Z+1|0,v=v+1|0;continue;}break;}if(B>>>0<v>>>0&&ur(b,o+B|0,v-B|0),v>>>0<n>>>0)break f;}break i;}for(;Zr(b,32),3&(Z=Z+1|0););B=v+1|0;}v=mr[12+a>>2];}for(n=v;;){if(i>>>0<=n>>>0)continue r;i:{f:switch(Dr[r+n|0]+-10|0){case 3:if(i>>>0<=(n=n+1|0)>>>0|10==Dr[r+n|0])break i;break;case 0:break f;default:continue r;}Zr(e,10),n=mr[12+a>>2]+1|0;}mr[12+a>>2]=n;}}}Mr=16+a|0;}function u(A){var r=0,i=mr[2768],f=A+3&-4,e=i+f|0;if(!(e>>>0<=i>>>0&&1<=(0|f)||(k.byteLength/65536|0)<<16>>>0<e>>>0&&!fA(0|e)||(mr[2768]=e,(0|i)<1))){mr[12+(A=(f=A+i|0)-(r=16)|0)>>2]=16,mr[A>>2]=16;A:{r:{if(!(!(e=mr[2764])|(0|i)!=mr[e+8>>2])){var a=i-((r=mr[i+-4>>2])>>31^r)|0,n=mr[a-4>>2];if(mr[e+8>>2]=f,r=-16,-1<mr[((e=a-(n>>31^n)|0)+mr[e>>2]|0)-4>>2])break r;mr[(i=mr[e+4>>2])+8>>2]=mr[e+8>>2],mr[mr[e+8>>2]+4>>2]=i,mr[e>>2]=A=A-e|0;break A;}mr[i+12>>2]=16,mr[i>>2]=16,mr[i+8>>2]=f,mr[i+4>>2]=e,mr[2764]=i;}mr[(e=i+r|0)>>2]=A=A-e|0;}mr[((-4&A)+e|0)-4>>2]=-1^A,(r=mr[(n=e)>>2]+-8|0)>>>0<=127?A=(r>>>3|0)-1|0:(A=110+((r>>>29-(f=rA(r))^4)-(f<<2)|0)|0,r>>>0<=4095||(A=(A=71+((r>>>30-f^2)-(f<<1)|0)|0)>>>0<63?A:63)),mr[n+4>>2]=10032+(i=A<<4),mr[e+8>>2]=mr[(i=i+10040|0)>>2],mr[i>>2]=e,mr[mr[e+8>>2]+4>>2]=e,i=mr[2767],e=31&A,n=32<=(63&A)>>>0?(A=1<<e,0):(A=(1<<e)-1&1>>>32-e,1<<e),mr[2766]|=n,mr[2767]=A|i,r=1;}return r;}function qA(A,r,i){var f=0;A:{var e=r,a=0;r:if(!(e>>>0<3)){var n=32==Dr[0|A]?32==Dr[A+1|0]?32==Dr[A+2|0]?3:2:1:0;if(!(e>>>0<=n+2>>>0)){var k=Dr[A+n|0];if(96==(0|k)||126==(0|k))for(b=e-n|0;;){i:{if((0|a)!=(0|b)){if(Dr[A+n|0]==(0|k))break i;b=a,e=n;}a=b>>>0<3?0:e;break r;}n=n+1|0,a=a+1|0;}}}if(e=a)for(a=(n=r>>>0<e>>>0?e:r)+A|0;;){r:{i:{f:{e:{if((0|e)!=(0|n)){if(32==(0|(b=Dr[0|(k=A+e|0)])))break r;if(123==(0|b))break e;n=e,a=k;}for(f=(e=r>>>0<n>>>0?n:r)-n|0,k=0;;){if((0|f)==(0|k))break f;if(vr(Dr[A+n|0])){e=n,f=k;break f;}n=n+1|0,k=k+1|0;}}var c=(a=e+1|0)>>>0<r>>>0?r:a,b=c+-1|0,a=e;e:{for(;;){if(r>>>0<=(n=a+1|0)>>>0)break e;var w=Dr[A+n|0];if(10==(0|w)|125==(0|w))break;f=f+1|0,a=n;}b=a,c=n;}if(((n=0)|r)==(0|c)|125!=Dr[A+c|0])break i;for(a=1+(n=(e+f|0)+A|0)|0;;){e:{a:{if(f){if(vr(Dr[0|(e=k+1|0)]))break a;n=k,a=e;}else f=0;for(;;){if(!f){f=0;break e;}if(!vr(Dr[n+f|0]))break e;f=f+-1|0;}}f=f+-1|0,k=e;continue;}break;}e=b+2|0;}for(i&&(mr[i+4>>2]=f,mr[i>>2]=a),r=r>>>0<e>>>0?e:r;;){f:{if((0|r)!=(0|e)){if(10!=(0|(i=Dr[A+e|0])))break f;}else e=r;n=e+1|0;break i;}if(!vr(i))break A;e=e+1|0;}}return n;}e=e+1|0;}}return 0;}function Z(A,r){for(var i,f,e,a,n,k,c=0,b=0;;){A:{if((0|r)!=(0|c)){if(60!=Dr[A+c|0])break A;r=c;}for(e=40,n=41;;){if(!(i=r))return 0;r:{i:if(c=Dr[(k=i+-1|0)+A|0]){if(c>>>0<=63&&(r=k,f=31&c,1&(f=32<=(63&c)>>>0?(a=1<<f,0):(a=(1<<f)-1&1>>>32-f,1<<f))|-2147463166&a))continue;f:{e:{a:{n:{if(59!=(0|c)){switch(c+-39|0){case 0:break e;case 1:break i;case 2:break f;}if((n=34)==(0|c))break a;if((n=93)==(0|c))break n;if((n=125)!=(0|c))break i;e=123;break f;}for(c=i=i+-2|0;;){if(!c){c=0;break r;}if(!((32|Dr[A+c|0])-97>>>0<26))break r;c=c+-1|0;}}e=91;break f;}e=34;break f;}e=n=39;}for(c=r=0;(0|c)!=(0|i);)r=((0|(a=Dr[A+c|0]))==(0|n)&(0|e)!=(0|a))+r|0,c=c+1|0,b=((0|e)==(0|a))+b|0;i=(0|r)==(0|b)?i:k;}return i;}r=i>>>0<=c>>>0||38!=Dr[A+c|0]?k:c;}}c=c+1|0;}}function $A(A,r,i,f){var e,a=0;A:if(!(lr[r+432>>2]<mr[r+408>>2]+mr[r+420>>2]>>>0))r:for(;;){if(f>>>0<=a>>>0)break A;var n=i+a|0,k=f-a|0;if(or(r,n,k)){i:for(var b=r,w=n,o=k,t=0,J=o>>>0<6?o:6;;){f:{if((0|t)!=(0|J)){if(35==Dr[w+t|0])break f;J=t;}var u=o>>>0<J>>>0?J:o;for(t=J;;){e:{if((0|t)!=(0|u)){if(32==Dr[w+t|0])break e;u=t;}for(var Z=o>>>0<u>>>0?u:o,t=u;;){a:{if((0|t)!=(0|Z)){if(10!=Dr[w+t|0])break a;Z=t;}for(o=Z;;){if(t=o){if(35==Dr[(o=t+-1|0)+w|0])continue;}else t=0;break;}n:{for(;;){if(!(o=t))break n;if(32!=Dr[(t=o+-1|0)+w|0])break;}o>>>0<=u>>>0||(fr(t=tr(b,1),b,w+u|0,o-u|0),(w=mr[b+16>>2])&&Qr[w](A,t,J,mr[b+112>>2]),Cr(b,1));}var B=Z;break i;}t=t+1|0;}}t=t+1|0;}}t=t+1|0;}a=B+a|0;}else{if(!(!mr[r+12>>2]|60!=Dr[0|n])&&(e=_A(A,r,n,k,1))){a=a+e|0;continue;}if(e=Jr(n,k))a=a+e|0;else if(ar(n,k)){for((e=mr[r+20>>2])&&Qr[e](A,mr[r+112>>2]),n=f>>>0<a>>>0?a:f,e=a;(0|n)!=(0|e);)if(k=i+e|0,e=a=e+1|0,10==Dr[0|k])continue r;a=n+1|0;}else{i:{if(4&(e=mr[r+428>>2])){var C,s,v=r,Q=n,m=k;Mr=C=Mr-32|0,mr[24+C>>2]=0,mr[28+C>>2]=0,mr[16+C>>2]=0;f:if(s=qA(Q,m,16+C|(mr[20+C>>2]=0)))for(var l=tr(v,0);;){e:{if(s>>>0<m>>>0){mr[8+C>>2]=0,mr[12+C>>2]=0,mr[C>>2]=0;var M=s,Y=Q+s|(mr[4+C>>2]=0),g=qA(Y,m-s|0,C);if(!g|mr[4+C>>2])break e;s=s+g|0;}!(Q=mr[l+4>>2])|10==Dr[(Q+mr[l>>2]|0)-1|0]||Zr(l,10),(Q=mr[v>>2])&&Qr[Q](A,l,mr[20+C>>2]?16+C|0:0,mr[v+112>>2]),Cr(v,0);break f;}for(;;){if((0|M)==(0|(m+-1|0)))g=m;else{var d=Q+M|0,M=g=M+1|0;if(10!=Dr[0|d])continue;}break;}g>>>0<=s>>>0||(Jr(Y,s=g-s|0)?Zr(l,10):ur(l,Y,s)),s=g;}else s=0;if(Mr=32+C|0,e=s)break i;e=mr[r+428>>2];}if(2&e){var O,W=r,H=n,y=k,I=0;Mr=O=Mr-16|0,mr[8+O>>2]=0;var E=tr(W,1),R=tr(W,0);f:{var x,F,X,V=W,j=H,P=y,T=12+O|0,p=8+O|0,z=0,U=0,L=0,K=0,S=0;e:{for(;;){if((0|P)==(0|U))break e;if(10==(0|(K=Dr[j+U|0])))break;U=U+1|0,z=(124==(0|K))+z|0;}if(z){L=U;a:{for(;;){if(!(K=L)){K=0,L=1;break a;}if(!vr(Dr[(L=K+-1|0)+j|0]))break;}L=0;}if(z=z-(124==Dr[0|j])|0,!(lr[V+436>>2]<(X=(z=L?z:z-(124==Dr[(j+K|0)-1|0])|0)+1|(L=0))>>>0))for(F=sr(mr[T>>2]=X,4),mr[p>>2]=F,(z=U+1|0)>>>0<P>>>0&&(z=124==Dr[j+z|0]?U+2|0:z),P=P>>>0<z>>>0?z:P,U=z;;){a:{if((0|P)!=(0|U)){if(10!=Dr[j+U|0])break a;P=U;}for(x=j+P|0,T=0;;){n:{if(!(P>>>0<=z>>>0|X>>>0<=T>>>0))for(;;){if((0|P)==(0|z)){U=Dr[0|x],z=P;break n;}if(32!=(0|(U=Dr[j+z|0])))break n;z=z+1|0;}if(T>>>(L=0)<X>>>0)break e;Ar(E,V,j,K,X,F,4),L=P+1|0;break e;}L=0,58==(255&U)&&(mr[(p=(T<<2)+F|0)>>2]|=L=1,z=z+1|0),p=((U=P>>>0<z>>>0?z:P)+L|0)-z|0;n:{for(;;){if((0|z)==(0|U))break n;k:{if(45!=(0|(S=Dr[j+z|0]))){if(58==(0|S))break k;U=z,p=L;break n;}L=L+1|0,z=z+1|0;continue;}break;}mr[(p=(T<<2)+F|0)>>2]|=2,p=L+1|0,U=z+1|0;}z=P>>>0<U>>>0?U:P;n:{k:{for(;;){if((0|z)==(0|U))break k;if(32!=(0|(S=Dr[j+U|0])))break;U=U+1|0;}if(!p|124!=((L=0)|S))break e;break n;}if(U=z,!p){var _=0;break f;}}T=T+1|0,z=U+1|0;}}U=U+1|0;}}}_=L;}if(_){for(var q=mr[8+O>>2],$=mr[12+O>>2];;){f:{var AA=0;if(!(y>>>0<=(I=_)>>>0)){for(;;){if((0|y)==(0|I))break f;var rA=Dr[H+I|0];if(10==(0|rA))break;I=I+1|0,AA=(124==(0|rA))+AA|0;}if(AA){Ar(R,W,H+_|0,I-_|0,$,q,0),_=I+1|0;continue;}}}break;}(H=mr[W+36>>2])&&Qr[H](A,E,R,mr[W+112>>2]),I=_;}else q=mr[8+O>>2];if(ir(q),Cr(W,1),Cr(W,0),Mr=16+O|0,e=I){a=a+e|0;continue;}}if(cr(n,k)){var iA,fA,aA=r,nA=n,kA=k,cA=0,bA=0,wA=0,tA=tr(aA,0);f:{for(;;){var JA=fA=iA=cA;if(kA>>>0<=cA>>>0)break f;for(;;){if((0|iA)==(0|(kA+-1|0)))cA=kA;else if(JA=nA+iA|0,iA=cA=iA+1|0,10!=Dr[0|JA])continue;break;}e:{var uA=cr(iA=nA+fA|0,JA=cA-fA|0);if(uA)fA=fA+uA|0;else if(Jr(iA,JA)){if(kA>>>0<=cA>>>0)break e;if(!cr(iA=nA+cA|0,JA=kA-cA|0)&&!Jr(iA,JA))break e;}if(cA>>>0<=fA>>>0)continue;iA=nA+fA|0,bA?(0|(JA=bA+wA|0))!=(0|iA)&&rr(JA,iA,cA-fA|0):bA=iA,wA=(cA+wA|0)-fA|0;continue;}break;}JA=cA;}fA=JA,$A(tA,aA,bA,wA),(nA=mr[aA+4>>2])&&Qr[nA](A,tA,mr[aA+112>>2]),Cr(aA,0),a=fA+a|0;continue;}if(kr(n,k)){var ZA,BA,sA=r,GA=n,vA=k,QA=0,mA=0,DA=0,MA=tr(sA,0);f:{for(;;){var YA=BA=ZA=QA;if(vA>>>0<=QA>>>0)break f;for(;;){if((0|ZA)==(0|(vA+-1|0)))QA=vA;else if(YA=GA+ZA|0,ZA=QA=ZA+1|0,10!=Dr[0|YA])continue;break;}e:{var gA=kr(ZA=GA+BA|0,YA=QA-BA|0);if(gA)BA=BA+gA|0;else if(Jr(ZA,YA)){if(vA>>>0<=QA>>>0)break e;if(!kr(ZA=GA+QA|0,YA=vA-QA|0)&&!Jr(ZA,YA))break e;}if(QA>>>0<=BA>>>0)continue;ZA=GA+BA|0,mA?(0|(YA=mA+DA|0))!=(0|ZA)&&rr(YA,ZA,QA-BA|0):mA=ZA,DA=(QA+DA|0)-BA|0;continue;}break;}YA=QA;}BA=YA,$A(MA,sA,mA,DA),(GA=mr[sA+8>>2])&&Qr[GA](A,MA,mr[sA+112>>2]),Cr(sA,0),a=BA+a|0;continue;}if(Br(n,k)){for(var dA=A,OA=r,hA=n,WA=k,HA=0,yA=0,EA=tr(OA,0);;){f:if(!(WA>>>0<=(xA=HA)>>>0)){for(;;){if((0|xA)==(0|(WA+-1|0)))yA=WA;else{var RA=hA+xA|0,xA=yA=xA+1|0;if(10!=Dr[0|RA])continue;}break;}var FA=Br(xA=hA+HA|0,RA=yA-HA|0);if(FA)HA=HA+FA|0;else if(!Jr(xA,RA))break f;if(xA=HA,(HA=yA)>>>0<=xA>>>0)continue;Jr(yA=hA+xA|0,xA=HA-xA|0)?Zr(EA,10):ur(EA,yA,xA);continue;}break;}for(xA=mr[EA+4>>2];xA&&10==Dr[(xA=xA+-1|0)+mr[EA>>2]|0];)mr[EA+4>>2]=xA;Zr(EA,10),(hA=mr[OA>>2])&&Qr[hA](dA,EA,0,mr[OA+112>>2]),Cr(OA,0),a=HA+a|0;continue;}if(wr(n,k)){a=br(A,r,n,k,0)+a|0;continue;}if(nr(n,k)){a=br(A,r,n,k,1)+a|0;continue;}var XA=A,NA=r,VA=n,jA=k,PA=0,TA=0,pA=0,zA=0,UA=0,LA=jA+-1|0;f:{for(;;){if(pA=PA=zA,!(jA>>>0<=PA>>>0)){for(;;){if((0|pA)==(0|LA))zA=jA;else if(TA=VA+pA|0,pA=zA=pA+1|0,10!=Dr[0|TA])continue;break;}if(!cr(TA=VA+PA|0,zA-PA|0)){var KA=jA-PA|0;if(Jr(TA,KA))break f;if(pA=er(TA,KA)){UA=pA;break f;}if(!or(NA,TA,KA)&&!ar(TA,KA)&&!cr(TA,KA)){if(!(256&(pA=mr[NA+428>>2])))continue;var SA=Dr[0|TA];if(Gr(SA))continue;if(!nr(TA,KA)&&!wr(TA,KA))e:{if(!(!mr[NA+12>>2]|60!=(0|SA))){if(_A(XA,NA,TA,KA,0))break e;pA=mr[NA+428>>2];}if(!(4&pA))continue;if(!qA(TA,KA,0))continue;}}}}break;}zA=PA;}f:{e:{a:{n:{k:{for(;;){if(!(pA=PA))break k;if(10!=Dr[(PA=pA+-1|0)+VA|0])break;}if(!UA)break a;for(jA=pA;;){if(jA=(PA=jA)+-1|0){if(10!=Dr[VA+jA|0])continue;}else jA=0,PA=1;break;}for(;;){if(!(TA=jA))break n;if(10!=Dr[(jA=TA+-1|0)+VA|0])break;}fr(jA=tr(NA,0),NA,VA,TA),(TA=mr[NA+32>>2])&&Qr[TA](XA,jA,mr[NA+112>>2]),Cr(NA,0),pA=pA-PA|0,VA=VA+PA|0;break n;}if(pA=0,!UA){fr(PA=tr(NA,0),NA,VA,0);break e;}}if(fr(PA=tr(NA,jA=1),NA,VA,pA),!(VA=mr[NA+16>>2]))break f;Qr[VA](XA,PA,UA,mr[NA+112>>2]);break f;}fr(PA=tr(NA,0),NA,VA,pA);}jA=0,(VA=mr[NA+32>>2])&&Qr[VA](XA,PA,mr[NA+112>>2]);}Cr(NA,jA),a=zA+a|0;continue;}a=a+e|0;}}}}function B(A,r){var i,f,e,a=A+11&-8,n=mr[A>>2];return a+r>>>0<=(n+A|0)-4>>>0?(mr[(i=mr[A+4>>2])+8>>2]=mr[A+8>>2],mr[mr[A+8>>2]+4>>2]=i,(0|(e=A+4|0))!=(0|a)&&(mr[(i=A-((i=mr[A+-4>>2])>>31^i)|0)>>2]=a=(e=a-e|0)+mr[i>>2]|0,mr[(i+(-4&a)|0)-4>>2]=a,mr[(A=A+e|0)>>2]=n=n-e|0),r+24>>>0<=n>>>0?(mr[(a=8+(A+r|0)|0)>>2]=i=(n=n-r|0)-8|0,mr[(a+(-4&i)|0)-4>>2]=7-n,(e=mr[(f=a)>>2]+-8|0)>>>0<=127?n=(e>>>3|0)-1|0:(n=110+((e>>>29-(i=rA(e))^4)-(i<<2)|0)|0,e>>>0<=4095||(n=(n=71+((e>>>30-i^2)-(i<<1)|0)|0)>>>0<63?n:63)),mr[f+4>>2]=10032+(i=n<<4),mr[a+8>>2]=mr[(i=i+10040|0)>>2],mr[i>>2]=a,mr[mr[a+8>>2]+4>>2]=a,i=mr[2767],a=31&n,a=32<=(63&n)>>>0?(n=1<<a,0):(n=(1<<a)-1&1>>>32-a,1<<a),mr[2766]|=a,mr[2767]=i|n,mr[A>>2]=r=r+8|0,mr[((-4&r)+A|0)-4>>2]=r):mr[(A+n|0)-4>>2]=n,A+4|0):0;}function Ar(A,r,i,f,e,a,n){var k,c,b=0,w=0;Mr=k=Mr-16|0;A:if(!(!mr[r+44>>2]|!mr[r+40>>2])){var o=tr(r,1),b=f?124==Dr[0|i]:b;r:for(;;){i:{if(!(e>>>0<=w>>>0|f>>>0<=b>>>0))for(c=tr(r,1);;){if((0|f)==(0|b)){b=f;break i;}if(!vr(Dr[i+b|0]))break i;b=b+1|0;}(i=e-w|0)&&(mr[8+k>>2]=0,mr[12+k>>2]=0,mr[k>>2]=0,mr[4+k>>2]=0,Qr[mr[r+44>>2]](o,k,mr[(w<<2)+a>>2]|n,mr[r+112>>2],i)),Qr[mr[r+40>>2]](A,o,mr[r+112>>2]),Cr(r,1);break A;}for(var t=f>>>0<b>>>0?b:f,J=b;;){i:{var u=b;if((0|J)!=(0|t)){if(124!=Dr[i+J|0])break i;t=J;}for(var Z=(b>>>0<(J=t+-1|0)>>>0?u:J)+1|0,J=t;;){if((J=(u=J)+-1|0)>>>0<=b>>>0)u=Z;else if(vr(Dr[i+J|0]))continue;break;}fr(c,r,i+b|0,u-b|0),Qr[mr[r+44>>2]](o,c,mr[(w<<2)+a>>2]|n,mr[r+112>>2],0),Cr(r,1),w=w+1|0,b=t+1|0;continue r;}J=J+1|0;}}}Mr=16+k|0;}function rr(A,r,i){A:if((0|A)!=(0|r))if((r-A|0)-i>>>0<=-(i<<1)>>>0)t(A,r,i);else{var f=3&(A^r);if(!(A>>>0<r>>>0)){if(!f){if(A+i&3)for(;;){if(!i)break A;if(_[0|(f=(i=i+-1|0)+A|0)]=Dr[r+i|0],!(3&f))break;}if(!(i>>>0<=3))for(;mr[(i=i+-4|0)+A>>2]=mr[r+i>>2],3<i>>>0;);}if(!i)break A;for(;_[(i=i+-1|0)+A|0]=Dr[r+i|0],i;);break A;}if(!f){if(3&A)for(;;){if(!i)break A;if(_[0|A]=Dr[0|r],r=r+1|0,i=i+-1|0,!(3&(A=A+1|0)))break;}if(!(i>>>0<=3))for(;mr[A>>2]=mr[r>>2],r=r+4|0,A=A+4|0,3<(i=i+-4|0)>>>0;);}if(i)for(;_[0|A]=Dr[0|r],A=A+1|0,r=r+1|0,i=i+-1|0;);}}function ir(A){var r,i,f,e,a;(A|=0)&&(f=r=mr[(i=A+-4|0)>>2],e=i,(0|(a=mr[A+-8>>2]))<=-1&&(mr[(e=mr[5+(A=i+a|0)>>2])+8>>2]=mr[A+9>>2],mr[mr[A+9>>2]+4>>2]=e,f=r+(-1^a)|0,e=A+1|0),(0|(i=mr[(A=i+r|0)>>2]))!=mr[(A+i|0)-4>>2]&&(mr[(r=mr[A+4>>2])+8>>2]=mr[A+8>>2],mr[mr[A+8>>2]+4>>2]=r,f=i+f|0),mr[e>>2]=f,mr[((-4&f)+e|0)-4>>2]=-1^f,(f=mr[(a=e)>>2]+-8|0)>>>0<=127?A=(f>>>3|0)-1|0:(A=110+((f>>>29-(r=rA(f))^4)-(r<<2)|0)|0,f>>>0<=4095||(A=(A=71+((f>>>30-r^2)-(r<<1)|0)|0)>>>0<63?A:63)),mr[a+4>>2]=10032+(i=A<<4),mr[e+8>>2]=mr[(i=i+10040|0)>>2],mr[i>>2]=e,mr[mr[e+8>>2]+4>>2]=e,i=mr[2767],e=31&A,e=32<=(63&A)>>>0?(A=1<<e,0):(A=(1<<e)-1&1>>>32-e,1<<e),mr[2766]|=e,mr[2767]=A|i);}function d(A){var r,i=r=mr[A+116>>2];A:{var f=mr[A+112>>2];if(!(r|f&&((0|i)<(0|(r=mr[A+124>>2]))||(0|i)<=(0|r)&&!(lr[A+120>>2]<f>>>0)))){Mr=i=Mr-16|0;var e=-1,a=Dr[(r=A)+74|0];if(_[r+74|0]=a+-1|a,lr[r+28>>2]<lr[r+20>>2]&&Qr[mr[r+36>>2]](r,0,0),mr[r+28>>2]=0,mr[r+16>>2]=0,mr[r+20>>2]=0,(a=4&(a=mr[r>>2])?(mr[r>>2]=32|a,-1):(mr[r+8>>2]=f=mr[r+44>>2]+mr[r+48>>2]|0,mr[r+4>>2]=f,a<<27>>31))||1==(0|Qr[mr[r+32>>2]](r,i+15|0,1))&&(e=Dr[i+15|0]),Mr=i+16|0,-1<(0|(f=e)))break A;}return mr[A+104>>2]=0,-1;}r=mr[A+8>>2];A:{if((i=mr[A+116>>2])|(a=mr[A+112>>2])){i=(-1^mr[A+124>>2])+i|0,(a=(e=-1^mr[A+120>>2])+a|0)>>>0<e>>>0&&(i=i+1|0),e=a;var n=r-(a=mr[A+4>>2])|0,k=e>>>0<n>>>0?0:1;if(!((0|(n>>=31))<(0|i)||(0|n)<=(0|i)&&k)){mr[A+104>>2]=e+a;break A;}}mr[A+104>>2]=r;}return r?(a=mr[A+124>>2],e=mr[(i=A)+120>>2],n=r=1+(r-(A=mr[A+4>>2])|0)|0,e=e+r|0,r=(r>>31)+a|0,mr[i+120>>2]=e,mr[i+124>>2]=e>>>0<n>>>0?r+1|0:r):A=mr[A+4>>2],Dr[0|(A=A+-1|0)]!=(0|f)&&(_[0|A]=f),f;}function e(A,r){if(r){var i=A+r|0;if(_[i+-1|0]=0,!(r>>>(_[0|A]=0)<3||(_[i+-2|0]=0,_[A+1|0]=0,_[i+-3|0]=0,r>>>(_[A+2|0]=0)<7||(_[i+-4|0]=0,r>>>(_[A+3|0]=0)<9||(mr[(A=(i=0-A&3)+A|0)>>2]=0,(i=r-i&-4)>>>(mr[(r=i+A|0)-4>>2]=0)<9||(mr[A+8>>2]=0,mr[A+4>>2]=0,mr[r+-8>>2]=0,i>>>(mr[r+-12>>2]=0)<25||(mr[A+24>>2]=0,mr[A+20>>2]=0,mr[A+16>>2]=0,mr[A+12>>2]=0,mr[r+-16>>2]=0,mr[r+-20>>2]=0,mr[r+-24>>2]=0,mr[r+-28>>2]=0,(r=(r=i)-(i=4&A|24)|0)>>>0<32)))))))for(A=A+i|0;mr[A+24>>2]=0,mr[A+28>>2]=0,mr[A+16>>2]=0,mr[A+20>>2]=0,mr[A+8>>2]=0,mr[A+12>>2]=0,mr[A>>2]=0,A=A+32|(mr[A+4>>2]=0),31<(r=r+-32|0)>>>0;);}}function fr(A,r,i,f){var e,a,n=0,k=0,c=0,b=0;Mr=a=Mr-16|0,mr[8+a>>2]=0,mr[12+a>>2]=0,mr[a>>2]=0,mr[4+a>>2]=0;A:if(!(lr[r+432>>2]<mr[r+408>>2]+mr[r+420>>2]>>>0))r:for(;;){if(f>>>0<=k>>>0)break A;for(e=f>>>0<n>>>0?n:f;;){i:{if((0|n)!=(0|e)){if(!(c=Dr[148+(Dr[i+n|0]+r|0)|0]))break i;e=n;}var w=i+k|0;if((n=mr[r+100>>2])?(mr[a>>2]=w,mr[4+a>>2]=e-k,Qr[n](A,a,mr[r+112>>2])):ur(A,w,e-k|0),f>>>0<=e>>>0)break A;k=(n=0|Qr[mr[1872+(c<<2)>>2]](A,r,i+e|0,e-b|0,e,f-e|0))+e|0,b=n?k:b,n=n?k:e+1|0;continue r;}n=n+1|0,c=0;}}Mr=16+a|0;}function er(A,r){var i=0;A:{if(61!=(0|(e=Dr[0|A]))){if(45!=(0|e))break A;for(var f=1<r>>>0?r:1,e=1;;){r:{if((0|e)!=(0|f)){if(45==Dr[A+e|0])break r;f=e;}for(e=r>>>0<f>>>0?f:r;;){if((0|e)==(0|f))return 2;if(r=A+f|0,f=f+1|0,32!=(0|(r=Dr[0|r])))break;}i=(10==(0|r))<<1;break A;}e=e+1|0;}}for(f=1<r>>>0?r:1,e=1;;){r:{if((0|e)!=(0|f)){if(61==Dr[A+e|0])break r;f=e;}for(e=r>>>0<f>>>0?f:r,i=1;;){if((0|e)==(0|f))break A;if(r=A+f|0,f=f+1|0,32!=(0|(r=Dr[0|r])))break;}return 10==(0|r);}e=e+1|0;}}return i;}function c(A,r,i){var f,e=0;for(Mr=f=Mr-16|0,O(A,(AA(i,12)>>>0)/10|0),_[13+f|0]=37;;){A:{var a=e;if(!(i>>>0<=a>>>0)){for(;;){if((0|i)==(0|a))a=i;else if(1==Dr[Dr[r+a|0]+1968|0]){a=a+1|0;continue;}break;}if(e>>>0<a>>>0&&ur(A,r+e|0,a-e|0),!(i>>>0<=a>>>0)){if(2==Dr[(e=Dr[r+a|0])+1968|0])break A;switch(e+-38|0){case 0:ur(A,6657,5);break A;case 1:ur(A,2224,6);break A;}_[15+f|0]=Dr[2240+(15&e)|0],_[14+f|0]=Dr[2240+(e>>>4|0)|0],ur(A,13+f|0,3);break A;}}Mr=16+f|0;break;}e=a+1|0;}}function b(A,r,i,f,e){if(!mr[r+64>>2])return 0;var a=Dr[0|i]==(0|e)?Dr[i+1|0]==(0|e):0;A:{for(;;){var k=0;if(f>>>0<=a>>>0)break A;var c=o(i+a|0,f-a|0,e);if(!c)break A;if(f>>>0<=(a=a+c|0)>>>0)break A;if(Dr[0|(k=i+a|0)]==(0|e)&&!vr(Dr[k+-1|0])){if(!(!(1&mr[r+428>>2])|(0|(k=a+1|0))==(0|f)|95!=(0|e))&&!vr(c=Dr[i+k|0])&&(94<=c+-33>>>0||Gr(c)))continue;break;}}fr(f=tr(r,1),r,i,a),A=0|Qr[mr[r+64>>2]](A,f,mr[r+112>>2]),Cr(r,1),k=A?k:0;}return k;}function ar(A,r){var i=0;A:if(!(r>>>0<3)){var f=32==Dr[0|A]?32==Dr[A+1|0]?32==Dr[A+2|0]?3:2:1:0;if(!(r>>>0<=f+2>>>0)){r:{var e=Dr[A+f|0];switch(e+-42|0){case 1:case 2:break A;case 0:case 3:break r;}if(95!=(0|e))break A;}for(;;){r:{if((0|r)!=(0|f)){var a=Dr[A+f|0];if(10!=(0|a)){if((0|e)==(0|a)){i=i+1|0;break r;}if(32==(0|a))break r;return;}}i=2<i>>>0;break A;}f=f+1|0;}}}return i;}function C(A,r,i){var f=255&r;A:if(3&A){for(;;){if((0|f)==Dr[0|A])break A;if(i=i+-1|0,!(3&(A=A+1|0)&&i))break;}if(!i)return;}A:if(!((0|f)==Dr[0|A]|i>>>0<4))for(f=AA(f,16843009);;){var e=f^mr[A>>2];if((-1^e)&e-16843009&-2139062144)break A;if(A=A+4|0,!(3<(i=i+-4|0)>>>0))break;}if(i)for(r&=255;;){if((0|r)==Dr[0|A])return A;if(A=A+1|0,!(i=i+-1|0))break;}}function s(A,r,i,f){var e=0,a=0,n=i+-1|0,k=m(A),b=1;A:for(;;){r:if(!(i>>>0<=b>>>0))for(;;){i:{if((0|b)==(0|n))var w=n,b=i;else{var o=b+1|0;if(60!=Dr[r+b|0]|47!=(0|(w=Dr[o+r|0])))break i;w=b,b=o;}if(10!=Dr[(r+w|0)-1|0]&&!(!f|(0|e)<1))continue A;if(i>>>0<=w+(k+3|0)>>>0)break r;o=A;var t=k,J=r+w|0,u=i-w|0,Z=0,B=t+3|0;if(u>>>0<=B>>>0||l(2+J|0,o,t)|62!=Dr[2+(t+J|0)|0]||!(o=Jr(J+B|0,u-B|0))||(Z=(t=(o=o+B|0)>>>0<u>>>0?Jr(o+J|0,u-o|0):0)+o|0),!(o=Z))continue A;a=w+o|0;break r;}e=(10==(0|w))+e|0,b=o;}break;}return a;}function n(A,r){var i,f=0;for(Mr=i=Mr-16|0,q[6+i>>1]=0,q[8+i>>1]=0,q[10+i>>1]=0,mr[i>>2]=q[12+i>>1]=0,mr[4+i>>2]=0,k^=(k=r>>31)+r;;){var e=f,a=(0|k)/10|0;_[i+f|0]=48+(AA(a,-10)+k|0),f=f+1|0;var n=9<(0|k),k=a;if(!n)break;}for((0|r)<=-1&&(_[i+f|0]=45,f=e+2|0),k=0;;){if((0|(f=f+-1|0))<=(0|k)){K(A,i),Mr=16+i|0;break;}e=Dr[0|(r=i+k|0)],_[0|(a=r)]=Dr[0|(r=i+f|0)],_[0|r]=e,k=k+1|0;}}function nr(A,r){var i,f=r?32==Dr[0|A]:0;if(f>>>0<r>>>0&&(f=(32==Dr[A+f|0])+f|0),f>>>0<r>>>0&&(f=(32==Dr[A+f|0])+f|0),!(9<(Dr[A+f|0]+-48&255)>>>0|r>>>0<=f>>>0)){for(i=r>>>0<f>>>0?f:r;;){var e=f;if((0|f)==(0|i))f=i+1|0,e=i;else if(f=e+1|0,(Dr[A+e|0]+-48&255)>>>0<10)continue;break;}if(!(r>>>0<=f>>>0||46!=Dr[0|(i=A+e|0)]|32!=Dr[A+f|0]))return I(i,r-e|0)?0:e+2|0;}return 0;}function kr(A,r){var i=0,f=r?32==Dr[0|A]:0;f>>>0<r>>>0&&(f=(32==Dr[A+f|0])+f|0),f>>>0<r>>>0&&(f=(32==Dr[A+f|0])+f|0);A:{var e=f+1|0;if(!(r>>>0<=e>>>0)){var a=A+f|0;if(!(62!=Dr[0|a]|33!=Dr[A+e|0])){if((a=o(1+a|0,(-1^f)+r|0,60))&&!(r>>>0<=(a=f+a|0)>>>0)&&33==Dr[A+a|0])break A;if(!(r>>>0<=(i=f+2|0)>>>0))return 32==Dr[A+i|0]?f+3|0:i;}}}return i;}function G(A,r,i){var f=0,e=0;for(O(A,(AA(i,12)>>>0)/10|0);;){A:{var a=f;if(a>>>0<i>>>0){for(;;){if((0|i)==(0|a))a=i;else if(!(e=_[Dr[r+a|0]+2272|0])){a=a+1|0,e=0;continue;}break;}if(f>>>0<a>>>0&&ur(A,r+f|0,a-f|0),a>>>0<i>>>0)break A;}break;}47==(0|(f=Dr[r+a|0]))?Zr(A,47):7!=Dr[f+2272|0]&&K(A,mr[2528+(e<<2)>>2]),f=a+1|0;}}function v(A,r,i,f,e){var a=0,n=0,k=mr[(126==(0|e)?88:60)+r>>2];A:if(k){for(;;){if(f>>>0<=a>>>0)break A;var c=o(i+a|0,f-a|0,e);if(!c)break A;if(!(f>>>0<=(a=1+(c=c+a|0)|0)>>>0)){var b=i+c|0;if(!(!c|Dr[0|b]!=(0|e)|Dr[i+a|0]!=(0|e)||vr(Dr[b-1|0])))break;}}fr(f=tr(r,1),r,i,c),A=0|Qr[k](A,f,mr[r+112>>2]),Cr(r,1),n=A?c+2|0:0;}return n;}function Q(A,r,i,f,e,a,n){var k=mr[9548+(a<<=4)>>2],c=mr[a+9540>>2],b=mr[a+9536>>2];return mr[(a=mr[a+9544>>2])+148>>2]=f,mr[a+144>>2]=i,i=N(128),f=mr[a+128>>2],n&&(mr[k+124>>2]=e,J(i,A,r,c),mr[k+124>>2]=0,mr[a+128>>2]|=64),mr[a+124>>2]=e,J(i,A,r,b),mr[a+128>>2]=f,mr[a+124>>2]=0,A=w((r=mr[i+4>>2])+1|0),_[A+r|0]=0,(f=mr[i>>2])&&t(A,f,r),L(i),A;}function m(A){A:{r:if(3&(i=A)){if(!Dr[0|A])return 0;for(;;){if(!(3&(i=i+1|0)))break r;if(!Dr[0|i])break;}break A;}for(;;){var r=i,i=i+4|0,f=mr[r>>2];if((-1^f)&f+-16843009&-2139062144)break;}if(!(255&f))return r-A|0;for(;f=Dr[r+1|0],r=i=r+1|0,f;);}return i-A|0;}function D(A,r){for(var i,f,e=0;;){if(!((f=mr[r+4>>2])>>>0<=(i=e)>>>0)){for(;;){if((0|i)==(0|f))i=f;else if(92!=Dr[mr[r>>2]+i|0]){i=i+1|0;continue;}break;}if(e>>>0<i>>>0&&(ur(A,mr[r>>2]+e|0,i-e|0),f=mr[r+4>>2]),!(f>>>0<=(e=i+1|0)>>>0)){Zr(A,Dr[e+mr[r>>2]|0]),e=i+2|0;continue;}}break;}}function cr(A,r){var i=r?32==Dr[0|A]:0;i>>>0<r>>>0&&(i=(32==Dr[A+i|0])+i|0),i>>>0<r>>>0&&(i=(32==Dr[A+i|0])+i|0);A:{r:if(!(62!=Dr[A+i|0]|r>>>0<=i>>>0)){var f=i+1|0;if(!(r>>>0<=f>>>0)){i:switch(Dr[A+f|0]+-32|0){case 1:break r;case 0:break i;default:break A;}return i+2|0;}}f=0;}return f;}function l(A,r,i){var f,e=0;if(!i)return 0;var a=Dr[0|A];A:if(a){for(;(i=i+-1|0)&&(f=Dr[0|r])&&((0|a)==(0|f)||(0|z(a))==(0|z(f)));)if(r=r+1|0,a=Dr[A+1|0],A=A+1|0,!a)break A;e=a;}return z(255&e)-z(Dr[0|r])|0;}function br(A,r,i,f,e){var a,n;for(Mr=a=Mr-16|0,mr[12+a>>2]=e,n=tr(r,e=0);;){if(!(f>>>0<=e>>>0)){A:for(var k,c,b=n,w=r,o=i+e|0,t=f-e|0,J=12+a|0,u=0,Z=0,B=0,C=0,s=t>>>0<3?t:3;;){r:{if((0|u)!=(0|s)){if(32==Dr[o+u|0])break r;s=u;}var G=wr(o,t);if(!G&&!(G=nr(o,t))){b=0;break A;}for(var v=t>>>0<G>>>0?G:t,u=G;;){i:{if((0|u)!=(0|v)){if(10!=Dr[(o+u|0)-1|0])break i;v=u;}var Q=tr(w,1),m=tr(w,1);ur(Q,o+G|0,v-G|0);var D,l=t+-1|0;f:{e:{for(;;){u=0;a:{n:{k:{c:{for(;;){var M=u;if(t>>>0<=(u=c=v)>>>0)break c;for(;;){if((0|u)==(0|l))v=t;else if(G=o+u|0,u=v=u+1|0,10!=Dr[0|G])continue;break;}u=1;var Y=o+c|0,g=v-c|0;if(!Jr(Y,g))break;}for(k=v>>>(u=0)<g>>>0?0:g;;){b:{w:{if((G=4)!=(0|u)&&(0|(G=k))!=(0|u)){if(32==Dr[(u+c|0)+o|0])break w;G=u;}if(4&Dr[w+428|0]&&qA(G+Y|0,g-G|0,0)&&(C=!C),k=u=0,C||(u=wr(k=G+Y|0,D=g-G|0),k=nr(k,D)),D=1&M){var d=mr[J>>2],O=1&d;if(!(!k|O)||O&&u){mr[J>>2]=8|d;break c;}}o:{if(u){if(!ar(G+Y|0,g-G|0)|k)break o;break b;}if(!k)break b;}if(B=D?1:B,(0|G)==(0|s))break c;if(Z)break n;Z=mr[Q+4>>2];break n;}u=u+1|0;continue;}break;}if(1&(-1^M|0!=(0|G)))break k;mr[J>>2]|=8;}if(u=mr[J>>2],B&&(mr[J>>2]=u|=2),v=0!=(0|Z)&Z>>>0<(t=mr[Q+4>>2])>>>0,o=mr[Q>>2],!(2&u))break e;if(!v)break a;$A(m,w,o,Z),$A(m,w,mr[Q>>2]+Z|0,mr[Q+4>>2]-Z|0);break f;}D&&(Zr(Q,10),B=1);}ur(Q,G+Y|0,g-G|0);continue;}break;}$A(m,w,o,t);break f;}v?(fr(m,w,o,Z),$A(m,w,mr[Q>>2]+Z|0,mr[Q+4>>2]-Z|0)):fr(m,w,o,t);}(o=mr[w+28>>2])&&Qr[o](b,m,mr[J>>2],mr[w+112>>2]),Cr(w,1),Cr(w,1),b=c;break A;}u=u+1|0;}}u=u+1|0;}if(e=b+e|0,b&&!(8&Dr[12+a|0]))continue;}break;}return(i=mr[r+24>>2])&&Qr[i](A,n,mr[12+a>>2],mr[r+112>>2]),Cr(r,0),Mr=16+a|0,e;}function M(A,r){for(var i,f,e=0;;){A:{if(14!=(0|e)){if(!(r>>>0<=(i=m(f=mr[1136+(e<<2)>>2]))>>>0||l(A,f,i))){if(f=1,Gr(i=Dr[A+i|0]))break A;if(!(28<(i=i+-35|0)>>>0)&&1<<i&268439553)break A;}e=e+1|0;continue;}f=0;}break;}return f;}function Y(A,r,i){var f,e,a,n;A:if(!(60!=Dr[0|A]|r>>>0<3)){for(f=e=47==Dr[A+1|0]?2:1;;){if((0|r)==(0|f))break A;if(!(a=_[0|i]))break;if(Dr[A+f|0]!=(0|a))break A;i=i+1|0,f=f+1|0;}return n=U(A=Dr[A+f|0])?e:0,62==(0|A)?e:n;}return 0;}function wr(A,r){var i=r?32==Dr[0|A]:0;i>>>0<r>>>0&&(i=(32==Dr[A+i|0])+i|0),i>>>0<r>>>0&&(i=(32==Dr[A+i|0])+i|0);var f=i+1|0;if(!(r>>>0<=f>>>0)){var e=A+i|0,a=Dr[0|e]+-42|0;if(!(3<a>>>0|2==(0|a)|32!=Dr[A+f|0]))return I(e,r-i|0)?0:i+2|0;}return 0;}function or(A,r,i){var f=0;A:if(35==Dr[0|r]&&(f=1,64&Dr[A+428|0]))for(A=i>>>0<6?i:6,f=0;;){r:{if((0|A)!=(0|f)){if(35==Dr[r+f|0])break r;A=f;}if(A>>>0<i>>>0&&32!=Dr[A+r|(f=0)])break A;f=1;break A;}f=f+1|0;}return f;}function g(A,r,i,f,e){var a=0;A:if(!(!r|f>>>0<2|Dr[A+-1|0]!=(0|e))){if((a=2)<=r>>>0){if(47==(0|(A=_[A+-2|0])))break A;if(a=1,!(94<=A+-33>>>0||Gr(A)))break A;return 0!=(0|U(A));}if(!(47!=Dr[A+-2|0]|i>>>0<3)&&92==Dr[A+-3|(a=0)])break A;a=1;}return a;}function O(A,r){var i,f=-1;A:if(!(16777216<r>>>0)){var e=mr[A+8>>2];if(e>>>0<r>>>0){for(i=mr[A+12>>2];(e=e+i|0)>>>0<r>>>0;);if(!(r=a(mr[A>>2],e)))break A;mr[A+8>>2]=e,mr[A>>2]=r;}f=0;}return f;}function h(A,r){var i=0;if(!Gr(Dr[0|A]))return 0;var f=1<(r=r+-1|0)>>>0?r:1;for(r=1;;){A:{if((0|r)!=(0|f)){var e=Dr[A+r|0];if(46==(0|e)){i=i+1|0;break A;}if(Gr(e)|45==(0|e))break A;}else r=f;return i?r:0;}r=r+1|0;}}function tr(A,r){var i,f=404+(A=AA(r,12)+A|0)|0,e=mr[A+408>>2];return lr[A+412>>2]<=e>>>0||!(i=mr[mr[f>>2]+(e<<2)>>2])?(r=A=N(mr[1956+(r<<2)>>2]),0<=(0|W(f,mr[4+f>>2]<<1))&&(mr[4+f>>2]=(e=mr[4+f>>2])+1,mr[mr[f>>2]+(e<<2)>>2]=r),A):(mr[A+408>>2]=e+1,mr[i+4>>2]=0,i);}function W(A,r){if(!(r>>>0<=lr[A+8>>2])){var i=a(mr[A>>2],r<<2);if(!i)return-1;var f=mr[A+8>>2];e((f<<2)+i|0,r-f<<2),mr[A+8>>2]=r,mr[A>>2]=i,lr[A+4>>2]<=r>>>0||(mr[A+4>>2]=r);}return 0;}function H(A,r,i){var f=i>>>16|0,e=A>>>16|0,a=AA(f,e),n=65535&i,k=AA(n,A&=65535);return A=(65535&(e=(k>>>16|0)+AA(e,n)|0))+AA(A,f)|0,eA=a+AA(r,i)+(e>>>16)+(A>>>16)|0,65535&k|A<<16;}function y(A,r){var i=Dr[0|A],f=Dr[0|r];A:if(!(!i|(0|f)!=(0|i)))for(;;){if(f=Dr[r+1|0],!(i=Dr[A+1|0]))break A;if(r=r+1|0,A=A+1|0,(0|i)!=(0|f))break;}return i-f|0;}function I(A,r){for(var i,f,e=0;;){if((0|r)==(0|e))i=r+1|0;else if(f=A+e|0,e=i=e+1|0,10!=Dr[0|f])continue;break;}return i>>>0<r>>>0&&er(A+i|0,r-i|0);}function Jr(A,r){for(var i,f=0,e=0;;){A:{r:{if((0|r)==(0|f))f=r;else{if(32==(0|(i=Dr[A+f|0])))break A;if(10!=(0|i))break r;}e=f+1|0;}return e;}f=f+1|0;}}function E(A,r,i){A:{for(;;){var f=Dr[0|A],e=Dr[0|r];if((0|f)!=(0|e))break A;if(r=r+1|0,A=A+1|0,!(i=i+-1|0))break;}return;}return f-e|0;}function ur(A,r,i){A:{var f=mr[A+4>>2],e=f+i|0;if(lr[A+8>>2]<e>>>0){if((0|O(A,e))<0)break A;f=mr[A+4>>2];}t(mr[A>>2]+f|0,r,i),mr[A+4>>2]+=i;}}function Zr(A,r){A:{var i=mr[A+4>>2],f=i+1|0;if(lr[A+8>>2]<f>>>0){if((0|O(A,f))<0)break A;i=mr[A+4>>2];}_[mr[A>>2]+i|0]=r,mr[A+4>>2]+=1;}}function R(A,r,i){for(A=((7&(r=X(r,i)))<<2)+A|0;;){if(A=mr[A>>2]){if((0|r)!=mr[A>>2]){A=A+12|0;continue;}}else A=0;break;}return A;}function x(A,r,i){var f=A+112|0;return i?(mr[16+f>>2]=0,mr[20+f>>2]=0,mr[f>>2]=0,mr[4+f>>2]=0,mr[24+f>>2]=0,mr[28+f>>2]=0,mr[8+f>>2]=0,mr[12+f>>2]=0,mr[16+f>>2]=65,t(A,2572,112)):(mr[16+f>>2]=0,mr[20+f>>2]=0,mr[f>>2]=0,mr[4+f>>2]=0,mr[24+f>>2]=0,mr[28+f>>2]=0,mr[8+f>>2]=0,mr[12+f>>2]=0,mr[16+f>>2]=r,i=t(A,2936,112),4&r&&(mr[i+68>>2]=0),8&r&&(mr[i+48>>2]=0,mr[i+76>>2]=0),513&r&&(mr[i+12>>2]=0)),mr[A+136>>2]=9344,mr[A+132>>2]=9296,mr[A+140>>2]=1,(r=w(444))?(T((A=t(r,A,112))+404|0,4),T(A+416|0,8),e(A+148|0,256),(mr[A+84>>2]||mr[A+64>>2]|mr[A+60>>2])&&(_[A+243|0]=1,_[A+190|0]=1,_[A+274|0]=1,_[A+210|0]=1),mr[A+52>>2]&&(_[A+244|0]=2),mr[A+72>>2]&&(_[A+158|0]=3),(mr[A+76>>2]||mr[A+68>>2])&&(_[A+239|0]=4),_[A+240|0]=6,_[A+208|0]=5,_[A+212|0]=9,_[A+186|0]=7,_[A+267|0]=10,_[A+206|0]=8,mr[A+428>>2]=155,_[A+242|0]=12,_[A+195|0]=11,mr[A+440>>2]=0,mr[A+432>>2]=16,mr[A+436>>2]=64,mr[A+112>>2]=f,A):0;}function F(A){mr[A+112>>2]=0,mr[A+116>>2]=0;var r=mr[A+8>>2];mr[A+104>>2]=r,mr[A+120>>2]=r=r-mr[A+4>>2]|0,mr[A+124>>2]=r>>31;}function Br(A,r){return(32!=Dr[0|A]|r>>>0<4|32!=Dr[A+1|0]|32!=Dr[A+2|0]||(r=4,32!=Dr[A+3|0]))&&(r=0),r;}function X(A,r){for(var i=0,f=0;(0|r)!=(0|i);)f=z(Dr[A+i|0])+AA(f,65599)|0,i=i+1|0;return f;}function N(A){var r;return(r=w(16))&&(mr[r+8>>2]=0,mr[r>>2]=0,mr[r+4>>2]=0,mr[r+12>>2]=A),r;}function V(A,r){return K(0|A,256&mr[16+(0|r)>>2]?3094:3088),1;}function j(A){A&&(ir(mr[A>>2]),mr[A+8>>2]=0,mr[A>>2]=0,mr[A+4>>2]=0);}function P(A,r){mr[(r|=0)>>2]=0,mr[r+4>>2]=0,mr[r+8>>2]=0;}function T(A,r){mr[A+8>>2]=0,mr[A>>2]=0,mr[A+4>>2]=0,W(A,r);}function Cr(A,r){A=AA(r,12)+A|0,mr[A+408>>2]+=-1;}function sr(A,r){return(A=w(r=AA(A,r)))&&e(A,r),A;}function Gr(A){return(32|A)-97>>>0<26?1:0!=(A+-48>>>0<10|0);}function p(A,r){r>>>0<=lr[A+4>>2]&&(mr[A+4>>2]=r);}function z(A){return A+-65>>>0<26?32|A:A;}function U(A){return 32==(0|A)|A+-9>>>0<5;}function L(A){A&&(ir(mr[A>>2]),ir(A));}function vr(A){return 32==(0|A)|10==(0|A);}function K(A,r){ur(A,r,m(r));}var S=A.memory,Qr=i,_=new f.Int8Array(k),q=new f.Int16Array(k),mr=new f.Int32Array(k),Dr=new f.Uint8Array(k),$=new f.Uint16Array(k),lr=new f.Uint32Array(k);new f.Float32Array(k),new f.Float64Array(k);var AA=f.Math.imul,rA=f.Math.clz32,iA=A.i,fA=A.k,Mr=19424,eA=0;return Qr[1]=function(A,r,i){A|=0,mr[32+(i|=0)>>2]&&ur(A,1105,15),mr[i+36>>2]&&(ur(A,1121,9),K(A,mr[i+36>>2]),Zr(A,34));},Qr[2]=function(A,r,i,f,e,a){var n;A|=0,r|=0;A:{r:{i:{if(!(62!=(0|(f=Dr[0|(i|=0)]))|(a|=0)>>>0<4)){if(33!=(0|(e=Dr[i+1|0])))break i;if(vr(Dr[i+2|(e=0)]))break A;f:{f=r,i=i+2|0,a=a+-2|0,r=0;e:{a:if(n=mr[f+56>>2])for(;;){if(a>>>0<=r>>>0)break a;if(!(e=o(i+r|0,a-r|0,60)))break a;if(!(a>>>0<=(r=r+e|0)>>>0|60!=Dr[i+r|0])&&33==Dr[(e=r+-1|0)+i|0])break e;r=r+1|0;}A=0;break f;}fr(a=tr(f,1),f,i,e),A=0|Qr[n](A,a,mr[f+112>>2]),Cr(f,1),A=A?r+1|0:0;}return 0|(A?A+2|0:0);}if(a>>>0<3)break r;e=Dr[i+1|0];}if((0|(n=255&e))!=(0|f)){if(e=0,126==(64|f))break A;if(vr(n))break A;return 0|((A=b(A,r,i+1|0,a+-1|0,f))?A+1|0:0);}}if(!(Dr[i+1|(e=0)]!=(0|f)|a>>>0<4)){if((0|(n=Dr[i+2|0]))!=(0|f)){if(vr(n))break A;return 0|((A=v(A,r,i+2|0,a+-2|0,f))?A+2|0:0);}if(!(a>>>0<5||(0|(n=Dr[i+3|0]))==(0|f)|126==(64|f)||vr(n))){r:{i=i+3|0,a=a+-3|0;var k=e=0;i:{f:{for(;;){if(a>>>0<=e>>>0)break f;if(!(n=o(i+e|0,a-e|0,f)))break f;if(Dr[0|(n=(e=e+n|0)+i|0)]==(0|f)&&!vr(Dr[n+-1|0]))break;}if(!(Dr[(n=e+1|0)+i|0]!=(0|f)|a>>>0<=(k=e+2|0)>>>0|!mr[r+84>>2]|Dr[i+k|0]!=(0|f))){fr(a=tr(r,1),r,i,e),A=0|Qr[mr[r+84>>2]](A,a,mr[r+112>>2]),Cr(r,1),A=A?e+3|0:0;break r;}if(Dr[i+n|0]==(0|f)&&n>>>0<a>>>0)break i;k=(A=v(A,r,i+-1|0,a+1|0,f))?A+-1|0:0;}A=k;break r;}A=(A=b(A,r,i+-2|0,a+2|0,f))?A+-2|0:0;}e=A?A+3|0:0;}}}return 0|e;},Qr[3]=function(A,r,i,f,e,a){var n,k;for(A|=0,r|=0,i|=0,a|=0,Mr=n=Mr-16|0,f=0;;){if((0|f)==(0|a))f=a;else if(96==Dr[i+f|0]){f=f+1|0;continue;}break;}var c=f;for(e=0;!(a>>>0<=c>>>0|f>>>0<=e>>>0);)e=96==Dr[i+c|0]?e+1|0:0,c=c+1|0;A:if(!(a>>>0<=c>>>0&&e>>>(a=0)<f>>>0)){var b=c>>>0<f>>>0?f:c;for(e=f;;){r:{i:{if((0|e)!=(0|b)){if(32==Dr[i+e|0])break i;b=e;}for(k=f>>>0<(e=c-f|0)>>>0?f:e;;){if((a=e)>>>0<=f>>>0)a=k;else if(32==Dr[(e=a+-1|0)+i|0])continue;break;}if(a>>>0<=b>>>0)break r;mr[8+n>>2]=0,mr[12+n>>2]=0,mr[4+n>>2]=a-b,mr[n>>2]=i+b,a=0|Qr[mr[r+52>>2]](A,n,mr[r+112>>2])?c:0;break A;}e=e+1|0;continue;}break;}return A=0|Qr[mr[r+52>>2]](A,0,mr[r+112>>2]),Mr=16+n|0,0|(A?c:0);}return Mr=16+n|0,0|a;},Qr[4]=function(A,r,i,f,e){if(A|=0,r|=0,!(32!=Dr[(i|=0)-1|(e=0)]|(0|f)>>>0<2|32!=Dr[i+-2|0])){for(e=mr[A+4>>2];e&&32==Dr[(e=e+-1|0)+mr[A>>2]|0];)mr[A+4>>2]=e;e=0!=(0|Qr[mr[r+72>>2]](A,mr[r+112>>2]));}return 0|e;},Qr[5]=function(A,r,i,f,e,a){A|=0,r|=0,i|=0,a|=0;var n,k=0,c=0,b=0,w=0;A:{r:{i:{f:{if(0|f){var o=r+420|0,t=mr[o>>2];if(33==Dr[i+-1|0]){if(w=1,!mr[r+68>>2])break i;break f;}}else t=mr[(o=r+420|0)>>2];if(!mr[r+76>>2])break i;}for(e=1<a>>>0?a:1,n=f=1;;){if((0|f)==(0|e))break i;f:{var J=Dr[i+f|0];e:if(10==(0|J))k=1;else{var u=f+-1|0;if(92!=Dr[u+i|0]){a:switch(J+-91|0){case 0:n=n+1|0;break e;case 2:break a;default:break e;}if((0|n)<2)break f;n=n+-1|0;}}f=f+1|0;continue;}break;}e=J=f+1|0;f:{e:{a:{n:{for(;;){if(a>>>0<=e>>>0)break n;var Z=Dr[i+e|0];if(!vr(Z))break;e=e+1|0;}if(91==(0|Z))break a;if(40==(0|Z)){for(Z=(J=(J=e+1|0)>>>0<a>>>0?a:J)+-1|0;;){var B=e;if(a>>>0<=(e=e+1|0)>>>0)B=Z,e=J;else if(vr(Dr[i+e|0]))continue;break;}for(J=e;;){if(a>>>0<=J>>>0)break i;k=2;k:{if(92!=(0|(n=Dr[0|(Z=i+J|0)]))){if(41==(0|n)){Z=J;break e;}if(k=1,J&&vr(Dr[Z+-1|0])&&34==(0|n)|39==(0|n))break k;}J=J+k|0;continue;}break;}for(Z=b=J+(c=1)|0;;){if(a>>>0<=Z>>>0)break i;k=2;var C=Dr[i+Z|0];if(92!=(0|C))if(k=1,(0|n)==(0|C))c=0;else if(!(41!=(0|C)|c)){for(a=J>>>0<(a=Z+-1|0)>>>0?b:a,c=Z;;){if((c=c+-1|0)>>>0<=b>>>0)k=Dr[i+a|0],c=a;else if(vr(k=Dr[i+c|0]))continue;break;}if(34==(0|(a=255&k))|39==(0|a))break e;c=b=0,J=Z;break e;}Z=k+Z|0;}}}if(k){for(a=tr(r,1),e=1;(0|f)!=(0|e);)10==(0|(k=Dr[0|(Z=i+e|0)]))&&(k=32)==Dr[Z+-1|0]||Zr(a,k),e=e+1|0;k=mr[a>>2],e=mr[a+4>>2];}else k=i+1|0,e=u;if(!(e=R(r+116|0,k,e)))break i;C=mr[e+8>>2],n=mr[e+4>>2];break f;}for(e=Z=e+1|0;;){if(a>>>0<=e>>>0)break i;if(93==Dr[i+e|0])break;e=e+1|0;}if((0|e)==(0|Z)){if(k){for(a=tr(r,1),e=1;(0|f)!=(0|e);)10==(0|(J=Dr[0|(k=i+e|0)]))&&(J=32)==Dr[k+-1|0]||Zr(a,J),e=e+1|0;J=mr[a+4>>2],k=mr[a>>2];}else k=i+1|0,J=u;}else J=e-Z|0,k=i+Z|0,Z=e;if(!(e=R(r+116|0,k,J)))break i;J=Z+1|0,C=mr[e+8>>2],n=mr[e+4>>2];break f;}for(n=J>>>0<e>>>0?J:e;;){if((k=J)>>>0<=e>>>0)a=Dr[(J=n+-1|0)+i|0],k=n;else if(vr(a=Dr[(J=k+-1|0)+i|0]))continue;break;}n=C=0,(e=60==Dr[i+e|0]?B+2|0:e)>>>0<(a=62==(255&a)?J:k)>>>0&&ur(n=tr(r,1),i+e|0,a-e|0),b>>>0<c>>>0&&ur(C=tr(r,1),i+b|0,c-b|0),J=Z+1|0;}if(f>>>(e=0)<2||(e=tr(r,1),w?ur(e,i+1|0,u):(mr[r+440>>2]=1,fr(e,r,i+1|0,u),mr[r+440>>2]=0)),n){if(D(i=tr(r,1),n),A=w?((f=mr[A+4>>2])&&33==Dr[(f=f+-1|0)+mr[A>>2]|0]&&(mr[A+4>>2]=f),0|Qr[mr[r+68>>2]](A,i,C,e,mr[r+112>>2])):0|Qr[mr[r+76>>2]](A,i,C,e,mr[r+112>>2]),mr[o>>2]=t,A)break A;break r;}}mr[o>>2]=t;}J=0;}return 0|J;},Qr[6]=function(A,r,i,f,e,a){A|=0,r|=0,i|=0,Mr=f=Mr-32|0;A:{var n=28+f|(mr[28+f>>2]=0),k=0;r:{i:{f:{if(!(60!=Dr[0|(e=i)]|(a|=0)>>>0<3)){var c=47==Dr[e+1|0]?2:1;if(Gr(Dr[c+e|0])){for(mr[n>>2]=0;;){e:{if((0|a)!=(0|c)){if(!Gr(k=Dr[e+c|0])&&3<(k=k+-43|0)>>>0|1==(0|k))break e;c=c+1|0;continue;}c=a;}break;}e:{a:if(!(c>>>0<2)){var b=Dr[0|(k=e+c|0)];if(64==(0|b)){b=a-c|0;var w=0,o=0,t=0;n:{for(;;){if((0|b)==(0|w))break n;k:{var J=Dr[k+w|0];c:if(!(Gr(J)|J+-45>>>0<2)){switch(J+-62|0){default:if(95==(0|J))break c;break n;case 1:break n;case 0:break k;case 2:}o=o+1|0;}w=w+1|0;continue;}break;}t=1==(0|o)?w+1|0:0;}if(!(k=t))break a;mr[n>>2]=2,a=c+k|0;break A;}if(!(c>>>0<3)&&58==(0|b))break e;}if(c>>>0<a>>>0)break r;break i;}if(a>>>0<=(c=c+(mr[n>>2]=1)|0)>>>0)break i;for(k=c;;){if(a>>>0<=k>>>0){a=0;break A;}e:{if(92!=(0|(b=Dr[e+k|0]))){switch(b+-32|0){default:if(10==(0|b)|39==(0|b)|62==(0|b))break e;break;case 0:case 2:break e;case 1:}b=1;}else b=2;k=b+k|0;continue;}break;}if(62!=(0|b)|k>>>0<=c>>>0)break f;k=k+1|0;}}a=k;break A;}c=k;}mr[n>>2]=0;}for(k=a>>>0<c>>>0?c:a;;){r:{if((0|c)!=(0|k)){if(62!=Dr[e+c|0])break r;k=c;}a=k>>>0<a>>>0?k+1|0:0;break A;}c=c+1|0;}}mr[16+f>>2]=0,mr[20+f>>2]=0,mr[12+f>>2]=a,mr[8+f>>2]=i;A:{r:if(!(a>>>0<3)){if(mr[r+48>>2]&&(n=mr[28+f>>2]))e=tr(r,1),mr[12+f>>2]=a+-2,mr[8+f>>2]=i+1,D(e,8+f|0),i=0|Qr[mr[r+48>>2]](A,e,n,mr[r+112>>2]),Cr(r,1);else{if(!(i=mr[r+80>>2]))break r;i=0|Qr[i](A,8+f|0,mr[r+112>>2]);}if(i)break A;}a=0;}return Mr=32+f|0,0|a;},Qr[7]=function(A,r,i,f,e,a){var n;return A|=0,r|=0,i|=0,a|=0,Mr=f=Mr-16|0,mr[8+f>>2]=0,mr[12+f>>2]=0,mr[f>>2]=0,(e=2)<=a>>>(mr[4+f>>2]=0)?C(1932,a=Dr[i+1|0],24)?(n=mr[r+100>>2])?(mr[4+f>>2]=1,mr[f>>2]=i+1,Qr[n](A,f,mr[r+112>>2])):Zr(A,a):e=0:1==(0|a)&&Zr(A,Dr[0|i]),Mr=16+f|0,0|e;},Qr[8]=function(A,r,i,f,e,a){A|=0,r|=0,i|=0,a|=0;var n,k=0,c=0;Mr=n=Mr-16|0,mr[8+n>>2]=0,mr[12+n>>2]=0,mr[n>>2]=0,a>>>(mr[4+n>>2]=0)<2?e=1:35!=(0|(f=Dr[i+1|0]))|a>>>0<=(e=(k=35==(0|f))?2:1)>>>0||(e=(c=120==(0|z(Dr[i+e|0])))+e|0,k=1);var b=a>>>0<e>>>0?e:a,w=e;A:{for(;;){if(((f=0)|w)==(0|b))break A;var o=_[i+w|0];r:{i:if(c){if(!(0!=(o+-48>>>0<10|0)|(32|o)-97>>>0<6))break r;}else{if(k){if(o+-48>>>0<10)break i;break r;}if(!Gr(o))break r;}w=w+1|0;continue;}break;}if(!(w>>>0<=e>>>0|a>>>0<=w>>>0|59!=(0|o))){a=w+1|0;r:{if(k){if(7<w-e>>>0)break A;b=c?16:10,Mr=w=Mr-144|0,mr[w+44>>2]=o=i+e|0,mr[w+4>>2]=o,mr[w>>2]=0,mr[w+76>>2]=-1,mr[w+8>>2]=(0|o)<0?-1:o+2147483647|0,F(w),o=w;var t,J=0,u=0,Z=0,B=0,C=0,s=0;for(Mr=t=Mr-16|0;;){var G=mr[o+4>>2];if(!U(G=G>>>0<lr[o+104>>2]?(mr[o+4>>2]=G+1,Dr[0|G]):d(o)))break;}i:{f:switch(G+-43|0){case 0:case 2:break f;default:break i;}s=45==(0|G)?-1:0,G=(G=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=G+1,Dr[0|G]):d(o);}i:{f:{e:{a:{n:{k:{if(!(-17&b|48!=(0|G))){if(88!=(-33&(G=(G=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=G+1,Dr[0|G]):d(o))))break k;if(G=(b=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=b+1,Dr[0|b]):d(o),Dr[G+9025|0]<(b=16))break n;if(!mr[o+104>>2])break i;mr[o+4>>2]+=-2;break i;}if(!(Dr[G+9025|0]<b>>>0)){mr[o+104>>2]&&(mr[o+4>>2]+=-1),F(o);break i;}}if(10==(0|b)){var v=G+-48|0;if(v>>>0<=9){for(b=0;J=AA(b,10),G=(b=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=b+1,Dr[0|b]):d(o),b=J+v|0,v=G+-48|0,b>>>0<429496729&&v>>>0<=9;);u=b,J=0;}if(9<v>>>0)break a;for(B=H(u,0,10),Z=eA,b=v;;){if(J=Z,(u=b+B|0)>>>0<b>>>0&&(J=J+1|0),429496729==(0|J)&2576980378<=u>>>0|429496729<J>>>0|(C=9<(v=(G=(G=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=G+1,Dr[0|G]):d(o))+-48|0)>>>0))break a;if(B=H(u,J,10),!(-1==(0|(C=Z=eA))&B>>>0<=(-1^(b=v))>>>0|C>>>0<4294967295))break;}b=10;break e;}}if(b+-1&b){if((v=Dr[G+9025|0])>>>0<b>>>0){for(;Z=(C=AA(b,C)+v|0)>>>0<=119304646,u=b,G=(G=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=G+1,Dr[0|G]):d(o),(v=Dr[G+9025|0])>>>0<u>>>0&&Z;);u=C;}if(b>>>0<=v>>>0)break e;for(C=b;;){if(B=H(u,J,C),-1==(0|(Z=eA))&(-1^(v&=255))>>>0<B>>>0|4294967295<Z>>>0)break e;if(J=Z,(G=v+B|0)>>>0<v>>>0&&(J=J+1|0),u=G,Z=b,G=(G=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=G+1,Dr[0|G]):d(o),Z>>>0<=(v=Dr[G+9025|0])>>>0)break e;var Q=t,m=C,D=u,l=H(g=J,0,0),B=eA,Z=H(D,0,m),D=(M=eA)+(Y=H(D,0,0))|0,M=eA,Y=(M=D>>>0<Y>>>0?M+1|0:M)+l|0,m=H(m,0,g)+D|0,g=eA;if(mr[8+Q>>2]=g=(D=m>>>0<D>>>0?g+1|0:g)+Y|0,l=l>>>0<0?B+1|0:B,l=Y>>>0<M>>>0?l+1|0:l,mr[12+Q>>2]=g>>>0<D>>>0?l+1|0:l,mr[Q>>2]=Z,mr[4+Q>>2]=m,mr[8+t>>2]|mr[12+t>>2])break;}break e;}if(Z=_[9281+(AA(b,23)>>>5&7)|0],(v=Dr[G+9025|0])>>>0<b>>>0){for(;B=(C=C<<Z|v)>>>0<=134217727,u=b,G=(G=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=G+1,Dr[0|G]):d(o),(v=Dr[G+9025|0])>>>0<u>>>0&&B;);u=C;}if(B=31&(C=Z),B=32<=(63&Z)>>>0?-1>>>B|(Z=0):(Z=-1>>>B|0,(1<<B)-1<<32-B|-1>>>B),!Z&B>>>0<u>>>0|Z>>>0<0|b>>>0<=v>>>0)break e;for(;;){if(Y=255&v,v=u,u=31&(G=C),u=Y|(G=32<=(63&G)>>>0?(J=v<<u,0):(J=(1<<u)-1&v>>>32-u|J<<u,v<<u)),G=(G=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=G+1,Dr[0|G]):d(o),(0|J)==(0|Z)&B>>>0<u>>>0|Z>>>0<J>>>0)break e;if(!((v=Dr[G+9025|0])>>>0<b>>>0))break;}break e;}if(b=10,9<v>>>0)break f;}if(!(b>>>0<=Dr[G+9025|0])){for(;G=b,C=(J=mr[o+4>>2])>>>0<lr[o+104>>2]?(mr[o+4>>2]=J+1,Dr[0|J]):d(o),Dr[C+9025|0]<G>>>0;);u=-2147483648,J=0;}}if(mr[o+104>>2]&&(mr[o+4>>2]+=-1),!J&2147483648<=u>>>0|0<J>>>0){if(!s){B=2147483647,Z=0;break i;}if(B=-2147483648,!J&2147483648<u>>>(Z=0)|0<J>>>0)break i;}B=(b=(o=s)^u)-o|0,Z=((G=o>>31)^J)-(G+(b>>>0<o>>>0)|0)|0;}if(Mr=16+t|0,eA=Z,Mr=w+144|0,!((w=B)+-14>>>0<18|w>>>0<9|65534==(-2&w)|w+-11>>>0<2|55296==(-2048&w))&&w>>>0<1114112)break r;break A;}b=i;i:if(!(6<(w=a)+-4>>>(o=0))){switch(v=3,J=5,u=6,w+-(G=2)|0){default:u=$[8496+(Dr[b+6|0]<<1)>>1]+w|0;case o=4:J=$[8496+(Dr[b+5|0]<<1)>>1]+u|0;case 3:o=$[8496+(Dr[b+4|0]<<1)>>1]+J|0;case 2:v=$[8496+(Dr[b+3|0]<<1)>>1]+o|0;case 1:G=$[8498+(Dr[b+2|0]<<1)>>1]+v|0;case 0:}if(!(770<(o=$[8496+(Dr[b+1|0]<<1)>>1]+G|0)>>>0)){if(G=Dr[0|b]==Dr[0|(o=mr[3472+(o<<2)>>2])]){if(b=b+1|0,G=o+1|0,v=w+-1|(C=0)){f:if(J=Dr[0|b]){for(;!((0|(u=Dr[0|G]))!=(0|J)||!(v=v+-1|0)|!u);)if(G=G+1|0,J=Dr[b+1|0],b=b+1|0,!J)break f;C=J;}b=(255&C)-Dr[0|G]|0;}else b=0;G=!b&&!Dr[w+o|0];}if(G)break i;}o=0;}if(!o)break A;}(f=mr[r+96>>2])?(mr[4+n>>2]=a,mr[n>>2]=i,Qr[f](A,n,mr[r+112>>2])):(Zr(A,38),k&&Zr(A,35),c&&Zr(A,120),ur(A,i+e|0,a-e|0)),f=a;}}return Mr=16+n|0,0|f;},Qr[9]=function(A,r,i,f,e,a){A|=0,i|=0,f|=0,a|=0;var n=0;if(Mr=e=Mr-16|0,!(mr[440+(r|=0)>>2]|!mr[r+48>>2])){var k,c=tr(r,1),n=12+e|0,b=0,w=0;A:if(!(47!=Dr[i+1|0]|a>>>0<4|47!=Dr[i+2|0]))for(;;){r:{if((0|f)!=(0|b)){if((32|Dr[(-1^b)+i|0])-97>>>0<26)break r;f=b;}var o=i-f|0;if(!M(o,f+a|0))break A;if(!(b=h(i+3|0,a+-3|0)))break A;for(k=(b=b+3|0)>>>0<a>>>0?a:b;;){var t=i;i:{if(b>>>0<a>>>0){if(!U(Dr[i+b|0]))break i;}else b=k;if(!(i=Z(t,b)))break A;ur(c,o,i+f|0),mr[n>>2]=f,w=i;break A;}b=b+1|0;}}b=b+1|0;}(n=w)&&(p(A,mr[A+4>>2]-mr[12+e>>2]|0),Qr[mr[r+48>>2]](A,c,1,mr[r+112>>2])),Cr(r,1);}return Mr=16+e|0,0|n;},Qr[10]=function(A,r,i,f,e,a){A|=0,i|=0,f|=0,a|=0;var n=0;if(Mr=e=Mr-16|0,!(mr[440+(r|=0)>>2]|!mr[r+48>>2])){var k,c=tr(r,1),n=12+e|0,b=0,w=0;A:{for(;;){if((0|f)==(0|b))break A;if(!(k=Dr[(-1^b)+i|0])||!Gr(k)&&!C(1296,k,5))break;b=b+1|0;}f=b;}if(f){var o=a+-1|0,b=k=0;A:{for(;;){if((0|a)==(0|b))break A;r:{var t=Dr[i+b|0];i:if(!Gr(t)){f:switch(t+-45|0){default:if(95==(0|t))break i;if(64!=(0|t))break r;k=k+1|0;break i;case 1:break f;case 0:break i;}if(o>>>0<=b>>>0)break r;w=w+1|0;}b=b+1|0;continue;}break;}a=b;}!w|1!=((b=0)|k)|a>>>0<2||!(a=Z(i,a))||(ur(c,i-f|0,f+a|0),mr[n>>2]=f,b=a),n=b;}else n=0;n&&(p(A,mr[A+4>>2]-mr[12+e>>2]|0),Qr[mr[r+48>>2]](A,c,2,mr[r+112>>2])),Cr(r,1);}return Mr=16+e|0,0|n;},Qr[11]=function(A,r,i,f,e,a){A|=0,i|=0,f|=0,a|=0;var n,k=0;if(Mr=n=Mr-16|0,!(mr[440+(r|=0)>>2]|!mr[r+76>>2])){k=12+n|0;var c,b=e=tr(r,1),w=0;A:{r:{if(f&&(94<=(f=Dr[i+-1|0])+-33>>>0||Gr(f))){if(f=U(f),a>>>0<4)break A;if(f)break r;break A;}if(a>>>0<4)break A;}if(!E(i,1291,4)&&(f=h(i,a)))for(c=a>>>0<f>>>0?f:a;;){a=i;r:{if((0|f)!=(0|c)){if(!U(Dr[i+f|0]))break r;}else f=c;if(!(f=Z(a,f)))break A;ur(b,i,f),mr[k>>2]=0,w=f;break A;}f=f+1|0;}}(k=w)&&(ur(i=tr(r,1),1924,7),ur(i,mr[e>>2],mr[e+4>>2]),p(A,mr[A+4>>2]-mr[12+n>>2]|0),mr[r+100>>2]?(f=tr(r,1),Qr[mr[r+100>>2]](f,e,mr[r+112>>2]),Qr[mr[r+76>>2]](A,i,0,f,mr[r+112>>2]),Cr(r,1)):Qr[mr[r+76>>2]](A,i,0,e,mr[r+112>>2]),Cr(r,1)),Cr(r,1);}return Mr=16+n|0,0|k;},Qr[12]=function(A,r,i,f,e,a){A|=0,i|=0,f|=0,e|=0,a|=0;var n,k=0;if(Mr=n=Mr-16|0,!(mr[440+(r|=0)>>2]|!mr[r+48>>2])){A:{var c=tr(r,1);r:{k=12+n|0;var b,w=i,o=a,t=8+n|0,J=0;i:if(b=g(w,f,e,o,114)){5<=o>>>0&&(J=!l(w+1|0,1301,4));var u=1;f:{e:{a:for(;;){var Z=u+10|0;n:{if(Z>>>0<=o>>>0){var B=10;if(!l(w+u|0,1306,10))break n;}var C=(Z=u)+2|0;if(C>>>0<o>>>0&&(Z=l(w+u|0,1317,2)?u:C),!Gr(Dr[w+Z|0]))break i;Z=Z+1|0,B=24;}for(C=o>>>0<Z>>>0?Z:o;;){n:{k:{if((0|Z)!=(0|C)){var s=Dr[w+Z|0];if(Gr(s)|95==(0|s))break k;C=Z;}if((u=C-u|(Z=0))>>>0<2|B>>>0<u>>>0)break f;if(o>>>0<=C>>>0)break n;if(!(45==(0|(Z=Dr[w+C|0]))&J)&&43!=(0|Z))break n;if(u=C+(Z=1)|0,C)continue a;break e;}Z=Z+1|0;continue;}break;}break;}Z=C;}e:if(!(47!=Dr[w+Z|0]|o>>>0<=Z>>>0))for(C=o>>>0<Z>>>0?Z:o;;){if((0|Z)==(0|C)){Z=C;break e;}a:if(!Gr(o=Dr[w+Z|0])){switch(o+-45|0){case 1:break e;case 0:case 2:break a;}if(95!=(0|o))break e;}Z=Z+1|0;}ur(c,w-b|0,Z+b|0),mr[t>>2]=1==(0|b),mr[k>>2]=b;}k=Z;break r;}k=0;}if(!k){if(k=12+n|0,w=8+n|0,!(a>>>(t=o=C=Z=0)<3||!(f=g(i,f,e,a,117))||(C=!(Gr(e=Dr[i+1|0])|95==(0|e)),(t=45!=((o=0)|e))?C:o))){for(Z=2;;){r:{if((0|a)!=(0|Z)){i:if(!Gr(e=Dr[i+Z|0])){switch(e+-45|0){case 1:break r;case 0:case 2:break i;}if(95!=(0|e))break r;}Z=Z+1|0;continue;}Z=a;}break;}ur(c,i-f|0,f+Z|0),mr[w>>2]=1==(0|f),mr[k>>2]=f;}if(!(k=Z)){k=0;break A;}}i=tr(r,1),mr[8+n>>2]&&Zr(i,47),ur(i,mr[c>>2],mr[c+4>>2]),p(A,mr[A+4>>2]-mr[12+n>>2]|0),mr[r+100>>2]?(f=tr(r,1),Qr[mr[r+100>>2]](f,c,mr[r+112>>2]),Qr[mr[r+76>>2]](A,i,0,f,mr[r+112>>2]),Cr(r,1)):Qr[mr[r+76>>2]](A,i,0,c,mr[r+112>>2]),Cr(r,1);}Cr(r,1);}return Mr=16+n|0,0|k;},Qr[13]=function(A,r,i,f,e,a){A|=0,i|=0;var n=0;A:if(!(!mr[92+(r|=0)>>2]|(a|=0)>>>0<2)){r:{i:{if(40==Dr[i+1|0])for(f=2;;){if((0|f)==(0|a))break A;var k=2;e=3;var c=i+f|0;if(41==Dr[0|c]|92==Dr[c-(n=1)|0])break i;f=f+1|0;}for(k=f=1;;){if((0|f)==(0|a)){e=0;break r;}if(vr(Dr[i+f|0])){e=0,a=f;break r;}f=f+1|0;}}a=f;}return(f=a-k|0)&&(fr(e=tr(r,1),r,i+k|0,f),Qr[mr[r+92>>2]](A,e,mr[r+112>>2]),Cr(r,1),e=a+n|0),0|e;}return 0;},Qr[14]=function(A,r,i,f){A|=0,r|=0,i|=0;var e,a=mr[4+(f|=0)>>2];a?e=mr[f+8>>2]:(ur(A,2843,18),mr[f+8>>2]=e=i+-1|0,a=mr[f+4>>2]);A:{if((0|a)<(0|(i=i-e|0)))for(;;){if((0|i)<=(0|a))break A;ur(A,2862,10),mr[f+4>>2]=a=mr[f+4>>2]+1|0;}if((0|i)<(0|a)){for(ur(A,2873,6),a=mr[f+4>>2];(0|i)<(0|a);)ur(A,2880,12),mr[f+4>>2]=a=mr[f+4>>2]+-1|0;ur(A,2893,5);}else ur(A,2899,11);}ur(A,2911,10),(i=mr[f+12>>2])&&K(A,i),ur(A,2922,4),mr[f>>2]=(i=mr[f>>2])+1,n(A,i),ur(A,2927,2),r&&G(A,mr[r>>2],mr[r+4>>2]),ur(A,2930,5);},Qr[15]=function(A,r){return r|=0,ur(A|=0,2828,6),r&&G(A,mr[r>>2],mr[r+4>>2]),ur(A,2835,7),1;},Qr[16]=function(A,r,i){return A|=0,!(r|=i=0)|!mr[r+4>>2]||(ur(A,2789,30),ur(A,mr[r>>2],mr[r+4>>2]),ur(A,2820,7),i=1),0|i;},Qr[17]=function(A,r,i){return A|=0,!(r|=i=0)|!mr[r+4>>2]||(ur(A,2770,8),ur(A,mr[r>>2],mr[r+4>>2]),ur(A,2779,9),i=1),0|i;},Qr[18]=function(A,r,i){return A|=0,!(r|=i=0)|!mr[r+4>>2]||(ur(A,2759,4),ur(A,mr[r>>2],mr[r+4>>2]),ur(A,2764,5),i=1),0|i;},Qr[19]=function(A,r,i,f){return(f|=0)&&(r=mr[f+4>>2])&&ur(0|A,mr[f>>2],r),1;},Qr[20]=function(A,r,i){return A|=0,!(r|=i=0)|!mr[r+4>>2]||(ur(A,2731,12),ur(A,mr[r>>2],mr[r+4>>2]),ur(A,2744,14),i=1),0|i;},Qr[21]=function(A,r,i){return A|=0,!(r|=i=0)|!mr[r+4>>2]||(ur(A,2718,5),ur(A,mr[r>>2],mr[r+4>>2]),ur(A,2724,6),i=1),0|i;},Qr[22]=function(A,r,i){return A|=0,!(r|=i=0)|!mr[r+4>>2]||(ur(A,2705,5),ur(A,mr[r>>2],mr[r+4>>2]),ur(A,2711,6),i=1),0|i;},Qr[23]=function(A,r){A|=0;for(var i=0,f=mr[4+(r|=0)>>2];1<=(0|f);)ur(A,2684,12),mr[r+4>>2]=f=mr[r+4>>2]+-1|0,i=1;i&&ur(A,2697,7),P(0,r);},Qr[24]=function(A,r,i,f){r|=0,i|=0;var e=0,a=0;mr[4+(A|=0)>>2]&&Zr(A,10);A:{if(!(!i|!mr[i+4>>2]))for(ur(A,3419,18);;){r:{var n=mr[i+4>>2];if(e>>>0<n>>>0)for(;;){if((0|e)==(0|n))break r;var k=mr[i>>2],c=Dr[k+e|0];if(U(c))e=e+1|0;else for(n=n>>>0<e>>>0?e:n,f=e;;){i:{if((0|f)!=(0|n)){if(!U(Dr[f+k|0]))break i;n=f;}f=A,a&&(Zr(A,32),k=mr[i>>2]),G(f,(f=(46==(0|c))+e|0)+k|0,n-f|0);break r;}f=f+1|0;}}ur(A,2927,2);break A;}a=a+1|0,e=n+1|0;}ur(A,3438,11);}r&&G(A,mr[r>>2],mr[r+4>>2]),ur(A,3450,14);},Qr[25]=function(A,r){r|=0,mr[4+(A|=0)>>2]&&Zr(A,10),ur(A,3405,13),r&&ur(A,mr[r>>2],mr[r+4>>2]),ur(A,3390,14);},Qr[26]=function(A,r){r|=0,mr[4+(A|=0)>>2]&&Zr(A,10),ur(A,3352,37),r&&ur(A,mr[r>>2],mr[r+4>>2]),ur(A,3390,14);},Qr[27]=function(A,r,i){A|=0;var f,e=0;A:if(r|=0){for(i=mr[r+4>>2];;){if(f=i){if(10==Dr[(i=f+-1|0)+mr[r>>2]|0])continue;}else f=0;break;}for(;;){if((0|e)==(0|f))break A;var a=mr[r>>2];if(10!=Dr[a+e|0])break;e=e+1|0;}mr[(i=A)+4>>2]&&(Zr(A,10),a=mr[r>>2]),ur(i,e+a|0,f-e|0),Zr(A,10);}},Qr[28]=function(A,r,i,f){r|=0,i|=0,f|=0,mr[4+(A|=0)>>2]&&Zr(A,10);var e=mr[f+16>>2];ur(A,3336,2),n(A,i),64&e?(ur(A,3339,5),(e=mr[f+12>>2])&&K(A,e),ur(A,2922,4),mr[(e=f)>>2]=(f=mr[f>>2])+1,n(A,f),ur(A,2927,2)):ur(A,3202,1),r&&ur(A,mr[r>>2],mr[r+4>>2]),ur(A,3345,3),n(A,i),ur(A,3349,2);},Qr[29]=function(A,r){r|=0,mr[4+(A|=0)>>2]&&Zr(A,10),K(A,256&mr[r+16>>2]?3329:3323);},Qr[30]=function(A,r,i){r|=0,i|=0,mr[4+(A|=0)>>2]&&Zr(A,10),ur(A,(i&=1)?3297:3303,5),r&&ur(A,mr[r>>2],mr[r+4>>2]),ur(A,i?3309:3316,6);},Qr[31]=function(A,r,i,f){r|=0,ur(A|=0,3292,4);A:if(r){for(f=mr[r>>2],r=mr[r+4>>2];;){if(!(i=r)){ur(A,f,0);break A;}if(10!=Dr[f+(r=i+-1|0)|0])break;}ur(A,f,i);}ur(A,2873,6);},Qr[32]=function(A,r,i){r|=0,i|=0;var f,e,a=0;mr[4+(A|=0)>>2]&&Zr(A,10);A:if(r&&(f=mr[r+4>>2])){for(e=mr[r>>2];;){if((0|f)==(0|a))break A;if(!U(Dr[a+e|0]))break;a=a+1|0;}ur(A,3282,3);r:{if(128&Dr[i+16|0])for(;;){if((e=mr[r+4>>2])>>>0<=(f=a)>>>0)break r;for(;;){if((0|f)==(0|e))f=e;else if(10!=Dr[mr[r>>2]+f|0]){f=f+1|0;continue;}break;}var n=f;if(a>>>0<f>>>0&&(ur(A,mr[r>>2]+a|0,f-a|0),e=mr[r+4>>2]),e+-1>>>0<=n>>>0)break r;V(A,i),a=f+1|0;}ur(A,mr[r>>2]+a|0,mr[r+4>>2]-a|0);}ur(A,3286,5);}},Qr[33]=function(A,r,i){r|=0,i|=0,mr[4+(A|=0)>>2]&&Zr(A,10),ur(A,3231,15),r&&ur(A,mr[r>>2],mr[r+4>>2]),ur(A,3247,16),i&&ur(A,mr[i>>2],mr[i+4>>2]),ur(A,3264,17);},Qr[34]=function(A,r){r|=0,ur(A|=0,3218,5),r&&ur(A,mr[r>>2],mr[r+4>>2]),ur(A,3224,6);},Qr[35]=function(A,r,i,f,e){r|=0,e|=0,ur(A|=0,(f=4&(i|=0))>>>2|0?3132:3136,3),2<=(0|e)&&(ur(A,3140,10),n(A,e),ur(A,3151,2));A:{switch((3&i)-1|0){case 2:ur(A,3154,16);break A;case 0:ur(A,3171,14);break A;case 1:ur(A,3186,15);break A;}ur(A,3202,1);}r&&ur(A,mr[r>>2],mr[r+4>>2]),ur(A,f?3204:3211,6);},Qr[36]=function(A,r,i,f){A|=0,i|=0,f|=0;var e,a=0;A:if((r|=0)&&(e=mr[r+4>>2])){if(32&Dr[f+16|0]&&(e=M(mr[r>>2],e),2!=(0|i)&&!e))break A;ur(A,3063,9),2==(0|i)&&ur(A,3124,7),c(A,mr[r>>2],mr[r+4>>2]),mr[f+28>>2]?(Zr(A,34),Qr[mr[f+28>>2]](A,r,f),Zr(A,62)):ur(A,2927,2),i=mr[r>>2];var n=f=0,k=mr[r+4>>2];r:{for(;;){if((0|f)==(0|k)|7==(0|f))break r;if(e=f+3124|0,a=mr[r>>2]+f|0,f=f+1|0,(0|(a=Dr[0|a]))!=(0|(e=_[0|e])))break;}n=a-e|0;}n?G(A,i,mr[r+4>>2]):G(A,i+7|0,mr[r+4>>2]+-7|0),ur(A,3083,4),a=1;}return 0|a;},Qr[37]=function(A,r,i,f,e){A|=0,i|=0,f|=0,e|=0;var a=0;return!(r|=0)|!mr[r+4>>2]||(ur(A,3101,10),c(A,mr[r>>2],mr[r+4>>2]),ur(A,3112,7),f&&(r=mr[f+4>>2])&&G(A,mr[f>>2],r),!i|!mr[i+4>>2]||(ur(A,3073,9),G(A,mr[i>>2],mr[i+4>>2])),K(A,256&mr[e+16>>2]?3120:2927),a=1),0|a;},Qr[38]=V,Qr[39]=function(A,r,i,f,e){var a;if(A|=0,i|=0,f|=0,e|=0,r|=0){if(32&Dr[e+16|0]&&!M(mr[r>>2],mr[r+4>>2]))return 0;ur(A,3063,9),(a=mr[r+4>>2])&&c(A,mr[r>>2],a);}else ur(A,3063,9);return!i|!mr[i+4>>2]||(ur(A,3073,9),G(A,mr[i>>2],mr[i+4>>2])),mr[e+28>>2]?(Zr(A,34),Qr[mr[e+28>>2]](A,r,e),Zr(A,62)):ur(A,2927,2),f&&(r=mr[f+4>>2])&&ur(A,mr[f>>2],r),ur(A,3083,4),1;},Qr[40]=function(A,r,i){A|=0,r|=0;var f,e=0;A:{r:{var a,n=mr[20+(i|=0)>>2],k=mr[i+16>>2];if(!(!n|!(1024&k))){for(;;){var c=mr[(e<<2)+n>>2];if(!c)break r;if(e=e+1|0,f=Y(mr[r>>2],mr[r+4>>2],c))break;}i=mr[i+24>>2],k=0,Zr(A,60);i:if(2==(0|f))Zr(A,47),K(A,c);else{K(A,c),c=m(c);for(var b=N(16),w=N(16);;){f=0;f:{e:{a:for(;;){for(a=1;;){if(!a)break e;if(lr[r+4>>2]<=(c=c+1|0)>>>0)break e;n=k,e=f;n:{k:{c:{var o=_[mr[r>>2]+c|(a=0)];switch(o+-61|0){case 0:break c;case 1:continue;}b:switch(o+-32|0){default:if(39!=(0|o))break k;case 2:if(!e)break f;if(k=o,a=f=1,!n)continue;if(((e=0)|k)==(0|n))break n;Zr(w,k),k=n;continue a;case 0:break b;case 1:break k;}if(!n)break f;Zr(w,32);continue a;}if(a=f=1,!e)continue;break f;}if(a=1,!n&&(k=0,f=1,e))continue;Zr(e?w:b,o),k=n,f=e;continue;}break;}break;}for(;;){if(!(n=mr[(e<<2)+i>>2]))break f;a:if(((f=0)|(k=m(n)))==mr[b+4>>2]){for(;(0|f)!=(0|k);){if((0|z(_[f+n|0]))!=(0|z(Dr[mr[b>>2]+f|0])))break a;f=f+1|0;}if(!k|!mr[w+4>>2])break f;Zr(A,32),G(A,mr[b>>2],mr[b+4>>2]),K(A,3060),G(A,mr[w>>2],mr[w+4>>2]),Zr(A,34);break f;}e=e+1|0;}}L(b),L(w);break i;}j(b),j(w),k=0;}}Zr(A,62);break A;}}512&k?G(A,mr[r>>2],mr[r+4>>2]):1&k||2&k&&Y(mr[r>>2],mr[r+4>>2],3048)||(i=mr[r+4>>2],r=mr[r>>2],8&k&&Y(r,i,3054)||4&k&&Y(r,i,3056)||ur(A,r,i));}return 1;},Qr[41]=function(A,r){(r|=0)&&G(0|A,mr[r>>2],mr[r+4>>2]);},Qr[42]=P,{o:function(){for(var A,r,i=0;mr[10036+(A=i<<4)>>2]=r=10032+A|0,mr[10040+A>>2]=r,64!=(0|(i=i+1|0)););u(48);},t:function(A){return 0|w(0|A);},J:function(A,r,i,f,e,a){var n;return A|=0,r|=0,i|=0,f|=0,e|=0,a|=0,Dr[9376]||(_[9376]=1,n=x(9380,805,0),mr[2384]=n,n=x(9568,805,1),mr[2387]=9568,mr[2386]=9380,mr[2385]=n),0|Q(A,r,i,f,e,0,a);},u:function(A,r,i,f,e,a){var n;return A|=0,r|=0,i|=0,f|=0,e|=0,a|=0,Dr[9720]||(_[9720]=1,n=x(9724,1825,0),mr[2388]=n,n=x(9876,1825,1),mr[2391]=9876,mr[2390]=9724,mr[2389]=n),0|Q(A,r,i,f,e,1,a);},Z:ir,B:function(A){var r,i=0|A;return(A=k.byteLength/65536|0)<(i=A+i|0)&&i<65536&&(i=new ArrayBuffer(AA(i,65536)),(r=new f.Int8Array(i)).set(_),_=r,_=new f.Int8Array(i),q=new f.Int16Array(i),mr=new f.Int32Array(i),Dr=new f.Uint8Array(i),$=new f.Uint16Array(i),lr=new f.Uint32Array(i),new f.Float32Array(i),new f.Float64Array(i),S.buffer=k=i),0|A;}};}({Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,NaN:NaN,Infinity:1/0,Math:Math},A,r.buffer);}(u,k,A)};},instantiate:function(r){return{then:function(A){A({C:new f.Instance(new f.Module(r))});}};},RuntimeError:Error},k=new f.Memory({A:1,G:256}),snudown_es_c=k.buffer,A=new f.Table({A:43,G:43,element:"anyfunc"});n(snudown_es_c),snudown_es_r[2768]=19424;var snudown_es_b,snudown_es_e,snudown_es_a,snudown_es_t,J,u={i:function(A,r,i){o.copyWithin(A,r,r+i);},k:function(A){var r=o.length;if(16777216<(A>>>=0))return!1;for(var i,f=1;f<=4;f*=2){var e=Math.min(16777216,(0<(i=Math.max(16777216,A,Math.min(r*(1+.2/f),A+100663296)))%65536&&(i+=65536-i%65536),i));A:{try{k.grow(e-snudown_es_c.byteLength+65535>>>16),n(k.buffer);var a=1;break A;}catch(A){}a=void 0;}if(a)return!0;}return!1;},memory:k,table:A};f.instantiate({}.v,{m:u,D:u}).then(function(A){snudown_es_b=(A=A.C.exports).t,snudown_es_e=A.J,snudown_es_a=A.u,snudown_es_t=A.Z,J=A.B,A.o();});function snudown_es_markdown(A,r){return snudown_es_i(snudown_es_e,A,r);}function markdownWiki(A,r){return snudown_es_i(snudown_es_a,A,r);}
// CONCATENATED MODULE: ./lib/modules/hosts/github.js




/* harmony default export */ var github = (new Host('github', {
  domains: ['gist.github.com'],
  logo: 'https://assets-cdn.github.com/favicon.ico',
  name: 'github gists',
  detect: ({
    pathname
  }) => /^\/(?:[\w-]+\/)?([a-z0-9]{20,}|\d+)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      files,
      description
    } = await ajax({
      url: `https://api.github.com/gists/${id}`,
      type: 'json',
      cacheFor: utils_time["a" /* DAY */]
    });
    let src = '';

    for (const [filename, {
      content,
      language,
      truncated
    }] of Object.entries(files)) {
      src += string_namespaceObject.escape`<h5>${filename}:</h5>`;

      if (language === 'Markdown') {
        src += snudown_es_markdown(content);
      } else {
        src += string_namespaceObject.escape`<pre><code>${content}</code></pre>`;
      }

      if (truncated) {
        src += '<p>&lt;file truncated&gt;</p>';
      }
    }

    return {
      type: 'TEXT',
      title: description,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/googlemaps.js

/* harmony default export */ var googlemaps = (new Host('googlemaps', {
  domains: ['maps.google.ca', 'maps.google.com', 'google.co.uk', 'google.com', 'google.ca'],
  logo: 'https://maps.google.com/favicon.ico',
  name: 'Google Maps',
  detect: ({
    host,
    searchParams,
    pathname
  }) => {
    if (host.startsWith('maps.') || pathname.startsWith('/maps')) {
      const coords = searchParams.get('ll') || searchParams.get('q');

      if (coords) {
        return [coords, searchParams.get('z'), searchParams.has('maptype') ? searchParams.get('maptype') : 'roadmap'];
      } else {
        const location = pathname.split('/').find(part => part.startsWith('@'));

        if (location) {
          const [long, lat, zoom] = location.substring(1).split(',');
          return [`${long},${lat}`, zoom.endsWith('z') ? zoom : 16, zoom.endsWith('z') ? 'roadmap' : 'satellite'];
        }
      }
    }
  },

  handleLink(href, [coords, zoom, mapType]) {
    let embed = `https://www.google.com/maps/embed/v1/view?center=${coords}&key=AIzaSyCtnLZP1XwkgIK53Asx_5qtZa2k9eZcdDc`;
    if (zoom) embed += `&zoom=${zoom}`;
    if (mapType) embed += `&maptype=${mapType}`;
    return {
      type: 'IFRAME',
      embed,
      muted: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/gyazo.js


/* harmony default export */ var gyazo = (new Host('gyazo', {
  name: 'gyazo',
  domains: ['gyazo.com'],
  permissions: ['https://api.gyazo.com/api/oembed'],
  logo: 'https://gyazo.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(\w{32})\b/i.exec(pathname),

  async handleLink(href, [, id]) {
    const info = await ajax({
      url: 'https://api.gyazo.com/api/oembed',
      query: {
        url: href
      },
      type: 'json'
    });

    switch (info.type) {
      case 'photo':
        return {
          type: 'IMAGE',
          src: info.url
        };

      case 'video':
        return {
          type: 'VIDEO',
          muted: true,
          loop: true,
          fallback: `https://i.gyazo.com/${id}.gif`,
          sources: [{
            source: `https://i.gyazo.com/${id}.mp4`,
            type: 'video/mp4'
          }]
        };

      default:
        throw new Error(`Invalid media type: ${info.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/hastebin.js

/* harmony default export */ var hastebin = (new Host('hastebin', {
  name: 'hastebin',
  domains: ['hastebin.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:raw\/)?([^\/]+)/i.exec(pathname),

  handleLink(href, [, filename]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://hastebin.com/${filename}`,
      height: '500px',
      width: '800px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/iloopit.js

/* harmony default export */ var iloopit = (new Host('iloopit', {
  name: 'iLoopit - gif maker',
  domains: ['iloopit.net'],
  logo: 'https://iloopit.net/favicon.ico',
  detect: ({
    href
  }) => /^https?:\/\/(\w+\.)?iloopit\.net\/.+?\/\?type=looplayer&loopid=(\d+)/i.exec(href) || /^https?:\/\/(\w+\.)?iloopit\.net(\/tube)?\/(\d+)\/.+?\/(\?type=(looplayer)|(embed))?/i.exec(href),

  handleLink(href) {
    let link = '';
    const titleResult = /iloopit\.net(?:\/tube)?\/(\d+)\/(.+)?\//.exec(href);

    if (titleResult) {
      link = `https://iloopit.net/${titleResult[1]}/${titleResult[2]}/?type=embed`;
    } else {
      link = href.replace('type=looplayer', 'type=embed');
    }

    return {
      type: 'IFRAME',
      muted: true,
      embed: link,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/imgflip.js

/* harmony default export */ var imgflip = (new Host('imgflip', {
  name: 'imgflip',
  domains: ['imgflip.com'],
  logo: 'https://imgflip.com/favicon02.png',
  detect: ({
    pathname
  }) => /^\/(i|gif)\/([a-z0-9]+)/.exec(pathname),

  handleLink(href, [, type, id]) {
    return {
      type: 'IMAGE',
      src: `https://i.imgflip.com/${id}.${type === 'gif' ? 'gif' : 'jpg'}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/imgur.js



/* harmony default export */ var imgur = (new Host('imgur', {
  name: 'imgur',
  domains: ['imgur.com'],
  logo: 'https://i.imgur.com/favicon.ico',
  options: {
    preferResAlbums: {
      title: 'imgurPreferResAlbumsTitle',
      description: 'imgurPreferResAlbumsDesc',
      value: true,
      type: 'boolean'
    },
    useGifOverGifv: {
      title: 'imgurUseGifOverGifVTitle',
      description: 'imgurUseGifOverGifVDesc',
      value: false,
      type: 'boolean'
    },
    preferredImgurLink: {
      title: 'imgurPreferredImgurLinkTitle',
      description: 'imgurPreferredImgurLinkDesc',
      type: 'enum',
      value: 'share',
      values: [{
        name: 'full page (imgur.com)',
        value: 'share'
      }, {
        name: 'direct image (i.imgur.com)',
        value: 'direct'
      }]
    },
    imgurImageResolution: {
      title: 'imgurImageResolutionTitle',
      description: 'imgurImageResolutionDesc',
      type: 'enum',
      value: '',
      values: [{
        name: 'Full Resolution',
        value: ''
      }, {
        name: 'Retina (1360px)',
        value: 'r'
      }, {
        name: 'Huge (1024px)',
        value: 'h'
      }, {
        name: 'Giant (680px)',
        value: 'g'
      }, {
        name: 'Large (640px)',
        value: 'l'
      }]
    }
  },

  detect({
    pathname,
    href
  }) {
    const hashRe = /^https?:\/\/(?:i\.|m\.|edge\.|www\.)*imgur\.com\/(r\/\w+\/)*(?!gallery)(?!removalrequest)(?!random)(?!memegen)((?:\w{5}|\w{7})(?:[&,](?:\w{5}|\w{7}))*)(?:#\d+)?[a-z]?(\.(?:jpe?g|gifv?|png))?(\?.*)?$/i;
    const hostedHashRe = /^https?:(\/\/i\.\w+\.*imgur\.com\/)((?:\w{5}|\w{7})(?:[&,](?:\w{5}|\w{7}))*)(?:#\d+)?[a-z]?(\.(?:jpe?g|gif|png))?(\?.*)?$/i;
    if (pathname === '/rules' || pathname === '/inbox') return null;
    href = href.split('?')[0];
    let groups;

    if (groups = /^https?:\/\/(?:m\.|www\.)?imgur\.com\/gallery\/(\w+)(?:[/#]|$)/i.exec(href)) {
      const hash = groups[1];
      return () => _api(string_namespaceObject.encode`gallery/${hash}`).catch(() => _api(string_namespaceObject.encode`album/${hash}`));
    } else if (groups = /^https?:\/\/(?:m\.|www\.)?imgur\.com\/a\/(\w+)(?:[/#]|$)/i.exec(href)) {
      if (this.options.preferResAlbums.value) {
        const hash = groups[1];
        return () => _api(string_namespaceObject.encode`album/${hash}`);
      }
    } else if (groups = hostedHashRe.exec(href)) {
      const hash = groups[2];
      return () => _handleImage(hash, href);
    } else if (groups = hashRe.exec(href)) {
      const [, subreddit, hash] = groups;
      if (subreddit) return () => _api(string_namespaceObject.encode`gallery/${subreddit}${hash}`);

      if (hash.search(/[&,]/) > -1) {
        return () => _handleImageCollection(hash.split(/[&,]/), href);
      } else {
        return () => _handleImage(hash, href);
      }
    }

    return false;

    async function _api(endpoint) {
      const {
        data
      } = await ajax({
        url: 'https://api.imgur.com/3/' + endpoint,
        type: 'json',
        headers: {
          Authorization: `Client-ID ${'1d8d9b36339e0e2'}`
        }
      });

      if (data.error) {
        throw new Error(`Imgur API error: ${data.error}`);
      }

      return data;
    }

    function _mockImageAPI(hash, url) {
      let thisCdnUrl = 'https://i.imgur.com/';
      let matches, extension;

      if (matches = hostedHashRe.exec(url)) {
        thisCdnUrl = matches[1];
        extension = matches[3];
      } else if (matches = hashRe.exec(url)) {
        extension = matches[3];
      }

      if (!extension) {
        extension = '.jpg';
      }

      return {
        id: hash,
        animated: false,
        looping: false,
        has_sound: false,
        link: `${thisCdnUrl}${hash}${extension}`,
        gifv: undefined,
        title: '',
        description: ''
      };
    }

    function _handleImage(hash, url) {
      const [,,, extension] = hashRe.exec(url) || [];

      if (['.png', '.jpg', '.jpeg'].includes(extension)) {
        return _mockImageAPI(hash, url);
      } else if (hostedHashRe.test(url)) {
        return _mockImageAPI(hash, url);
      } else {
        return _api(`image/${hash}`);
      }
    }

    function _handleImageCollection(hashes, url) {
      return {
        is_album: true,
        images: hashes.map(hash => _mockImageAPI(hash, url)),
        title: '',
        description: ''
      };
    }
  },

  async handleLink(href, getInfo) {
    const baseUrl = 'https://imgur.com/';
    const shareLinkPreferred = this.options.preferredImgurLink.value === 'share';
    const resolutionSuffix = this.options.imgurImageResolution.value;
    const useGif = this.options.useGifOverGifv.value;
    const info = await getInfo();

    if (info.images && info.images.length) {
      return _handleAlbum(href, info);
    } else if (info.gifv && !useGif) {
      return _handleGifv(info);
    } else if (info.link) {
      return _handleSingleImage(info);
    }

    throw new Error('could not handle info');

    function _handleAlbum(href, info) {
      return {
        type: 'GALLERY',
        title: info.title,
        caption: info.description,
        src: info.images.map(info => {
          const media = info.gifv && !useGif ? _handleGifv(info) : _handleSingleImage(info);
          media.href = shareLinkPreferred ? `${href.split('#')[0]}#${info.id}` : `${info.link}`;
          return media;
        })
      };
    }

    function _handleSingleImage(info) {
      const src = info.link.replace('http:', 'https:').replace(`/${info.id}.`, `/${info.id}${resolutionSuffix}.`);
      return {
        src,
        href: shareLinkPreferred ? `${baseUrl}${info.id}` : `${info.link}`,
        type: 'IMAGE',
        caption: info.description,
        title: info.title
      };
    }

    function _handleGifv(info) {
      return {
        type: 'VIDEO',
        href: shareLinkPreferred ? `${baseUrl}${info.id}` : `${info.link}`,
        fallback: info.link.replace('http:', 'https:'),
        caption: info.description,
        title: info.title,
        loop: info.looping !== false,
        muted: !info.has_sound,
        sources: [{
          source: info.mp4.replace('http:', 'https:'),
          type: 'video/mp4'
        }]
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/instagram.js

/* harmony default export */ var instagram = (new Host('instagram', {
  name: 'Instagram',
  domains: ['instagram.com', 'instagr.am'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/p\/([a-z0-9_\-]{10,})(?:\/|$)/i.exec(pathname),
  handleLink: (href, [, id]) => ({
    type: 'IFRAME',
    expandoClass: 'image',
    embed: `https://instagram.com/p/${id}/embed/captioned/`,
    width: '600px',
    height: '700px'
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/ireddit.js


/* harmony default export */ var ireddit = (new Host('ireddit', {
  name: 'i.redd.it',
  domains: ['i.redd.it'],
  attribution: false,

  detect({
    pathname
  }, thing) {
    return pathname.endsWith('.gif') && thing && thing.isLinkPost() && thing.getFullname();
  },

  async handleLink(href, fullname) {
    const postMetadata = await getPostMetadata({
      id: fullname.replace('t3_', '')
    });
    if (!postMetadata.preview) throw new Error('Post has no preview.');
    const preview = postMetadata.preview.images[0];

    if (preview.variants.mp4) {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        fallback: preview.variants.gif && preview.variants.gif.source.url,
        sources: [{
          source: preview.variants.mp4.source.url,
          type: 'video/mp4'
        }]
      };
    } else {
      return {
        type: 'IMAGE',
        src: preview.source.url
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/jsfiddle.js

/* harmony default export */ var jsfiddle = (new Host('jsfiddle', {
  name: 'jsfiddle',
  domains: ['jsfiddle.net'],
  logo: 'https://jsfiddle.net/favicon.png',
  detect: ({
    pathname
  }) => /^(\/(?:\w+\/(?!embedded\/))?[a-z0-9]{5,}(?:\/\d+)?(?=\/|$))(\/embedded\/[\w,]+\/)?/i.exec(pathname),

  handleLink(href, [, path, categories]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://jsfiddle.net${path}${categories || '/embedded/result,js,resources,html,css/'}`,
      width: '800px',
      height: '500px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/liveleak.js

/* harmony default export */ var liveleak = (new Host('liveleak', {
  name: 'LiveLeak',
  domains: ['liveleak.com'],
  logo: 'https://www.liveleak.com/favicon.ico',
  detect: ({
    pathname,
    search
  }) => pathname === '/view' && search,
  handleLink: (href, query) => ({
    type: 'IFRAME',
    embed: `https://www.liveleak.com/ll_embed${query}`,
    embedAutoplay: `https://www.liveleak.com/ll_embed${query}&autostart=true`,
    fixedRatio: true
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/livememe.js

/* harmony default export */ var livememe = (new Host('livememe', {
  name: 'livememe',
  domains: ['livememe.com'],
  logo: 'https://livememe.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?!edit)(\w{7})(?:\/|$)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://e.lvme.me/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/makeameme.js

/* harmony default export */ var makeameme = (new Host('makeameme', {
  name: 'makeameme',
  domains: ['makeameme.org'],
  logo: 'https://makeameme.org/images/favicons/favicon-32x32.png',
  detect: ({
    pathname
  }) => /^\/meme\/([\w\-]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://makeameme.org/media/created/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/memecrunch.js

/* harmony default export */ var memecrunch = (new Host('memecrunch', {
  name: 'memecrunch',
  domains: ['memecrunch.com'],
  logo: 'https://memecrunch.com/static/favicon.ico',
  detect: ({
    pathname
  }) => /^\/meme\/([0-9A-Z]+)\/([\w\-]+)(\/image\.(png|jpg))?/i.exec(pathname),

  handleLink(href, [, id, format]) {
    return {
      type: 'IMAGE',
      src: `https://memecrunch.com/meme/${id}/${format || 'null'}/image.png`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/memedad.js

/* harmony default export */ var memedad = (new Host('memedad', {
  name: 'memedad',
  domains: ['memedad.com'],
  logo: 'https://memedad.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/meme\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IMAGE',
      src: `https://memedad.com/memes/${id}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/navertv.js

/* harmony default export */ var navertv = (new Host('Naver', {
  name: 'Naver',
  domains: ['tv.naver.com'],
  logo: 'https://www.naver.com/favicon.ico?1',
  detect: ({
    pathname
  }) => /^\/(?:v)\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    const embed = `https://tv.naver.com/embed/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoPlay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/onedrive.js



/* harmony default export */ var onedrive = (new Host('onedrive', {
  domains: ['onedrive.live.com', '1drv.ms'],
  name: 'Microsoft OneDrive',
  detect: () => true,

  async handleLink(href) {
    const encodedUrl = `u!${btoa(href)}`.replace(/=+$/g, '').replace(/\//g, '_').replace(/\+/g, '-');
    const json = await ajax({
      url: `https://api.onedrive.com/v1.0/shares/${encodedUrl}/root?expand=children`,
      type: 'json',
      cacheFor: utils_time["a" /* DAY */]
    });

    if (json.children.length) {
      return {
        type: 'GALLERY',
        src: json.children.map(processFile)
      };
    } else {
      return processFile(json);
    }

    function processFile({
      name,
      description,
      webUrl,
      '@content.downloadUrl': src,
      file: {
        mimeType
      }
    }) {
      const type = mimeType.slice(0, mimeType.indexOf('/'));

      switch (type) {
        case 'image':
          return {
            type: 'IMAGE',
            title: name,
            caption: description,
            src,
            href: webUrl
          };

        case 'video':
          return {
            type: 'VIDEO',
            title: name,
            caption: description,
            loop: false,
            sources: [{
              source: src,
              type: mimeType
            }]
          };

        case 'audio':
          return {
            type: 'AUDIO',
            loop: false,
            sources: [{
              file: src,
              type: mimeType
            }]
          };

        default:
          throw new Error(`Invalid type: ${type}`);
      }
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pastebin.js

/* harmony default export */ var pastebin = (new Host('pastebin', {
  name: 'pastebin',
  domains: ['pastebin.com'],
  attribution: false,
  detect: ({
    href
  }) => /^https?:\/\/(?:www\.)?pastebin\.com\/(?:raw\.php\?i=|index\/)?([a-z0-9]{8})/i.exec(href),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://pastebin.com/embed_iframe.php?i=${id}`,
      height: '500px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/peertube.js

/* harmony default export */ var peertube = (new Host('peertube', {
  name: 'peertube',
  domains: ['peervideo.net', 'peertube.social', 'peertube.mastodon.host', 'evertron.tv', 'mplayer.demouliere.eu', 'cloud.allplayer.tk', 'video.tedomum.net', 'peertube.fr', 'hostyour.tv', 'videobit.cc', 'videoshare.cc', 'peertube.openstreetmap.fr', 'video.ploud.fr', 'tube.kdy.ch', 'lostpod.space', 'pe.ertu.be', 'peertube.live', 'peer.tube', 'watching.cypherpunk.observer', 'queertube.org', 'exode.me', 'framatube.org', 'peervideo.net'],
  attribution: false,
  detect: ({
    hostname,
    pathname
  }) => {
    const [, route,, id] = pathname.split('/');

    if (route === 'videos') {
      return [hostname, id];
    }
  },

  handleLink(href, [hostname, id]) {
    const embed = `https://${hostname}/videos/embed/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/photobucket.js


/* harmony default export */ var photobucket = (new Host('photobucket', {
  name: 'photobucket',
  domains: ['photobucket.com'],
  logo: 'https://pic2.pbsrc.com/common/favicon.ico',
  detect: ({
    href
  }) => /([is]?)[0-9]+|media|smg|img(?=.photobucket.com)/i.exec(href),

  async handleLink(href, [, prefix]) {
    let src = href.replace('.html', '');

    if (prefix !== 'i') {
      const {
        imageUrl
      } = await ajax({
        url: 'https://api.photobucket.com/v2/media/fromurl',
        query: {
          url: src
        },
        type: 'json'
      });
      src = imageUrl.replace('http:', 'https:');
    }

    return {
      type: 'IMAGE',
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pixiv.js

/* harmony default export */ var pixiv = (new Host('pixiv', {
  name: 'pixiv',
  domains: ['pixiv.net'],
  logo: 'https://www.pixiv.net/favicon.ico',
  detect: ({
    pathname,
    search
  }) => pathname === '/member_illust.php' && /illust_id=(\d+)/.exec(search) || /(?:\/en|^)\/artworks\/(\d+)\/?$/.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'image',
      muted: true,
      embed: `https://embed.pixiv.net/embed_mk2.php?id=${id}&size=large`,
      width: '700px',
      height: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/poly.js

/* harmony default export */ var poly = (new Host('poly', {
  name: 'Poly',
  domains: ['poly.google.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/view\/([a-zA-Z0-9-]+)\/?$/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://poly.google.com/view/${id}/embed`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/pornhub.js

/* harmony default export */ var pornhub = (new Host('pornhub', {
  name: 'Pornhub',
  domains: ['www.pornhub.com', 'www.pornhubpremium.com'],
  attribution: false,
  detect: ({
    searchParams
  }) => searchParams.get('viewkey'),

  handleLink(href, path) {
    const url = `https://www.pornhub.com/embed/${path}`;
    return {
      type: 'IFRAME',
      embed: url,
      embedAutoplay: `${url}?autoplay=1`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/ppy.js

/* harmony default export */ var ppy = (new Host('ppy.sh', {
  name: 'ppy.sh',
  domains: ['osu.ppy.sh'],
  logo: 'https://s.ppy.sh/favicon.ico',
  detect: ({
    pathname
  }) => /^\/ss\/(\d+(?:\/[0-9a-f]+)?)/i.exec(pathname),

  handleLink(href, [, code]) {
    return {
      type: 'IMAGE',
      src: `https://osu.ppy.sh/ss/${code}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redditbooru.js


/* harmony default export */ var redditbooru = (new Host('redditbooru', {
  name: 'redditbooru',
  domains: ['redditbooru.com'],
  logo: 'https://redditbooru.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/gallery\/([\w]+)(\/[\w\-]+)?/i.exec(pathname),

  async handleLink(href, [, id, base36]) {
    if (base36) {
      id = parseInt(id, 36);
    }

    const info = await ajax({
      url: 'https://redditbooru.com/images/',
      query: {
        postId: id
      },
      type: 'json'
    });

    if (!info.length) {
      throw new Error('Gallery was empty.');
    }

    const src = info.map(({
      caption,
      cdnUrl,
      sourceUrl
    }) => ({
      type: 'IMAGE',
      title: caption,
      src: cdnUrl,
      caption: sourceUrl ? `Source: <a href="${sourceUrl}">${sourceUrl}</a>` : ''
    }));
    return {
      type: 'GALLERY',
      title: info[0].title,
      src
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redditgallery.js


/* harmony default export */ var redditgallery = (new Host('redditgallery', {
  name: 'redditgallery',
  domains: ['reddit.com'],
  attribution: false,

  detect({
    pathname
  }) {
    return pathname.match(/^\/gallery\/(\w+)/);
  },

  async handleLink(href, [, id]) {
    const {
      media_metadata = {},
      gallery_data: {
        items = []
      } = {}
    } = await getPostMetadata({
      id
    });
    const pieces = Object(utils_array["c" /* filterMap */])(items, ({
      media_id,
      caption
    }) => {
      const {
        m
      } = media_metadata[media_id] || {};
      const type = m.startsWith('image') ? 'IMAGE' : 'Unknown';
      return type === 'IMAGE' ? [{
        type,
        caption,
        src: `https://i.redd.it/${media_id}.${m.substr(6)}`
      }] : undefined;
    });
    if (!pieces.length) throw new Error('Gallery has no valid pieces.');
    return {
      type: 'GALLERY',
      src: pieces
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redditmedia.js

/* harmony default export */ var redditmedia = (new Host('redditmedia', {
  name: 'redditmedia',
  domains: ['redditmedia.com'],
  attribution: false,
  detect: ({
    hostname,
    searchParams
  }) => hostname !== 'pixel.redditmedia.com' && searchParams,

  handleLink(href, searchParams) {
    if (searchParams.get('fm') === 'mp4') {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        sources: [{
          source: href,
          type: 'video/mp4'
        }]
      };
    }

    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redditpoll.js

/* harmony default export */ var redditpoll = (new Host('redditpoll', {
  name: 'redditpoll',
  domains: ['reddit.com'],
  attribution: false,

  detect({
    pathname
  }) {
    return pathname.match(/^\/poll\/(\w+)/);
  },

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      embed: `https://www.reddit.com/poll/${id}`,
      height: '500px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/reddituploads.js

/* harmony default export */ var reddituploads = (new Host('reddituploads', {
  name: 'reddituploads',
  domains: ['reddituploads.com'],
  attribution: false,
  detect: () => true,

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/redgifs.js



/* harmony default export */ var redgifs = (new Host('redgifs', {
  name: 'redgifs',
  domains: ['redgifs.com'],
  logo: 'https://redgifs.com/assets/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?:(?:ifr|watch)\/)(\w+)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const embed = `https://redgifs.com/ifr/${id}`;

    try {
      const info = (await ajax({
        url: string_namespaceObject.encode`https://api.redgifs.com/v1/gfycats/${id}`,
        type: 'json',
        cacheFor: utils_time["a" /* DAY */]
      })).gfyItem;
      let height = info.height;
      let width = info.width;
      const ratio = width / height;
      const maxSize = 600;

      if (height > width) {
        height = Math.min(height, maxSize);
        width = parseInt(ratio * height, 10);
      } else {
        width = Math.min(width, maxSize);
        height = parseInt(width / ratio, 10);
      }

      return {
        type: 'IFRAME',
        embed: `${embed}?autoplay=0`,
        embedAutoplay: embed,
        fixedRatio: false,
        width: `${width}px`,
        height: `${height}px`
      };
    } catch (error) {
      return {
        type: 'IFRAME',
        embed: `${embed}?autoplay=0`,
        embedAutoplay: embed,
        fixedRatio: true
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/ridewithgps.js

/* harmony default export */ var ridewithgps = (new Host('ridewithgps', {
  name: 'ridewithgps',
  domains: ['ridewithgps.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(trips|routes)\/(\d+)/i.exec(pathname),

  handleLink(href, [, type, id]) {
    return {
      type: 'IFRAME',
      embed: `https://ridewithgps.com/${type}/${id}/embed`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/simplecove.js


/* harmony default export */ var simplecove = (new Host('simplecove', {
  name: 'SimpleCove',
  domains: ['simplecove.com'],
  logo: 'https://simplecove.com/static/images/reslogo.jpg',
  detect: ({
    pathname
  }) => /^\/(\d+)/i.exec(pathname),

  async handleLink(elem, [, id]) {
    const data = await ajax({
      url: `https://www.simplecove.com/resapi/${id}`,
      type: 'json'
    });
    const images = data.map(x => ({
      src: x.photo_src.replace('http:', 'https:'),
      caption: x.photo_caption,
      type: 'IMAGE'
    }));
    return {
      type: 'GALLERY',
      src: images
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/snag.js

/* harmony default export */ var snag = (new Host('snag', {
  name: 'snag.gy',
  logo: 'https://snaggys3static-snaggy.netdna-ssl.com/favicon.png',
  domains: ['snag.gy'],
  detect: ({
    pathname
  }) => /^\/(\w+)(?:\.(\w+))?$/i.exec(pathname),

  handleLink(href, [, id, extension]) {
    return {
      type: 'IMAGE',
      src: `https://i.snag.gy/${id}.${extension || 'jpg'}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/soundcloud.js


/* harmony default export */ var soundcloud = (new Host('soundcloud', {
  name: 'soundcloud',
  domains: ['soundcloud.com'],
  logo: 'https://a-v2.sndcdn.com/assets/images/sc-icons/favicon-2cadd14b.ico',
  detect: () => true,

  handleLink(href) {
    return {
      type: 'IFRAME',
      embed: string_namespaceObject.encode`https://w.soundcloud.com/player/?url=${href}`,
      height: '166px',
      width: '700px',
      pause: '{"method":"pause"}',
      play: '{"method":"play"}'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/spotify.js

/* harmony default export */ var spotify = (new Host('spotify', {
  name: 'spotify',
  domains: ['spotify.com'],
  logo: 'https://spotify.com/favicon.ico',
  detect: ({
    href
  }) => /^https:\/\/(?:open|play)\.spotify\.com\/((?:track|artist|album|user\/\w+\/playlist)\/[a-zA-z0-9]+)$/i.exec(href),

  handleLink(href, [, uri]) {
    return {
      type: 'IFRAME',
      embed: `https://embed.spotify.com/?uri=spotify:${uri.replace(/\//g, ':')}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/steamcommunity.js


/* harmony default export */ var steamcommunity = (new Host('steamcommunity', {
  name: 'Steam Community',
  logo: 'https://store.steampowered.com/favicon.ico',
  domains: ['steamcommunity.com'],
  detect: ({
    pathname,
    searchParams
  }) => pathname.startsWith('/sharedfiles/filedetails') && searchParams.get('id'),
  permissions: ['https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/*'],

  async handleLink(href, id) {
    const {
      response: {
        publishedfiledetails: [{
          title,
          description: caption,
          preview_url: previewUrl,
          file_url: fileUrl,
          filename
        }]
      }
    } = await ajax({
      method: 'POST',
      url: 'https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v0001/?format=json',
      data: {
        itemcount: '1',
        'publishedfileids[0]': id
      },
      type: 'json'
    });
    if (!filename) throw new Error('Response missing filename. (Private Steam Community profile?)');
    return {
      type: 'IMAGE',
      title,
      caption,
      src: ['.png', '.jpg', '.gif'].some(ext => filename.endsWith(ext)) ? fileUrl : previewUrl
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/steampowered.js

/* harmony default export */ var steampowered = (new Host('steampowered', {
  name: 'Steam',
  logo: 'https://store.steampowered.com/favicon.ico',
  domains: ['steampowered.com', 'steamusercontent.com'],
  detect: ({
    pathname
  }) => /^\/ugc\/(\d{15,20}\/\w{40})(?:$|\/)/i.exec(pathname),

  handleLink(href, [pathname]) {
    return {
      type: 'IMAGE',
      src: `http://images.akamai.steamusercontent.com${pathname}`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/strawpollcom.js

/* harmony default export */ var strawpollcom = (new Host('strawpoll.com', {
  name: 'strawpoll.com',
  domains: ['strawpoll.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:embed\/)?([a-z0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://strawpoll.com/embed/${id}`,
      height: '450px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/strawpollme.js

/* harmony default export */ var strawpollme = (new Host('strawpoll', {
  name: 'strawpoll.me',
  domains: ['strawpoll.me'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/(?:embed_\d\/)?(\d+)/i.exec(pathname),

  handleLink(href, [, uid]) {
    return {
      type: 'IFRAME',
      expandoClass: 'selftext',
      muted: true,
      embed: `https://www.strawpoll.me/embed_1/${uid}`,
      height: '500px',
      width: '700px'
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/streamable.js


/* harmony default export */ var streamable = (new Host('streamable', {
  name: 'streamable',
  domains: ['streamable.com'],
  logo: 'https://cdn-e2.streamable.com/static/14a98f7cb1ddc5213329c039dc39cac543ba410f/img/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?:[es]\/)?(\w+)(?:\/\w+)?$/i.exec(pathname),

  async handleLink(href, [, hash]) {
    const {
      title,
      files: {
        mp4: {
          url
        }
      },
      thumbnail_url: thumbnail,
      source
    } = await ajax({
      url: `https://api.streamable.com/videos/${hash}`,
      type: 'json'
    });
    return {
      type: 'VIDEO',
      title,
      loop: true,
      sources: [{
        source: url,
        type: 'video/mp4'
      }],
      poster: thumbnail,
      source
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/streamja.js

/* harmony default export */ var streamja = (new Host('streamja', {
  name: 'streamja',
  domains: ['streamja.com'],
  logo: 'https://streamja.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/([^\/]+)$/i.exec(pathname),

  handleLink(href, [, code]) {
    const short = code.substring(0, 2).toLowerCase();
    return {
      type: 'VIDEO',
      loop: true,
      sources: [{
        source: `https://upload.streamja.com/mp4/${short}/${code}.mp4`,
        type: 'video/mp4'
      }],
      poster: `https://upload.streamja.com/i/${short}/${code}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/streamvi.js

/* harmony default export */ var streamvi = (new Host('streamvi', {
  name: 'streamvi',
  domains: ['streamvi.com'],
  logo: 'https://streamvi.com/assets/logo.png',
  detect: ({
    searchParams
  }) => {
    const code = searchParams.get('video');
    if (code) return [code.toString()];
  },

  handleLink(href, [code]) {
    return {
      type: 'VIDEO',
      loop: true,
      sources: [{
        source: `https://cdn.streamvi.com/uploads/${code}.mp4`,
        type: 'video/mp4'
      }],
      poster: `https://cdn.streamvi.com/uploads/${code}.jpg`
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/supgif.js

/* harmony default export */ var supgif = (new Host('supgif', {
  name: 'Supgif',
  domains: ['supgif.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/c\/([\w\-]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://www.supgif.com/embed/${id}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/supload.js



/* harmony default export */ var supload = (new Host('supload', {
  name: 'supload',
  domains: ['supload.com'],
  logo: 'https://supload.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/([A-Za-z0-9_-]+)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const data = await ajax({
      url: 'https://www.supload.com/oembed',
      query: {
        url: `https://supload.com/${id}`,
        format: 'json'
      },
      type: 'json',
      cacheFor: utils_time["a" /* DAY */]
    });

    if (data.type === 'photo') {
      return {
        type: 'IMAGE',
        src: data.url
      };
    } else {
      return {
        type: 'VIDEO',
        loop: true,
        muted: true,
        sources: [{
          source: data.webmUrl,
          type: 'video/webm'
        }, {
          source: data.mp4Url,
          type: 'video/mp4'
        }]
      };
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/tenor.js


/* harmony default export */ var tenor = (new Host('tenor', {
  name: 'tenor',
  domains: ['tenor.co'],
  logo: 'https://www.tenor.co/favicon.ico',
  detect: (() => {
    const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    const alphabetMap = alphabet.split('').reduce((obj, c, i) => {
      obj[c] = i;
      return obj;
    }, {});

    function parseViewShortId(s) {
      return s.split('').reduce((n, c) => n * alphabet.length + alphabetMap[c], 0);
    }

    return ({
      hostname,
      pathname
    }) => {
      if (hostname === 'tenor.co') {
        const pathMatch = /^\/([a-zA-Z0-9]+)\.gif$/i.exec(pathname);
        return pathMatch && {
          id: parseViewShortId(pathMatch[1])
        };
      } else if (hostname === 'media.tenor.co') {
        return {
          id: null
        };
      } else {
        const pathMatch = /^\/view\/.+\-(\d+)(\.gif)?$/i.exec(pathname);
        return pathMatch && {
          id: pathMatch[1]
        };
      }
    };
  })(),

  async handleLink(href, {
    id
  }) {
    if (id === null) {
      return {
        type: 'IMAGE',
        src: href
      };
    }

    const {
      results: [gif]
    } = await ajax({
      url: 'https://api.tenor.co/v1/gifs',
      query: {
        key: 'JJHDC7UK73EH',
        ids: id
      },
      type: 'json'
    });
    return {
      type: 'IMAGE',
      src: gif.media[0].gif.url,
      title: gif.h1_title,
      caption: gif.generatedcaption
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/tuckbot.js

/* harmony default export */ var tuckbot = (new Host('tuckbot', {
  name: 'TuckBot.tv',
  domains: ['tuckbot.tv'],
  attribution: false,
  detect: ({
    hostname,
    hash
  }) => {
    const [, route, redditPostId] = hash.split('/');
    if (route === 'watch') return [hostname, redditPostId];
  },

  handleLink(_href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://tuckbot.tv/#/embed/${id}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/tumblr.js



/* harmony default export */ var tumblr = (new Host('tumblr', {
  name: 'tumblr',
  domains: ['tumblr.com'],
  permissions: ['https://api.tumblr.com/v2/blog/*/posts'],
  logo: 'https://secure.assets.tumblr.com/images/favicons/favicon.ico',

  detect({
    hostname,
    pathname
  }) {
    const pathMatch = /^\/(?:post|image)\/(\d+)(?:\/|$)/i.exec(pathname);
    return pathMatch && [hostname, pathMatch[1]];
  },

  async handleLink(href, [blog, id]) {
    const {
      response
    } = await ajax({
      url: `https://api.tumblr.com/v2/blog/${blog}/posts`,
      query: {
        api_key: 'WeJQquHCAasi5EzaN9jMtIZkYzGfESUtEvcYDeSMLICveo3XDq',
        id,
        filter: 'raw'
      },
      type: 'json'
    });
    const post = response.posts[0];

    function render(string) {
      return post.format === 'markdown' ? snudown_es_markdown(string) : string;
    }

    const defaults = {
      title: post.title,
      caption: post.caption,
      credits: `Posted by: <a href="${response.blog.url}">${response.blog.name}</a> @ Tumblr`
    };

    switch (post.type) {
      case 'photo':
        if (!post.photos.length) throw new Error('No images in gallery.');
        return {
          type: 'GALLERY',
          ...defaults,
          src: post.photos.map(photo => ({
            type: 'IMAGE',
            src: photo.original_size.url,
            caption: photo.caption
          }))
        };

      case 'text':
        return {
          type: 'TEXT',
          ...defaults,
          src: render(post.body)
        };

      case 'quote':
        return {
          type: 'TEXT',
          ...defaults,
          credits: post.source,
          src: `<blockquote><p>${render(post.text)}</p></blockquote>`
        };

      case 'link':
        return {
          type: 'TEXT',
          ...defaults,
          title: `<a href="${post.url}">${post.title}</a>`,
          src: render(post.description)
        };

      case 'chat':
        return {
          type: 'TEXT',
          ...defaults,
          src: post.dialogue.reduce((prev, {
            label,
            phrase
          }) => `${prev}<blockquote><p><b>${label}</b> ${phrase}</p></blockquote>`, '')
        };

      case 'answer':
        const asking = post.asking_url ? `<a href="${post.asking_url}">${post.asking_name}</a>` : post.asking_name;
        return {
          type: 'TEXT',
          ...defaults,
          src: `<blockquote><p>${asking} sent: ${post.question}</p></blockquote>${render(post.answer)}`
        };

      default:
        throw new Error(`Unsupported post type: ${post.type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twimg.js

/* harmony default export */ var twimg = (new Host('twimg', {
  name: 'twimg',
  domains: ['pbs.twimg.com'],
  logo: 'https://twitter.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/media\/[\w\-]+\.\w+/i.test(pathname),

  handleLink(href) {
    return {
      type: 'IMAGE',
      src: href
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitch.js

/* harmony default export */ var twitch = (new Host('twitch', {
  name: 'twitch.tv',
  domains: ['twitch.tv'],
  logo: 'https://www.twitch.tv/favicon.ico',
  detect: ({
    href
  }) => /^https?:\/\/(?:www\.)?twitch\.tv\/(\w+)(?:\/([cbv])\/([0-9]+))?\/?(?:\?t=(?:([0-9]+)h)?(?:([0-9]+)m)?(?:([0-9]+)s)?)?$/i.exec(href),

  handleLink(href, [, channel, typeId, videoId, h, m, s]) {
    const channelOrVideo = videoId ? `video=${typeId.replace('b', 'a')}${videoId}` : `channel=${channel}`;
    const embed = `https://player.twitch.tv/?${channelOrVideo}&parent=${location.hostname}&time=${+h || 0}h${+m || 0}m${+s || 0}s`;
    return {
      type: 'IFRAME',
      embed: `${embed}&autoplay=false`,
      embedAutoplay: `${embed}&autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitchclips.js

/* harmony default export */ var twitchclips = (new Host('twitchclips', {
  name: 'twitch.tv clips',
  domains: ['twitch.tv'],
  logo: 'https://www.twitch.tv/favicon.ico',
  detect: ({
    hostname,
    pathname
  }) => hostname === 'clips.twitch.tv' ? /^\/(\w+(?:\/[A-Z]\w+)?(?:[\-\w]*))(?:\/|$)/.exec(pathname) : /^\/\w+\/clip\/(\w+(?:\/[A-Z]\w+)?(?:[\-\w]*))(?:\/|$)/.exec(pathname),

  handleLink(href, [, clipId]) {
    const embed = `https://clips.twitch.tv/embed?clip=${clipId}&parent=${location.hostname}`;
    return {
      type: 'IFRAME',
      embed: `${embed}&autoplay=false`,
      embedAutoplay: `${embed}&autoplay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/twitter.js



/* harmony default export */ var twitter = (new Host('twitter', {
  name: 'twitter',
  domains: ['twitter.com'],
  permissions: ['https://publish.twitter.com/oembed'],
  attribution: false,
  detect: ({
    href
  }) => /^https?:\/\/(?:mobile\.)?twitter\.com\/(?:#!\/)?[\w]+\/status\/?[\w]+/i.exec(href),

  async handleLink(href, [url]) {
    const {
      html
    } = await ajax({
      url: 'https://publish.twitter.com/oembed',
      query: {
        url,
        omit_script: false
      },
      type: 'json'
    });
    const $dummy = jquery_default()('<div>');
    return {
      type: 'GENERIC_EXPANDO',
      muted: true,
      expandoClass: 'selftext',
      generate: () => $dummy[0],
      onAttach: () => {
        $dummy.html(html);
      }
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vidble.js



/* harmony default export */ var vidble = (new Host('vidble', {
  name: 'vidble',
  domains: ['vidble.com'],
  logo: 'https://vidble.com/assets/ico/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(show|album)\/([a-z0-9]+)/i.exec(pathname),

  async handleLink(href, [, type, hash]) {
    switch (type) {
      case 'show':
        return {
          type: 'IMAGE',
          src: `https://vidble.com/${hash}_med.jpg`
        };

      case 'album':
        const urlObj = new URL(href);
        const {
          pics
        } = await ajax({
          url: string_namespaceObject.encode`https://vidble.com/album/album/${hash}?json=1`,
          type: 'json'
        });
        if (!pics.length) throw new Error('No images in gallery.');
        const src = pics.map((src, i) => {
          urlObj.hash = `#pic_${i}`;
          return {
            type: 'IMAGE',
            src,
            href: urlObj.href
          };
        });
        return {
          type: 'GALLERY',
          src
        };

      default:
        throw new Error(`This should never happen. Invalid type: ${type}`);
    }
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vimeo.js

/* harmony default export */ var vimeo = (new Host('vimeo', {
  name: 'vimeo',
  domains: ['vimeo.com'],
  attribution: false,
  detect: ({
    pathname
  }) => /^\/([0-9]+)(?:\/|$)/i.exec(pathname),

  handleLink(href, [, id]) {
    const embed = `https://player.vimeo.com/video/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoplay=true`,
      pause: '{"method":"pause"}',
      play: '{"method":"play"}',
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vlipsy.js

/* harmony default export */ var vlipsy = (new Host('vlipsy', {
  name: 'Vlipsy',
  domains: ['vlipsy.com'],
  logo: 'https://vlipsy.com/favicon.ico',
  detect: ({
    pathname
  }) => /^\/vlip\/(?:\w+-)*(\w+)$/.exec(pathname),

  handleLink(href, [, id]) {
    return {
      type: 'IFRAME',
      embed: `https://vlipsy.com/embed/${id}`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/vlive.js

/* harmony default export */ var vlive = (new Host('vlive', {
  name: 'VLive',
  domains: ['vlive.tv'],
  logo: 'https://www.vlive.tv/favicon.ico',
  detect: ({
    pathname
  }) => /^\/(?:video)\/([0-9]+)/i.exec(pathname),

  handleLink(href, [, id]) {
    const embed = `https://vlive.tv/embed/${id}`;
    return {
      type: 'IFRAME',
      embed,
      embedAutoplay: `${embed}?autoPlay=true`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/exec-loader?cache!./lib/core/metadata/packageInfo.js
/* harmony default export */ var packageInfo = ({"announcementsSubreddit":"RESAnnouncements","name":"Reddit Enhancement Suite","version":"5.22.5","isBeta":false,"isPatch":true,"isMinor":false,"isMajor":false,"updatedURL":"https://redditenhancementsuite.com/releases/#v5.22.5","homepageURL":"https://redditenhancementsuite.com"});
// CONCATENATED MODULE: ./lib/core/metadata/index.js

const {
  announcementsSubreddit,
  name: metadata_name,
  version: metadata_version,
  isBeta,
  isPatch,
  isMinor,
  isMajor,
  updatedURL,
  homepageURL
} = packageInfo;
// CONCATENATED MODULE: ./lib/modules/hosts/wikipedia.js





const req = url => ajax({
  url,
  type: 'json',
  headers: {
    'Api-User-Agent': `Reddit-Enhancement-Suite/${metadata_version} ( ${homepageURL} )`
  }
});

/* harmony default export */ var wikipedia = (new Host('wikipedia', {
  name: 'wikipedia',
  domains: ['wikipedia.org', 'wikipedia.com'],
  logo: 'https://en.wikipedia.org/static/favicon/wikipedia.ico',
  detect: url => url.pathname.startsWith('/wiki/') && {
    article: url.pathname.substr(6),
    language: url.host.split('.')[0],
    hash: decodeURIComponent(url.hash.substr(1))
  },

  async handleLink(href, {
    language,
    article,
    hash
  }) {
    if (language === 'www' || language === 'wikipedia') language = 'en';
    const {
      index: sectionId = 0
    } = hash && (await req(`https://${language}.wikipedia.org/w/api.php?action=parse&format=json&prop=sections&page=${article}&origin=*`)).parse.sections.find(({
      anchor
    }) => anchor === hash) || {};
    const {
      parse: html
    } = await req(`https://${language}.wikipedia.org/w/api.php?action=parse&format=json&prop=text|displaytitle&section=${sectionId}&page=${article}&origin=*`);
    const cleanDoc = new DOMParser().parseFromString(html.text['*'], 'text/html');

    for (const e of cleanDoc.querySelectorAll('.metadata, .hatnote, .mw-editsection, .mwe-math-mathml-inline, .reference, .references')) e.remove();

    for (const e of cleanDoc.querySelectorAll('a')) {
      e.href = new URL(e.getAttribute('href'), `https://${language}.wikipedia.org/wiki/${article}`).href;
    }

    return {
      type: 'TEXT',
      title: jquery_default()('<div>', {
        html: html.displaytitle || html.title
      }).text(),
      src: cleanDoc.body.innerHTML
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/xboxdvr.js

/* harmony default export */ var xboxdvr = (new Host('xboxdvr', {
  name: 'XboxDVR',
  domains: ['xboxdvr.com'],
  logo: 'https://gamerdvr.com/assets/favicon-240671aabcbf14dcaa1f3f2b406091d2.png',
  detect: ({
    pathname
  }) => /^\/(gamer\/[^\/]+\/\w+\/\d+)(?:\/|$)/.exec(pathname),

  handleLink(href, [, path]) {
    return {
      type: 'IFRAME',
      embed: `https://xboxdvr.com/${path}/embed`,
      fixedRatio: true
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/xkcd.js


/* harmony default export */ var xkcd = (new Host('xkcd', {
  name: 'xkcd',
  domains: ['xkcd.com'],
  permissions: ['https://xkcd.com/*/info.0.json'],
  logo: 'https://xkcd.com/favicon.ico',
  detect: ({
    hostname,
    pathname
  }) => ['xkcd.com', 'www.xkcd.com'].includes(hostname) && /^\/([0-9]+)(?:\/|$)/i.exec(pathname),

  async handleLink(href, [, id]) {
    const {
      title,
      alt,
      img
    } = await ajax({
      url: `https://xkcd.com/${id}/info.0.json`,
      type: 'json'
    });
    return {
      type: 'IMAGE',
      title,
      caption: alt,
      src: img
    };
  }

}));
// CONCATENATED MODULE: ./lib/modules/hosts/youtube.js



/* harmony default export */ var youtube = (new Host('youtube', {
  name: 'youtube',
  attribution: false,
  domains: ['youtube.com', 'youtu.be'],
  detect: ({
    pathname,
    hostname,
    searchParams
  }) => {
    const split = pathname.substring(1).split('/');
    if (split[0] === 'channel' && split[2] === 'live') return [`live_stream?channel=${split[1]}`, searchParams];
    if (hostname.endsWith('youtu.be')) return [split[0], searchParams];
    const vParam = searchParams.get('v');
    if (vParam) return [vParam, searchParams];
    if (/watch|embed|v/i.exec(split[0])) return [split[1], searchParams];
    const uParam = searchParams.get('u');

    if (split[0] === 'attribution_link' && uParam !== null) {
      const vParam = new URLSearchParams(uParam.split('?')[1]).get('v');
      if (vParam) return [vParam, searchParams];
    }
  },

  handleLink(href, [id, searchParams]) {
    const url = new URL(`https://www.youtube.com/embed/${id}`);
    url.searchParams.set('version', '3');
    url.searchParams.set('rel', '0');
    const tParam = searchParams.get('t');

    if (tParam) {
      let start = 0;
      const timeBlocks = {
        h: 3600,
        m: 60,
        s: 1
      };
      const timeMatch = tParam.match(/[0-9]+[hms]/ig);

      if (timeMatch) {
        for (const ts of timeMatch) {
          const unit = timeBlocks[ts.slice(-1)];
          const amount = parseInt(ts.slice(0, -1), 10);
          start += unit * amount;
        }
      } else {
        start = parseInt(tParam, 10);
        if (isNaN(start)) start = 0;
      }

      url.searchParams.set('start', String(start));
    }

    for (const k of ['end', 'start', 'list']) {
      const param = searchParams.get(k);
      if (param) url.searchParams.set(k, param);
    }

    return {
      type: 'IFRAME',
      embed: url.href,
      embedAutoplay: `${url.href}&autoplay=1`,
      fixedRatio: true
    };
  },

  getVideoData: Object(utils_async["a" /* batch */])(async ids => {
    const {
      items
    } = await ajax({
      url: 'https://www.googleapis.com/youtube/v3/videos',
      query: {
        id: [...ids].sort().join(','),
        part: ['id', 'contentDetails', 'snippet', 'statistics'].join(','),
        fields: `items(${['id', 'contentDetails(duration)', 'snippet(title,publishedAt)', 'statistics(viewCount)'].join(',')})`,
        key: 'AIzaSyB8ufxFN0GapU1hSzIbuOLfnFC0XzJousw'
      },
      type: 'json',
      cacheFor: utils_time["a" /* DAY */]
    });
    return ids.map(id => {
      const data = items.find(({
        id: _id
      }) => _id === id);

      try {
        const {
          contentDetails: {
            duration: rawDuration
          },
          snippet: {
            title,
            publishedAt
          },
          statistics: {
            viewCount
          }
        } = data;
        const duration = ['0'].concat(rawDuration.match(/^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/i).slice(1)).map(time => `0${time || 0}`.slice(-2)).filter((time, i, {
          length
        }) => +time !== 0 || i >= length - 2).join(':');
        return {
          title,
          duration,
          publishedAt,
          viewCount
        };
      } catch (e) {}
    });
  }, {
    size: 50,
    delay: 750
  })
}));
// CONCATENATED MODULE: ./lib/modules/hosts/znipe.js

/* harmony default export */ var znipe = (new Host('znipe', {
  name: 'ZnipeTV',
  domains: ['beta.znipe.tv', 'www.znipe.tv'],
  logo: 'https://assets.znipe.tv/icons/favicon.jpg',
  detect: ({
    searchParams
  }) => {
    const mParam = searchParams.get('m');
    if (mParam) return ['m', mParam];
    const vParam = searchParams.get('v');
    if (vParam) return ['v', vParam];
  },

  handleLink(href, [clipType, clipId]) {
    return {
      type: 'IFRAME',
      embed: `https://beta.znipe.tv/watch?${clipType}=${clipId}`
    };
  }

}));
// CONCATENATED MODULE: ./node_modules/sibling-loader?import=default!./lib/modules/hosts/default.js
/* generated by sibling-loader */




















































































/* harmony default export */ var modules_hosts_default = ({ "aarli.js": aarli, "adultswim.js": adultswim, "archilogic.js": archilogic, "archiveis.js": archiveis, "bime.js": bime, "clyp.js": clyp, "codepen.js": codepen, "coub.js": coub, "dailymotion.js": dailymotion, "default.js": hosts_default, "defaultAudio.js": defaultAudio, "defaultVideo.js": defaultVideo, "derpibooru.js": derpibooru, "deviantart.js": deviantart, "dropbox.js": dropbox, "facebookvideo.js": facebookvideo, "fiveHundredPx.js": fiveHundredPx, "flickr.js": flickr, "gamerdvr.js": gamerdvr, "getyarn.js": getyarn, "gfycat.js": gfycat, "gifyoutube.js": gifyoutube, "giphy.js": giphy, "github.js": github, "googlemaps.js": googlemaps, "gyazo.js": gyazo, "hastebin.js": hastebin, "iloopit.js": iloopit, "imgflip.js": imgflip, "imgur.js": imgur, "instagram.js": instagram, "ireddit.js": ireddit, "jsfiddle.js": jsfiddle, "liveleak.js": liveleak, "livememe.js": livememe, "makeameme.js": makeameme, "memecrunch.js": memecrunch, "memedad.js": memedad, "navertv.js": navertv, "onedrive.js": onedrive, "pastebin.js": pastebin, "peertube.js": peertube, "photobucket.js": photobucket, "pixiv.js": pixiv, "poly.js": poly, "pornhub.js": pornhub, "ppy.js": ppy, "redditbooru.js": redditbooru, "redditgallery.js": redditgallery, "redditmedia.js": redditmedia, "redditpoll.js": redditpoll, "reddituploads.js": reddituploads, "redgifs.js": redgifs, "ridewithgps.js": ridewithgps, "simplecove.js": simplecove, "snag.js": snag, "soundcloud.js": soundcloud, "spotify.js": spotify, "steamcommunity.js": steamcommunity, "steampowered.js": steampowered, "strawpollcom.js": strawpollcom, "strawpollme.js": strawpollme, "streamable.js": streamable, "streamja.js": streamja, "streamvi.js": streamvi, "supgif.js": supgif, "supload.js": supload, "tenor.js": tenor, "tuckbot.js": tuckbot, "tumblr.js": tumblr, "twimg.js": twimg, "twitch.js": twitch, "twitchclips.js": twitchclips, "twitter.js": twitter, "vidble.js": vidble, "vimeo.js": vimeo, "vlipsy.js": vlipsy, "vlive.js": vlive, "vreddit.js": vreddit, "wikipedia.js": wikipedia, "xboxdvr.js": xboxdvr, "xkcd.js": xkcd, "youtube.js": youtube, "znipe.js": znipe });
// CONCATENATED MODULE: ./lib/modules/showImages.js

















const siteModules = new Map(Array.from(Object.values(modules_hosts_default)).map(host => [host.moduleID, Object(flow["a" /* downcast */])(host, Host)]));
const genericHosts = [siteModules.get('default'), siteModules.get('defaultVideo'), siteModules.get('defaultAudio')].map(host => Object(flow["a" /* downcast */])(host, Host));
const showImages_module = new Module('showImages');
showImages_module.moduleName = 'showImagesName';
showImages_module.category = 'productivityCategory';
showImages_module.description = 'showImagesDesc';
showImages_module.bodyClass = true;
showImages_module.options = {
  mediaBrowse: {
    title: 'showImagesMediaBrowseTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMediaBrowseDesc'
  },
  browsePreloadCount: {
    title: 'showImagesBrowsePreloadCountTitle',
    type: 'text',
    value: '1',
    description: 'showImagesBrowsePreloadCountDesc',
    dependsOn: options => options.mediaBrowse.value
  },
  galleryPreloadCount: {
    title: 'showImagesGalleryPreloadCountTitle',
    type: 'text',
    value: '2',
    description: 'showImagesGalleryPreloadCountDesc'
  },
  collapseInlineMedia: {
    title: 'showImagesCollapseInlineMediaTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesCollapseInlineMediaDesc'
  },
  conserveMemory: {
    title: 'showImagesConserveMemoryTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesConserveMemoryDesc'
  },
  maxWidth: {
    title: 'showImagesMaxWidthTitle',
    type: 'text',
    value: '100%',
    description: 'showImagesMaxWidthDesc',
    advanced: true
  },
  maxHeight: {
    title: 'showImagesMaxHeightTitle',
    type: 'text',
    value: '80%',
    description: 'showImagesMaxHeightDesc',
    advanced: true
  },
  displayOriginalResolution: {
    title: 'showImagesDisplayOriginalResolutionTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesDisplayOriginalResolutionDesc'
  },
  selfTextMaxHeight: {
    title: 'showImagesSelfTextMaxHeightTitle',
    type: 'text',
    value: '0',
    description: 'showImagesSelfTextMaxHeightDesc',
    advanced: true
  },
  commentMaxHeight: {
    title: 'showImagesCommentMaxHeightTitle',
    type: 'text',
    value: '0',
    description: 'showImagesCommentMaxHeightDesc',
    advanced: true
  },
  autoMaxHeight: {
    title: 'showImagesAutoMaxHeightTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesAutoMaxHeightDesc',
    dependsOn: options => !!parseInt(options.selfTextMaxHeight.value, 10) || !!parseInt(options.commentMaxHeight.value, 10),
    advanced: true
  },
  openInNewWindow: {
    title: 'showImagesOpenInNewWindowTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesOpenInNewWindowDesc'
  },
  hideNSFW: {
    title: 'showImagesHideNSFWTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesHideNSFWDesc'
  },
  highlightNSFWButton: {
    title: 'showImagesHighlightNSFWButtonTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesHighlightNSFWButtonDesc',
    bodyClass: true
  },
  highlightSpoilerButton: {
    title: 'showImagesHighlightSpoilerButtonTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesHighlightSpoilerButtonDesc',
    bodyClass: true
  },
  imageZoom: {
    title: 'showImagesImageZoomTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesImageZoomDesc'
  },
  imageMove: {
    title: 'showImagesImageMoveTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesImageMoveDesc'
  },
  mediaControls: {
    title: 'showImagesMediaControlsTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMediaControlsDesc'
  },
  mediaControlsPosition: {
    title: 'showImagesMediaControlsPositionTitle',
    dependsOn: options => options.mediaControls.value,
    type: 'enum',
    value: 'top-left',
    values: [{
      name: 'Top left',
      value: 'top-left'
    }, {
      name: 'Top right',
      value: 'top-right'
    }, {
      name: 'Bottom left.',
      value: 'bottom-left'
    }, {
      name: 'Bottom right.',
      value: 'bottom-right'
    }],
    description: 'showImagesMediaControlsPositionDesc'
  },
  clippy: {
    title: 'showImagesClippyTitle',
    dependsOn: options => options.mediaControls.value,
    type: 'boolean',
    value: true,
    description: 'showImagesClippyDesc'
  },
  crossposts: {
    title: 'showImagesCrosspostsTitle',
    description: 'showImagesCrosspostsDescription',
    type: 'enum',
    value: 'withMetadata',
    values: [{
      name: 'Do not replace Reddit crosspost expando',
      value: 'none'
    }, {
      name: 'Show with original post\'s metadata',
      value: 'withMetadata'
    }, {
      name: 'Show without metadata',
      value: 'plain'
    }]
  },
  displayImageCaptions: {
    title: 'showImagesDisplayImageCaptionsTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesDisplayImageCaptionsDesc',
    advanced: true,
    bodyClass: true
  },
  captionsPosition: {
    title: 'showImagesCaptionsPositionTitle',
    dependsOn: options => options.displayImageCaptions.value,
    type: 'enum',
    value: 'titleAbove',
    values: [{
      name: 'Display all captions above image.',
      value: 'allAbove'
    }, {
      name: 'Display title and caption above image, credits below.',
      value: 'creditsBelow'
    }, {
      name: 'Display title above image, caption and credits below.',
      value: 'titleAbove'
    }, {
      name: 'Display all captions below image.',
      value: 'allBelow'
    }],
    description: 'showImagesCaptionsPositionDesc',
    advanced: true,
    bodyClass: true
  },
  markVisited: {
    title: 'showImagesMarkVisitedTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesMarkVisitedDesc',
    advanced: true
  },
  markSelftextVisited: {
    title: 'showImagesMarkSelftextVisitedTitle',
    dependsOn: options => options.markVisited.value,
    type: 'boolean',
    value: false,
    description: 'showImagesMarkSelftextVisitedDesc',
    advanced: true
  },
  sfwHistory: {
    title: 'showImagesSfwHistoryTitle',
    dependsOn: options => options.markVisited.value,
    type: 'enum',
    value: 'add',
    values: [{
      name: 'Add links to history',
      value: 'add'
    }, {
      name: 'Do not add or color links.',
      value: 'none'
    }],
    description: 'showImagesSfwHistoryDesc'
  },
  galleryRememberWidth: {
    title: 'showImagesGalleryRememberWidthTitle',
    dependsOn: options => options.imageZoom.value,
    type: 'boolean',
    value: true,
    description: 'showImagesGalleryRememberWidthDesc'
  },
  galleryAsFilmstrip: {
    title: 'showImagesGalleryAsFilmstripTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesGalleryAsFilmstripDesc'
  },
  filmstripLoadIncrement: {
    title: 'showImagesFilmstripLoadIncrementTitle',
    dependsOn: options => options.galleryAsFilmstrip.value,
    type: 'text',
    value: '30',
    description: 'showImagesFilmstripLoadIncrementDesc'
  },
  useSlideshowWhenLargerThan: {
    title: 'showImagesUseSlideshowWhenLargerThanTitle',
    dependsOn: options => options.galleryAsFilmstrip.value,
    type: 'text',
    value: '0',
    description: 'showImagesUseSlideshowWhenLargerThanDesc'
  },
  showViewImagesTab: {
    title: 'showImagesShowViewImagesTabTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesShowViewImagesTabDesc'
  },
  autoExpandTypes: {
    title: 'showImagesAutoExpandTypesTitle',
    type: 'enum',
    value: 'any',
    values: [{
      name: 'Images (but occasionally also .gif)',
      value: 'image'
    }, {
      name: 'Images, text',
      value: 'image text'
    }, {
      name: 'Images, text, galleries, and muted videos',
      value: 'image text gallery video'
    }, {
      name: 'All muted expandos (includes iframes)',
      value: 'any'
    }],
    description: 'showImagesAutoExpandTypesDesc'
  },
  autoExpandSelfText: {
    title: 'showImagesAutoExpandSelfTextTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesAutoExpandSelfTextDesc'
  },
  autoExpandSelfTextFirstVisibleNonMuted: {
    title: 'showImagesAutoExpandSelfTextFirstVisibleNonMutedTitle',
    dependsOn: options => options.autoExpandSelfText.value,
    type: 'boolean',
    value: true,
    description: 'showImagesAutoExpandSelfTextFirstVisibleNonMutedDesc'
  },
  autoExpandSelfTextNSFW: {
    title: 'showImagesAutoExpandSelfTextNSFWTitle',
    dependsOn: options => options.autoExpandSelfText.value,
    type: 'boolean',
    value: false,
    description: 'showImagesAutoExpandSelfTextNSFWDesc'
  },
  showSiteAttribution: {
    title: 'showImagesShowSiteAttributionTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesShowSiteAttributionDesc'
  },
  expandoCommentRedirects: {
    title: 'showImagesExpandoCommentRedirectsTitle',
    type: 'enum',
    value: 'expando',
    values: [{
      name: 'Do nothing',
      value: 'nothing'
    }, {
      name: 'Create expandos',
      value: 'expando'
    }, {
      name: 'Create expandos, redirect the link back to the image',
      value: 'rewrite'
    }],
    description: 'showImagesExpandoCommentRedirectsDesc'
  },
  startVideosMuted: {
    title: 'showImagesStartVideosMutedTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesStartVideosMutedDesc'
  },
  maxSimultaneousPlaying: {
    title: 'showImagesMaxSimultaneousPlayingTitle',
    type: 'text',
    value: '0',
    description: 'showImagesMaxSimultaneousPlayingDesc'
  },
  autoplayVideo: {
    title: 'showImagesAutoplayVideoTitle',
    type: 'boolean',
    value: true,
    description: 'showImagesAutoplayVideoDesc'
  },
  hidePinnedRedditVideos: {
    title: 'showImagesHidePinnedRedditVideosTitle',
    type: 'boolean',
    value: false,
    description: 'showImagesHidePinnedRedditVideosDesc',
    bodyClass: true
  },
  ...Array.from(siteModules.values()).reduce((options, siteModule) => {
    if (genericHosts.includes(siteModule)) return options;
    const key = siteModuleOptionKey(siteModule);
    options[key] = {
      title: siteModule.name,
      description: 'showImagesHostToggleDesc',
      value: true,
      type: 'boolean'
    };

    if (siteModule.options) {
      Object.assign(options, siteModule.options);
      Object.values(siteModule.options).map(v => {
        const origDependsOn = v.dependsOn;

        v.dependsOn = options => options[key].value && (!origDependsOn || origDependsOn());
      });
    }

    return options;
  }, {})
};

showImages_module.onInit = () => {
  if (Object(utils_location["i" /* isAppType */])('r2')) {
    const preventVideoPlayerScriptTasks = [stopPageContextScript(script => /^\/?videoplayer\./.test(new URL(script.src, location.origin).pathname), 'head', true), stopPageContextScript(script => !!script.innerHTML.match('RedditVideoPlayer'), pagePhases.contentStart.then(() => document.querySelector('#siteTable')), false)];
    loadOptions.then(() => {
      const removeNativePlayer = isRunning(showImages_module) && isSiteModuleEnabled(vreddit) && vreddit.options && vreddit.options.forceReplaceNativeExpando.value;
      if (!removeNativePlayer) Object(utils_array["d" /* forEachSeq */])(preventVideoPlayerScriptTasks, ({
        undo
      }) => undo());
    });
  }
};

showImages_module.exclude = [/^\/ads\/[\-\w\._\?=]*/i, 'submit', /^\/subreddits/i];

showImages_module.beforeLoad = () => {
  const selfTextMaxHeight = parseInt(showImages_module.options.selfTextMaxHeight.value, 10);

  if (selfTextMaxHeight) {
    Object(dom["b" /* addCSS */])(`
			.selftext.expanded ~ * .md {
				max-height: ${selfTextMaxHeight}px;
				overflow-y: auto !important;
				position: relative;
			}
		`);
  }

  const commentMaxHeight = parseInt(showImages_module.options.commentMaxHeight.value, 10);

  if (commentMaxHeight) {
    Object(dom["b" /* addCSS */])(`
			.comment .md {
				max-height: ${commentMaxHeight}px;
				overflow-y: auto !important;
				position: relative;
			}
		`);
  }

  Object(watchers["watchForElements"])(['selfText'], null, scanBody);
  Object(watchers["watchForThings"])(['comment', 'message'], thing => scanBody(thing.getTextBody()), {
    id: showImages_module
  });
  Object(watchers["watchForThings"])(['post'], thing => checkElementForMedia(thing.getPostLink()), {
    id: showImages_module
  });
  watchForRedditEvents('comment', (placeholder, {
    _: {
      update
    }
  }) => {
    if (update) return;
    const comment = placeholder.closest('.Comment');
    scanBody(comment);
  });
  watchForRedditEvents('postAuthor', (placeholder, {
    _: {
      update
    }
  }) => {
    if (update) return;
    const body = placeholder.closest('[data-test-id="post-content"]');
    if (body && body.querySelector('.media-element')) return;
    scanBody(body);
  });
};

showImages_module.contentStart = () => {
  if (showImages_module.options.showViewImagesTab.value && Object(utils_location["i" /* isAppType */])('r2')) {
    viewImagesButton();
  }

  if (showImages_module.options.mediaBrowse.value) {
    selectedThing_namespaceObject.addListener(mediaBrowse, 'instantly');
  }

  if (showImages_module.options.autoMaxHeight.value) {
    jquery_default()(document.body).on('mediaResize', '.thing > .entry', updateParentHeight);
  }
};

showImages_module.go = () => {
  if (Object(utils_location["n" /* isPageType */])('wiki')) scanBody(document.querySelector('.wiki-page-content'));
  const spotlight = document.querySelector('#siteTable_organic');

  if (spotlight) {
    const nextprev = spotlight.querySelector('.nextprev');

    if (nextprev) {
      nextprev.addEventListener('click', () => {
        const open = spotlight.querySelector('.expando-button.expanded');
        if (open) open.click();
      });
    }
  }
};

showImages_module.afterLoad = () => {
  if (showImages_module.options.conserveMemory.value) {
    enableConserveMemory();
  }
};

function siteModuleOptionKey(siteModule) {
  const id = siteModule.moduleID;
  return `display_${id}`;
}

function isSiteModuleEnabled(siteModule) {
  const key = siteModuleOptionKey(siteModule);
  return !showImages_module.options[key] || showImages_module.options[key].value;
}

const sitesMap = Object(once["a" /* default */])(() => Array.from(siteModules.values()).filter(isSiteModuleEnabled).reduce((map, siteModule) => {
  for (const domain of siteModule.domains) {
    map.set(domain, (map.get(domain) || []).concat(siteModule));
  }

  return map;
}, new Map()));

function* modulesForHostname(hostname) {
  do {
    for (const m of sitesMap().get(hostname) || []) yield m;
  } while (hostname = hostname.replace(/^.+?(\.|$)/, ''));

  for (const m of genericHosts) yield m;
}

function enableConserveMemory() {
  const fullscreenActive = () => !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);

  const rootMargin = '50% 100000%';
  const boxMap = new WeakMap();
  const ioBox = new IntersectionObserver(entries => {
    for (const {
      isIntersecting,
      target
    } of entries) {
      if (!isIntersecting && fullscreenActive()) return;
      const {
        media
      } = Object(flow["a" /* downcast */])(boxMap.get(target), expando_Expando);
      if (media) media.setLoaded(isIntersecting);else ioBox.unobserve(target);
    }
  }, {
    rootMargin
  });
  const buttonMap = new WeakMap();
  const ioButton = new IntersectionObserver(entries => {
    if (fullscreenActive()) return;

    for (const {
      isIntersecting,
      target
    } of entries) {
      const expando = Object(flow["a" /* downcast */])(buttonMap.get(target), expando_Expando);
      const {
        open
      } = expando;

      if (!isIntersecting && !open) {
        ioButton.unobserve(target);
        expando.empty();
      }
    }
  }, {
    rootMargin
  });
  window.addEventListener('scroll', Object(utils_async["f" /* idleThrottle */])(() => {
    for (const expando of activeExpandos.values()) {
      if (expando.isAttached()) {
        const {
          box,
          media,
          button
        } = expando;
        if (!media) continue;

        if (media.supportsUnload()) {
          ioBox.observe(box);
        } else {
          ioBox.unobserve(box);
        }

        boxMap.set(box, expando);
        ioButton.observe(button);
        buttonMap.set(button, expando);
      } else {
        expando.destroy();
      }
    }
  }));
}

let autoExpandActive = false;
let mediaBrowseModeActive = false;
const viewImagesButton = Object(once["a" /* default */])(() => createElement_namespaceObject.tabMenuItem({
  text: 'show images',
  className: 'res-show-images',
  onChange: active => {
    autoExpandActive = active;

    for (const expando of expando_expandos.values()) {
      if (!(expando instanceof expando_Expando && expando.ready && expando.button.offsetParent)) continue;
      const open = isExpandWanted(expando);
      if (open) expando.expand();else if (!autoExpandActive) expando.collapse();
    }
  }
}));
async function toggleThingExpandos(thing, {
  scrollOnToggle
} = {}) {
  const gate = thing.entry.querySelector('.expando-gate__show-once');

  if (gate) {
    gate.click();
    return;
  }

  const expandos = expando_Expando.getAllExpandosFrom(thing);
  if (!expandos.length) return;
  const openExpandos = expandos.filter(v => v.open);

  if (openExpandos.length) {
    for (const expando of openExpandos) expando.collapse();

    if (scrollOnToggle) {
      Object(dom["l" /* scrollToElement */])(thing.entry, null, {
        scrollStyle: 'directional',
        restrictDirectionTo: 'up'
      });
    }
  } else {
    for (const expando of expandos) {
      const lock = expando instanceof expando_Expando && expando.lock;

      if (lock) {
        lock.open();
        await lock.promise;
      }

      if (!(expando instanceof expando_Expando) || isExpandWanted(expando, {
        thing,
        autoExpandFirstVisibleNonMutedInThing: true,
        autoExpand: true,
        autoExpandTypes: [],
        ignoreDuplicatesScope: thing.entry
      })) {
        expando.expand();
      }
    }

    if (scrollOnToggle) {
      Object(dom["l" /* scrollToElement */])(thing.entry, null, {
        scrollStyle: 'top',
        restrictDirectionTo: 'down'
      });
    }
  }
}
const preloadExpandos = Object(utils_async["f" /* idleThrottle */])((fromThing, direction, preloadCount = parseInt(showImages_module.options.browsePreloadCount.value, 10)) => {
  const pieces = [];
  let target = fromThing;

  do {
    const expando = expando_Expando.getEntryExpandoFrom(target);
    if (expando && expando instanceof expando_Expando) pieces.push(expando);
  } while ((target = target.getNext({
    direction
  })) && pieces.length <= preloadCount);

  preloadMedia(pieces);
});

function mediaBrowse(selected, unselected, options) {
  if (!selected || !options.allowMediaBrowse || autoExpandActive) return;
  const oldExpando = expando_Expando.getEntryExpandoFrom(unselected);
  const newExpando = expando_Expando.getEntryExpandoFrom(selected);

  if (oldExpando) {
    mediaBrowseModeActive = oldExpando.expandWanted || oldExpando.open;
    oldExpando.collapse();
  }

  if (mediaBrowseModeActive && newExpando) {
    newExpando.expand();
    options.scrollStyle = 'top';
    preloadExpandos(selected, options.direction);
  }
}

function hasEntryAnyExpandedNonMuted(thing) {
  return expando_Expando.getTextExpandosFrom(thing).some(expando => expando.types.includes('non-muted') && (expando.open || expando.expandWanted));
}

const showImages_types = ['selftext', 'video', 'image', 'iframe', 'gallery', 'native', 'muted', 'non-muted'];
function matchesTypes(wantedTypes, expandoTypes = showImages_types) {
  return !wantedTypes.length || !!lodash_es_intersection(expandoTypes, wantedTypes).length;
}

function isExpandWanted(expando, {
  thing,
  autoExpand = autoExpandActive,
  autoExpandTypes = showImages_module.options.autoExpandTypes.value.replace('any', '').split(' ').filter(Boolean),
  ignoreDuplicates = true,
  ignoreDuplicatesScope,
  onlyExpandMuted = true,
  autoExpandFirstVisibleNonMutedInThing = false,
  treatVideosAsMutedIfStartingMuted = true
} = {}) {
  if (ignoreDuplicates) {
    const duplicates = expando.getDuplicates().filter(v => activeExpandos.has(v));

    if (duplicates.length) {
      if (!ignoreDuplicatesScope) return false;
      if (duplicates.some(v => ignoreDuplicatesScope.contains(v.button))) return false;
    }
  }

  const expandoIsNonMuted = expando.types.includes('non-muted');
  const typeCriteriaOK = matchesTypes(autoExpandTypes, expando.types);
  const muteCriteriaOK = !(onlyExpandMuted && expandoIsNonMuted) || treatVideosAsMutedIfStartingMuted && expando.types.includes('video') && showImages_module.options.startVideosMuted.value || autoExpandFirstVisibleNonMutedInThing && Object(dom["d" /* elementInViewport */])(expando.button) && !hasEntryAnyExpandedNonMuted(thing);
  return autoExpand && muteCriteriaOK && typeCriteriaOK;
}

function resolveMediaUrl(element, thing) {
  if (showImages_module.options.expandoCommentRedirects.value !== 'nothing' && thing && element.classList.contains('title')) {
    const dataUrl = thing.element.getAttribute('data-url');
    const fullDataUrl = dataUrl && new URL(dataUrl, location.href);
    const commentLink = thing.getCommentsLink();

    if (fullDataUrl && commentLink && fullDataUrl.href !== commentLink.href) {
      return fullDataUrl;
    }
  }

  return new URL(element.href, location.href);
}

function promptSiteModulePermissions(siteModule) {
  const {
    name,
    permissions = []
  } = siteModule;
  const message = string_namespaceObject.html`<div>
		<p>In order to inline expand content from ${name}, RES needs permission to access these sites:</p>
		<p><code>${permissions.map(url => `${/((?:\w+\.)+\w+)(?=\/|$)/i.exec(url)[0]}`).join(', \n')}</code></p>
		<p>Be assured RES does not access/modify any of your information on these domains - it only accesses the public API.</p>
		<hr>
		<p>If you prefer not to use RES' expando for these sites, you may:</p>
		<button>Disable this host</button>
	</div>`;
  const notification = notifications_showNotification({
    header: 'Permission required',
    moduleID: 'permissions',
    closeDelay: Infinity,
    message
  });
  const disableHostButton = message.querySelector('button');
  return Promise.race([permissions_namespaceObject.request(permissions).catch(() => new Promise(() => {})), Object(dom["r" /* waitForEvent */])(disableHostButton, 'click').then(() => {
    const opt = showImages_module.options[siteModuleOptionKey(siteModule)];
    opt.value = false;
    options_save(opt);
    return Promise.reject(new Error('Host disabled'));
  })]).finally(() => {
    notification.close();
  });
}

const generateSiteModuleLock = Object(memoize["a" /* default */])(async siteModule => {
  if (!siteModule.permissions || (await permissions_namespaceObject.has(siteModule.permissions))) return;
  let resolve, reject;
  return {
    promise: new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    }),
    open: () => promptSiteModulePermissions(siteModule).then(resolve, reject)
  };
});

function scanBody(element) {
  if (!element) return;
  const promises = [...element.querySelectorAll('a')].filter(link => {
    const existingContent = link.querySelector('img, video');

    if (existingContent && showImages_module.options.collapseInlineMedia.value && existingContent.matches('[src^="https://external-preview.redd.it"')) {
      if (existingContent.hasAttribute('src')) {
        link.href = existingContent.getAttribute('src');
      }

      existingContent.replaceWith(string_namespaceObject.html`<i>Collapsed inline media</i>`);
      return true;
    }

    return !existingContent;
  }).map(link => checkElementForMedia(Object(flow["a" /* downcast */])(link, HTMLAnchorElement)));
  return Promise.allSettled(promises);
}

const linksMap = new WeakMap();
function getLinkExpando(link) {
  return linksMap.get(link);
}

const inText = element => !!element.closest('.md, .search-result-footer');

async function checkElementForMedia(element) {
  const thing = Thing["a" /* Thing */].from(element);
  const entryExpando = !inText(element) && expando_Expando.getEntryExpandoFrom(thing);
  const nativeExpando = entryExpando instanceof expando_Expando ? null : entryExpando;

  if (showImages_module.options.hideNSFW.value && thing && thing.isNSFW()) {
    if (nativeExpando) nativeExpando.detach();
    return;
  }

  if (nativeExpando) {
    trackNativeExpando(nativeExpando, element, thing);
  }

  if (thing && thing.isCrosspost() && showImages_module.options.crossposts.value === 'none') {
    return;
  }

  const mediaUrl = resolveMediaUrl(element, thing);

  if (mediaUrl && showImages_module.options.expandoCommentRedirects.value === 'rewrite') {
    element.href = mediaUrl.href;
    element.removeAttribute('data-inbound-url');
  }

  for (const siteModule of modulesForHostname(mediaUrl.hostname)) {
    const detectResult = siteModule.detect(mediaUrl, thing);
    if (!detectResult) continue;

    if (nativeExpando) {
      const forceReplaceNativeExpandoOption = siteModule.options && siteModule.options.forceReplaceNativeExpando;

      if (nativeExpando.open && !(forceReplaceNativeExpandoOption && forceReplaceNativeExpandoOption.value)) {
        console.log('Native expando has already been opened; skipping.', element.href);
        return;
      }

      nativeExpando.detach();
    }

    const expando = new expando_Expando(mediaUrl.href);
    placeExpando(expando, element, thing);
    expando.onExpand(() => {
      trackMediaLoad(element, thing);
    });
    linksMap.set(element, expando);
    const lock = await generateSiteModuleLock(siteModule);
    if (lock) expando.setLock(lock);

    try {
      if (lock) await lock.promise;
      await completeExpando(expando, thing, siteModule, detectResult);
      break;
    } catch (e) {
      console.error(`showImages: could not create expando for ${mediaUrl.href}`, e);
      if (nativeExpando) nativeExpando.reattach();
      expando.destroy();
      linksMap.delete(element);
    }
  }
}

function placeExpando(expando, element, thing) {
  if (!inText(element) && thing && thing.getTitleElement()) {
    if (element.parentElement) element.parentElement.after(expando.button);
    const sibling = expando.button.nextElementSibling;
    if (sibling && sibling.classList.contains('expando-button')) sibling.after(expando.button);
    thing.entry.appendChild(expando.box);
  } else {
    jquery_default()(element).add(jquery_default()(element).next('.keyNavAnnotation')).last().after(expando.box).after(jquery_default()('<span class="res-freetext-expando">').append(expando.button));
  }
}

async function completeExpando(expando, thing, siteModule, detectResult) {
  const mediaOptions = await siteModule.handleLink(expando.href, detectResult);

  if (mediaOptions.title && thing && string_namespaceObject.areSimilar(mediaOptions.title, thing.getTitle())) {
    mediaOptions.title = '';
  }

  const attribution = showImages_module.options.showSiteAttribution.value && thing && thing.isPost() && !thing.isSelfPost() && siteModule.domains.length && siteModule.attribution !== false;

  const isMuted = media => media.muted || ['IMAGE', 'TEXT'].includes(media.type);

  const muted = mediaOptions.type === 'GALLERY' ? mediaOptions.src.every(isMuted) : isMuted(mediaOptions);
  expando.initialize({
    types: [mediaOptions.type, muted ? 'muted' : 'non-muted', ...(mediaOptions.expandoClass || '').split(' ')].filter(v => v).map(s => s.toLowerCase()),
    buttonInfo: getMediaButtonInfo(mediaOptions),

    generateMedia() {
      const media = generateMedia(mediaOptions, {
        href: expando.href
      });

      if (showImages_module.options.crossposts.value === 'withMetadata' && thing && thing.isCrosspost()) {
        media.element.prepend(crosspostMetadataTemplate(thing.element.dataset));
      }

      if (attribution) addSiteAttribution(siteModule, media);
      return media;
    }

  });
  expando.button.setAttribute('data-host', siteModule.moduleID);
  expando.box.setAttribute('data-host', siteModule.moduleID);
  const hideButton = thing && thing.getHideElement();
  if (hideButton) hideButton.addEventListener('click', () => {
    expando.destroy();
  });

  if (thing && thing.isComment()) {
    expando.onExpand(Object(once["a" /* default */])(() => {
      let wasOpen;
      jquery_default()([thing, ...thing.getParents()].map(e => e.entry)).find('.tagline > .expand, > .buttons .toggleChildren').click(() => {
        if (thing.isContentVisible()) {
          if (wasOpen && expando.media) expando.expand();
        } else {
          wasOpen = expando.open;
          if (expando.open) expando.collapse();
        }
      });
    }));
  }

  expando.onExpand(() => {
    const lightbox = expando.media.element.closest('#overlayScrollContainer');
    if (lightbox) lightbox.firstChild.style.overflowY = 'initial';
  });
  expando.button.addEventListener('mousedown', () => {
    preloadMedia([expando]);
  });

  if (!expando.open) {
    let autoExpand;
    let autoExpandFirstVisibleNonMutedInThing;

    if (showImages_module.options.autoExpandSelfText.value && inText(expando.button) && thing && thing.isSelfPost() && !Object(utils_location["n" /* isPageType */])('comments')) {
      const dontAutoExpandNSFW = !showImages_module.options.autoExpandSelfTextNSFW.value && thing.isNSFW();
      autoExpand = !dontAutoExpandNSFW;
      autoExpandFirstVisibleNonMutedInThing = showImages_module.options.autoExpandSelfTextFirstVisibleNonMuted.value;
    }

    if (isExpandWanted(expando, {
      thing,
      autoExpand,
      autoExpandFirstVisibleNonMutedInThing
    })) {
      expando.expand();
    }
  }
}

function updateParentHeight(e) {
  const thing = Thing["a" /* Thing */].checkedFrom(e.currentTarget);
  const basisHeight = thing.isSelfPost() && parseInt(showImages_module.options.selfTextMaxHeight.value, 10) || thing.isComment() && parseInt(showImages_module.options.commentMaxHeight.value, 10) || 0;

  if (basisHeight > 0) {
    const expandoHeight = Array.from(thing.entry.querySelectorAll('.res-expando-box, .expando-button.expanded')).reduce((a, b) => a + b.getBoundingClientRect().height, 0);
    thing.getTextBody().style.maxHeight = `${basisHeight + expandoHeight}px`;
  }
}

function trackNativeExpando(expando, element, thing) {
  if (!showImages_module.options.markSelftextVisited.value && expando.button.classList.contains('selftext')) return;
  const trackLoad = Object(once["a" /* default */])(() => trackMediaLoad(element, thing));
  if (expando.open) trackLoad();else expando.button.addEventListener('click', trackLoad);
}

function getMediaButtonInfo(options) {
  let title = '';
  let type = options.type;

  if (options.type === 'GALLERY') {
    if (options.src.length === 1) {
      type = options.src[0].type;
    } else {
      title += `${options.src.length} items in gallery`;
    }
  }

  const defaultClass = {
    IMAGE: 'image',
    GALLERY: 'image gallery',
    TEXT: 'selftext',
    VIDEO: options.muted ? 'video-muted' : 'video',
    IFRAME: options.muted ? 'video-muted' : 'video',
    AUDIO: 'video',
    GENERIC_EXPANDO: 'selftext'
  }[type];
  return {
    title,
    mediaClass: options.expandoClass || defaultClass
  };
}

let lastPreloadIndex = 0;

function preloadMedia(pieces) {
  const index = ++lastPreloadIndex;
  return Object(utils_array["d" /* forEachSeq */])(pieces, piece => {
    if (!piece.generateMedia) return;
    if (lastPreloadIndex !== index) return;
    piece.media = piece.media || piece.generateMedia();
    return piece.media.ready;
  });
}

function generateMedia(options, context) {
  if (options.credits) options.credits = purify_es.sanitize(options.credits);
  if (options.caption) options.caption = purify_es.sanitize(options.caption);

  switch (options.type) {
    case 'GALLERY':
      return new showImages_Gallery(options, context);

    case 'IMAGE':
      return new showImages_Image(options, context);

    case 'TEXT':
      return new showImages_Text(options);

    case 'IFRAME':
      return new showImages_Iframe(options);

    case 'VIDEO':
      return new showImages_Video(options, context);

    case 'AUDIO':
      return new showImages_Audio(options);

    case 'GENERIC_EXPANDO':
      return new Generic(options);

    default:
      throw new Error(`Unreachable: invalid media type ${options.type}`);
  }
}

const observed = new WeakMap();
const resizeObserver = new ResizeObserver(entries => {
  for (const {
    target,
    contentRect
  } of entries) {
    const callback = observed.get(target);
    if (callback) callback(contentRect);
  }
});
class showImages_Media {
  constructor() {
    this.element = void 0;
    this.ready = void 0;
    this.onAttach = void 0;
    this.onResize = [];
    this.resizing = void 0;
    this.rotationState = 0;
    this._loaded = true;
  }

  isAttached() {
    return document.body.contains(this.element);
  }

  expand() {
    this.setLoaded(true);
  }

  collapse() {
    this.setLoaded(false);
  }

  supportsUnload() {
    return false;
  }

  _unload() {}

  _restore() {}

  setLoaded(state) {
    if (state === this._loaded) return;
    this._loaded = state;
    if (state) this._restore();else this._unload();
  }

  makeIndependent(element) {
    const wrapper = document.createElement('div');
    const independent = document.createElement('div');
    element.replaceWith(wrapper);
    wrapper.appendChild(independent);
    independent.appendChild(element);
    independent.classList.add('res-media-independent');
    wrapper.style.willChange = 'height';

    this.resizing = (contentRect = element.getBoundingClientRect()) => {
      for (const callback of this.onResize) callback(contentRect);

      wrapper.style.height = `${contentRect.height}px`;
    };

    this.onResize.push(contentRect => {
      this.element.dispatchEvent(new CustomEvent('mediaResize', {
        detail: contentRect,
        bubbles: true
      }));
    });
    observed.set(element, contentRect => {
      if (!this._loaded) return;
      if (this.resizing) this.resizing(contentRect);
    });
    resizeObserver.observe(element);
    Object(dom["r" /* waitForEvent */])(element, 'mediaManuallyMovedVertically').then(() => {
      resizeObserver.unobserve(element);
    });
  }

  keepVisible(element) {
    element.classList.add('res-element-keep-visible');
    const basisLeft = Object(once["a" /* default */])(() => Object(flow["a" /* downcast */])(element.parentElement, HTMLElement).getBoundingClientRect().left);
    let isAligned = false;
    this.onResize.push(({
      width: elementWidth
    }) => {
      const {
        width: viewportWidth
      } = Object(dom["i" /* getViewportSize */])();
      if (!isAligned && basisLeft() + elementWidth < viewportWidth) return;
      const {
        left: elementLeft,
        right: elementRight
      } = element.getBoundingClientRect();
      const deltaLeft = elementLeft - basisLeft();

      if (elementWidth > viewportWidth) {
        isAligned = true;
        showImages_move(element, -elementLeft, 0);
      } else if (elementRight - deltaLeft > viewportWidth) {
        isAligned = true;
        showImages_move(element, viewportWidth - elementRight, 0);
      } else if (deltaLeft) {
        isAligned = false;
        showImages_move(element, -deltaLeft, 0);
      }
    });
  }

  setMaxSize(element) {
    let value = showImages_module.options.maxWidth.value;
    let isPercentage = value.endsWith('%');
    const maxWidth = (isPercentage ? Object(dom["i" /* getViewportSize */])().width / 100 : 1) * parseInt(value, 10);
    if (maxWidth) element.style.maxWidth = `${maxWidth}px`;
    value = showImages_module.options.maxHeight.value;
    isPercentage = value.endsWith('%');
    const maxHeight = (isPercentage ? Object(dom["i" /* getViewportSize */])().height / 100 : 1) * parseInt(value, 10);
    if (maxHeight) element.style.maxHeight = `${maxHeight}px`;
  }

  makeZoomable(element, dragInitiater = element, absoluteSizing = false) {
    if (!showImages_module.options.imageZoom.value) return;
    element.classList.add('res-media-zoomable');
    let initialWidth, initialHeight, initialDiagonal, left, top;

    function getDiagonal(x, y) {
      const w = Math.max(1, x - left);
      const h = Math.max(1, y - top);
      return Math.round(Math.hypot(w, h));
    }

    addDragListener({
      media: this.element,
      element: dragInitiater,
      atShiftKey: false,
      onStart: (x, y) => {
        ({
          left,
          top,
          width: initialWidth,
          height: initialHeight
        } = element.getBoundingClientRect());
        initialDiagonal = getDiagonal(x, y);
      },
      onMove: (x, y, deltaX, deltaY) => {
        const conversionFactor = this.rotationState % 2 ? initialHeight / initialWidth : 1;

        if (absoluteSizing) {
          const {
            width,
            height
          } = element.getBoundingClientRect();
          resize(element, (width + deltaX) * conversionFactor, (height + deltaY) / conversionFactor);
        } else {
          const newWidth = getDiagonal(x, y) / initialDiagonal * initialWidth;
          resize(element, newWidth * conversionFactor);
        }
      }
    });
  }

  makeMovable(element, dragInitiater = element) {
    if (!showImages_module.options.imageMove.value) return;
    element.classList.add('res-media-movable');
    addDragListener({
      media: this.element,
      element: dragInitiater,
      atShiftKey: true,

      onMove(x, y, deltaX, deltaY) {
        showImages_move(element, deltaX, deltaY);
      }

    });
  }

  addControls(element, lookupUrl, downloadUrl) {
    if (!showImages_module.options.mediaControls.value) return element;
    const [y, x] = showImages_module.options.mediaControlsPosition.value.split('-');
    const wrapper = mediaControlsTemplate({
      clippy: showImages_module.options.clippy.value,
      lookupUrl,
      downloadUrl,
      x,
      y
    });
    element.replaceWith(wrapper);
    wrapper.appendChild(element);
    element.classList.add('res-media-rotatable');

    const compensateTransformedSize = () => {
      const {
        width,
        height
      } = element.getBoundingClientRect();
      Object.assign(wrapper.style, {
        width: `${width}px`,
        height: `${height}px`
      });
    };

    const compensateTransformedSizeObserver = new ResizeObserver(compensateTransformedSize);

    const updateRotation = () => {
      compensateTransformedSizeObserver.observe(element);
      element.setAttribute('rotation', String(positiveModulo(this.rotationState, 4)));
      compensateTransformedSize();
    };

    wrapper.querySelector('.res-media-controls').addEventListener('click', e => {
      switch (e.target.dataset.action) {
        case 'rotateLeft':
          --this.rotationState;
          updateRotation();
          break;

        case 'rotateRight':
          ++this.rotationState;
          updateRotation();
          break;

        case 'download':
          permissions_namespaceObject.request(['downloads']).then(() => {
            const ext = /(?:\.([^.]+))?$/.exec(downloadUrl);
            const thing = Thing["a" /* Thing */].from(wrapper);
            let title = thing && thing.getTitle();

            if (title && ext) {
              let extension = ext[1];
              if (extension.includes('?')) extension = extension.split('?')[0];
              title = title.replace(/[*|?:"~<>\\\/]|(\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/gi, '');
              const filename = `${title}.${extension}`;
              download(downloadUrl, filename);
            } else download(downloadUrl);
          });
          break;

        case 'imageLookup':
          lookupUrl = new URL(Object(flow["a" /* downcast */])(lookupUrl, 'string'), location.href).href;
          openNewTab(string_namespaceObject.encode`https://images.google.com/searchbyimage?image_url=${lookupUrl}`);
          break;

        case 'showImageSettings':
          settingsNavigation_open(showImages_module.moduleID, 'mediaControls');
          break;

        case 'clippy':
          e.target.textContent = [showImages_module.options.imageZoom.value && 'drag to resize', showImages_module.options.imageMove.value && 'shift-drag to move'].filter(Boolean).join(' or ');
          showImages_module.options.clippy.value = false;
          options_save(showImages_module.options.clippy);
          break;

        default:
          break;
      }

      e.stopPropagation();
      e.preventDefault();
    });
    return wrapper;
  }

}

class showImages_Gallery extends showImages_Media {
  constructor(options, context) {
    super();
    this.filmstripLoadIncrement = parseInt(showImages_module.options.filmstripLoadIncrement.value, 10) || Infinity;
    this.preloadCount = parseInt(showImages_module.options.galleryPreloadCount.value, 10) || 0;
    this.individualCtrl = void 0;
    this.msgPosition = void 0;
    this.ctrlToFilmstrip = void 0;
    this.ctrlConcurrentIncrease = void 0;
    this.pieces = void 0;
    this.lastRevealedPiece = null;
    this.filmstripActive = void 0;
    this.rememberResizeWidth = void 0;
    this.lastResizedWidth = void 0;
    this.element = galleryTemplate({
      title: options.title,
      caption: options.caption,
      credits: options.credits,
      src: options.src
    });
    const piecesContainer = this.element.querySelector('.res-gallery-pieces');
    this.individualCtrl = this.element.querySelector('.res-step-container');
    const ctrlPrev = this.individualCtrl.querySelector('.res-step-previous');
    const ctrlNext = this.individualCtrl.querySelector('.res-step-next');
    this.msgPosition = this.individualCtrl.querySelector('.res-step-position');
    this.ctrlToFilmstrip = this.individualCtrl.querySelector('.res-gallery-to-filmstrip');
    this.ctrlConcurrentIncrease = this.element.querySelector('.res-gallery-increase-concurrent');
    this.pieces = options.src.map(src => ({
      generateMedia: () => generateMedia(src, context),
      media: null,
      wrapper: string_namespaceObject.html`<div hidden></div>`
    }));
    piecesContainer.append(...this.pieces.map(({
      wrapper
    }) => wrapper));
    const slideshowWhenLargerThan = parseInt(showImages_module.options.useSlideshowWhenLargerThan.value, 10) || Infinity;
    this.filmstripActive = showImages_module.options.galleryAsFilmstrip.value && this.pieces.length < slideshowWhenLargerThan;

    if (this.filmstripActive || this.pieces.length === 1) {
      this.ready = this.expandFilmstrip();
      this.ctrlConcurrentIncrease.addEventListener('click', () => this.expandFilmstrip());
    } else {
      this.ready = this.changeSlideshowPiece(0);
      ctrlPrev.addEventListener('click', () => {
        this.changeSlideshowPiece(-1);
      });
      ctrlNext.addEventListener('click', () => {
        this.changeSlideshowPiece(1);
      });
      Object(dom["r" /* waitForEvent */])(this.ctrlToFilmstrip, 'click').then(() => {
        const currentIndex = this.pieces.indexOf(this.lastRevealedPiece);

        if (currentIndex > 0) {
          const showFromBeginning = document.createElement('div');
          showFromBeginning.textContent = 'Show earlier pieces';
          showFromBeginning.style.cursor = 'pointer';
          piecesContainer.before(showFromBeginning);
          showFromBeginning.addEventListener('click', () => {
            this.expandFilmstrip({
              revealFrom: 0,
              revealTo: currentIndex
            });
            showFromBeginning.remove();
          });
        }

        this.expandFilmstrip();
        this.ctrlConcurrentIncrease.addEventListener('click', () => this.expandFilmstrip());
      });
    }
  }

  shouldRememberResizeWidth() {
    return showImages_module.options.galleryRememberWidth.value && !this.filmstripActive;
  }

  rememberWidth(piece) {
    const resizedElement = piece.media && piece.media.element.querySelector('.res-media-zoomable');
    const resizedWidth = resizedElement && parseInt(resizedElement.style.width, 10);
    if (resizedWidth) this.lastResizedWidth = resizedWidth;
  }

  restoreWidth(piece) {
    if (!this.lastResizedWidth) return;
    const resizeElement = piece.media && piece.media.element.querySelector('.res-media-zoomable');
    if (resizeElement) resize(resizeElement, this.lastResizedWidth);
  }

  revealPiece(piece) {
    if (this.shouldRememberResizeWidth() && this.lastRevealedPiece) this.rememberWidth(this.lastRevealedPiece);
    this.lastRevealedPiece = piece;
    piece.media = piece.media || piece.generateMedia();
    const {
      media,
      wrapper
    } = piece;
    if (!media.isAttached()) wrapper.appendChild(media.element);
    wrapper.hidden = false;
    if (this.shouldRememberResizeWidth()) this.restoreWidth(piece);
    if (this.isAttached()) media.expand();
  }

  preloadAhead() {
    const preloadFrom = this.pieces.indexOf(this.lastRevealedPiece);
    const preloadTo = Math.min(preloadFrom + this.preloadCount + 1, this.pieces.length);
    return preloadMedia(this.pieces.slice(preloadFrom, preloadTo));
  }

  async expandFilmstrip({
    revealFrom = this.lastRevealedPiece ? this.pieces.indexOf(this.lastRevealedPiece) + 1 : 0,
    revealTo = Math.min(revealFrom + this.filmstripLoadIncrement, this.pieces.length)
  } = {}) {
    this.individualCtrl.remove();
    this.ctrlConcurrentIncrease.hidden = true;
    await Object(utils_array["d" /* forEachSeq */])(this.pieces.slice(revealFrom, revealTo), piece => {
      this.revealPiece(piece);
      return piece.media && piece.media.ready;
    });

    if (revealTo < this.pieces.length) {
      this.ctrlConcurrentIncrease.innerText = `Show next ${Math.min(this.filmstripLoadIncrement, this.pieces.length - revealTo)} pieces`;
      this.ctrlConcurrentIncrease.hidden = false;
    }

    return this.preloadAhead();
  }

  changeSlideshowPiece(step) {
    const previous = this.lastRevealedPiece;
    const previousIndex = previous ? this.pieces.indexOf(previous) : 0;
    let newIndex = previousIndex + step;
    newIndex = positiveModulo(newIndex, this.pieces.length);
    this.individualCtrl.setAttribute('first-piece', String(newIndex === 0));
    this.individualCtrl.setAttribute('last-piece', String(newIndex === this.pieces.length - 1));
    this.msgPosition.innerText = String(newIndex + 1);
    this.revealPiece(this.pieces[newIndex]);

    if (previous) {
      const {
        media,
        wrapper
      } = previous;
      if (!media) throw new Error();
      media.collapse();
      wrapper.hidden = true;
    }

    return this.preloadAhead();
  }

  supportsUnload() {
    return true;
  }

  setLoaded(state) {
    for (const {
      wrapper,
      media
    } of this.pieces) {
      if (!(wrapper !== null && wrapper !== void 0 && wrapper.hidden) && media && media.supportsUnload()) media.setLoaded(state);
    }
  }

  collapse() {
    for (const {
      media
    } of this.pieces) {
      if (media) media.collapse();
    }
  }

}

class showImages_Image extends showImages_Media {
  constructor({
    title,
    caption,
    credits,
    src,
    href
  }, context) {
    super();
    this.image = void 0;
    this.src = void 0;
    this.src = src;
    this.element = imageTemplate({
      title,
      caption,
      credits,
      src,
      href: href || context.href,
      openInNewWindow: showImages_module.options.openInNewWindow.value
    });
    this.image = Object(flow["a" /* downcast */])(this.element.querySelector('img.res-image-media'), HTMLImageElement);
    const anchor = this.element.querySelector('a.res-expando-link');
    this.ready = Object(dom["r" /* waitForEvent */])(this.image, 'load', 'error');
    this.image.addEventListener('error', () => {
      this.element.classList.add('res-media-load-error');
    });

    if (showImages_module.options.displayOriginalResolution.value) {
      this.image.addEventListener('load', () => {
        this.image.title = `${this.image.naturalWidth} × ${this.image.naturalHeight} px`;
      });
    }

    this.setMaxSize(this.image);
    const wrapper = this.addControls(anchor, src, src);
    this.makeZoomable(this.image);
    this.makeMovable(wrapper);
    this.keepVisible(wrapper);
    this.makeIndependent(wrapper);
  }

  supportsUnload() {
    return true;
  }

  _unload() {
    this.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
  }

  _restore() {
    this.image.src = this.src;
  }

}

class showImages_Iframe extends showImages_Media {
  constructor({
    embed,
    embedAutoplay,
    width = '640px',
    height = '360px',
    fixedRatio = false,
    pause: pauseCommand,
    play: playCommand
  }) {
    super();
    this.loaded = false;
    this.iframe = void 0;
    this.pauseCommand = void 0;
    this.playCommand = void 0;
    this.pauseCommand = pauseCommand;
    this.playCommand = playCommand;
    this.element = iframeTemplate({
      url: showImages_module.options.autoplayVideo.value && embedAutoplay ? embedAutoplay : embed,
      width,
      height
    });
    this.iframe = Object(flow["a" /* downcast */])(this.element.querySelector('iframe'), HTMLIFrameElement);
    const iframeWrapper = Object(flow["a" /* downcast */])(this.element.firstElementChild, HTMLElement);
    const dragHandle = this.element.querySelector('.res-iframe-expando-drag-handle');
    this.makeZoomable(this.iframe, dragHandle, !fixedRatio);
    this.makeMovable(iframeWrapper, dragHandle);
    this.keepVisible(iframeWrapper);
    this.makeIndependent(iframeWrapper);
  }

  async expand() {
    if (showImages_module.options.autoplayVideo.value && this.playCommand) {
      if (!this.loaded) await Object(dom["r" /* waitForEvent */])(this.iframe, 'load');
      this.loaded = true;

      try {
        this.iframe.contentWindow.postMessage(this.playCommand, '*');
      } catch (e) {
        console.error('Could not post "play" command to iframe', this, e);
      }
    }
  }

  collapse() {
    if (this.pauseCommand) {
      try {
        this.iframe.contentWindow.postMessage(this.pauseCommand, '*');
        return;
      } catch (e) {
        console.error('Could not post "pause" command to iframe', this, e);
      }
    }

    this.element.remove();
  }

}

class showImages_Text extends showImages_Media {
  constructor({
    title,
    credits,
    src
  }) {
    super();
    this.element = textTemplate({
      title,
      credits,
      src: purify_es.sanitize(src)
    });
  }

}

class showImages_Audio extends showImages_Media {
  constructor({
    autoplay = false,
    loop,
    sources
  }) {
    super();
    this.autoplay = void 0;
    this.audio = void 0;
    this.autoplay = autoplay;
    this.element = audioTemplate({
      loop,
      sources
    });
    this.audio = Object(flow["a" /* downcast */])(this.element.querySelector('audio'), HTMLAudioElement);
  }

  collapse() {
    if (!this.isAttached()) return;
    this.autoplay = !this.audio.paused;
    if (!this.audio.paused) this.audio.pause();
  }

  expand() {
    if (this.autoplay) this.audio.play();
  }

}

class Generic extends showImages_Media {
  constructor(options) {
    super();
    this.onAttach = options.onAttach;
    this.element = document.createElement('div');
    this.element.appendChild(options.generate());
  }

  collapse() {
    this.element.remove();
  }

}

const trackVisitNative = Object(utils_async["a" /* batch */])(async things => {
  if (!document.body.classList.contains('gold')) return;
  if (isPrivateBrowsing()) return;
  await ajax({
    method: 'POST',
    url: '/api/store_visits',
    data: {
      links: things.map(t => t.getFullname()).join(',')
    }
  });
}, {
  delay: 10000,
  size: 50
});

function trackMediaLoad(link, thing) {
  if (!showImages_module.options.markVisited.value) return;
  if (thing) trackVisitNative(thing);

  if (!(thing && thing.isNSFW() && showImages_module.options.sfwHistory.value !== 'add')) {
    addURLToHistory(link.href);
  }
}

function addSiteAttribution(siteModule, media) {
  const $element = jquery_default()(siteAttributionTemplate({
    name: siteModule.name,
    url: siteModule.landingPage || `https://${siteModule.domains[0]}`,
    logoUrl: siteModule.logo,
    settingsLink: makeUrlHash(showImages_module.moduleID, siteModuleOptionKey(siteModule))
  }));
  const $replace = jquery_default()('.res-expando-siteAttribution', media.element);

  if ($replace.length) {
    $element.replaceAll($replace);
  } else {
    $element.addClass('res-expando-siteAttribution-generic').appendTo(media.element);
  }
}

function addDragListener({
  media,
  element,
  atShiftKey,
  onStart,
  onMove
}) {
  let hasFrameExecution = false;

  const setFrameExecution = (() => {
    const throttle = Object(utils_async["e" /* frameThrottle */])(() => {
      hasFrameExecution = false;
    });
    return () => {
      throttle();
      hasFrameExecution = true;
    };
  })();

  let isActive, hasMoved, lastX, lastY;

  const handleMove = e => {
    const movementX = e.clientX - lastX;
    const movementY = e.clientY - lastY;

    if (!movementX && !movementY) {
      return;
    } else if (1 & ~e.buttons) {
      stop();
      return;
    } else if (atShiftKey !== e.shiftKey) {
      isActive = false;
      ({
        clientX: lastX,
        clientY: lastY
      } = e);
      return;
    }

    if (!isActive) {
      if (onStart) onStart(lastX, lastY);
      isActive = true;
      hasMoved = true;
      requestAnimationFrame(() => {
        media.classList.add('res-media-dragging');
      });
    }

    if (hasFrameExecution) return;
    setFrameExecution();
    onMove(e.clientX, e.clientY, movementX, movementY);
    ({
      clientX: lastX,
      clientY: lastY
    } = e);
  };

  function handleClick(e) {
    if (hasMoved) e.preventDefault();
  }

  function stop() {
    requestAnimationFrame(() => {
      media.classList.remove('res-media-dragging');
    });
    document.removeEventListener('mousemove', handleMove);
    document.removeEventListener('mouseup', stop);
    setTimeout(() => document.removeEventListener('click', handleClick));
  }

  element.addEventListener('mousedown', function (e) {
    if (e.button !== 0) return;
    ({
      clientX: lastX,
      clientY: lastY
    } = e);
    hasMoved = false;
    isActive = false;
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', stop);
    document.addEventListener('click', handleClick);
    e.preventDefault();
  });
}

const mutedVideoManager = Object(once["a" /* default */])(() => {
  const maxSimultaneousPlaying = parseInt(showImages_module.options.maxSimultaneousPlaying.value, 10) || Infinity;
  const videos = [];
  const updatePlay = Object(utils_async["e" /* frameThrottle */])(() => {
    const all = videos.filter(media => !(media.video.paused && !media.autoPaused) && (media.video.muted || !media.video.volume)).map(media => {
      const video = media.video;
      const thing = Thing["a" /* Thing */].from(video);
      return {
        media,
        visibility: Object(dom["h" /* getPercentageVisibleYAxis */])(video),
        top: video.getBoundingClientRect().top,
        selected: Number(thing && thing.isSelected())
      };
    });
    const notVisible = all.filter(({
      visibility
    }) => visibility === 0);

    for (const {
      media
    } of notVisible) media.setAutoPause(true);

    lodash_es_without(all, ...notVisible).sort((a, b) => b.selected - a.selected || b.visibility - a.visibility || a.top - b.top).forEach(({
      media
    }, index) => {
      media.setAutoPause(index >= maxSimultaneousPlaying);
    });
  });
  let intervalId = null;
  return {
    observe(video) {
      videos.push(video);
      updatePlay();
      if (intervalId === null) intervalId = setInterval(updatePlay, 100);
    },

    unobserve(video) {
      Object(pull["a" /* default */])(videos, video);

      if (!videos.length && intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
    }

  };
});

class showImages_Video extends showImages_Media {
  constructor({
    title,
    caption,
    credits,
    fallback,
    frameRate = 24,
    href,
    loop = false,
    muted = false,
    playbackRate = 1,
    poster,
    reversable = false,
    reversed = false,
    source,
    sources,
    time = 0
  }, context) {
    super();
    this.video = void 0;
    this.autoplay = void 0;
    this.time = void 0;
    this.frameRate = void 0;
    this.autoPaused = void 0;
    this.dashPlayer = void 0;
    this._loaded = false;
    this.autoplay = muted || showImages_module.options.autoplayVideo.value;
    this.time = time;
    this.frameRate = frameRate;
    this.element = videoTemplate({
      title,
      caption,
      credits,
      source: source || href || context.href,
      poster: !this.autoplay && poster || '',
      hasAudio: !muted,
      loop,
      reversable,
      formattedPlaybackRate: this.formatMultilineNumber(playbackRate, 'x')
    });
    this.video = Object(flow["a" /* downcast */])(this.element.querySelector('video'), HTMLVideoElement);
    const container = this.element.querySelector('.res-video-container');
    const msgError = this.element.querySelector('.res-video-error');

    const displayError = message => {
      msgError.hidden = false;
      msgError.textContent = `Could not play video: ${message}`;
    };

    const sourceElements = Object(utils_array["c" /* filterMap */])(sources, v => {
      if (this.video.canPlayType(v.type)) {
        const source = document.createElement('source');
        source.src = v.source;
        source.type = v.type;
        if (v.reverse) source.dataset.reverse = v.reverse;
        return [source];
      } else {
        if (v.type === 'application/dash+xml') {
          this.dashPlayer = loadScript('/dash.mediaplayer.min.js').then(() => {
            dashjs.skipAutoCreate = true;
            const player = dashjs.MediaPlayer().create();
            player.initialize();
            player.setAutoPlay(false);
            player.attachView(this.video);
            player.attachSource(v.source);
            player.preload();
            return {
              stop: () => player.attachSource(null),
              continue: () => player.attachSource(v.source)
            };
          });
          return [document.createElement('span')];
        }
      }
    });

    if (!sourceElements.length) {
      if (fallback) {
        return new showImages_Image({
          type: 'IMAGE',
          title,
          caption,
          credits,
          src: fallback
        }, context);
      } else {
        displayError('No playable sources were found');
      }
    }

    this.video.append(...sourceElements);
    this.video.addEventListener('play', () => {
      Object(dom["e" /* empty */])(msgError);
      msgError.hidden = true;
    });
    this.video.addEventListener('stalled', () => {
      displayError('Loading stalled');
    });
    this.video.addEventListener('error', () => {
      displayError('Unknown error');
    });
    if (reversed) this.reverse();
    this.ready = Promise.race([Object(dom["r" /* waitForEvent */])(this.video, 'ended'), Object(dom["r" /* waitForEvent */])(this.video, 'error'), Object(dom["r" /* waitForEvent */])(this.video, 'canplaythrough')]);

    const setPlayIcon = () => {
      if (!this.video.paused) this.element.setAttribute('playing', '');else this.element.removeAttribute('playing');
    };

    this.video.addEventListener('pause', () => {
      setPlayIcon();
    });
    this.video.addEventListener('play', setPlayIcon);
    this.video.addEventListener('loadedmetadata', () => {
      if (this.time !== this.video.currentTime) this.video.currentTime = this.time;
    });
    this.video.playbackRate = playbackRate;
    this.video.addEventListener('mousedown', e => {
      if (this.video.hasAttribute('controls')) {
        const {
          height,
          top
        } = this.video.getBoundingClientRect();

        if (height - 0 < e.clientY - top) {
          e.stopImmediatePropagation();
        }
      }
    });
    this.video.addEventListener('dblclick', async () => {
      if (document.fullscreen) return;
      const initialControlsState = this.video.controls;
      this.video.controls = true;
      const enterFullscreenPromise = Object(dom["r" /* waitForEvent */])(this.video, 'fullscreenchange', 'fullscreenerror');
      this.video.requestFullscreen();
      await enterFullscreenPromise;
      if (document.fullscreen) await Object(dom["r" /* waitForEvent */])(this.video, 'fullscreenchange', 'dblclick');
      if (document.fullscreen) document.exitFullscreen();
      this.video.controls = initialControlsState;
    });
    Promise.all([Object(dom["r" /* waitForEvent */])(this.element, 'mouseenter'), Object(dom["r" /* waitForEvent */])(this.video, 'canplay')]).then(() => this.addVideoControls());
    new MutationObserver(() => this.element.classList.toggle('res-video-has-native-controls', this.video.hasAttribute('controls'))).observe(this.video, {
      attributes: true
    });

    if (!loop && this.autoplay) {
      Object(dom["r" /* waitForEvent */])(this.video, 'ended').then(() => this.stopAutoplay());
    }

    if (!muted) {
      if (showImages_module.options.startVideosMuted.value) this.video.muted = true;
      Promise.all([Object(dom["r" /* waitForEvent */])(this.video, 'canplay'), showImages_Video.volumeStorage.get()]).then(([, volume]) => {
        this.video.volume = volume;
      });
    }

    this.setMaxSize(this.video);
    this.makeZoomable(this.video);
    this.addControls(this.video, undefined, sourceElements[0].getAttribute('src'));
    this.makeMovable(container);
    this.keepVisible(container);
    this.makeIndependent(container);
  }

  reverse() {
    this.time = this.video.duration - this.video.currentTime;
    if (isNaN(this.time)) this.time = 0;

    for (const v of this.video.querySelectorAll('source')) {
      [v.src, v.dataset.reverse] = [v.dataset.reverse, v.src];
    }

    this.video.load();
    this.video.play();
    this.element.toggleAttribute('reversed');
  }

  formatMultilineNumber(value, suffix) {
    return `${value.toFixed(2).replace('.', '.\u200B')}${suffix}`;
  }

  addVideoControls() {
    const ctrlContainer = this.element.querySelector('.res-video-controls');
    const ctrlReverse = ctrlContainer.querySelector('.res-video-reverse');
    const ctrlTogglePause = ctrlContainer.querySelector('.res-video-toggle-pause');
    const ctrlSpeedDecrease = ctrlContainer.querySelector('.res-video-speed-decrease');
    const ctrlSpeedIncrease = ctrlContainer.querySelector('.res-video-speed-increase');
    const ctrlTimeDecrease = ctrlContainer.querySelector('.res-video-time-decrease');
    const ctrlTimeIncrease = ctrlContainer.querySelector('.res-video-time-increase');
    const progress = this.element.querySelector('.res-video-progress');
    const indicatorPosition = progress.querySelector('.res-video-position');
    const ctrlPosition = progress.querySelector('.res-video-position-thumb');
    const msgSpeed = ctrlContainer.querySelector('.res-video-speed');
    const msgTime = ctrlContainer.querySelector('.res-video-time');
    ctrlContainer.hidden = false;
    this.video.addEventListener('click', e => {
      this.togglePlay();
      e.preventDefault();
    });
    ctrlTogglePause.addEventListener('click', () => this.togglePlay());
    if (ctrlReverse) ctrlReverse.addEventListener('click', () => this.reverse());
    ctrlSpeedDecrease.addEventListener('click', () => {
      this.video.playbackRate /= 1.1;
    });
    ctrlSpeedIncrease.addEventListener('click', () => {
      this.video.playbackRate *= 1.1;
    });
    ctrlTimeDecrease.addEventListener('click', () => {
      this.video.currentTime -= 1 / this.frameRate;
    });
    ctrlTimeIncrease.addEventListener('click', () => {
      this.video.currentTime += 1 / this.frameRate;
    });
    this.video.addEventListener('ratechange', () => {
      msgSpeed.textContent = this.formatMultilineNumber(this.video.playbackRate, 'x');
    });
    this.video.addEventListener('timeupdate', () => {
      indicatorPosition.style.left = `${this.video.currentTime / this.video.duration * 100}%`;
      msgTime.textContent = this.formatMultilineNumber(this.video.currentTime, 's');
    });
    progress.addEventListener('mousemove', e => {
      let left = e.offsetX;

      if (e.target === ctrlPosition) {
        left += e.target.offsetLeft;
      }

      ctrlPosition.style.left = `${left}px`;
      if (e.buttons === 1) ctrlPosition.click();
    });
    ctrlPosition.addEventListener('click', e => {
      const percentage = (e.target.offsetLeft + e.target.clientWidth / 2) / progress.clientWidth;
      this.video.currentTime = this.video.duration * percentage;
    });
    const ctrlVolume = ctrlContainer.querySelector('.res-video-volume');

    if (ctrlVolume) {
      const ctrlVolumeLevel = ctrlVolume.querySelector('.res-video-volume-level');
      const volumePercentage = ctrlVolume.querySelector('.res-video-volume-percentage');

      const updateVolume = e => {
        const base = ctrlVolumeLevel.clientHeight;
        const click = base - e.offsetY;
        const level = Math.min(click / base, 1);

        if (level > 0.01) {
          this.video.volume = level;
          this.video.muted = false;
          showImages_Video.volumeStorage.set(level);
        }
      };

      ctrlVolume.addEventListener('click', () => {
        this.video.muted = !this.video.muted;
      });
      ctrlVolumeLevel.addEventListener('mousemove', e => {
        if (e.buttons === 1) updateVolume(e);
      });
      ctrlVolumeLevel.addEventListener('click', e => {
        updateVolume(e);
        e.stopPropagation();
      });

      const refresh = () => {
        ctrlVolume.setAttribute('level', this.video.muted || !this.video.volume ? '0' : String(Math.ceil(this.video.volume * 3)));
        volumePercentage.style.height = `${this.video.volume * 100}%`;
      };

      this.video.addEventListener('volumechange', refresh);
      refresh();
    }
  }

  togglePlay() {
    if (this.video.paused) this.video.play();else this.video.pause();
    if (this.video.paused) this.stopAutoplay();
  }

  stopAutoplay() {
    this.autoplay = false;
  }

  setAutoPause(state) {
    this.autoPaused = state;

    if (state !== this.video.paused) {
      if (state) this.video.pause();else this.video.play();
    }
  }

  supportsUnload() {
    return this.video.paused;
  }

  async _unload() {
    if (!this.isAttached()) return;
    if (!this.video.paused) this.video.pause();
    this.time = this.video.currentTime;

    if (this.dashPlayer) {
      (await this.dashPlayer).stop();
    } else {
      this.video.setAttribute('src', '');
      this.video.load();
    }

    mutedVideoManager().unobserve(this);
  }

  async _restore() {
    if (this.dashPlayer) {
      (await this.dashPlayer).continue();
    } else if (this.video.hasAttribute('src')) {
      this.video.removeAttribute('src');
      this.video.load();
    }

    this.video.currentTime = this.time;
    if (this.video.readyState === 0) await Object(dom["r" /* waitForEvent */])(this.video, 'loadedmetadata');
    if (this.autoplay) this.video.play();
    mutedVideoManager().observe(this);
  }

}

showImages_Video.volumeStorage = storage_namespaceObject.wrap('showImages.video.volume', 1);
function showImages_move(ele, deltaX, deltaY) {
  ele.style.marginLeft = `${((parseFloat(ele.style.marginLeft) || 0) + deltaX).toFixed(2)}px`;
  ele.style.marginTop = `${((parseFloat(ele.style.marginTop) || 0) + deltaY).toFixed(2)}px`;
  if (deltaY) ele.dispatchEvent(new CustomEvent('mediaManuallyMovedVertically', {
    bubbles: true
  }));
}
function resize(ele, newWidth, newHeight) {
  if (newWidth < 20) return;

  if (typeof newHeight === 'number') {
    ele.style.height = `${newHeight}px`;
  } else if (ele.style.height) {
    const {
      width,
      height
    } = ele.getBoundingClientRect();
    ele.style.height = `${(height / width * newWidth).toFixed(2)}px`;
  }

  ele.style.width = `${newWidth}px`;
  ele.style.maxWidth = ele.style.maxHeight = 'none';
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Expando.js



class Expando_Expando extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = this.conditions.types.length ? `expando ${this.conditions.types.join('|')}` : 'expando';
  }

  static parseCriterion(input) {
    return {
      types: input.split(/[\s|]/).filter(Boolean)
    };
  }

  static thingToCriterion(thing) {
    const expando = thing.isPost() ? expando_Expando.getEntryExpandoFrom(thing) : expando_Expando.getTextExpandosFrom(thing)[0];
    return expando && expando.types.join(' & ') || '';
  }

  isValid() {
    return matchesTypes(this.value.types);
  }

  _matches(e) {
    if (!e) return false;
    if (!e.ready) return null;
    return matchesTypes(this.value.types, e.types);
  }

  _waitTillReady(thing) {
    const completeTask = thing.tasks.byId.get(showImages_module);

    if (completeTask) {
      const promise = completeTask();
      if (!(promise instanceof Promise)) return;
      return Promise.race([promise.catch(() => {}), new Promise((res, rej) => {
        setTimeout(rej, 1500);
      })]).catch(() => {
        promise.finally(() => {
          this.refresh();
        });
      });
    }
  }

  async evaluate(thing) {
    await this._waitTillReady(thing);

    if (thing.isPost()) {
      const expando = expando_Expando.getEntryExpandoFrom(thing);
      return this._matches(expando);
    } else {
      const expandos = expando_Expando.getTextExpandosFrom(thing);
      const res = expandos.map(this._matches.bind(this));
      if (res.some(Boolean)) return true;
      if (res.some(v => v === null)) return null;
      return false;
    }
  }

  onObserve() {
    return true;
  }

}
Expando_Expando.text = 'Expando';
Expando_Expando.defaultConditions = {
  types: []
};
Expando_Expando.fields = ['post has expando, and (if specified) expando types intersects with ', {
  type: 'checkset',
  items: showImages_types,
  id: 'types'
}];
Expando_Expando.slow = 9;
Expando_Expando.pattern = `[(${showImages_types.join('|')})]`;
Expando_Expando.criterionOperators = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsLocked.js

class IsLocked_IsLocked extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'locked';
  }

  evaluate(thing) {
    return thing.isLocked();
  }

}
IsLocked_IsLocked.text = 'Locked';
IsLocked_IsLocked.fields = ['post is locked'];
IsLocked_IsLocked.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsNSFW.js

class IsNSFW_IsNSFW extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'nsfw';
  }

  evaluate(thing) {
    return thing.isNSFW();
  }

}
IsNSFW_IsNSFW.text = 'NSFW';
IsNSFW_IsNSFW.fields = ['post is marked NSFW'];
IsNSFW_IsNSFW.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsSpoiler.js

class IsSpoiler_IsSpoiler extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'spoiler';
  }

  evaluate(thing) {
    return thing.isSpoiler();
  }

}
IsSpoiler_IsSpoiler.text = 'Spoiler';
IsSpoiler_IsSpoiler.fields = ['post is marked spoiler'];
IsSpoiler_IsSpoiler.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/IsVisited.js


class IsVisited_IsVisited extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'visited';
  }

  evaluate(thing) {
    if (thing.element.classList.contains('visited')) return true;
    const link = thing.getPostLink();
    const dataUrl = thing.element.getAttribute('data-url');
    if (!link && !dataUrl) return null;
    return link && isURLVisited(link.href) || dataUrl !== link.href && isURLVisited(dataUrl);
  }

}
IsVisited_IsVisited.text = 'Visited';
IsVisited_IsVisited.fields = ['link has been visited'];
IsVisited_IsVisited.slow = 2;
IsVisited_IsVisited.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/LinkFlair.js

class LinkFlair_LinkFlair extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `link flair ${this.conditions.patt}`.trim();
    this.value = this.build(false, '/./');
  }

  static thingToCriterion(thing) {
    return thing.getPostFlairText();
  }

  evaluate(thing) {
    const text = thing.getPostFlairText();
    return this.value.some(v => v.test(text));
  }

}
LinkFlair_LinkFlair.text = 'Link flair';
LinkFlair_LinkFlair.fields = ['post has link flair matching ', {
  type: 'text',
  id: 'patt'
}];
LinkFlair_LinkFlair.pattern = '[RegEx]';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostAfter.js

class PostAfter_PostAfter extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `after ${this.conditions.patt}`;
    this.value = new Date(this.conditions.patt);
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  static thingToCriterion(thing) {
    return thing.getTimestamp().toISOString();
  }

  isValid() {
    return !isNaN(this.value);
  }

  evaluate(thing) {
    const postTime = thing.getTimestamp();
    if (!postTime) return null;
    return postTime >= this.value;
  }

}
PostAfter_PostAfter.text = 'Post after';
PostAfter_PostAfter.defaultConditions = {
  patt: new Date().toISOString()
};
PostAfter_PostAfter.fields = ['posted after date ', {
  type: 'text',
  id: 'patt'
}];
PostAfter_PostAfter.pattern = 'Date — string representing a RFC2822 or ISO 8601 date';
// CONCATENATED MODULE: ./node_modules/lodash-es/head.js
function head_head(array){return array&&array.length?array[0]:undefined;}/* harmony default export */ var lodash_es_head = (head_head);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseSlice.js
var _baseSlice = __webpack_require__(75);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseWhile.js
function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?Object(_baseSlice["a" /* default */])(array,fromRight?0:index,fromRight?index+1:length):Object(_baseSlice["a" /* default */])(array,fromRight?index+1:0,fromRight?length:index);}/* harmony default export */ var _baseWhile = (baseWhile);
// CONCATENATED MODULE: ./node_modules/lodash-es/dropWhile.js
function dropWhile(array,predicate){return array&&array.length?_baseWhile(array,Object(_baseIteratee["a" /* default */])(predicate,3),true):[];}/* harmony default export */ var lodash_es_dropWhile = (dropWhile);
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostAge.js



const qualifiers = [['Y', 12], ['M', 30.44], ['d', 24], ['h', 60], ['m', 60], ['s', 1000]];
const PostAge_now = new Date();

function prettifyAge(remainder) {
  let remainderQualifier = '';

  for (const [qualifier, multiplier] of qualifiers.slice().reverse()) {
    if (remainder < multiplier) break;
    remainder /= multiplier;
    remainderQualifier = qualifier;
  }

  return remainder.toFixed(2) + remainderQualifier;
}

class PostAge_PostAge extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `age ${prettyOperator(this.conditions.op)} ${prettifyAge(this.conditions.age)}`;
    this.falseText = `age ${prettyOperator(inverseOperator(this.conditions.op))} ${prettifyAge(this.conditions.age)}`;
  }

  static parseCriterion(input) {
    let age = parseInt(input, 10);
    if (isNaN(age)) throw new Error('Invalid age');
    const ageQualifier = lodash_es_head(input.match(/Y|M|d|h|m|s/)) || 's';
    age = lodash_es_dropWhile(qualifiers, ([qualifier]) => qualifier !== ageQualifier).reduce((a, [, multiplier]) => a * multiplier, age);
    return {
      op: '<=',
      age
    };
  }

  static thingToCriterion(thing) {
    const remainder = PostAge_now - new Date(thing.getTimestamp());
    if (isNaN(remainder)) throw new Error('Could not determine Thing date');
    return prettifyAge(remainder);
  }

  evaluate(thing) {
    const postTime = thing.getTimestamp();
    if (!postTime) return null;
    return numericalCompare(this.value.op, PostAge_now - postTime, this.value.age);
  }

}
PostAge_PostAge.text = 'Post age';
PostAge_PostAge.defaultConditions = {
  op: '<=',
  age: 4 * 60 * 60 * 1000
};
PostAge_PostAge.fields = ['post is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'duration',
  id: 'age'
}, ' old'];
PostAge_PostAge.pattern = 'x[(Y|M|d|h|m)] — where x is the number of seconds or Y year, M month, h hour, m minute (case sensitive)';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostTitle.js

class PostTitle_PostTitle extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `title contains ${this.conditions.patt}`;
    this.value = this.build(false);
  }

  evaluate(thing) {
    const title = thing.getTitle();
    return this.value.some(v => v.test(title));
  }

}
PostTitle_PostTitle.text = 'Post title';
PostTitle_PostTitle.fields = ['post\'s title contains ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/PostType.js

const PostType_options = [['link post', 'link'], ['self post', 'self']];
class PostType_PostType extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `type ${this.conditions.kind}`;
  }

  static parseCriterion(input) {
    return {
      kind: input
    };
  }

  isValid() {
    return PostType_options.map(([, cls]) => cls).includes(this.value.kind);
  }

  evaluate(thing) {
    switch (this.value.kind) {
      case 'link':
        return thing.isLinkPost();

      case 'self':
        return thing.isSelfPost();

      default:
        return null;
    }
  }

}
PostType_PostType.text = 'Post type';
PostType_PostType.defaultConditions = {
  kind: 'link'
};
PostType_PostType.fields = ['post is a ', {
  type: 'select',
  id: 'kind',
  options: PostType_options
}];
PostType_PostType.pattern = `(${PostType_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Score.js


class Score_Score extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `score ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `score ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getScore());
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const score = thing.getScore();
    if (isNaN(score)) return null;
    return numericalCompare(this.value.op, score, this.value.val);
  }

}
Score_Score.text = 'Score';
Score_Score.defaultConditions = {
  op: '>',
  val: 0
};
Score_Score.fields = ['post has ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' points'];
Score_Score.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Selector.js


class Selector_Selector extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `$('${this.conditions.patt.replace(/\'/g, '\\\'')}')`;
    this.falseText = `$(':not(${this.conditions.patt.replace(/\'/g, '\\\'')}'))`;
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  isValid() {
    return this.value.patt && !!jquery_default()(this.value.patt);
  }

  evaluate(thing) {
    return jquery_default()(thing.element).is(this.value.patt) || jquery_default()(thing.entry).is(this.value.patt) || !!jquery_default()(thing.entry).has(this.value.patt).length;
  }

}
Selector_Selector.text = 'Selector';
Selector_Selector.defaultConditions = {
  patt: ''
};
Selector_Selector.fields = ['thing matches jQuery selector ', {
  type: 'text',
  id: 'patt'
}];
Selector_Selector.slow = 10;
Selector_Selector.pattern = 'string';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Subreddit.js

class Subreddit_Subreddit extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `in ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getSubreddit();
  }

  evaluate(thing) {
    const subreddit = thing.getSubreddit();
    if (!subreddit) return null;
    return this.value.some(v => v.test(subreddit));
  }

}
Subreddit_Subreddit.text = 'Subreddit';
Subreddit_Subreddit.fields = ['posted in /r/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserAttr.js


const UserAttr_options = [['a friend', 'friend'], ['a moderator', 'moderator'], ['an admin', 'admin'], ['me', 'me'], ['op', 'submitter']];
class UserAttr_UserAttr extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `by ${this.conditions.attr}`;
  }

  static parseCriterion(input) {
    return {
      attr: input
    };
  }

  isValid() {
    return UserAttr_options.map(([, cls]) => cls).includes(this.value.attr);
  }

  evaluate(thing) {
    if (this.value.attr === 'me') {
      const myName = loggedInUser();
      const author = thing.getAuthor();
      if (!myName || !author) return null;
      return author.trim().toLowerCase() === myName.trim().toLowerCase();
    } else {
      const element = thing.getAuthorElement();
      if (!element) return null;
      return element.classList.contains(this.value.attr);
    }
  }

}
UserAttr_UserAttr.text = 'User attribute';
UserAttr_UserAttr.fields = ['user is ', {
  type: 'select',
  id: 'attr',
  options: UserAttr_options
}];
UserAttr_UserAttr.defaultConditions = {
  attr: 'friend'
};
UserAttr_UserAttr.pattern = `(${UserAttr_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserFlair.js

class UserFlair_UserFlair extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `user flair ${this.conditions.patt}`.trim();
    this.value = this.build(false, '/./');
  }

  static thingToCriterion(thing) {
    return thing.getUserFlairText();
  }

  evaluate(thing) {
    const text = thing.getUserFlairText();
    return this.value.some(v => v.test(text));
  }

}
UserFlair_UserFlair.text = 'User flair';
UserFlair_UserFlair.fields = ['author of this post has flair matching ', {
  type: 'text',
  id: 'patt'
}];
UserFlair_UserFlair.pattern = '[RegEx]';
// EXTERNAL MODULE: ./node_modules/lodash-es/_Stack.js + 5 modules
var _Stack = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/lodash-es/_assignValue.js
var _assignValue = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/lodash-es/_copyObject.js
var _copyObject = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/lodash-es/keys.js
var lodash_es_keys = __webpack_require__(32);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssign.js
function baseAssign(object,source){return object&&Object(_copyObject["a" /* default */])(source,Object(lodash_es_keys["a" /* default */])(source),object);}/* harmony default export */ var _baseAssign = (baseAssign);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object,source){return object&&Object(_copyObject["a" /* default */])(source,Object(keysIn["a" /* default */])(source),object);}/* harmony default export */ var _baseAssignIn = (baseAssignIn);
// EXTERNAL MODULE: ./node_modules/lodash-es/_cloneBuffer.js
var _cloneBuffer = __webpack_require__(105);

// EXTERNAL MODULE: ./node_modules/lodash-es/_copyArray.js
var _copyArray = __webpack_require__(43);

// CONCATENATED MODULE: ./node_modules/lodash-es/_copySymbols.js
function copySymbols(source,object){return Object(_copyObject["a" /* default */])(source,Object(_getSymbols["a" /* default */])(source),object);}/* harmony default export */ var _copySymbols = (copySymbols);
// CONCATENATED MODULE: ./node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source,object){return Object(_copyObject["a" /* default */])(source,_getSymbolsIn(source),object);}/* harmony default export */ var _copySymbolsIn = (copySymbolsIn);
// EXTERNAL MODULE: ./node_modules/lodash-es/_getAllKeys.js
var _getAllKeys = __webpack_require__(74);

// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneArray.js
var _initCloneArray_objectProto=Object.prototype;var _initCloneArray_hasOwnProperty=_initCloneArray_objectProto.hasOwnProperty;function initCloneArray(array){var length=array.length,result=new array.constructor(length);if(length&&typeof array[0]=='string'&&_initCloneArray_hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/* harmony default export */ var _initCloneArray = (initCloneArray);
// EXTERNAL MODULE: ./node_modules/lodash-es/_Uint8Array.js
var _Uint8Array = __webpack_require__(71);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new _Uint8Array["a" /* default */](result).set(new _Uint8Array["a" /* default */](arrayBuffer));return result;}/* harmony default export */ var _cloneArrayBuffer = (cloneArrayBuffer);
// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView,isDeep){var buffer=isDeep?_cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/* harmony default export */ var _cloneDataView = (cloneDataView);
// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneRegExp.js
var reFlags=/\w*$/;function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/* harmony default export */ var _cloneRegExp = (cloneRegExp);
// EXTERNAL MODULE: ./node_modules/lodash-es/_Symbol.js
var _Symbol = __webpack_require__(11);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneSymbol.js
var symbolProto=_Symbol["a" /* default */]?_Symbol["a" /* default */].prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined;function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/* harmony default export */ var _cloneSymbol = (cloneSymbol);
// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?_cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/* harmony default export */ var _cloneTypedArray = (cloneTypedArray);
// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneByTag.js
var boolTag='[object Boolean]',dateTag='[object Date]',_initCloneByTag_mapTag='[object Map]',numberTag='[object Number]',regexpTag='[object RegExp]',_initCloneByTag_setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return _cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return _cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return _cloneTypedArray(object,isDeep);case _initCloneByTag_mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return _cloneRegExp(object);case _initCloneByTag_setTag:return new Ctor();case symbolTag:return _cloneSymbol(object);}}/* harmony default export */ var _initCloneByTag = (initCloneByTag);
// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object){return typeof object.constructor=='function'&&!Object(_isPrototype["a" /* default */])(object)?Object(_baseCreate["a" /* default */])(_getPrototype(object)):{};}/* harmony default export */ var _initCloneObject = (initCloneObject);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsMap.js
var _baseIsMap_mapTag='[object Map]';function baseIsMap(value){return Object(isObjectLike["a" /* default */])(value)&&Object(_getTag["a" /* default */])(value)==_baseIsMap_mapTag;}/* harmony default export */ var _baseIsMap = (baseIsMap);
// EXTERNAL MODULE: ./node_modules/lodash-es/_nodeUtil.js
var _nodeUtil = __webpack_require__(37);

// CONCATENATED MODULE: ./node_modules/lodash-es/isMap.js
var nodeIsMap=_nodeUtil["a" /* default */]&&_nodeUtil["a" /* default */].isMap;var isMap=nodeIsMap?Object(_baseUnary["a" /* default */])(nodeIsMap):_baseIsMap;/* harmony default export */ var lodash_es_isMap = (isMap);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsSet.js
var _baseIsSet_setTag='[object Set]';function baseIsSet(value){return Object(isObjectLike["a" /* default */])(value)&&Object(_getTag["a" /* default */])(value)==_baseIsSet_setTag;}/* harmony default export */ var _baseIsSet = (baseIsSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/isSet.js
var nodeIsSet=_nodeUtil["a" /* default */]&&_nodeUtil["a" /* default */].isSet;var isSet=nodeIsSet?Object(_baseUnary["a" /* default */])(nodeIsSet):_baseIsSet;/* harmony default export */ var lodash_es_isSet = (isSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;var argsTag='[object Arguments]',arrayTag='[object Array]',_baseClone_boolTag='[object Boolean]',_baseClone_dateTag='[object Date]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',_baseClone_mapTag='[object Map]',_baseClone_numberTag='[object Number]',objectTag='[object Object]',_baseClone_regexpTag='[object RegExp]',_baseClone_setTag='[object Set]',_baseClone_stringTag='[object String]',_baseClone_symbolTag='[object Symbol]',weakMapTag='[object WeakMap]';var _baseClone_arrayBufferTag='[object ArrayBuffer]',_baseClone_dataViewTag='[object DataView]',_baseClone_float32Tag='[object Float32Array]',_baseClone_float64Tag='[object Float64Array]',_baseClone_int8Tag='[object Int8Array]',_baseClone_int16Tag='[object Int16Array]',_baseClone_int32Tag='[object Int32Array]',_baseClone_uint8Tag='[object Uint8Array]',_baseClone_uint8ClampedTag='[object Uint8ClampedArray]',_baseClone_uint16Tag='[object Uint16Array]',_baseClone_uint32Tag='[object Uint32Array]';var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[_baseClone_arrayBufferTag]=cloneableTags[_baseClone_dataViewTag]=cloneableTags[_baseClone_boolTag]=cloneableTags[_baseClone_dateTag]=cloneableTags[_baseClone_float32Tag]=cloneableTags[_baseClone_float64Tag]=cloneableTags[_baseClone_int8Tag]=cloneableTags[_baseClone_int16Tag]=cloneableTags[_baseClone_int32Tag]=cloneableTags[_baseClone_mapTag]=cloneableTags[_baseClone_numberTag]=cloneableTags[objectTag]=cloneableTags[_baseClone_regexpTag]=cloneableTags[_baseClone_setTag]=cloneableTags[_baseClone_stringTag]=cloneableTags[_baseClone_symbolTag]=cloneableTags[_baseClone_uint8Tag]=cloneableTags[_baseClone_uint8ClampedTag]=cloneableTags[_baseClone_uint16Tag]=cloneableTags[_baseClone_uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!Object(isObject["a" /* default */])(value)){return value;}var isArr=Object(isArray["a" /* default */])(value);if(isArr){result=_initCloneArray(value);if(!isDeep){return Object(_copyArray["a" /* default */])(value,result);}}else{var tag=Object(_getTag["a" /* default */])(value),isFunc=tag==funcTag||tag==genTag;if(Object(isBuffer["a" /* default */])(value)){return Object(_cloneBuffer["a" /* default */])(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:_initCloneObject(value);if(!isDeep){return isFlat?_copySymbolsIn(value,_baseAssignIn(result,value)):_copySymbols(value,_baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=_initCloneByTag(value,tag,isDeep);}}stack||(stack=new _Stack["a" /* default */]());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(lodash_es_isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(lodash_es_isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=bitmask&CLONE_SYMBOLS_FLAG?isFlat?_getAllKeysIn:_getAllKeys["a" /* default */]:isFlat?keysIn["a" /* default */]:lodash_es_keys["a" /* default */];var props=isArr?undefined:keysFunc(value);Object(_arrayEach["a" /* default */])(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}Object(_assignValue["a" /* default */])(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/* harmony default export */ var _baseClone = (baseClone);
// CONCATENATED MODULE: ./node_modules/lodash-es/cloneDeep.js
var cloneDeep_CLONE_DEEP_FLAG=1,cloneDeep_CLONE_SYMBOLS_FLAG=4;function cloneDeep(value){return _baseClone(value,cloneDeep_CLONE_DEEP_FLAG|cloneDeep_CLONE_SYMBOLS_FLAG);}/* harmony default export */ var lodash_es_cloneDeep = (cloneDeep);
// CONCATENATED MODULE: ./node_modules/lodash-es/zip.js
var zip=Object(_baseRest["a" /* default */])(lodash_es_unzip);/* harmony default export */ var lodash_es_zip = (zip);
// CONCATENATED MODULE: ./lib/modules/customToggles.js








const customToggles_module = new Module('customToggles');
customToggles_module.moduleName = 'customTogglesName';
customToggles_module.category = 'coreCategory';
customToggles_module.description = 'customTogglesDesc';
customToggles_module.options = {
  toggle: {
    description: 'customTogglesToggleDesc',
    title: 'customTogglesToggleTitle',
    type: 'table',
    fields: [{
      key: 'id',
      name: 'id',
      type: 'hidden',

      get value() {
        return `~${performance.timing.navigationStart + performance.now()}`;
      }

    }, {
      key: 'enabled',
      name: 'enabled',
      type: 'boolean',
      value: true
    }, {
      key: 'text',
      name: 'text',
      type: 'text'
    }],
    value: []
  }
};
const toggles = new Map();
const customToggles = [];

customToggles_module.beforeLoad = () => {
  for (const instance of customToggles_module.options.toggle.value) {
    const [key, initialEnabled, text] = instance;

    if (toggles.has(key)) {
      console.error(`A toggle with key ${key} already exists`, instance);
      continue;
    }

    const toggle = new customToggles_Toggle(key, text, initialEnabled);
    customToggles.push(toggle);
    toggle.onStateChange(() => {
      instance[1] = toggle.enabled;
      jquery_default()(customToggles_module).trigger(jquery_default.a.Event('toggle'));
    });
    toggle.onToggle(() => {
      options_save(customToggles_module.options.toggle);
    });
    toggle.addMenuItem();
  }
};

customToggles_module.contentStart = () => {
  registerCommandLine();
};

class customToggles_Toggle {
  constructor(key, text, enabled) {
    this.text = void 0;
    this.enabled = void 0;
    this.stateChangeCallbacks = [];
    this.toggleCallbacks = [];
    this.multicast = void 0;
    this.text = text;
    this.enabled = enabled;
    this.multicast = multicast(Object(utils_async["e" /* frameThrottle */])(enabled => {
      this.toggle('multicast', enabled);
    }), {
      local: false,
      name: `toggle.${key}`
    });
    toggles.set(key, this);
  }

  toggle(type = 'manual', state = !this.enabled) {
    if (this.enabled === state) return;
    this.enabled = state;

    for (const callback of this.stateChangeCallbacks) callback();

    if (type !== 'multicast') {
      for (const callback of this.toggleCallbacks) callback(type);

      if (type !== 'autoLocal') this.multicast(state);
    }
  }

  onStateChange(callback) {
    this.stateChangeCallbacks.push(callback);
  }

  onToggle(callback) {
    this.toggleCallbacks.push(callback);
  }

  addMenuItem(title = `Toggle ${this.text}`, order = 9, on, off) {
    menu_addMenuItem(Object(once["a" /* default */])(() => {
      const item = string_namespaceObject.html`<div title="${title}">${this.text || '\u00A0'}</div>`;
      const toggle = createElement_namespaceObject.toggleButton(undefined, this.text, this.enabled, on, off);
      item.append(toggle);
      this.onStateChange(() => {
        toggle.classList.toggle('enabled', this.enabled);
      });
      return item;
    }), e => {
      this.toggle();
      e.stopPropagation();
    }, order);
  }

  addCLI(commandPredicate) {
    registerCommand(commandPredicate, `${commandPredicate} - toggle ${this.text}`, () => ` ${this.enabled ? 'Disable' : 'Enable'} ${this.text}`, () => {
      this.toggle();
    });
  }

  buildCheckbox() {
    const checkbox = document.createElement('input');
    checkbox.setAttribute('type', 'checkbox');
    checkbox.checked = this.enabled;
    checkbox.addEventListener('change', () => {
      this.toggle('manual', checkbox.checked);
    });
    this.onStateChange(() => {
      checkbox.checked = this.enabled;
    });
    return checkbox;
  }

}

function registerCommandLine() {
  const getMatchingToggles = val => Array.from(toggles.values()).filter(({
    text
  }) => text.toLowerCase().match(val.toLowerCase())).sort(({
    text: a
  }, {
    text: b
  }) => a.localeCompare(b));

  const bestMatch = val => lodash_es_sortBy(getMatchingToggles(val), ({
    text
  }) => text.toLowerCase().indexOf(val.toLowerCase()))[0];

  registerCommand('toggle', 'toggle - toggle any custom toggle', (command, val) => getMatchingToggles(val).length ? `Toggle ${getMatchingToggles(val).map(toggle => toggle === bestMatch(val) ? `<b>${toggle.text}</b>` : toggle.text).join('|')}` : `No toggles matching <i>${val}</i>`, (command, val) => {
    const match = getMatchingToggles(val)[0];
    if (match) match.toggle();else return `${val} does not match a valid toggle`;
  });
}

function toggleActive(key) {
  const toggle = toggles.get(key);
  return !!toggle && toggle.enabled;
}
const getToggles = () => (stage_namespaceObject.get(customToggles_module.moduleID) || customToggles_module.options).toggle.value.map(([key,, text]) => ({
  key,
  text
}));
// CONCATENATED MODULE: ./lib/modules/filteReddit/Filter.js



class Filter_Filter {
  constructor(id, BaseCase, name, conditions = null, state = true, effects = {}) {
    this.id = void 0;
    this.name = void 0;
    this.parent = void 0;
    this.updatePromise = void 0;
    this.BaseCase = void 0;
    this.case = void 0;
    this.state = void 0;
    this.active = false;
    this.element = void 0;
    this.effects = {};

    this.refresh = thing => {
      if (!this.parent) return;
      this.updatePromise = this.parent.refresh(this, thing ? [thing] : undefined);
    };

    this.matches = Object(utils_async["b" /* fastAsync */])(function* (thing) {
      try {
        const result = yield this.case.evaluate(thing);
        return result === null ? false : this.state === !result;
      } catch (e) {
        return false;
      }
    });
    this.id = id;
    this.BaseCase = BaseCase;
    this.name = name;
    this.state = state;
    Object.assign(this.effects, lodash_es_pickBy(effects, Boolean));
    this.setCase(BaseCase.fromConditions(conditions));
  }

  isActive() {
    return !!this.getEffects().length && this.case.isEvaluatable();
  }

  createElement() {}

  setParent(parent) {
    this.parent = parent;
  }

  getStateText(state = this.state, cased = this.case) {
    return state !== false ? this.name || cased.trueText || (this.BaseCase.text || this.BaseCase.type).toLowerCase() : this.name && `¬ ${this.name}` || cased.falseText || `¬ ${this.getStateText(true, cased)}`;
  }

  getSaveValues() {
    const values = {
      type: this.BaseCase.type,
      state: this.state,
      effects: this.effects
    };

    if (this.BaseCase.variant === 'basic') {
      values.conditions = this.case.conditions;

      if (this.name && this.name !== this.case.trueText) {
        values.name = this.name;
      }
    }

    return values;
  }

  remove() {
    for (const effect of Object.keys(this.effects)) this.effects[effect] = false;

    if (this.parent) this.parent.removeFilter(this);
  }

  getEffects() {
    return Object.entries(this.effects).filter(([, enabled]) => enabled).map(([name]) => name);
  }

  setCase(newCase) {
    this.case = newCase;
    this.active = this.isActive();
    if (this.active) this.case.observe(this);
  }

  update(state = this.state, conditions, effects = {}, describeOnly = false) {
    const cased = conditions === undefined ? this.case : this.BaseCase.fromConditions(conditions, true);
    if (!cased.isValid()) throw new Error('Invalid conditions');

    if (describeOnly) {
      return `Show only posts which matches "${this.getStateText(state, cased)}"`;
    }

    this.state = state;
    Object.assign(this.effects, effects);
    this.setCase(cased);
    this.refresh();
    if (this.parent) this.parent.save();
  }

  async updateByInputConstruction({
    criterion,
    disableFilter,
    reverseActive,
    fromSelected
  }, describeOnly = false) {
    if (disableFilter) {
      if (describeOnly) return 'Disable filter';
      return this.update(undefined, undefined, {
        hide: false
      });
    }

    let state, conditions;

    if (fromSelected) {
      ({
        state,
        conditions
      } = await this.BaseCase.getSelectedEntryValue());
    } else {
      if (criterion) conditions = this.BaseCase.criterionToConditions(criterion);
      state = this.state;
    }

    if (reverseActive) state = !state;
    return this.update(state, conditions, {
      hide: true
    }, describeOnly);
  }

  getMatchingEntry() {
    return this.case.conditions;
  }

  removeEntry(entry, effect) {
    this.update(undefined, undefined, {
      [effect]: false
    });
  }

  async buildReasonElement(thing, effect) {
    const entry = await this.getMatchingEntry(thing);
    const element = string_namespaceObject.html`
			<div class="res-thing-filter-remove-matching-entry" title="${JSON.stringify(entry, null, '  ')}">
				${effect}: ${this.getStateText(!this.state)} — click to remove matching filter entry
			</div>
		`;
    element.addEventListener('click', () => {
      this.removeEntry(entry, effect);
    });
    return element;
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/ExternalFilter.js





class ExternalFilter_ExternalFilter extends Filter_Filter {
  constructor(...args) {
    super(...args);
    this.toggleEffects = ['hide'];
  }

  isActive() {
    return this.case.constructor.type !== 'false' && super.isActive();
  }

  createElement() {
    this.element = string_namespaceObject.html`
			<div class="res-filterline-external-filter" type="${this.BaseCase.type}">
				<div>${this.name || this.BaseCase.type}</div>
			</div>
		`;

    if (filteReddit_module.options.hasOwnProperty(this.BaseCase.type)) {
      this.element.prepend(string_namespaceObject.html`${string_namespaceObject.safe(makeUrlHashLink(filteReddit_module.moduleID, this.BaseCase.type, ' ', 'gearIcon'))}`);
    }

    const setActive = active => {
      const effects = this.toggleEffects.reduce((acc, val) => {
        acc[val] = active;
        return acc;
      }, {});
      this.update(undefined, undefined, effects);
    };

    if (isUseful(this.case.constructor.type)) {
      const t = createElement_namespaceObject.toggleButton(setActive, null, this.isActive(), '', '');
      this.element.appendChild(t);
    }
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/LineFilter.js









class LineFilter_LineFilter extends Filter_Filter {
  constructor(id, BaseCase, name, _conditions = null, state = true, effects = {}) {
    if (BaseCase.variant === 'ondemand') {
      const externOpts = BaseCase._customFilter && BaseCase._customFilter.opts;

      if (externOpts) {
        if (!name) ({
          name
        } = externOpts);

        if (!effects.hasOwnProperty('propagate')) {
          const {
            propagate
          } = externOpts;
          Object.assign(effects, {
            propagate
          });
        }
      }
    }

    super(id, BaseCase, name, _conditions, state, effects);
    this.initialConditions = void 0;
    this.getBuilder = Object(memoize["a" /* default */])((filterline, card) => {
      const builderCases = getByContext(filterline.thingType);
      let lastConditions = this.case.conditions;

      if (this.BaseCase.variant === 'ondemand') {
        Object.assign(builderCases, getByContext('browse'));
        lastConditions = this.BaseCase.getCustomFilter().body;
      }

      if (!this.initialConditions) this.initialConditions = lastConditions;
      const $builderBlock = caseBuilder_namespaceObject.drawBuilderBlock(lastConditions, builderCases, false);
      $builderBlock.on('change input', Object(utils_async["e" /* frameThrottle */])(() => {
        const conditions = caseBuilder_namespaceObject.readBuilderBlock($builderBlock, builderCases);

        if (!lodash_es_isEqual(lastConditions, conditions)) {
          lastConditions = conditions;
          this.update(undefined, conditions);
          const lastFocus = $builderBlock.get(0).contains(document.activeElement) && document.activeElement;
          if (lastFocus) card.refresh().then(() => lastFocus.focus());
        }
      }));
      sortable_core_esm.create($builderBlock.get(0), {
        handle: '.handle'
      });
      return {
        get builder() {
          return $builderBlock.get(0);
        },

        isCaseChanged: () => !lodash_es_isEqual(this.initialConditions, lastConditions)
      };
    });
  }

  update(state = this.state, conditions, effects, describeOnly) {
    if (this.BaseCase.variant === 'ondemand' && conditions && !describeOnly) {
      updateCustomFilter(this.BaseCase.getCustomFilter(), {
        body: conditions
      });
      conditions = null;
    }

    const message = super.update(state, conditions, effects, describeOnly);
    if (this.element) this.refreshElement();
    return message;
  }

  setParent(parent) {
    super.setParent(parent);
    this.getBuilder.cache.clear();
  }

  createElement() {
    this.element = string_namespaceObject.html`<div class="res-filterline-filter" type="${this.BaseCase.type}"></div>`;
    this.refreshElement();
    this.element.addEventListener('click', () => {
      if (!this.effects.hide) this.update(undefined, undefined, {
        hide: true
      });else if (this.state) this.update(false, undefined, {
        hide: true
      });else this.update(true, undefined, {
        hide: false
      });
    });
    this.element.addEventListener('contextmenu', e => {
      if (this.effects.hide) this.update(undefined, undefined, {
        hide: false
      });else this.remove();
      e.preventDefault();
    });
    this.element.addEventListener('mouseenter', async () => {
      await new Promise(res => {
        setTimeout(res, 150);
      });
      if (this.element.matches(':hover')) this.showInfocard();
    });
    this.element.addEventListener('click', () => infocard('filterline-filter').resetShowTimer());
    this.element.addEventListener('contextmenu', () => infocard('filterline-filter').resetShowTimer());
  }

  showInfocard(immediately = false) {
    const card = infocard('filterline-filter');
    if (card.visible) immediately = true;
    card.target(this.element).options({
      width: 570,
      openDelay: immediately ? 0 : 550,
      pin: pin.bottom
    }).populateWith(this.populateHover.bind(this)).begin();
  }

  refreshElement() {
    this.element.setAttribute('text', this.getStateText());
    this.element.classList.toggle('res-filterline-filter-disabled', this.BaseCase.variant !== 'basic' && !this.case.isEvaluatable());
    this.element.classList.toggle('res-filterline-filter-hiding', this.case.isEvaluatable() && !!this.effects.hide);
  }

  populateHover(card) {
    const {
      parent: filterline
    } = this;
    if (!filterline) throw new Error('Filter not attached');

    const redraw = () => {
      this.getBuilder.cache.clear();
      card.refresh();
    };

    const head = string_namespaceObject.html`
			<div class="res-filterline-filter-hover-preamble">
				<span>Filter ${this.BaseCase.text}</span>
				<div class="res-filterline-filter-hover-group" group="case-actions">
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
			</div>
		`;
    const body = string_namespaceObject.html`
			<div class="res-filterline-filter-hover">
				<span class="res-filterline-filter-hover-options"></span>
				<span>For posts (<span class="res-filterline-filter-hover-number-matches">…</span>) ${this.state ? 'not ' : ''}matching:</span>
				<div class="builderItem"></div>
				<div class="res-filterline-filter-hover-notice">${this.BaseCase.variant === 'ondemand' && 'By adding browse context conditions such as "Date", "Logged in user", and "Custom toggle", you control where and when this filter is available.'}</div>
				<div class="res-filterline-filter-hover-group" group="match-effects">
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
				<div class="res-filterline-filter-hover-group" group="match-actions" hidden>
					<div class="res-filterline-filter-hover-buttons"></div>
				</div>
		`;
    const {
      builder,
      isCaseChanged
    } = this.getBuilder(filterline, card);
    body.querySelector('.builderItem').appendChild(builder);
    setTimeout(() => {
      if (!builder.contains(document.activeElement)) {
        const e = [...builder.querySelectorAll('input'), ...builder.querySelectorAll('select')].find(e => e.offsetParent);
        if (e) e.focus();
      }
    });

    if (filterline.thingType === 'comment') {
      const options = body.querySelector('.res-filterline-filter-hover-options');
      const propagate = string_namespaceObject.html`<label style="display: flex; align-items: center;"><input style="margin-right: 3px;" type="checkbox" ${this.effects.propagate && 'checked'}>Also hide children</label>`;
      options.append(propagate);
      Object(dom["r" /* waitForEvent */])(propagate, 'change').then(() => {
        this.update(undefined, undefined, {
          propagate: Object(flow["a" /* downcast */])(propagate.querySelector('input'), HTMLInputElement).checked
        });
      }).then(redraw);
    }

    function addButton(container, text, groupName, action) {
      const button = string_namespaceObject.html`<button class="res-filterline-filter-hover-button" action="${action}">${text}</button>`;
      const group = Object(flow["a" /* downcast */])(container.querySelector(`[group=${groupName}]`), HTMLElement);
      group.hidden = false;
      const buttons = Object(flow["a" /* downcast */])(group.querySelector('.res-filterline-filter-hover-buttons'), HTMLElement);
      buttons.appendChild(button);
      return Object(dom["r" /* waitForEvent */])(button, 'click');
    }

    if (this.BaseCase.variant === 'basic' && this.BaseCase === cases_Group) {
      addButton(head, 'To on-demand', 'case-actions', 'to-ondemand').then(() => {
        const conditions = getGroup('all', [cases_getConditions('currentLocation'), getGroup(this.state ? 'all' : 'none', [this.case.conditions])]);
        if (!this.name) this.name = window.prompt('Filter name:');
        this.BaseCase = addOndemandCase(addCustomFilter({
          body: resolveGroup(conditions, false, true),
          opts: {
            ondemand: true,
            name: this.name
          }
        }));
        this.update(true, null);
      }).then(redraw);
    }

    if (isCaseChanged()) {
      addButton(head, 'Reset change', 'case-actions', 'reset').then(() => {
        this.update(undefined, this.initialConditions);
      }).then(redraw);
    }

    if (this.BaseCase.variant === 'ondemand' || this.BaseCase === cases_Group) {
      addButton(head, 'Rename', 'case-actions', 'rename').then(() => {
        const name = window.prompt('New filter name:', this.case.trueText);
        if (!name) return;

        if (this.BaseCase.variant === 'ondemand') {
          const customFilter = this.BaseCase.getCustomFilter();
          updateCustomFilter(customFilter, {
            opts: {
              name
            }
          });
        }

        this.name = name;
        this.update();
      }).then(redraw);
    }

    addButton(head, 'Invert', 'case-actions', 'invert').then(() => {
      this.update(!this.state);
    }).then(redraw);
    addButton(head, 'Remove', 'case-actions', 'remove').then(() => {
      this.remove();
    }).then(card.close.bind(card));
    addButton(body, this.effects.hide ? 'Don\'t hide' : 'Hide', 'match-effects', `hide-${this.effects.hide ? 'false' : 'true'}`).then(() => {
      this.update(undefined, undefined, {
        hide: !this.effects.hide
      });
    }).then(redraw);
    addButton(body, this.effects.highlight ? 'Don\'t highlighting' : 'Highlight', 'match-effects', 'highlight').then(() => {
      this.update(undefined, undefined, {
        highlight: !this.effects.highlight
      });
    }).then(redraw);

    if (isRunning(commentNavigator_namespaceObject) && !this.effects.hide) {
      addButton(body, 'Navigate by', 'match-actions', 'navigate-by').then(() => {
        updateCustomConditions(getGroup(this.state ? 'none' : 'all', [this.case.conditions]));
        setCategory('custom');
        card.close();
      });
    }

    Object(utils_array["a" /* asyncFilter */])(Array.from(filterline.things), async thing => await this.matches(thing)).then(matches => {
      const numberSpan = body.querySelector('.res-filterline-filter-hover-number-matches');
      numberSpan.textContent = String(matches.length);

      if (filterline.thingType === 'post' && matches.length) {
        addButton(body, 'Permanently hide', 'match-actions', 'native-hide').then(() => {
          filterline.hidePermanently(matches);
        });
      }
    });
    return [head, body];
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit/Filterline.js











class Filterline_Filterline {
  constructor(storage, thingType) {
    this.things = new Set();
    this.thingType = void 0;
    this.storage = void 0;
    this.filters = [];
    this.sortedFilters = [];
    this.currentMatches = new Map();
    this.permanentlyHiddenThings = new Set();
    this.displayReasons = false;
    this.element = void 0;
    this.dropdown = void 0;
    this.preamble = void 0;
    this.filterContainer = void 0;
    this.poweredElement = void 0;
    this.permanentlyHideCheckbox = void 0;
    this.initialized = false;

    this.togglePowered = (powered = !this.isPowered()) => {
      bodyClasses_namespaceObject.toggle(!powered, 'res-filters-disabled');
      this.poweredElement.checked = powered;
    };

    this.deferredFilters = {};
    this.save = Object(utils_async["f" /* idleThrottle */])(async () => {
      const filters = this.filters.reduce((acc, v) => {
        acc[v.id] = v.getSaveValues();
        return acc;
      }, { ...this.deferredFilters
      });
      await this.storage.deletePath('filters');
      await this.storage.patch({
        filters,
        lastUsed: Date.now()
      });
    });
    this.availableEffects = {
      propagate: (thing, match) => {
        thing.element.classList.toggle('res-thing-hide-children', !!match);

        this._refreshAfterChange();
      },
      highlight: (thing, match) => {
        thing.entry.classList.toggle('res-thing-filterline-highlight', !!match);
      },
      hide: (thing, match) => {
        thing.setHideFilter(match);

        this._refreshAfterChange();
      },
      placeholder: (thing, match) => {
        function removePlaceholders() {
          thing.element.classList.remove('res-thing-has-placeholder');

          for (const ele of thing.entry.querySelectorAll('.res-thing-placeholder-message')) ele.remove();
        }

        function replaceWithPlaceholder(ele) {
          if (!ele) return;
          const placeholder = string_namespaceObject.html`<span class="res-thing-placeholder-message">
					<span class="res-icon">&#xF093;</span> Content ignored. Click to show anyway.
				</span>`;
          ele.after(placeholder);
          thing.element.classList.add('res-thing-has-placeholder');
          Object(dom["r" /* waitForEvent */])(placeholder, 'click').then(removePlaceholders);
        }

        if (match) {
          replaceWithPlaceholder(thing.getTitleElement());
          replaceWithPlaceholder(thing.getTextBody());
        } else {
          removePlaceholders();
        }

        this._refreshAfterChange();
      },
      collapse: (thing, match) => {
        thing.setCommentCollapse(!!match, 'filterline', true);

        this._refreshAfterChange();
      }
    };
    this._refreshAfterChange = Object(utils_async["e" /* frameThrottle */])(() => {
      selectedThing_namespaceObject.refresh();
      this.checkEmptyState();
    });
    this.refreshThing = Object(utils_async["g" /* keyedMutex */])(Object(utils_async["b" /* fastAsync */])(function* (thing, invokedByFilter) {
      if (!this.currentMatches.has(thing)) this.currentMatches.set(thing, {});
      const currentMatches = this.currentMatches.get(thing);
      const activeEffects = Object.keys(this.availableEffects);
      const allFilters = [...new Set(activeEffects.map(effect => this.getFiltersToTest(currentMatches[effect], invokedByFilter)).flat())].sort((a, b) => this.sortedFilters.indexOf(a) - this.sortedFilters.indexOf(b));
      const refreshEffects = activeEffects.filter(effect => !(invokedByFilter && !invokedByFilter.effects.hasOwnProperty(effect) || currentMatches[effect] && !allFilters.includes(currentMatches[effect])));

      const updateEffect = (effect, filter) => {
        const old = currentMatches[effect];
        if (filter == old) return;
        currentMatches[effect] = filter;
        this.availableEffects[effect](thing, filter);
        if (this.displayReasons) this.refreshDisplayReasonsChunked([thing]);
      };

      for (const filter of allFilters.filter(v => this.getActiveFilters().includes(v))) {
        const effects = filter.getEffects().filter(v => refreshEffects.includes(v));

        if (effects.length && (yield filter.matches(thing))) {
          for (const effect of effects) updateEffect(effect, filter);

          Object(pull["a" /* default */])(refreshEffects, ...effects);
        }
      }

      for (const effect of refreshEffects) {
        updateEffect(effect, null);
      }
    }));

    this.checkEmptyState = (() => {
      let notification;
      const showNotification = Object(debounce["a" /* default */])(() => {
        const info = jquery_default()('<p>').text(i18n('filteRedditEmptyNotificationInfo'));
        const toggle = jquery_default()('<button>').text(i18n('filteRedditEmptyNotificationToggleShowReason')).click(() => {
          this.toggleDisplayReasons();
        });
        notification = notifications_showNotification({
          moduleID: filteReddit_module.moduleID,
          notificationID: 'everyThingHidden',
          header: i18n('filteRedditEmptyNotificationHeader'),
          message: jquery_default()('<div>').append(info).append(toggle).get(0),
          closeDelay: Infinity
        });
      }, 3000);
      return () => {
        if (Array.from(this.things).some(v => v.isVisible())) {
          showNotification.cancel();
          if (notification) notification.close();
        } else if (!this.displayReasons && Array.from(this.currentMatches.values()).some(v => v.hide)) {
            showNotification();
          }
      };
    })();

    this.refreshDisplayReasonsChunked = Object(utils_async["c" /* forEachChunked */])(this.refreshDisplayReasons.bind(this));
    this.storage = storage;
    this.thingType = thingType;
  }

  isInitialized() {
    if (this.initialized) return true;
    if (!this.things.size || !this.getActiveFilters().length) return false;
    this.initialized = true;
    this.sortedFilters = lodash_es_sortBy(this.filters, ({
      case: {
        constructor: {
          slow
        }
      }
    }) => slow);

    if (this.thingType === 'post') {
      delete this.availableEffects.collapse;
      delete this.availableEffects.propagate;
    }

    return true;
  }

  isPowered() {
    return !document.documentElement.classList.contains('res-filters-disabled');
  }

  createElement() {
    const element = this.element = string_namespaceObject.html`
			<div class="res-filterline">
				<div class="res-filterline-preamble"></div>
				<div class="res-filterline-filters">
					<input type="checkbox" ${this.isPowered() && 'checked'} class="res-filterline-toggle-powered" title="Stop filtering temporarily"></input>
				</div>
			</div>
		`;
    this.preamble = element.querySelector('.res-filterline-preamble');
    this.filterContainer = element.querySelector('.res-filterline-filters');
    this.addFilterElements(this.filters);
    Object(dom["r" /* waitForEvent */])(this.preamble, 'mouseenter', 'click').then(() => this.createDropdown());
    this.poweredElement = Object(flow["a" /* downcast */])(element.querySelector('.res-filterline-toggle-powered'), HTMLInputElement);
    this.poweredElement.addEventListener('change', () => {
      this.togglePowered();
    });
  }

  addFilterElements(filters) {
    for (const filter of filters) {
      if (filter instanceof ExternalFilter_ExternalFilter) continue;
      filter.createElement();
      this.filterContainer.appendChild(filter.element);
    }
  }

  getFiltersOfCase(CaseClass) {
    return this.filters.filter(v => v.BaseCase === CaseClass);
  }

  getPickable() {
    return Object.values(getByContext(this.thingType, false)).filter(v => !v.disabled && v.variant !== 'external');
  }

  createDropdown() {
    const element = string_namespaceObject.html`
			<div class="res-filterline-dropdown">
				<div class="res-filterline-dropdown-other"></div>
				<div class="res-filterline-dropdown-toggles">
					<div class="res-filterline-display-match-reason">
						<label>
							<input type="checkbox" ${this.displayReasons && 'checked'}">
							<span>Show matching filters</span>
						</label>
					</div>
				</div>
				<div class="res-filterline-show-help">
					Usage information
				</div>
			</div>
		`;
    this.preamble.append(element);
    this.preamble.addEventListener('mouseenter', () => {
      infocard('filterline-filter').close();
    });

    function addDetails(summary, className, ...elements) {
      const e = string_namespaceObject.html`<details class="${className}"><summary>${summary}</summary></details>`;
      e.append(...elements);
      element.querySelector('.res-filterline-dropdown-other').append(e);
    }

    addDetails('Modify external filters', 'res-filterline-external', ...this.filters.filter(filter => filter instanceof ExternalFilter_ExternalFilter).map(filter => {
      filter.createElement();
      return filter.element;
    }));
    const dp = lodash_es_groupBy(lodash_es_without(this.getPickable(), cases_Group), v => v.variant);

    for (const [name, CaseClasses] of Object.entries(dp)) {
      addDetails(`New ${name} filter`, `res-filterline-new-${name}`, ...CaseClasses.sort((a, b) => a.type.localeCompare(b.type)).map(CaseClass => this.createNewFilterElement(CaseClass)));
    }

    const _getAsConditions = this.getAsConditions.bind(this);

    addDetails('New complex filter', 'res-filterline-new-group', this.createNewFilterElement(cases_Group, 'Copy active filters', {
      get conditions() {
        return _getAsConditions();
      }

    }), ...cases_Group.fields[0].options.map(op => this.createNewFilterElement(cases_Group, `Matches ${op}`, {
      conditions: {
        op,
        of: []
      }
    })));
    addDetails('Use as default', 'res-filterline-set-default', ...defaultFilters.map(({
      type,
      text
    }) => {
      const e = string_namespaceObject.html`<div class="res-filterline-dropdown-action">${text}</div>`;
      e.addEventListener('click', () => saveFilterlineStateAsDefault(type));
      return e;
    }), (() => {
      const e = string_namespaceObject.html`<div class="res-filterline-dropdown-action">Reset this Filterline</div>`;
      e.addEventListener('click', () => {
        this.storage.delete();
        if (confirm('Reload page to restore default')) location.reload();
      });
      return e;
    })());
    const displayReasonsCheckbox = Object(flow["a" /* downcast */])(element.querySelector('.res-filterline-display-match-reason input'), HTMLInputElement);
    displayReasonsCheckbox.addEventListener('change', () => {
      this.toggleDisplayReasons(displayReasonsCheckbox.checked);
    });

    if (this.thingType === 'post' && loggedInUser()) {
      const permanentlyHide = string_namespaceObject.html`
				<div class="res-filterline-permanently-hide">
					<label>
						<input type="checkbox">
						<span>Permanently hide</span>
					</label>
				</div>
			`;
      const checkbox = this.permanentlyHideCheckbox = Object(flow["a" /* downcast */])(permanentlyHide.querySelector('input'), HTMLInputElement);
      this.updatePermanentlyHideCheckbox();
      permanentlyHide.addEventListener('click', async () => {
        checkbox.disabled = true;
        await (this.permanentlyHiddenThings.size ? this.unhidePermanently() : this.hidePermanently());
        checkbox.disabled = false;
      });
      element.querySelector('.res-filterline-dropdown-toggles').append(permanentlyHide);
    }

    Object(flow["a" /* downcast */])(element.querySelector('.res-filterline-show-help'), HTMLElement).addEventListener('click', () => {
      showFeatureTip('filterlineVisible');
    });
  }

  updatePermanentlyHideCheckbox() {
    if (!this.permanentlyHideCheckbox) return;
    this.permanentlyHideCheckbox.checked = this.permanentlyHideCheckbox.indeterminate = false;
    if (!this.permanentlyHiddenThings.size) return;
    if (this.getThings('hide').length === this.permanentlyHiddenThings.size) this.permanentlyHideCheckbox.checked = true;else this.permanentlyHideCheckbox.indeterminate = true;
  }

  createNewFilterElement(CaseClass, text = CaseClass.text, newOpts) {
    let fromSelected = false;
    const element = string_namespaceObject.html`<div class="res-filterline-dropdown-action res-filterline-filter-new" type="${CaseClass.type}">${text}</div>`;
    element.addEventListener('click', () => {
      const existing = CaseClass.unique && this.getFiltersOfCase(CaseClass)[0];
      let filter;

      if (existing) {
        if (!(existing instanceof LineFilter_LineFilter)) throw new Error();
        filter = existing;
      } else {
        filter = Object(flow["a" /* downcast */])(this.createFilter({
          type: CaseClass.type,
          add: true,
          ...newOpts
        }), LineFilter_LineFilter);
      }

      if (fromSelected) filter.updateByInputConstruction({
        fromSelected
      });else filter.showInfocard(true);
    });

    if (CaseClass.thingToCriterion || !CaseClass.defaultConditions) {
      const c = string_namespaceObject.html`<div class="res-filterline-filter-new-from-selected" title="From selected entry"></div>`;
      c.addEventListener('click', () => {
        fromSelected = true;
        setTimeout(() => {
          fromSelected = false;
        });
      });
      element.append(c);
    }

    return element;
  }

  async hidePermanently(things = this.getThings('hide')) {
    await Promise.all(lodash_es_difference(things, Array.from(this.permanentlyHiddenThings)).map(thing => thingHide_hide(thing)));

    for (const v of things) this.permanentlyHiddenThings.add(v);

    this.updatePermanentlyHideCheckbox();
    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'hideThings',
      message: string_namespaceObject.html`<div><p>Reddit has now hidden ${things.length} things. Undo by unchecking the checkbox in the menu.</p><p><a href="/user/me/hidden/">See all hidden posts</a></p>`
    });
  }

  async unhidePermanently(things = [...this.permanentlyHiddenThings]) {
    await Promise.all(lodash_es_intersection(things, Array.from(this.permanentlyHiddenThings)).map(thing => unhide(thing)));

    for (const v of things) this.permanentlyHiddenThings.delete(v);

    this.updatePermanentlyHideCheckbox();
    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'unhideThings',
      message: `${things.length} things are no longer hidden.`
    });
  }

  getAsConditions(hasEffect = 'hide') {
    const extracted = Object(utils_array["c" /* filterMap */])(this.filters, v => v.effects[hasEffect] && v instanceof LineFilter_LineFilter && [v] || undefined);
    return resolveGroup(getGroup('all', extracted.map(v => v.state ? v.case.conditions : getGroup('none', [v.case.conditions]))), false, true);
  }

  resumeDeferredTypes(types) {
    Object.entries(this.deferredFilters).filter(([, {
      type
    }]) => types.includes(type)).forEach(([id]) => this.createFilterFromStateValues(id));
  }

  restoreState(filters) {
    for (const [id, opts] of Object.entries(filters)) {
      try {
        if (opts.type === 'inert') throw new Error('Requested inert filter. This state is likely due to a bug. Ignoring.');
        const filter = this.getFilter(id);
        if (filter) throw new Error(`Filter with id ${id} already exists`);
        const CaseClass = cases_has(opts.type) && cases_get(opts.type);

        if (CaseClass && !CaseClass.disabled && CaseClass.variant !== 'external') {
          this.createFilterFromStateValues(id, opts);
        } else {
          this.deferredFilters[id] = opts;
        }
      } catch (e) {
        console.error('Could not create filter', id, opts);
        this.storage.deletePath('filters', id);
      }
    }
  }

  createFilterFromStateValues(id, opts) {
    const deferredOpts = this.deferredFilters[id];
    delete this.deferredFilters[id];
    return this.createFilter({
      id,
      ...opts,
      ...deferredOpts,
      add: true,
      save: false
    });
  }

  getCLI() {
    const deconstruct = val => {
      const [, modifiers, key, criterion] = val.match(/^([^\w]*)(\w*)(.*)/);
      return {
        key,
        criterion: criterion.trim(),
        disableFilter: !!modifiers.match('/'),
        reverseActive: !!modifiers.match('!'),
        asNewFilter: !!modifiers.match('\\+'),
        fromSelected: !!modifiers.match('=')
      };
    };

    const findMatchingCases = val => this.getPickable().sort((a, b) => a.variant.localeCompare(b.variant) || a.type.localeCompare(b.type)).map(CaseClass => ({
      name: CaseClass.variant === 'ondemand' ? CaseClass.text : CaseClass.type,
      cls: CaseClass
    })).filter(({
      name
    }) => name.toLowerCase().match(val.toLowerCase()));

    let filter;

    async function getTip(val) {
      const deconstructed = deconstruct(val);
      const {
        key,
        asNewFilter
      } = deconstructed;
      const bestMatch = key && lodash_es_sortBy(findMatchingCases(key), ({
        name
      }) => name.toLowerCase().indexOf(key.toLowerCase()))[0];
      const {
        cls: MatchedCase
      } = bestMatch || {};
      let message;

      if (bestMatch) {
        try {
          const lastFilter = this.getFiltersOfCase(MatchedCase).slice(-1)[0];
          filter = lastFilter && !asNewFilter ? lastFilter : this.createFilter({
            type: MatchedCase.type
          });
          const actionDescription = await filter.updateByInputConstruction(deconstructed, true);
          message = `${filter.parent ? `Modify "${filter.getStateText(filter.state)}"` : 'New filter'}: ${actionDescription}`;
        } catch (e) {
          message = `Error: ${e.message}`;
        }
      } else {
        filter = null;
        message = 'No filter selected.';
      }

      return ['<pre>', 'Syntax: [modifiers] filterName [criterion]', '', message, '', 'Filters:', ...findMatchingCases('').map(v => ` ${MatchedCase === v.cls ? `<b>${v.name}</b>` : v.name} ${v.cls.pattern}`), '', 'Modifiers:', ' / — disable the filter', ' ! — reverse the active state', ' + — create as new filter', ' = — use the currently selected post\'s data as criterion', '', 'Examples:', ' =postAfter   → filter posts older than selected', ' +=!postAfter → new filter, filter posts younger than selected', '</pre>'].join('\n');
    }

    function executeCommand(val) {
      if (!filter) return;
      if (!filter.parent) this.addFilter(filter);
      filter.updateByInputConstruction(deconstruct(val));
      filter = null;
    }

    return {
      getTip: getTip.bind(this),
      executeCommand: executeCommand.bind(this)
    };
  }

  createFilter(opts) {
    const {
      Filter = LineFilter_LineFilter,
      id = `~${performance.timing.navigationStart + performance.now()}`,
      add = false,
      save = true,
      type,
      criterion,
      effects,
      name,
      state
    } = opts;
    let {
      conditions
    } = opts;
    if (this.deferredFilters.hasOwnProperty(id)) return this.createFilterFromStateValues(id, opts);
    const CaseClass = cases_get(type);

    if (CaseClass.unique) {
      const [existing] = this.getFiltersOfCase(CaseClass);
      if (existing) return existing;
    }

    if (!conditions && criterion) {
      conditions = CaseClass.criterionToConditions(criterion);
    }

    const filter = new Filter(id, CaseClass, name, conditions, state, effects);

    if (add) {
      this.addFilter(filter);
      if (save) this.save();
    }

    return filter;
  }

  addFilter(filter) {
    filter.setParent(this);
    this.filters.push(filter);

    if (this.isInitialized()) {
      this.sortedFilters.push(filter);
      this.refresh(filter);
    }

    if (this.filterContainer) this.addFilterElements([filter]);
  }

  async removeFilter(filter) {
    if (filter.element) filter.element.remove();
    if (this.isInitialized()) await this.refresh(filter);
    Object(pull["a" /* default */])(this.filters, filter);
    Object(pull["a" /* default */])(this.sortedFilters, filter);
    this.save();
  }

  getFilter(id) {
    return this.filters.find(filter => filter.id === id);
  }

  getActiveFilters() {
    return this.filters.filter(v => v.active);
  }

  getFiltersToTest(currentFilter, invokedByFilter) {
    if (!invokedByFilter) return this.sortedFilters;
    const invokedByFilterIndex = this.sortedFilters.indexOf(invokedByFilter);
    const currentFilterIndex = this.sortedFilters.indexOf(currentFilter);

    if (!currentFilter) {
      return [invokedByFilter];
    } else if (currentFilter === invokedByFilter) {
      return this.sortedFilters.slice(invokedByFilterIndex);
    } else if (currentFilterIndex > invokedByFilterIndex) {
      return [invokedByFilter, currentFilter];
    } else {
      return [];
    }
  }

  refresh(invokedByFilter, things = Array.from(this.things)) {
    return Promise.all(things.map(thing => this.refreshThing(thing, invokedByFilter)));
  }

  addThing(thing) {
    this.things.add(thing);
    if (this.isInitialized()) return this.refreshThing(thing);
  }

  getThings(withEffect) {
    return Array.from(this.currentMatches.entries()).filter(([, effects]) => effects[withEffect]).map(([thing]) => thing);
  }

  toggleDisplayReasons(newState = !this.displayReasons) {
    this.displayReasons = newState;
    this.refreshDisplayReasonsChunked(this.things);
    bodyClasses_namespaceObject.toggle(this.displayReasons, 'res-display-match-reason');
  }

  async refreshDisplayReasons(thing) {
    const reasons = this.displayReasons ? await Promise.all(Object.entries(this.currentMatches.get(thing) || {}).map(([effect, filter]) => filter && filter.buildReasonElement(thing, effect)).filter(Boolean)) : [];
    thing.setFilterReasons(reasons);
  }

}
// CONCATENATED MODULE: ./lib/modules/filteReddit.js














const filteReddit_module = new Module('filteReddit');
filteReddit_module.moduleName = 'filteRedditName';
filteReddit_module.category = 'subredditsCategory';
filteReddit_module.description = 'filteRedditDesc';
filteReddit_module.keywords = ['filterreddit'];
filteReddit_module.options = {
  hideUntilProcessed: {
    type: 'boolean',
    value: true,
    description: 'filteRedditHideUntilProcessedDesc',
    title: 'filteRedditHideUntilProcessedTitle',
    advanced: true
  },
  NSFWfilter: {
    type: 'boolean',
    value: false,
    description: 'filteRedditNSFWfilterDesc',
    title: 'filteRedditNSFWfilterTitle'
  },
  allowNSFW: {
    type: 'table',
    addRowText: 'filteRedditAddSubreddits',
    description: 'filteRedditAllowNSFWDesc',
    title: 'filteRedditAllowNSFWTitle',
    fields: [{
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'where',
      name: 'filteRedditAllowNSFWWhere',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditAllowNSFWWhenBrowsingSubreddit',
        value: 'visit'
      }],
      value: 'everywhere'
    }],
    value: []
  },
  NSFWQuickToggle: {
    type: 'boolean',
    value: true,
    description: 'filteRedditNSFWQuickToggleDesc',
    title: 'filteRedditNSFWQuickToggleTitle',
    advanced: true
  },
  showFilterline: {
    type: 'boolean',
    value: false,
    description: 'filteRedditShowFilterlineDesc',
    title: 'filteRedditShowFilterlineTitle'
  },
  excludeOwnPosts: {
    type: 'boolean',
    value: true,
    description: 'filteRedditExcludeOwnPostsDesc',
    title: 'filteRedditExcludeOwnPostsTitle'
  },
  excludeModqueue: {
    type: 'boolean',
    value: true,
    description: 'filteRedditExcludeModqueueDesc',
    title: 'filteRedditExcludeModqueueTitle'
  },
  excludeUserPages: {
    type: 'boolean',
    value: false,
    description: 'filteRedditExcludeUserPagesDesc',
    title: 'filteRedditExcludeUserPagesTitle'
  },
  keywords: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'subreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'unlessKeyword',
      name: 'unlessKeyword',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditKeywordsDesc',
    title: 'filteRedditKeywordsTitle'
  },
  subreddits: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'subreddit',
      name: 'filteRedditSubredditsSubreddits',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditSubredditsDesc',
    title: 'filteRedditSubredditsTitle',

    onChange() {
      if (filteReddit_module.options.useRedditFilters.value) {
        reconcileNativeFilters();
      }
    }

  },
  filterSubredditsFrom: {
    type: 'enum',
    value: 'everywhere-except-subreddit',
    values: [{
      name: 'filteRedditFilterSubredditsEverywhereButSubreddit',
      value: 'everywhere-except-subreddit'
    }, {
      name: 'filteRedditEverywhere',
      value: 'everywhere'
    }, {
      name: 'filteRedditFilterSubredditsAllPopularAndDomain',
      value: 'legacy'
    }],
    description: 'filteRedditFilterSubredditsFromDesc',
    title: 'filteRedditFilterSubredditsFromTitle'
  },
  useRedditFilters: {
    type: 'boolean',
    value: false,
    description: 'filteRedditUseRedditFiltersDesc',
    title: 'filteRedditUseRedditFiltersTitle',

    onChange() {
      if (filteReddit_module.options.useRedditFilters.value) {
        reconcileNativeFilters();
      }
    }

  },
  forceSyncFilters: {
    type: 'button',
    text: 'filteRedditForceSyncFiltersLabel',
    description: 'filteRedditForceSyncFiltersDesc',
    title: 'filteRedditForceSyncFiltersTitle',

    callback() {
      return reconcileNativeFilters({
        warnNotLoggedIn: true
      });
    }

  },
  comments: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'subreddits',
      type: 'list',
      listType: 'subreddits'
    }],
    value: [],
    description: 'filteRedditCommentContentDesc',
    title: 'filteRedditCommentContentTitle'
  },
  commentsHideReplies: {
    type: 'boolean',
    value: false,
    description: 'filteRedditCommentContentHideRepliesDesc',
    title: 'filteRedditCommentContentHideRepliesTitle'
  },
  users: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'username',
      name: 'filteRedditUsername',
      type: 'text'
    }],
    value: [],
    description: 'filteRedditUsersDesc',
    title: 'filteRedditUsersTitle'
  },
  usersMatchAction: {
    type: 'enum',
    value: 'hide',
    values: [{
      name: 'Hidden',
      value: 'hide'
    }, {
      name: 'Replaced with placeholder',
      value: 'placeholder'
    }],
    description: 'filteRedditUsersMatchActionDesc',
    title: 'filteRedditUsersMatchActionTitle'
  },
  usersMatchRepliesAction: {
    type: 'enum',
    value: 'collapse',
    values: [{
      name: 'Kept visible',
      value: ''
    }, {
      name: 'Collapsed',
      value: 'collapse'
    }, {
      name: 'Hidden',
      value: 'propagate'
    }],
    description: 'filteRedditUsersMatchRepliesActionDesc',
    title: 'filteRedditUsersMatchRepliesActionTitle'
  },
  domains: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }],
    value: [],
    description: 'filteRedditDomainsDesc',
    title: 'filteRedditDomainsTitle'
  },
  flair: {
    type: 'table',
    addRowText: 'filteRedditAddFilter',
    fields: [{
      key: 'keyword',
      name: 'filteRedditKeyword',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'filteRedditApplyTo',
      type: 'enum',
      values: [{
        name: 'filteRedditEverywhere',
        value: 'everywhere'
      }, {
        name: 'filteRedditEverywhereBut',
        value: 'exclude'
      }, {
        name: 'filteRedditOnlyOn',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'subreddits',
      name: 'filteRedditSubreddits',
      type: 'list',
      listType: 'subreddits'
    }],
    value: [],
    description: 'filteRedditFlairDesc',
    title: 'filteRedditFlairTitle'
  },
  customFiltersP: {
    type: 'builder',
    description: 'filteRedditCustomFiltersDesc',
    title: 'filteRedditCustomFiltersPTitle',
    value: [],
    addItemText: 'filteRedditAddCustomFilter',

    defaultTemplate() {
      return {
        note: '',
        ver: 3,
        body: cases_getConditions('group'),
        id: `customFilter-${Date.now()}`,
        opts: {
          ondemand: false,
          name: ''
        }
      };
    },

    customOptionsFields: [['Name: ', {
      type: 'text',
      id: 'name'
    }], [{
      type: 'check',
      id: 'ondemand',
      label: 'On-demand only'
    }]],

    get cases() {
      populatePrimitives();
      return { ...getByContext('post'),
        ...getByContext('browse')
      };
    }

  },
  customFiltersC: {
    type: 'builder',
    description: 'filteRedditCustomFiltersDesc',
    title: 'filteRedditCustomFiltersCTitle',
    value: [],
    addItemText: 'filteRedditAddCustomFilter',

    defaultTemplate() {
      return {
        note: '',
        ver: 3,
        body: cases_getConditions('group'),
        id: `customFilter-${Date.now()}`,
        opts: {
          ondemand: false,
          name: '',
          propagate: false
        }
      };
    },

    customOptionsFields: [['Name: ', {
      type: 'text',
      id: 'name'
    }], [{
      type: 'check',
      id: 'ondemand',
      label: 'On-demand only'
    }], [{
      type: 'check',
      id: 'propagate',
      label: 'Also hide replies'
    }]],

    get cases() {
      populatePrimitives();
      return { ...getByContext('comment'),
        ...getByContext('browse')
      };
    }

  }
};
filteReddit_module.include = ['linklist', 'modqueue', 'profile', 'comments', 'commentsLinklist', 'search'];
const featureTips = {
  filterline: {
    message: `
RES allows you to easily apply complex filters to post listings and comments. To toggle Filterline, click on the tab.
	`,
    title: 'Filterline',
    position: 6,
    quiet: true
  },
  filterlineVisible: {
    message: () => snudown_es_markdown(`
* Click once on a filter to enable it (e.g. clicking \`expando\` will only show posts with embedded media).
* Click again to only show posts which do not not match.
* A third click makes the filter inactive.
* To clear a filter, right-click on it.
* **Hover** on it to modify conditions, highlight or permanently hide all matches.

To find more filters and options, hover on icon to the left.

You can use the currently selected post as a basis for a new filter. To do this, click on **=** to the right of the filter name.

**Complex filter** creates filters which matches when \`none\`, \`one\`, \`any\`, or \`all\` of the subfilters matches. Click \`To on-demand\` to make these filters available on other pages.

**Use as default** lets you store the current filters to be used on other pages.

To see why a post is hidden, open dropdown and check **Show filter-reason**. This also gives you the opportunity to remove an external filter so that you don't have to look for it in the settings console.

You can use the command line to manipulate Filterline. Enter it by pressing the key \`f\`.
		`),
    title: 'Filterline — how to use it',
    position: 7,
    options: [{
      moduleID: 'filteReddit',
      key: 'showFilterline'
    }]
  }
};
const pageID = Object(utils_location["g" /* fullLocation */])();
const filterlineStorage = storage_namespaceObject.wrap(`filterline.${pageID}`, {});
const filteReddit_thingType = Object(utils_location["n" /* isPageType */])('comments', 'commentsLinklist') ? 'comment' : 'post';
const customFilterVariant = filteReddit_thingType === 'post' ? 'customFiltersP' : 'customFiltersC';

const createStateFromTypes = types => types.reduce((acc, v, i) => {
  if (v) acc[`!${i}`] = {
    type: v
  };
  return acc;
}, {});

const defaultFilters = [];

if (filteReddit_thingType === 'comment') {
  if (Object(utils_location["d" /* currentSubreddit */])()) {
    defaultFilters.push({
      type: 'subreddit',
      text: 'On this subreddit',
      storage: storage_namespaceObject.wrap(`RESmodules.filteReddit.commentDefault-${String(Object(utils_location["d" /* currentSubreddit */])())}`, null)
    });
  }

  defaultFilters.push({
    type: 'everywhere',
    text: 'Everywhere',
    storage: storage_namespaceObject.wrap('RESmodules.filteReddit.commentDefault', createStateFromTypes(['hasExpando', 'score', 'isRead', 'postAge']))
  });
} else if (filteReddit_thingType === 'post') {
  defaultFilters.push({
    type: 'everywhere',
    text: 'Everywhere',
    storage: storage_namespaceObject.wrap('RESmodules.filteReddit.postDefault', createStateFromTypes(['isNSFW', 'isSpoiler', 'isVisited', 'commentsOpened', 'hasExpando', 'score']))
  });
}

let nsfwToggle;
let filteReddit_filterline;
let filteReddit_visible;

let _filterlineResolve;

const filterlinePromise = new Promise(res => {
  _filterlineResolve = res;
});
let ensureFilterlineVisible;

const initialState = (async () => {
  const state = filterlineStorage.get();

  const _default = Promise.all(defaultFilters.map(({
    storage
  }) => storage.get())).then(v => v.find(Boolean));

  let {
    filters,
    visible,
    lastUsed
  } = await state;
  if (!filters || !Object.values(filters).length) filters = await _default;
  return {
    filters,
    visible,
    lastUsed
  };
})();

filteReddit_module.beforeLoad = async () => {
  updateNsfwBodyClass(filteReddit_module.options.NSFWfilter.value);
  nsfwToggle = new customToggles_Toggle('nsfwMode', i18n('nsfwSwitchToggleText'), filteReddit_module.options.NSFWfilter.value);
  nsfwToggle.onToggle(() => {
    filteReddit_module.options.NSFWfilter.value = nsfwToggle.enabled;
    options_save(filteReddit_module.options.NSFWfilter);
  });
  nsfwToggle.onStateChange(() => {
    updateNsfwBodyClass(nsfwToggle.enabled);
  });
  nsfwToggle.addCLI('nsfw');
  Object(watchers["watchForThings"])(['post'], updateNsfwThingClass, {
    immediate: true
  });
  populatePrimitives(['browse', filteReddit_thingType]);
  filteReddit_filterline = new Filterline_Filterline(filterlineStorage, filteReddit_thingType);
  const {
    filters,
    visible: _visible,
    lastUsed
  } = await initialState;
  filteReddit_filterline.restoreState(filters);
  populateFromOptions();

  _filterlineResolve(filteReddit_filterline);

  const hideUntilProcessed = filteReddit_module.options.hideUntilProcessed.value && filteReddit_filterline.getActiveFilters().length;
  Object(watchers["watchForThings"])([filteReddit_thingType], async thing => {
    if (!shouldFilter(thing)) return;
    if (hideUntilProcessed) thing.element.classList.add('res-thing-filter-unprocessed');

    try {
      await filteReddit_filterline.addThing(thing);
    } catch (e) {
      console.error(e);
    }

    if (hideUntilProcessed) thing.element.classList.remove('res-thing-filter-unprocessed');
  }, {
    immediate: true,
    id: 'filter'
  });
  if (filteReddit_module.options.excludeModqueue.value && Object(utils_location["n" /* isPageType */])('modqueue') || filteReddit_module.options.excludeUserPages.value && Object(utils_location["n" /* isPageType */])('profile')) filteReddit_filterline.togglePowered(false);
  filteReddit_visible = typeof _visible === 'boolean' ? _visible : filteReddit_module.options.showFilterline.value || filteReddit_filterline.getActiveFilters().some(v => !(v instanceof ExternalFilter_ExternalFilter));
  if (lastUsed) requestIdleCallback(() => {
    filterlineStorage.patch({
      lastUsed: Date.now()
    });
  });
};

filteReddit_module.contentStart = () => {
  makeFilterlineInteractable();

  if (filteReddit_module.options.NSFWQuickToggle.value) {
    nsfwToggle.addMenuItem(i18n('nsfwSwitchToggleTitle'), 8);
  }

  registerSubredditFilterCommand();
};

const shouldFilter = thing => !(filteReddit_module.options.excludeOwnPosts.value && context_data.username && Object(utils_location["e" /* currentUserProfile */])() !== context_data.username && context_data.username === thing.getAuthor());

function makeFilterlineInteractable() {
  const insertFilterline = Object(once["a" /* default */])(() => {
    filteReddit_filterline.createElement();

    if (Object(utils_location["i" /* isAppType */])('r2')) {
      Object(dom["o" /* waitForDescendant */])(document.body, Object(utils_location["n" /* isPageType */])('comments') ? '.comments-page .nestedlisting' : '#siteTable, .search-result-listing').then(sibling => sibling.before(filteReddit_filterline.element));
    } else {
      filterlineTab.append(filteReddit_filterline.element);
    }

    addFeatureTip('filterlineVisible', { ...featureTips.filterlineVisible,
      attachTo: filteReddit_filterline.element
    });
  });
  const filterlineTab = createElement_namespaceObject.tabMenuItem({
    text: '',
    title: 'Toggle Filterline visibility',
    className: 'res-toggle-filterline-visibility',
    checked: filteReddit_visible,
    onChange: active => {
      filteReddit_visible = active;

      if (filteReddit_visible) {
        insertFilterline();
        Object(dom["l" /* scrollToElement */])(filteReddit_filterline.element, null, {
          scrollStyle: 'legacy'
        });
      }

      if (filteReddit_filterline.element) filteReddit_filterline.element.hidden = !filteReddit_visible;
      filterlineStorage.patch({
        visible: filteReddit_visible
      });
    }
  });

  ensureFilterlineVisible = () => {
    if (!filteReddit_visible) filterlineTab.click();
  };

  const {
    getTip,
    executeCommand
  } = filteReddit_filterline.getCLI();
  registerCommand(/(fl|filterline)/, 'fl - modify Filterline', (cmd, val) => getTip(val), (cmd, val) => {
    ensureFilterlineVisible();
    executeCommand(val);
  });
  registerCommand(/fp/, 'fp - toggle filtering', () => 'Toggle filtering', () => {
    ensureFilterlineVisible();
    filteReddit_filterline.poweredElement.click();
  });
  addFeatureTip('filterline', { ...featureTips.filterline,
    attachTo: filterlineTab,
    continuation: () => {
      ensureFilterlineVisible();
      return 'filterlineVisible';
    }
  });
  if (filteReddit_visible) insertFilterline();
}

class filteReddit_ListFilter {
  get list() {
    return filteReddit_module.options[this.externalKey].value;
  }

  constructor(externalKey) {
    this.externalKey = void 0;
    this.filter = void 0;
    this.externalKey = externalKey;
  }

  initialize(caseType, additionalCriteria, useEffects = ['hide']) {
    const _listFilter = this;

    const sources = new Map();
    this.filter = addExternalFilter(this.externalKey, i18n(filteReddit_module.options[this.externalKey].title), () => {
      sources.clear();
      return resolveGroup(getGroup('any', this.list.map(v => {
        const c = getStringMatchConditions(v, caseType, additionalCriteria);
        sources.set(c, v);
        return c;
      })));
    }, class extends ExternalFilter_ExternalFilter {
      constructor(id, BaseCase, name, conditions, state, effects = {}) {
        const _effects = useEffects.reduce((acc, val) => {
          acc[val] = typeof effects[val] === 'boolean' ? effects[val] : true;
          return acc;
        }, {});

        super(id, BaseCase, name, conditions, state, _effects);
        this.toggleEffects = useEffects;
      }

      async getMatchingEntry(thing) {
        const matching = Array.from(sources.keys()).map(v => Case_Case.fromConditions(v).evaluate(thing) && sources.get(v));
        return (await Promise.all(matching)).filter(Boolean);
      }

      removeEntry(entries) {
        _listFilter.toggleEntry(false, ...entries);
      }

    });
  }

  findEntry(matchString) {
    return this.list.find(([str]) => str.toLowerCase() === matchString.toLowerCase());
  }

  toggleEntry(newState, ...entries) {
    if (newState) {
      this.list.push(...entries);
    } else {
      Object(pull["a" /* default */])(this.list, ...entries);
    }

    options_save(filteReddit_module.options[this.externalKey]);
    if (this.filter) return this.filter.update(undefined, null);
  }

  includesString(matchString) {
    return !!this.findEntry(matchString);
  }

  async toggleString(matchString, newState = !this.includesString(matchString)) {
    if (selectedThing_namespaceObject.current) selectedThing_namespaceObject.current.anchor();
    await this.toggleEntry(newState, this.findEntry(matchString) || [matchString]);
  }

}

const listFilters = {
  users: new filteReddit_ListFilter('users'),
  subreddits: new filteReddit_ListFilter('subreddits'),
  keywords: new filteReddit_ListFilter('keywords'),
  domains: new filteReddit_ListFilter('domains'),
  flair: new filteReddit_ListFilter('flair'),
  comments: new filteReddit_ListFilter('comments')
};
function addExternalFilter(id, name, getConditions, Filter = ExternalFilter_ExternalFilter) {
  const cased = createAdHoc(id, getConditions, 'external', filteReddit_thingType);
  return filteReddit_filterline.createFilter({
    Filter,
    id,
    name,
    type: cased.type,
    state: false,
    add: true,
    save: false
  });
}

function populateFromOptions() {
  const customFilters = lodash_es_groupBy(filteReddit_module.options[customFilterVariant].value, ({
    opts: {
      ondemand
    } = {}
  }) => ondemand ? 'ondemand' : 'always');

  if (customFilters.ondemand) {
    const cases = customFilters.ondemand.map(v => addOndemandCase(v, true));
    filteReddit_filterline.resumeDeferredTypes(cases.map(({
      type
    }) => type));
  }

  addExternalFilter(customFilterVariant, i18n(filteReddit_module.options[customFilterVariant].title), () => ({
    type: 'false'
  }));

  for (const customFilter of customFilters.always || []) {
    const conditions = resolveGroup(customFilter.body);
    if (!isUseful(conditions.type)) continue;
    addExternalFilter(customFilter.id, (customFilter.opts || {}).name, () => conditions, class extends ExternalFilter_ExternalFilter {
      constructor(id, BaseCase, name, conditions, state, effects) {
        const propagate = !!(customFilter.opts && customFilter.opts.propagate);
        super(id, BaseCase, name, conditions, state, {
          hide: true,
          propagate,
          ...effects
        });
      }

    });
  }

  if (!Object(utils_location["n" /* isPageType */])('profile')) {
    const effects = [filteReddit_module.options.usersMatchAction.value, filteReddit_module.options.usersMatchRepliesAction.value].filter(Boolean);
    listFilters.users.initialize('username', undefined, effects);
  }

  if (filteReddit_thingType === 'post') {
    listFilters.keywords.initialize('postTitle');
    listFilters.domains.initialize('domain', {
      fullMatch: false
    });

    if (filteReddit_module.options.filterSubredditsFrom.value === 'everywhere' || filteReddit_module.options.filterSubredditsFrom.value === 'everywhere-except-subreddit' && !Object(utils_location["d" /* currentSubreddit */])() || Object(utils_location["l" /* isCurrentSubreddit */])('all') || Object(utils_location["l" /* isCurrentSubreddit */])('popular') || Object(utils_location["b" /* currentDomain */])() || Object(utils_location["k" /* isCurrentMultireddit */])('me/f/all')) {
      listFilters.subreddits.initialize('subreddit');
    }

    listFilters.flair.initialize('linkFlair');
  } else {
    listFilters.comments.initialize('commentContent', undefined, ['hide', filteReddit_module.options.commentsHideReplies.value ? 'propagate' : null].filter(Boolean));
  }
}

function addOndemandCase(customFilter, onlyUseful = false) {
  const getConditions = () => resolveGroup(customFilter.body);

  if (!onlyUseful || isUseful(getConditions().type)) {
    return createAdHoc(customFilter.id, getConditions, 'ondemand', filteReddit_thingType, customFilter);
  } else {
    return cases_Inert;
  }
}
function addCustomFilter({
  body,
  opts
}) {
  const customFilter = {
    note: `From ${Object(utils_location["g" /* fullLocation */])()}`,
    ver: 3,
    id: `customFilter-${Date.now()}`,
    body,
    opts
  };
  filteReddit_module.options[customFilterVariant].value.unshift(customFilter);
  options_save(filteReddit_module.options[customFilterVariant]);
  return customFilter;
}
function updateCustomFilter(customFilter, val) {
  extendDeep(customFilter, val);
  options_save(filteReddit_module.options[customFilterVariant]);
}
async function saveFilterlineStateAsDefault(type) {
  const {
    storage
  } = defaultFilters.find(v => v.type === type) || {};
  if (!storage) throw new Error(`Could not find storage for type ${type}`);
  const v = await filterlineStorage.get();
  let {
    filters
  } = lodash_es_cloneDeep(v) || {};
  if (lodash_es_isEmpty(filters)) filters = null;
  await storage.set(filters);
  notifications_showNotification('Saved.', 1000);
}

function getStringMatchConditions(source, caseType, additionalCriteria) {
  const [matchString = '', applyTo = 'everywhere', applyList = '', except = ''] = source;
  const mainFilter = {
    type: caseType,
    patt: matchString,
    ...additionalCriteria
  };
  if (source.length === 1) return mainFilter;
  let applyToConditions;

  if (applyTo !== 'everywhere') {
    const subreddits = applyList.split(',');

    if (subreddits.findIndex(v => !v) !== -1) {
      console.error('Filter must have subreddits specified', source);
      return {
        type: 'false'
      };
    }

    applyToConditions = getGroup(applyTo === 'exclude' ? 'none' : 'any', [subreddits.includes('all') ? {
      type: 'currentSub',
      patt: 'all'
    } : null, subreddits.includes('popular') ? {
      type: 'currentSub',
      patt: 'popular'
    } : null, ...subreddits.map(sr => ({
      type: 'subreddit',
      patt: sr
    }))].filter(Boolean));
  }

  return getGroup('all', [applyToConditions || null, mainFilter, except && except.length && getGroup('none', [{
    type: caseType,
    patt: except,
    ...additionalCriteria
  }]) || null].filter(Boolean));
}

const reconcileNativeFilters = (() => {
  const getTopScore = Object(utils_async["a" /* batch */])(async requests => {
    const resp = await ajax({
      url: `/r/${requests.map(r => r.sub).join('+')}/top.json`,
      query: {
        t: 'day',
        limit: 100
      },
      type: 'json'
    });

    if (!resp.data.children.length) {
      return requests.map(() => 0);
    }

    const topScoreBySub = new Map(resp.data.children.reverse().map(post => [post.data.subreddit.toLowerCase(), post.data.score]));
    return requests.map(({
      sub,
      depth = 0
    }) => {
      const score = topScoreBySub.get(sub.toLowerCase());

      if (score !== undefined) {
        return score;
      } else if (depth > 5) {
        return 0;
      } else {
        return getTopScore({
          sub,
          depth: depth + 1
        });
      }
    });
  }, {
    size: 100,
    delay: 2000
  });

  async function sortByPopularity(subreddits) {
    const scores = await Promise.all(subreddits.map(sub => getTopScore({
      sub
    })));
    return lodash_es_sortBy(lodash_es_zip(subreddits, scores), ([, score]) => score).map(([sub]) => sub).filter(Boolean).reverse();
  }

  return Object(utils_async["h" /* mutex */])(async ({
    warnNotLoggedIn = false
  } = {}) => {
    const user = context_data.username;

    if (!user) {
      if (warnNotLoggedIn) {
        notifications_showNotification({
          moduleID: filteReddit_module.moduleID,
          notificationID: 'filterSyncNotLoggedIn',
          header: 'Filters not synced',
          message: 'You must log in to sync filters.'
        });
      }

      console.warn('Not syncing filters, not logged in...');
      return;
    }

    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      notificationID: 'filterSyncStarted',
      message: 'Filter sync started...'
    });
    const {
      data: {
        subreddits
      }
    } = await ajax({
      url: `/api/filter/user/${user}/f/all`,
      type: 'json'
    });
    const existing = subreddits.map(({
      name
    }) => name.toLowerCase());
    const desired = (await sortByPopularity(filteReddit_module.options.subreddits.value.map(([sr]) => sr).filter(sr => !string_namespaceObject.regexRegex.test(sr)).map(name => name.toLowerCase()))).slice(0, 100);
    const toRemove = lodash_es_difference(existing, desired).length;
    const toAdd = lodash_es_difference(desired, existing).length;

    if (!toRemove && !toAdd) {
      notifications_showNotification({
        moduleID: filteReddit_module.moduleID,
        optionKey: 'useRedditFilters',
        notificationID: 'filterSyncNoneAddedOrRemoved',
        closeDelay: 5000,
        header: 'No filters synced',
        message: `
					Either no subreddit filters were changed, or you have more than 100 subreddits filtered.
					Reddit's native /r/all filtering is limited to 100 subreddits.
				`
      });
      return;
    }

    try {
      await ajax({
        method: 'PUT',
        url: `/api/filter/user/${user}/f/all`,
        data: {
          model: JSON.stringify({
            subreddits: desired.map(name => ({
              name
            }))
          })
        }
      });
    } catch (e) {
      console.error(e);
      notifications_showNotification({
        moduleID: filteReddit_module.moduleID,
        optionKey: 'useRedditFilters',
        notificationID: 'filterSyncError',
        header: 'Error syncing filters',
        message: `Filters could not be synced: ${e}`
      });
      return;
    }

    notifications_showNotification({
      moduleID: filteReddit_module.moduleID,
      optionKey: 'useRedditFilters',
      notificationID: 'filterSyncSuccess',
      header: 'Successfully synced filters',
      message: `Removed ${toRemove} and added ${toAdd} filters.`
    });
  });
})();

const subredditAllowNsfwOption = Object(once["a" /* default */])(() => indexOptionTable(filteReddit_module.options.allowNSFW, 0, key => key.toLowerCase()));
const allowAllNsfw = Object(memoize["a" /* default */])(subreddit => {
  const currOptionValue = subredditAllowNsfwOption()[subreddit.toLowerCase()];
  return currOptionValue && currOptionValue[0][1] === 'visit';
});

function allowNSFW(postSubreddit, currSubreddit = Object(utils_location["d" /* currentSubreddit */])()) {
  if (!filteReddit_module.options.allowNSFW.value || !filteReddit_module.options.allowNSFW.value.length) return false;

  if (currSubreddit && allowAllNsfw(currSubreddit)) {
    return true;
  }

  if (!postSubreddit) postSubreddit = currSubreddit;
  if (!postSubreddit) return false;
  const postOptionValue = subredditAllowNsfwOption()[postSubreddit.toLowerCase()];

  if (postOptionValue) {
    if (postOptionValue[0][1] === 'everywhere') {
      return true;
    } else {
      return (currSubreddit || '').split('+').includes(postSubreddit);
    }
  }

  return false;
}

function updateNsfwThingClass(thing) {
  if (thing.isNSFW()) {
    if (allowNSFW(thing.getSubreddit(), Object(utils_location["d" /* currentSubreddit */])())) {
      thing.element.classList.add('allowOver18');
    }

    thing.element.classList.add('over18');
  }
}

function updateNsfwBodyClass(filterOn) {
  bodyClasses_namespaceObject.toggle(filterOn, 'hideOver18');
}

function registerSubredditFilterCommand() {
  const getSubreddit = val => val || selectedThing_namespaceObject.current && selectedThing_namespaceObject.current.getSubreddit() || Object(utils_location["d" /* currentSubreddit */])() || '';

  registerCommand(/^f(?:ilter)?/, 'f[ilter] [subreddit] - toggle subreddit filter', (cmd, val) => {
    const subreddit = getSubreddit(val);
    return `toggle subreddit filter for: ${subreddit}`;
  }, (cmd, val) => {
    const subreddit = getSubreddit(val);
    if (!subreddit) return 'no subreddit specified or post selected';
    listFilters.subreddits.toggleString(subreddit);
  });
}
// EXTERNAL MODULE: ./node_modules/suncalc/suncalc.js
var suncalc = __webpack_require__(106);

// CONCATENATED MODULE: ./lib/modules/nightMode.js









const nightMode_module = new Module('nightMode');
nightMode_module.moduleName = 'nightModeName';
nightMode_module.category = 'appearanceCategory';
nightMode_module.description = 'nightModeDesc';
nightMode_module.options = {
  nightModeOn: {
    type: 'boolean',
    value: false,
    description: 'nightModeNightModeOnDesc',
    title: 'nightModeNightModeOnTitle'
  },
  nightSwitch: {
    type: 'boolean',
    value: true,
    description: 'nightModeNightSwitchDesc',
    title: 'nightModeNightSwitchTitle',
    advanced: true
  },
  automaticNightMode: {
    type: 'enum',
    value: 'none',
    values: [{
      name: 'nightModeAutomaticNightModeNone',
      value: 'none'
    }, {
      name: 'nightModeAutomaticNightModeAutomatic',
      value: 'automatic'
    }, {
      name: 'nightModeAutomaticNightModeUser',
      value: 'user'
    }, {
      name: 'nightModeAutomaticNightModeSystem',
      value: 'system'
    }],
    description: 'nightModeAutomaticNightModeDesc',
    title: 'nightModeAutomaticNightModeTitle'
  },
  nightModeStart: {
    type: 'text',
    value: '20:00',
    description: 'nightModeNightModeStartDesc',
    title: 'nightModeNightModeStartTitle',
    dependsOn: options => options.automaticNightMode.value === 'user'
  },
  nightModeEnd: {
    type: 'text',
    value: '6:00',
    description: 'nightModeNightModeEndDesc',
    title: 'nightModeNightModeEndTitle',
    dependsOn: options => options.automaticNightMode.value === 'user'
  },
  nightModeOverrideHours: {
    type: 'text',
    value: '8',
    description: 'nightModeNightModeOverrideHoursDesc',
    title: 'nightModeNightModeOverrideHoursTitle',
    dependsOn: options => options.automaticNightMode.value !== 'none'
  },
  useSubredditStyles: {
    type: 'boolean',
    value: false,
    description: 'nightModeUseSubredditStylesDesc',
    title: 'nightModeUseSubredditStylesTitle',
    advanced: true
  },
  subredditStylesWhitelist: {
    type: 'list',
    value: '',
    listType: 'subreddits',
    description: 'nightModeSubredditStylesWhitelistDesc',
    title: 'nightModeSubredditStylesWhitelistTitle'
  },
  coloredLinks: {
    type: 'boolean',
    bodyClass: true,
    value: false,
    description: 'nightModeColoredLinksDesc',
    title: 'nightModeColoredLinksTitle'
  }
};
const localStorageKey = 'RES_nightMode';
const nightModeActive = () => typeof localStorage === 'object' && !!localStorage.getItem(localStorageKey);
const nightmodeOverrideStorage = storage_namespaceObject.wrap('RESmodules.nightMode.nightModeOverrideStart', null);
let nightMode_toggle;

nightMode_module.onInit = () => {
  if (nightModeActive()) addStyle();
};

nightMode_module.beforeLoad = () => {
  nightMode_toggle = new customToggles_Toggle('nightMode', i18n('nightModeToggleText'), nightMode_module.options.nightModeOn.value);
  nightMode_toggle.onToggle(type => {
    options_save(nightMode_module.options.nightModeOn);
    if (type === 'manual') nightmodeOverrideStorage.set(Date.now());
  });
  nightMode_toggle.onStateChange(() => {
    nightMode_module.options.nightModeOn.value = nightMode_toggle.enabled;
    refreshStyle();
    refreshSubredditStyleCompatability();
  });
  nightMode_toggle.addCLI('ns');
  if (nightMode_module.options.nightSwitch.value) nightMode_toggle.addMenuItem(i18n('nightModeToggleTitle'), 7, '☽', '☀');

  if (nightMode_module.options.automaticNightMode.value !== 'none') {
    refreshAutomaticNightMode();
  }

  refreshSubredditStyleCompatability();
};

nightMode_module.always = () => {
  refreshStyle();
};

const nightMode_id = `nightMode.compatibleSubredditStyle.${Object(utils_location["d" /* currentSubreddit */])() || ''}`;
let compatibleSubredditStyle = session_namespaceObject.get(nightMode_id).then(compatible => typeof compatible === 'boolean' ? compatible : !nightModeActive());
const onUpdate = [];

async function refreshSubredditStyleCompatability() {
  const subreddit = Object(utils_location["d" /* currentSubreddit */])();
  if (!subreddit) return;
  compatibleSubredditStyle = !subreddit || ['all', 'popular', 'friends', 'mod'].includes(subreddit) || (await (async () => {
    await loadOptions;

    if (!nightModeActive()) {
      return true;
    }

    if (nightMode_module.options.useSubredditStyles.value) {
      return true;
    }

    const isWhitelisted = nightMode_module.options.subredditStylesWhitelist.value.split(',').includes(subreddit.toLowerCase());

    if (isWhitelisted) {
      return true;
    }
  })()) || (await (async () => {
    const query = () => !!document.querySelector('.side a[href$="#/RES_SR_Config/NightModeCompatible"]');

    return query() || (await pagePhases.bodyStart.then(query)) || (await Object(dom["n" /* waitForChild */])(document.body, '.side').then(query)) || pagePhases.contentStart.then(query);
  })());
  const compatible = await compatibleSubredditStyle;

  for (const callback of onUpdate) callback();

  session_namespaceObject.set(nightMode_id, compatible);
}

async function toggledSubredditStyle(toggledOn) {
  const currSub = Object(utils_location["d" /* currentSubreddit */])();

  if (!nightModeActive() || !currSub) {
    return;
  }

  const subreddit = currSub.toLowerCase();
  const whitelist = nightMode_module.options.subredditStylesWhitelist.value.split(',');

  if (toggledOn && !compatibleSubredditStyle) {
    if (!whitelist.includes(subreddit)) {
      whitelist.push(subreddit);
    }
  } else if (!toggledOn) {
    Object(pull["a" /* default */])(whitelist, subreddit);
  }

  nightMode_module.options.subredditStylesWhitelist.value = whitelist.join(',');
  options_save(nightMode_module.options.subredditStylesWhitelist);
  await refreshSubredditStyleCompatability();
}

async function refreshAutomaticNightMode() {
  const nightModeOverrideStart = await nightmodeOverrideStorage.get();
  const nightModeOverrideLength = utils_time["b" /* HOUR */] * parseFloat(nightMode_module.options.nightModeOverrideHours.value);
  const nightModeOverrideEnd = (parseInt(nightModeOverrideStart, 10) || 0) + nightModeOverrideLength;
  if (Date.now() <= nightModeOverrideEnd) return;
  nightMode_toggle.toggle('auto', await isTimeForNightMode());
}

function getGeolocation() {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(position => resolve(position.coords), reject);
  });
}

async function getNightModeTimes() {
  switch (nightMode_module.options.automaticNightMode.value) {
    case 'automatic':
      try {
        const {
          latitude,
          longitude
        } = await getGeolocation();
        const {
          sunrise,
          sunset
        } = Object(suncalc["getTimes"])(new Date(), latitude, longitude);
        return {
          startingTime: sunset,
          endingTime: sunrise
        };
      } catch (err) {
        console.warn('Failed to init automatic night mode:', err);

        switch (err.code) {
          case err.PERMISSION_DENIED:
            if (!location.protocol.startsWith('http')) throw err;
            return alert_namespaceObject.open(i18n('nightModeAutomaticNightModeDenied', 'confirm'), {
              cancelable: true
            }).then(() => {
              nightMode_module.options.automaticNightMode.value = 'none';
              options_save(nightMode_module.options.automaticNightMode);
              return {
                startingTime: new Date(0),
                endingTime: new Date(0)
              };
            });

          case err.POSITION_UNAVAILABLE:
          case err.TIMEOUT:
          case err.UNKNOWN_ERROR:
          default:
            throw err;
        }
      }

    case 'user':
      return {
        startingTime: timeStringToDate(nightMode_module.options.nightModeStart.value),
        endingTime: timeStringToDate(nightMode_module.options.nightModeEnd.value)
      };

    default:
      throw new Error(`Invalid automaticNightMode value: ${nightMode_module.options.automaticNightMode.value}`);
  }
}

async function isTimeForNightMode() {
  if (nightMode_module.options.automaticNightMode.value === 'system') {
    return window.matchMedia('(prefers-color-scheme: dark)').matches;
  }

  const currentTime = new Date();
  const {
    startingTime,
    endingTime
  } = await getNightModeTimes();

  if (startingTime <= endingTime) {
    return startingTime <= currentTime && currentTime < endingTime;
  } else {
    return startingTime <= currentTime || currentTime < endingTime;
  }
}

function timeStringToDate(timeString) {
  const [hour, minute] = timeString.split(':').map(s => parseInt(s, 10));
  const date = new Date();
  date.setHours(hour, minute, 0, 0);
  return date;
}

const nightMode_className = () => {
  switch (Object(utils_location["a" /* appType */])()) {
    case 'r2':
    case 'options':
      return 'res-nightmode';

    case 'd2x':
      return 'res-d2x-nightmode';

    default:
      throw new Error(`Impossible appType: ${Object(utils_location["a" /* appType */])()}`);
  }
};

const addStyle = () => bodyClasses_namespaceObject.add(nightMode_className());

const removeStyle = () => bodyClasses_namespaceObject.remove(nightMode_className());

const refreshStyle = () => {
  if (isRunning(nightMode_module) && nightMode_module.options.nightModeOn.value) {
    addStyle();
    localStorage.setItem(localStorageKey, 'true');
  } else {
    removeStyle();
    localStorage.removeItem(localStorageKey);
  }
};
// CONCATENATED MODULE: ./lib/modules/userTagger.js











const userTagger_module = new Module('userTagger');
const bgToTextColorMap = {
  none: 'inherit',
  aqua: 'black',
  black: 'white',
  blue: 'white',
  cornflowerblue: 'white',
  fuchsia: 'white',
  gray: 'white',
  green: 'white',
  lime: 'black',
  maroon: 'white',
  navy: 'white',
  olive: 'white',
  orange: 'white',
  orangered: 'white',
  pink: 'black',
  purple: 'white',
  red: 'white',
  silver: 'black',
  teal: 'white',
  white: 'black',
  yellow: 'black'
};
userTagger_module.moduleName = 'userTaggerName';
userTagger_module.category = 'usersCategory';
userTagger_module.description = 'userTaggerDesc';
userTagger_module.options = {
  showTaggingIcon: {
    title: 'userTaggerShowTaggingIconTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerShowTaggingIconDesc'
  },
  storeSourceLink: {
    title: 'userTaggerStoreSourceLinkTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerStoreSourceLinkDesc',
    advanced: true
  },
  useCommentsLinkAsSource: {
    title: 'userTaggerUseCommentsLinkAsSourceTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerUseCommentsLinkAsSourceDesc',
    advanced: true
  },
  trackVoteWeight: {
    title: 'userTaggerTrackVoteWeightTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerTrackVoteWeightDesc',
    advanced: true
  },
  vwNumber: {
    title: 'userTaggerVwNumberTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerVWNumberDesc',
    advanced: true,
    dependsOn: options => options.trackVoteWeight.value
  },
  truncateTag: {
    title: 'userTaggerTruncateTagTitle',
    type: 'boolean',
    value: true,
    description: 'userTaggerTruncateTagDesc',
    advanced: true
  },
  presetTags: {
    title: 'userTaggerPresetTagsTitle',
    type: 'table',
    addRowText: '+add preset',
    fields: [{
      key: 'text',
      name: 'text',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'select',
      value: 'none',
      values: Object.entries(bgToTextColorMap).map(([k, v]) => ({
        name: k,
        value: k,
        style: `color: ${v}; background-color: ${k};`
      }))
    }],
    value: [],
    description: 'userTaggerPresetTagsDesc',
    advanced: true
  }
};
const tagStorage = storage_namespaceObject.wrapPrefix('tag.', () => null, user => user.toLowerCase(), true);

userTagger_module.beforeLoad = () => {
  Object(watchers["watchForThings"])(null, thing => {
    const ele = thing.getAuthorElement();
    if (ele) applyFromElement(ele);
  });
  Object(watchers["watchForElements"])(['page', 'selfText'], usernameSelector, applyFromElement);
  watchForRedditEvents('postAuthor', (element, {
    author,
    _: {
      update
    }
  }) => {
    if (update) return;

    for (const tag of element.getElementsByClassName('RESUserTag')) tag.remove();

    applyToUser(element, {
      username: author
    });
  });
  watchForRedditEvents('commentAuthor', (element, {
    author,
    _: {
      update
    }
  }) => {
    if (update) return;
    applyToUser(element, {
      username: author
    });
  });
  watchForRedditEvents('userHovercard', (element, {
    user: {
      username
    },
    _: {
      update
    }
  }) => {
    if (update) return;
    applyToUser(element, {
      username,
      renderTaggingIcon: false
    });
  });
};

userTagger_module.contentStart = () => {
  if (userTagger_module.options.trackVoteWeight.value && loggedInUser()) {
    attachVoteHandler();
  }

  userTagger_registerCommandLine();
  addDashboardTab('userTaggerContents', i18n('userTaggerMyUserTags'), userTagger_module.moduleID, userTagger_addDashboardFunctionality);
};

function applyFromElement(element) {
  const username = getUsernameFromLink(element);
  if (username) return applyToUser(element, {
    username
  });
}

function applyToUser(element, {
  username,
  renderTaggingIcon = userTagger_module.options.showTaggingIcon.value && username !== loggedInUser(),
  renderVoteWeight = userTagger_module.options.trackVoteWeight.value && username !== loggedInUser()
} = {}) {
  const tag = userTagger_Tag.getUnfilled(username);
  tag.add(element, {
    renderVoteWeight,
    renderTaggingIcon
  });
  tag.fill();
}
const tags = new Map();
class userTagger_Tag {
  static buildTagElement({
    text,
    color
  } = {}) {
    return string_namespaceObject.html`
			<span class="RESUserTag">
				<a
					class="userTagLink ${text || color ? 'hasTag' : 'RESUserTagImage'} ${userTagger_module.options.truncateTag.value ? 'truncateTag' : ''}"
					${(text || color) && string_namespaceObject._html`style="background-color: ${color || 'none'}; color: ${bgToTextColorMap[color || 'none']} !important;"`}
					title="${text || 'set a tag'}"
					href="javascript:void 0"
				>${text || '\u00A0'}</a>
			</span>
		`;
  }

  static async getStored() {
    return Object.entries(await tagStorage.getAll()).map(([k, v]) => {
      const tag = userTagger_Tag.getUnfilled(k);
      tag.load(v);
      return tag;
    });
  }

  static getUnfilled(id) {
    let tag = tags.get(id);

    if (!tag) {
      tag = new userTagger_Tag(id);
      tags.set(id, tag);
    }

    return tag;
  }

  static async get(id) {
    const tag = userTagger_Tag.getUnfilled(id);
    await tag.fill();
    return tag;
  }

  get ignored() {
    return listFilters.users.includesString(this.id);
  }

  constructor(id = '~dummy') {
    this.id = void 0;
    this.text = null;
    this.link = null;
    this.color = null;
    this.votesUp = 0;
    this.votesDown = 0;
    this.instances = [];
    this.fill = Object(once["a" /* default */])(async () => {
      const data = await tagStorage.get(this.id);

      if (data) {
        if (Object.keys(this.getBaseDifference(data)).length) {
          this.load(data);
        } else {
          this.delete();
        }
      }
    });
    this.id = id;
  }

  load(data) {
    if (data.color !== undefined) this.color = data.color;else if (data.color === 'none') this.color = null;
    if (data.link !== undefined) this.link = data.link;
    if (data.text !== undefined) this.text = data.text;
    if (data.votesDown !== undefined) this.votesDown = data.votesDown;
    if (data.votesUp !== undefined) this.votesUp = data.votesUp;

    for (const instance of this.instances) this.render(instance);
  }

  extract() {
    return {
      color: this.color,
      link: this.link,
      text: this.text,
      votesDown: this.votesDown,
      votesUp: this.votesUp
    };
  }

  save() {
    tagStorage.set(this.id, this.getBaseDifference());
  }

  getBaseDifference(data = this.extract()) {
    const base = new userTagger_Tag().extract();
    return lodash_es_pickBy(data, (v, k) => base[k] !== v);
  }

  delete() {
    tagStorage.delete(this.id);
  }

  add(element, {
    renderTaggingIcon,
    renderVoteWeight,
    append = Object(utils_location["i" /* isAppType */])('d2x')
  } = {}) {
    const instance = this.instances.find(v => v.element === element) || {
      element
    };
    instance.append = append;
    if (!this.instances.includes(instance)) this.instances.push(instance);
    if (renderTaggingIcon) instance.renderTaggingIcon = true;
    if (renderVoteWeight) instance.renderVoteWeight = true;
    this.render(instance);
  }

  get votes() {
    return this.votesUp - this.votesDown;
  }

  ignore({
    showNotice = true
  } = {}) {
    if (showNotice) {
      notifications_showNotification({
        moduleID: userTagger_module.moduleID,
        notificationID: 'addedToIgnoreList',
        message: `
					<p>Now ignoring content posted by ${this.id}.</p>
					${Object(utils_location["n" /* isPageType */])('inbox') ? `
						<p>If you wish to block ${this.id} from sending you messages, go to <a href="/message/messages/">your messages</a> and click 'block user' underneath their last message.</p>
						<p><a href="https://www.reddit.com/r/changelog/comments/ijfps/reddit_change_users_may_block_other_users_that/">About blocking users</a>.</p>
					` : ''}
				`,
        closeDelay: 5000
      });
    }

    listFilters.users.toggleString(this.id, true);
    if (!this.text) this.load({
      text: 'ignored'
    });
    this.save();
  }

  unignore() {
    listFilters.users.toggleString(this.id, false);
    if (this.text === 'ignored') this.load({
      text: null
    });
    this.save();
  }

  openPrompt(instance) {
    if (this.link === null && userTagger_module.options.storeSourceLink.value) {
      this.link = getLinkBasedOnTagLocation(instance.element);
    }

    infocard('userTagger').target(instance.tagger || instance.element).options({
      openDelay: 0,
      width: 350,
      closeOnMouseOut: false
    }).populateWith(card => populateDialog(this, card)).begin();
  }

  render(instance) {
    if (instance.vw) instance.vw.remove();

    if (instance.renderVoteWeight && (this.votesUp || this.votesDown)) {
      instance.vw = Object(dom["k" /* preventCloning */])(string_namespaceObject.html`
				<a
					class="voteWeight"
					href="javascript:void 0"
					title="${i18n('userTaggerYourVotesFor', this.id, `+${this.votesUp} -${this.votesDown}`)}"
					style="${getVoteWeightStyle(this)}"
				>${userTagger_module.options.vwNumber.value ? `[${this.votes > 0 ? '+' : ''}${this.votes}]` : '[vw]'}</a>
			`);
      instance.vw.addEventListener('click', () => this.openPrompt(instance));

      if (instance.append) {
        (instance.tagger || instance.element).appendChild(instance.vw);
      } else {
        (instance.tagger || instance.element).after(instance.vw);
      }
    }

    if (instance.tagger) instance.tagger.remove();

    if (this.text || this.color || instance.renderTaggingIcon) {
      instance.tagger = Object(dom["k" /* preventCloning */])(this.text || this.color ? userTagger_Tag.buildTagElement(this) : userTagger_Tag.defaultTagElement());
      instance.tagger.addEventListener('click', () => this.openPrompt(instance));

      if (instance.append) {
        instance.element.appendChild(instance.tagger);
      } else {
        instance.element.after(instance.tagger);
      }
    }
  }

}

userTagger_Tag.defaultTagElement = (e => () => e().cloneNode(true))(Object(once["a" /* default */])(() => userTagger_Tag.buildTagElement()));

function populateDialog(tag, card) {
  const head = string_namespaceObject.html`<div class="userTagger-dialog-head">
		<span class="res-icon">&#xF0AC;</span>
		<span>${tag.id}</span>
		<span class="res-usertag-ignore"></span>
		</div>
	</div>`;
  const colors = Object.entries(bgToTextColorMap).map(([color, textColor]) => ({
    textColor,
    color
  }));
  const presetTags = userTagger_module.options.presetTags.value;
  const body = string_namespaceObject.html`
		<form id="userTaggerToolTip">
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerText">Text</label>
				<input class="fieldPair-text" type="text" id="userTaggerText" value="${tag.text}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerColor">Color</label>
				<select id="userTaggerColor">
					${colors.map(({
    textColor,
    color
  }) => string_namespaceObject._html`
						<option style="color: ${textColor}; background-color: ${color}" value="${color}" ${tag.color === color && string_namespaceObject._html`selected`}>${color}</option>
					`)}
				</select>
			</div>
			<div class="fieldPair" style="flex-wrap: wrap">
				<label class="fieldPair-label" for="userTaggerPreview">Preview</label>
				<span id="userTaggerPreview"></span>
				<a id="userTaggerPresetSaveAs" title="save as preset" href="javascript:void 0">save as preset</a>
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerLink">
					<span class="userTaggerOpenLink">
						<a title="open link" href="javascript:void 0">Source URL</a>
					</span>
				</label>
				<input class="fieldPair-text" type="text" id="userTaggerLink" value="${tag.link}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerVotesUp" title="Upvotes you have given this redditor">Upvotes</label>
				<input type="number" style="width: 50px;" id="userTaggerVotesUp" value="${tag.votesUp}">
			</div>
			<div class="fieldPair">
				<label class="fieldPair-label" for="userTaggerVotesDown" title="Downvotes you have given this redditor">Downvotes</label>
				<input type="number" style="width: 50px;" id="userTaggerVotesDown" value="${tag.votesDown}">
			</div>
			<div class="fieldPair" ${!presetTags.length && 'hidden'}>
				<label class="fieldPair-label" for="userTaggerPresetTags">Presets</label>
				<span id="userTaggerPresetTags"></span>
			</div>
			<div class="res-usertagger-footer">
				<a href="/r/dashboard#userTaggerContents" target="_blank" rel="noopener noreferer">View tagged users</a>
				<input type="submit" id="userTaggerSave" value="✓ save tag">
			</div>
		</form>
	`;
  const elements = {
    color: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerColor'), HTMLSelectElement),
    presetSaveAs: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerPresetSaveAs'), HTMLAnchorElement),
    presetTag: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerPresetTags'), HTMLElement),
    presetFieldPair: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerPresetTags').parentElement, HTMLElement),
    link: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerLink'), HTMLInputElement),
    openLink: Object(flow["a" /* downcast */])(body.querySelector('.userTaggerOpenLink a'), HTMLAnchorElement),
    preview: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerPreview'), HTMLElement),
    save: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerSave'), HTMLElement),
    text: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerText'), HTMLInputElement),
    votesDown: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerVotesDown'), HTMLInputElement),
    votesUp: Object(flow["a" /* downcast */])(body.querySelector('#userTaggerVotesUp'), HTMLInputElement)
  };
  head.querySelector('.res-usertag-ignore').append(createElement_namespaceObject.toggleButton(ignore => {
    const textShouldBeUpdated = extract().text === tag.text;
    if (ignore) tag.ignore();else tag.unignore();
    if (textShouldBeUpdated) elements.text.value = tag.text || '';
    updateTagPreview();
  }, 'userTaggerIgnore', tag.ignored, '\uF038', '\uF03B', false, true));

  function extract() {
    return {
      color: elements.color.value !== 'none' ? elements.color.value : null,
      link: elements.link.value || null,
      text: elements.text.value || null,
      votesDown: parseInt(elements.votesDown.value, 10) || 0,
      votesUp: parseInt(elements.votesUp.value, 10) || 0
    };
  }

  function updateTagPreview() {
    Object(dom["e" /* empty */])(elements.preview);
    elements.preview.appendChild(userTagger_Tag.buildTagElement(extract()));
  }

  function buildPresetTagElement(text, color) {
    const element = userTagger_Tag.buildTagElement({
      text,
      color
    });
    element.addEventListener('click', () => {
      tag.load({
        text,
        color
      });
      tag.save();
      card.close();
    });
    return element;
  }

  function saveAsPreset() {
    const {
      text,
      color
    } = extract();

    if (text || color) {
      elements.presetFieldPair.hidden = false;
      elements.presetTag.append(buildPresetTagElement(text, color));
      userTagger_module.options.presetTags.value.push([String(text), String(color)]);
      options_save(userTagger_module.options.presetTags);
    } else {
      window.alert('Tag text must be specified in order to save as preset.');
    }
  }

  elements.openLink.addEventListener('click', () => openNewTabs('none', ...elements.link.value.split(/\s/)));
  elements.presetTag.append(...presetTags.map(([text, color]) => buildPresetTagElement(text, color)));
  elements.presetSaveAs.addEventListener('click', () => saveAsPreset());
  jquery_default()(body).on('change input click', updateTagPreview);
  body.addEventListener('submit', e => {
    e.preventDefault();
    tag.load(extract());
    tag.save();
    card.close();
  });
  updateTagPreview();
  setTimeout(() => {
    elements.text.setSelectionRange(elements.text.value.length, elements.text.value.length);
    elements.text.focus();
  });
  return [head, body];
}

function userTagger_registerCommandLine() {
  let tag;
  registerCommand('tag', `tag [text] - ${i18n('userTaggerCommandLineDescription')}`, async (command, val) => {
    const username = selectedThing_namespaceObject.current && selectedThing_namespaceObject.current.getAuthor();
    tag = username && (await userTagger_Tag.get(username));
    return tag ? i18n(val ? 'userTaggerTagUserAs' : 'userTaggerTagUser', tag.id, val) : i18n('userTaggerTagCanNotSetTag');
  }, (command, val) => {
    if (tag) {
      tag.load({
        text: val
      });
      tag.save();
    } else {
      return i18n('userTaggerTagCanNotSetTag');
    }
  });
}

function attachVoteHandler() {
  document.body.addEventListener('click', e => {
    if (e.button !== 0) return;

    if (e.target.classList.contains('arrow')) {
      handleVoteClick(e.target);
    }
  }, true);
}

async function handleVoteClick(arrow) {
  const $this = jquery_default()(arrow);
  const $otherArrow = $this.siblings('.arrow');

  if ($this.hasClass('archived')) {
    return;
  }

  let up = 0;
  let down = 0;

  if ($this.hasClass('up')) {
    up = 1;

    if ($otherArrow.hasClass('downmod')) {
      down = -1;
    }
  } else if ($this.hasClass('upmod')) {
    up = -1;
  } else if ($this.hasClass('down')) {
    down = 1;

    if ($otherArrow.hasClass('upmod')) {
      up = -1;
    }
  } else if ($this.hasClass('downmod')) {
    down = -1;
  }

  const thing = Thing["a" /* Thing */].checkedFrom(arrow);
  const username = thing.getAuthor();
  if (username === loggedInUser()) return;
  const tag = username && (await userTagger_Tag.get(username));
  if (!tag) throw new Error('No tag');
  tag.load({
    votesUp: tag.votesUp + up,
    votesDown: tag.votesDown + down
  });
  tag.save();
}

function getLinkBasedOnTagLocation(obj) {
  const thing = Thing["a" /* Thing */].from(obj);
  if (!thing) return '';
  const link = !userTagger_module.options.useCommentsLinkAsSource.value && thing.getTitleElement() || thing.getCommentPermalink();
  return link ? link.href : '';
}

function getVoteWeightStyle({
  votes,
  votesUp,
  votesDown
}) {
  let red = 255;
  let green = 255;
  let blue = 255;
  let alpha = 1;

  if (votesUp > votesDown) {
    red = Math.max(0, 255 - 8 * votes);
    green = 255;
    blue = Math.max(0, 255 - 8 * votes);
    alpha = Math.abs(votes) / (votesUp + votesDown);
  } else if (votesUp < votesDown) {
    red = 255;
    green = Math.max(0, 255 - Math.abs(8 * votes));
    blue = Math.max(0, 255 - Math.abs(8 * votes));
    alpha = Math.abs(votes) / (votesUp + votesDown);
  }

  const color = `rgba(${red}, ${green}, ${blue}, ${0.2 + alpha * 0.8})`;
  return nightModeActive() ? `color: ${color};` : `background-color: ${color};`;
}

async function userTagger_addDashboardFunctionality(tabPage) {
  const headers = {
    username: i18n('userTaggerUsername'),
    tag: i18n('userTaggerTag'),
    color: i18n('userTaggerColor'),
    votesDown: i18n('userTaggerVotesDown'),
    votesUp: i18n('userTaggerVotesUp'),
    delete: ''
  };
  const data = await userTagger_Tag.getStored();
  const table = new table_namespaceObject.RESTable(headers, data, tag => {
    const tagSpan = document.createElement('span');
    tag.add(tagSpan, {
      renderTaggingIcon: true,
      append: true
    });
    const deleteSpan = string_namespaceObject.html`<span class="res-icon res-right deleteIcon" data-icon="&#xf056;"></span>`;
    deleteSpan.addEventListener('click', () => {
      alert_namespaceObject.open(i18n('userTaggerAreYouSureYouWantToDeleteTag', tag.id), {
        cancelable: true
      }).then(() => {
        tag.delete();
        Object(pull["a" /* default */])(data, tag);
        table.refresh();
      });
    });
    return {
      username: string_namespaceObject.html`<a href="/user/${tag.id}">${tag.id}</a>`,
      tag: tagSpan,
      color: string_namespaceObject.html`<span style="color: ${tag.color || 'initial'}">${tag.color ? tag.color : ''}</span>`,
      votesDown: tag.votesDown,
      votesUp: tag.votesUp,
      delete: deleteSpan
    };
  }, {
    sortBy: 'username'
  });
  const element = document.createElement('div');
  element.append(table.createSearchElement(tag => tag.id, 'Username', true), table.createSearchElement(tag => tag.text, 'Tag'), table.createSelectFilterElement([{
    name: i18n('userTaggerAllUsers'),
    filter: () => true,
    initialSelected: false
  }, {
    name: i18n('userTaggerTaggedUsers'),
    filter: tag => tag.text,
    initialSelected: true
  }]), table.createPaginationElement(), table.element);
  tabPage.append(element);
}
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserTag.js


class UserTag_UserTag extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `user tag ${this.conditions.patt}`.trim();
    this.value = this.build(true, '/./');
  }

  static async thingToCriterion(thing) {
    const author = thing.getAuthor();
    return author && (await userTagger_Tag.get(author)).text || '';
  }

  async evaluate(thing) {
    const author = thing.getAuthor();
    if (!author) return null;
    const tag = (await userTagger_Tag.get(author)).text;
    return tag ? this.value.some(v => v.test(tag)) : false;
  }

}
UserTag_UserTag.text = 'User tag';
UserTag_UserTag.fields = ['author of this post has tag matching ', {
  type: 'text',
  id: 'patt'
}];
UserTag_UserTag.pattern = '[RegEx]';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/UserVoteWeight.js




class UserVoteWeight_UserVoteWeight extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `vote weight ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `vote weight ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      val: parseInt(input, 10)
    };
  }

  static async thingToCriterion(thing) {
    const username = thing.getAuthor();
    if (!username) throw new Error('No username');
    return String((await userTagger_Tag.get(username)).votes || 0);
  }

  static get disabled() {
    return !modules_isEnabled(userTagger_namespaceObject) || !userTagger_module.options.trackVoteWeight.value;
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  async evaluate(thing) {
    const username = thing.getAuthor();
    if (!username) return null;
    return numericalCompare(this.value.op, (await userTagger_Tag.get(username)).votes, this.value.val);
  }

}
UserVoteWeight_UserVoteWeight.text = 'User vote weight';
UserVoteWeight_UserVoteWeight.defaultConditions = {
  op: '>',
  val: 0
};
UserVoteWeight_UserVoteWeight.fields = ['user\'s vote weight is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' votes'];
UserVoteWeight_UserVoteWeight.slow = 1;
UserVoteWeight_UserVoteWeight.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/Username.js

class Username_Username extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `by ${this.conditions.patt}`;
    this.value = this.build(true);
  }

  static thingToCriterion(thing) {
    return thing.getAuthor();
  }

  evaluate(thing) {
    const user = thing.getAuthor();
    if (!user) return null;
    return this.value.some(v => v.test(user));
  }

}
Username_Username.text = 'Username';
Username_Username.fields = ['posted by /u/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/VoteType.js

const VoteType_options = [['upvoted', 'upvote'], ['downvoted', 'downvote'], ['not voted', 'unvoted']];
class VoteType_VoteType extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = (VoteType_options.find(([, cls]) => cls === this.conditions.kind) || [])[0];
  }

  static parseCriterion(input) {
    return {
      kind: input
    };
  }

  isValid() {
    return VoteType_options.map(([, cls]) => cls).includes(this.value.kind);
  }

  evaluate(thing) {
    switch (this.value.kind) {
      case 'upvote':
        return thing.isUpvoted();

      case 'downvote':
        return thing.isDownvoted();

      case 'unvoted':
        return thing.isUnvoted();

      default:
        throw new Error('Invalid option');
    }
  }

}
VoteType_VoteType.text = 'Vote type';
VoteType_VoteType.defaultConditions = {
  kind: 'unvoted'
};
VoteType_VoteType.fields = ['post is ', {
  type: 'select',
  id: 'kind',
  options: VoteType_options
}, ' by me'];
VoteType_VoteType.pattern = `(${VoteType_options.map(([, cls]) => cls).join('|')})`;
// CONCATENATED MODULE: ./lib/modules/filteReddit/postCases/index.js























// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/CommentContent.js

class CommentContent_CommentContent extends Case_PatternCase {
  constructor(...args) {
    super(...args);
    this.trueText = `comment contains ${this.conditions.patt}`;
    this.value = this.build(false);
  }

  static parseCriterion(input) {
    return {
      patt: input
    };
  }

  evaluate(thing) {
    const body = thing.getTextBody();
    if (!body) return null;
    return this.value.some(v => v.test(body.textContent));
  }

}
CommentContent_CommentContent.text = 'Comment content';
CommentContent_CommentContent.fields = ['comment contains ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/CommentLength.js


const CommentLength_options = ['characters', 'words'];
class CommentLength_CommentLength extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `length ${prettyOperator(this.conditions.op)} ${this.conditions.val} ${this.conditions.kind}`;
    this.falseText = `length ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val} ${this.conditions.kind}`;
  }

  static parseCriterion(input) {
    return {
      op: '>=',
      kind: 'words',
      val: parseInt(input, 10)
    };
  }

  isValid() {
    return Number.isInteger(this.value.val);
  }

  evaluate(thing) {
    const md = thing.entry.querySelector('.md');
    if (!md) return null;

    switch (this.value.kind) {
      case 'characters':
        return numericalCompare(this.value.op, md.textContent.length, this.value.val);

      case 'words':
        return numericalCompare(this.value.op, md.textContent.split(' ').length, this.value.val);

      default:
        throw new Error('Invalid option');
    }
  }

}
CommentLength_CommentLength.text = 'Comment length';
CommentLength_CommentLength.fields = ['comment length is ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}, ' ', {
  type: 'select',
  id: 'kind',
  options: CommentLength_options
}];
CommentLength_CommentLength.defaultConditions = {
  op: '>',
  kind: 'words',
  val: 0
};
CommentLength_CommentLength.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/Depth.js


class Depth_Depth extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = `depth ${prettyOperator(this.conditions.op)} ${this.conditions.val}`;
    this.falseText = `depth ${prettyOperator(inverseOperator(this.conditions.op))} ${this.conditions.val}`;
  }

  static parseCriterion(input) {
    return {
      op: '==',
      val: parseInt(input, 10)
    };
  }

  static thingToCriterion(thing) {
    return String(thing.getParents().length);
  }

  isValid() {
    return this.value.val >= 0;
  }

  evaluate(thing) {
    const depth = thing.getParents().length;
    return numericalCompare(this.value.op, depth, this.value.val);
  }

}
Depth_Depth.text = 'Comment depth';
Depth_Depth.defaultConditions = {
  op: '>',
  val: 0
};
Depth_Depth.fields = ['comment\'s depth ', {
  type: 'select',
  options: 'COMPARISON',
  id: 'op'
}, ' ', {
  type: 'number',
  id: 'val'
}];
Depth_Depth.pattern = 'integer';
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/IsDeleted.js

class IsDeleted_IsDeleted extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'deleted';
  }

  evaluate(thing) {
    return thing.isDeleted();
  }

}
IsDeleted_IsDeleted.text = 'Deleted';
IsDeleted_IsDeleted.fields = ['comment is deleted'];
IsDeleted_IsDeleted.unique = true;
// CONCATENATED MODULE: ./lib/modules/readComments.js





const readComments_module = new Module('readComments');
readComments_module.moduleName = 'readCommentsName';
readComments_module.category = 'commentsCategory';
readComments_module.description = 'readCommentsDesc';
readComments_module.options = {
  cleanComments: {
    type: 'text',
    value: '30',
    description: 'readCommentsCleanCommentsDesc',
    title: 'readCommentsCleanCommentsTitle',
    advanced: true
  },
  monitorSelected: {
    type: 'boolean',
    value: true,
    description: 'readCommentsMonitorSelectedDesc',
    title: 'readCommentsMonitorSelectedTitle'
  },
  monitorWhenIncognito: {
    type: 'boolean',
    value: false,
    dependsOn: () => readComments_module.options.monitorSelected.value,
    description: 'readCommentsMonitorWhenIncognitoDesc',
    title: 'readCommentsMonitorWhenIncognitoTitle',
    advanced: true
  }
};
readComments_module.include = ['comments', 'commentsLinklist'];
const currentId = (utils_location["f" /* execRegexes */].comments(location.pathname) || [])[2] || location.pathname;
const readComments_entryStorage = storage_namespaceObject.wrapPrefix('readComments.', () => ({
  updateTime: Date.now(),
  ids: {}
}));
const readComments_initial = readComments_entryStorage.get(currentId);
let initialReadIds;

readComments_module.beforeLoad = async () => {
  initialReadIds = await readComments_initial.then(({
    ids
  }) => new Set(Object.keys(ids)));
  maybeHidePrevious();

  if (readComments_module.options.monitorSelected.value) {
    if (!readComments_module.options.monitorWhenIncognito.value && isPrivateBrowsing()) return;
    selectedThing_namespaceObject.addListener(current => {
      if (current.isComment() && current.isVisible()) readComments_add(current);
    }, 'beforePaint');
  }

  maybePruneOldEntries('readComments', readComments_entryStorage, parseInt(readComments_module.options.cleanComments.value, 10));
};

async function maybeHidePrevious() {
  if (!initialReadIds.size) return;
  const filterline = await filterlinePromise;
  const filter = filterline.createFilter({
    type: 'isRead',
    id: 'isRead'
  });
  if (filter.state === false && filter.effects.hide) return;
  await new Promise(res => {
    Object(watchers["watchForThings"])(['comment'], thing => {
      if (isRead(thing)) res();
    });
  });
  const hideButton = document.createElement('button');
  hideButton.textContent = 'Hide read comments';
  hideButton.addEventListener('click', () => {
    filter.update(false, undefined, {
      hide: true
    });
    if (!filter.parent) filterline.addFilter(filter);
    if (ensureFilterlineVisible) ensureFilterlineVisible();
    notification.close();
  });
  const notification = notifications_showNotification({
    moduleID: readComments_module.moduleID,
    notificationID: 'hideRead',
    header: 'Previously read comments',
    message: hideButton,
    closeDelay: 8000
  });
}

const _add = Object(utils_async["a" /* batch */])(ids => readComments_entryStorage.patch(currentId, {
  ids: ids.reduce((acc, id) => {
    acc[id] = true;
    return acc;
  }, {}),
  updateTime: Date.now()
}), {
  size: Infinity,
  delay: 5000,
  flushBeforeUnload: true
});

const readComments_add = thing => {
  if (!initialReadIds) throw new Error('readComments module is not initialized');
  const id = thing.getFullname();

  _add(id);
};
const isRead = thing => {
  if (!initialReadIds) throw new Error();
  return initialReadIds.has(thing.getFullname());
};
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/IsRead.js



class IsRead_IsRead extends Case_Case {
  constructor(...args) {
    super(...args);
    this.trueText = 'read';
  }

  static get disabled() {
    return !modules_isEnabled(readComments_namespaceObject);
  }

  evaluate(thing) {
    return isRead(thing);
  }

}
IsRead_IsRead.text = 'Read';
IsRead_IsRead.fields = ['comment is read'];
IsRead_IsRead.unique = true;
// CONCATENATED MODULE: ./lib/modules/filteReddit/commentCases/index.js

















// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/BrowsingFrontPage.js


class BrowsingFrontPage_BrowsingFrontPage extends Case_Case {
  evaluate() {
    return Object(utils_location["n" /* isPageType */])('linklist') && !Object(utils_location["d" /* currentSubreddit */])() && !Object(utils_location["c" /* currentMultireddit */])() && !Object(utils_location["e" /* currentUserProfile */])();
  }

}
BrowsingFrontPage_BrowsingFrontPage.text = 'Browsing the front page';
BrowsingFrontPage_BrowsingFrontPage.fields = ['when browsing the front page'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentLocation.js


class CurrentLocation_CurrentLocation extends Case_Case {
  evaluate() {
    return Object(utils_location["g" /* fullLocation */])() === this.value.patt;
  }

}
CurrentLocation_CurrentLocation.text = 'When browsing in location';
CurrentLocation_CurrentLocation.defaultConditions = {
  patt: Object(utils_location["g" /* fullLocation */])()
};
CurrentLocation_CurrentLocation.fields = ['when browsing ', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentMulti.js


class CurrentMulti_CurrentMulti extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = {
      name: Case_Case.buildRegex(this.conditions.name),
      user: Case_Case.buildRegex(this.conditions.user)
    };
  }

  evaluate() {
    const rawMulti = Object(utils_location["c" /* currentMultireddit */])();
    if (!rawMulti) return false;
    const parts = /^(?:user\/)?([a-z0-9_-]+)\/m\/([a-z0-9_-]+)$/i.exec(rawMulti);
    if (!parts) return false;
    const [, user, multi] = parts;

    if (user === 'me' && this.conditions.name === 'me') {
      return this.value.name.test(multi);
    } else {
      return this.value.user.test(user) && this.value.name.test(multi);
    }
  }

}
CurrentMulti_CurrentMulti.text = 'When browsing a multireddit';
CurrentMulti_CurrentMulti.defaultConditions = {
  user: '',
  name: ''
};
CurrentMulti_CurrentMulti.fields = ['when browsing /u/', {
  type: 'text',
  id: 'user'
}, '/m/', {
  type: 'text',
  id: 'name'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentUserProfile.js


class CurrentUserProfile_CurrentUserProfile extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.patt);
  }

  evaluate() {
    const user = Object(utils_location["e" /* currentUserProfile */])();
    return !!user && this.value.test(user);
  }

}
CurrentUserProfile_CurrentUserProfile.text = 'When browsing a user profile';
CurrentUserProfile_CurrentUserProfile.defaultConditions = {
  patt: ''
};
CurrentUserProfile_CurrentUserProfile.fields = ['when browsing /u/', {
  type: 'text',
  id: 'patt'
}, '\'s posts'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/CurrentSub.js


class CurrentSub_CurrentSub extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.patt);
  }

  evaluate() {
    const sub = Object(utils_location["d" /* currentSubreddit */])();
    return !!sub && this.value.test(sub);
  }

}
CurrentSub_CurrentSub.text = 'When browsing a subreddit';
CurrentSub_CurrentSub.defaultConditions = {
  patt: ''
};
CurrentSub_CurrentSub.fields = ['when browsing /r/', {
  type: 'text',
  id: 'patt'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Date.js


const Date_options = [['before', '<'], ['on or after', '>=']];
class Date_Date extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = {
      op: this.conditions.op,
      date: localization_dayjs(this.conditions.date)
    };
  }

  isValid() {
    return this.value.date.isValid();
  }

  evaluate() {
    return this.value.op === '<' === localization_dayjs().isBefore(this.value.date);
  }

}
Date_Date.text = 'Date';
Date_Date.defaultConditions = {
  op: '<',
  date: '2020-12-30'
};
Date_Date.fields = ['today is ', {
  type: 'select',
  options: Date_options,
  id: 'op'
}, ' ', {
  type: 'text',
  id: 'date'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Dow.js

const Dow_days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
class Dow_Dow extends Case_Case {
  evaluate() {
    const currentDOW = Dow_days[new Date().getDay()];
    return this.value.days.includes(currentDOW);
  }

}
Dow_Dow.text = 'Day of week';
Dow_Dow.defaultConditions = {
  days: []
};
Dow_Dow.fields = ['current day of the week is ', {
  type: 'checkset',
  items: Dow_days,
  id: 'days'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/LoggedInAs.js


class LoggedInAs_LoggedInAs extends Case_Case {
  constructor(...args) {
    super(...args);
    this.value = Case_Case.buildRegex(this.conditions.loggedInAs);
  }

  async evaluate() {
    await pagePhases.contentStart;
    const myName = loggedInUser();
    return !!myName && this.value.test(myName);
  }

}
LoggedInAs_LoggedInAs.text = 'Logged in user';
LoggedInAs_LoggedInAs.defaultConditions = {
  loggedInAs: ''
};
LoggedInAs_LoggedInAs.fields = ['logged in as /u/', {
  type: 'text',
  id: 'loggedInAs'
}];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/Toggle.js



const getOptions = () => getToggles().map(({
  key,
  text
}) => [text, key]);

class Toggle_Toggle extends Case_Case {
  evaluate() {
    const key = this.value.toggleName;
    return toggleActive(key);
  }

}
Toggle_Toggle.text = 'Custom toggle';
Toggle_Toggle.defaultConditions = {
  toggleName: getOptions()[0] || ''
};
Toggle_Toggle.fields = ['custom toggle ', {
  type: 'select',
  id: 'toggleName',

  get options() {
    return getOptions();
  }

}, ' is enabled'];
// CONCATENATED MODULE: ./lib/modules/filteReddit/browseCases/index.js









// CONCATENATED MODULE: ./lib/modules/filteReddit/cases.js






class cases_Inert extends Case_Case {
  isValid() {
    return false;
  }

  evaluate() {
    console.error('Evaluating inert case');
    return false;
  }

}

class cases_True extends Case_Case {
  evaluate() {
    return true;
  }

}

cases_True.text = 'True';
cases_True.fields = ['always true'];

class cases_False extends Case_Case {
  evaluate() {
    return false;
  }

}

cases_False.text = 'False';
cases_False.fields = ['always false'];
class cases_Group extends Case_Case {
  constructor(...args) {
    super(...args);
    this._cases = this.conditions.of.map(v => Case_Case.fromConditions(v));
    this.trueText = this._cases.length && this.toCriterion(this.conditions.op, this._cases) || 'empty group';

    this.value = (() => {
      const op = this.conditions.op;
      const [NONE, ANY, ONE, ALL] = [op === 'none', op === 'any', op === 'one', op === 'all'];

      const evaluators = this._cases.sort((a, b) => a.constructor.slow - b.constructor.slow).map(cased => cased.evaluate.bind(cased));

      return Object(utils_async["b" /* fastAsync */])(function* (thing) {
        let seenTrue = false;

        for (const evaluator of evaluators) {
          if (yield evaluator(thing)) {
            if (NONE) return false;else if (ANY) return true;else if (ONE && seenTrue) return false;
            seenTrue = true;
          } else {
            if (ALL) return false;
          }
        }

        if (NONE) return true;else if (ANY) return false;else if (ONE) return seenTrue;else return true;
      });
    })();
  }

  toCriterion(op, cases) {
    let str = cases.map(v => v.trueText).join(` ${(op === 'any' || op === 'none') && '∨' || op === 'one' && '⊕' || '∧'} `);
    if (cases.length > 1) str = `(${str})`;
    return op === 'none' ? `¬ ${str}` : str;
  }

  isValid() {
    return this._cases.every(v => v.isValid());
  }

  hasType(type) {
    return super.hasType(type) || this._cases.some(v => v.hasType(type));
  }

  evaluate(thing) {
    return this.value(thing);
  }

  onObserve() {
    return this._cases.map(v => v.observe(this)).some(v => v);
  }

}
cases_Group.text = 'Group of conditions';
cases_Group.fields = [{
  type: 'select',
  options: ['none', 'any', 'one', 'all'],
  id: 'op'
}, ' of these are true:', {
  type: 'multi',
  include: 'all',
  id: 'of'
}];
cases_Group.defaultConditions = {
  op: 'all',
  of: []
};
cases_Group.slow = 1;
const falseConditions = {
  type: 'false'
};
const trueConditions = {
  type: 'true'
};
const inertConditions = {
  type: 'inert'
};
function resolveGroup(initial, precompute = true, keepGroup = false) {
  let seenTrue = false;
  let of = [];
  let op = initial.op;

  for (let v of initial.of) {
    if (!cases_has(v.type)) {
      console.error(`Type ${v.type} is not available`);
      return inertConditions;
    }

    if (v.type === 'group') v = resolveGroup(v, precompute);

    if (!keepGroup && precompute && !available[v.type].prototype.evaluate.length) {
      const match = Case_Case.fromConditions(v).evaluate();

      if (typeof match === 'boolean') {
        if (match) {
          if (op === 'none') return falseConditions;
          if (op === 'any') return trueConditions;
          if (op === 'one' && seenTrue) return falseConditions;
          seenTrue = true;
        } else {
          if (op === 'all') return falseConditions;
        }

        continue;
      }
    }

    of.push(v);
  }

  if (op === 'one' && seenTrue) {
    op = 'none';
  }

  if (!keepGroup) {
    if (of.length === 1) {
      const p = of[0];

      if (op !== 'none') {
        return p;
      } else if (p.type === 'group') {
        if (p.op === 'none') {
          p.op = 'any';
          return p;
        } else if (p.op === 'any' || p.op === 'all') {
          p.op = 'none';
          return p;
        }
      }
    }

    if (!of.length) {
      if (op === 'none') return trueConditions;
      if (op === 'any') return falseConditions;
      if (op === 'one') return falseConditions;
      if (op === 'all') return trueConditions;
    }
  }

  if (precompute && (op === 'any' || op === 'none')) {
    const l = of.length;
    const typeSorted = of.sort((a, b) => a.type === b.type ? 0 : a.type > b.type ? 1 : -1);
    of = [];

    for (let i = 0; i < l; i++) {
      const a = typeSorted[i];
      const cls = available[a.type];
      const reconcile = cls.reconcile;

      if (reconcile) {
        const values = [a];
        let b;

        while ((b = typeSorted[i + 1]) && a.type === b.type) {
          i++;
          values.push(b);
        }

        of.push(...reconcile(values));
      } else {
        of.push(a);
      }
    }
  }

  return {
    type: 'group',
    op,
    of
  };
}
function cases_getConditions(type, conditions) {
  return {
    type,
    ...(available[type] && available[type].defaultConditions),
    ...conditions
  };
}
function getGroup(op, of) {
  return cases_getConditions('group', {
    op,
    of
  });
}
function createAdHoc(type, getConditions, variant, context, customFilter) {
  const {
    opts: {
      name = type
    } = {}
  } = customFilter || {};

  class AdHoc extends Case_Case {
    static get defaultConditions() {
      return getConditions();
    }

  }

  AdHoc.text = name;
  AdHoc.unique = true;
  AdHoc.variant = variant;
  AdHoc._customFilter = customFilter;
  cases_add(type, AdHoc, context);
  if (type !== AdHoc.type) console.warn('Type name was changed from', name, 'to', AdHoc.type);
  return AdHoc;
}
const available = {};

function getUniqueTypeName(name) {
  if (typeof name !== 'string') name = '';

  while (!name || cases_has(name)) {
    name += randomHash();
  }

  return name;
}

function cases_add(type, c, ...contexts) {
  if (!type || available.hasOwnProperty(type) && c !== available[type]) {
    type = getUniqueTypeName(type);
  }

  c.type = type;
  if (!c.contexts) c.contexts = [];
  c.contexts.push(...contexts);
  available[type] = c;
}
const primitives = new Set();
function populatePrimitives(types = ['post', 'comment', 'browse']) {
  function fill(cases, ...contexts) {
    for (const [k, v] of Object.entries(cases)) {
      cases_add(k, v, ...contexts);
      primitives.add(v);
    }
  }

  fill({
    inert: cases_Inert,
    false: cases_False,
    true: cases_True
  });
  fill({
    group: cases_Group
  }, 'post', 'comment', 'browse');
  if (types.includes('post')) fill(postCases_namespaceObject, 'post');
  if (types.includes('comment')) fill(commentCases_namespaceObject, 'comment');
  if (types.includes('browse')) fill(browseCases_namespaceObject, 'browse');
}
function filterThings(things, conditions) {
  if (!conditions) return things;
  const cased = Case_Case.fromConditions(conditions);
  return Object(utils_array["a" /* asyncFilter */])(things, thing => cased.evaluate(thing));
}
const cases_remove = type => {
  delete available[type];
};
const cases_has = type => available.hasOwnProperty(type);
const cases_get = type => cases_has(type) ? available[type] : cases_Inert;
const getByContext = (context, primitivesOnly = true) => lodash_es_pickBy(available, v => v.contexts.includes(context) && (!primitivesOnly || primitives.has(v)));
const isUseful = type => typeof type === 'string' && cases_has(type) && ![cases_Inert.type, cases_False.type, cases_True.type].includes(type);
// CONCATENATED MODULE: ./lib/modules/accountSwitcher.js








const accountSwitcher_module = new Module('accountSwitcher');
accountSwitcher_module.moduleName = 'accountSwitcherName';
accountSwitcher_module.category = 'myAccountCategory';
accountSwitcher_module.description = 'accountSwitcherDesc';
accountSwitcher_module.options = {
  keepLoggedIn: {
    type: 'boolean',
    value: false,
    description: 'accountSwitcherKeepLoggedInDesc',
    title: 'accountSwitcherKeepLoggedInTitle',
    keywords: ['remember']
  },
  accounts: {
    type: 'table',
    addRowText: 'accountSwitcherAddAccount',
    fields: [{
      key: 'username',
      name: 'accountSwitcherUsername',
      type: 'text'
    }, {
      key: 'password',
      name: 'accountSwitcherPassword',
      type: 'password'
    }, {
      key: '2fa',
      name: 'accountSwitcherRequiresOtp',
      type: 'boolean',
      value: false
    }],
    value: [],
    description: 'accountSwitcherAccountsDesc',
    title: 'accountSwitcherAccountsTitle'
  },
  updateOtherTabs: {
    type: 'boolean',
    description: 'accountSwitcherUpdateOtherTabsDesc',
    title: 'accountSwitcherUpdateOtherTabsTitle',
    value: true,
    advanced: true
  },
  reloadOtherTabs: {
    type: 'boolean',
    description: 'accountSwitcherReloadOtherTabsDesc',
    title: 'accountSwitcherReloadOtherTabsTitle',
    value: false,
    advanced: true
  },
  showCurrentUserName: {
    type: 'boolean',
    value: false,
    description: 'accountSwitcherShowCurrentUserNameDesc',
    title: 'accountSwitcherShowCurrentUserNameTitle',
    advanced: true
  },
  dropDownStyle: {
    type: 'enum',
    values: [{
      name: 'accountSwitcherSnoo',
      value: 'alien'
    }, {
      name: 'accountSwitcherSimpleArrow',
      value: 'arrow'
    }],
    value: 'alien',
    description: 'accountSwitcherDropDownStyleDesc',
    title: 'accountSwitcherDropDownStyleTitle',
    advanced: true,
    bodyClass: true
  },
  showUserDetails: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowUserDetailsDesc',
    title: 'accountSwitcherShowUserDetailsTitle',
    advanced: true
  },
  showKarma: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowKarmaDesc',
    title: 'accountSwitcherShowKarmaTitle',
    advanced: true,
    dependsOn: options => options.showUserDetails.value
  },
  showGold: {
    type: 'boolean',
    value: true,
    description: 'accountSwitcherShowGoldDesc',
    title: 'accountSwitcherShowGoldTitle',
    advanced: true,
    dependsOn: options => options.showUserDetails.value
  }
};
let hover;
const accounts = Object(once["a" /* default */])(() => accountSwitcher_module.options.accounts.value.reduce((acc, v) => {
  acc[v[0].toLowerCase()] = {
    text: v[0],
    storedPassword: v[1],
    requiresOtp: v[2]
  };
  return acc;
}, {}));

accountSwitcher_module.contentStart = () => {
  const downArrow = accountSwitcher_module.options.dropDownStyle.value === 'alien' ? string_namespaceObject.html`<span id="RESAccountSwitcherIcon" role="button"></span>` : string_namespaceObject.html`<span id="RESAccountSwitcherIcon" role="button"><span class="downArrow"></span></span>`;
  downArrow.addEventListener('click', () => hover.begin());
  downArrow.addEventListener('dblclick', manageAccounts);
  const userLink = document.querySelector('#header-bottom-right > span.user > a');

  if (userLink) {
    userLink.style.marginRight = '2px';
    userLink.after(downArrow);
  } else {
    addFloater(downArrow, {
      order: 3
    });
  }

  hover = dropdownList(accountSwitcher_module.moduleID).options({
    className: 'RESAccountSwitcherDropdown',
    openDelay: 0,
    offsetHeight: 5
  }).populateWith(createAccountMenu).target(downArrow);
  let username;
  registerCommand(/^sw$/, `sw [username] - ${i18n('accountSwitcherCliHelp')}`, (command, val) => {
    const usernames = Object.keys(accounts()).filter(username => username.startsWith(val.toLowerCase()));
    username = usernames.includes(val) ? val : usernames[0];
    return `${i18n('accountSwitcherCliSwitchToUsernamePrompt')} ${val}${lodash_es_without(usernames, val).length ? `[${usernames.map(v => v.replace(val, '')).filter(Boolean).join('|')}]` : ''}`;
  }, () => {
    if (username) switchTo(username);else manageAccounts();
  });
};

async function createAccountMenu() {
  const accountMenu = document.createDocumentFragment();
  const users = await Promise.all(Object.entries(accounts()).map(async ([username, {
    text
  }]) => ({
    text,
    username,
    active: username.localeCompare(loggedInUser() || '', {
      sensitivity: 'base'
    }) === 0,
    data: accountSwitcher_module.options.showUserDetails.value && (await getUserInfo(username).catch(e => {
      console.error('Error loading userinfo for', username, e);
      return {};
    })).data || {}
  })));

  for (const {
    text,
    username,
    active,
    data
  } of users) {
    if (!accountSwitcher_module.options.showCurrentUserName.value && active) continue;
    const goldExpDate = data.gold_expiration && new Date(data.gold_expiration * 1000);
    const element = string_namespaceObject.html`
			<li class="accountName ${active && 'active'}" role="button">
				<span style="margin-right: auto;">${text}</span>
				${accountSwitcher_module.options.showKarma.value && data.link_karma && string_namespaceObject._html`
					<span style="margin-left: 4px">(${data.link_karma} &middot; ${data.comment_karma})</span>
				`}
				${accountSwitcher_module.options.showGold.value && data.is_gold && string_namespaceObject._html`
					<span style="all: initial; margin-left: 4px; line-height: 0;" class="gilded-icon" title="${goldExpDate && i18n('accountSwitcherGoldUntil', formatDate(goldExpDate), formatDateDiff(new Date(), goldExpDate))}"></span>
				`}
				<a style="margin-left: 4px" onclick="event.stopPropagation()" href="/user/${username}" class="res-icon linkIcon"></a>
			</li>
		`;
    element.addEventListener('click', async () => {
      bodyClasses_namespaceObject.add('res-accountSwitcher-in-progress');

      try {
        await switchTo(username);
      } catch (e) {
        bodyClasses_namespaceObject.remove('res-accountSwitcher-in-progress');
        console.error(e);
      }
    });
    accountMenu.append(element);
  }

  {
    const element = string_namespaceObject.html`<li class="addAccount">+ add account</li>`;
    element.addEventListener('click', manageAccounts);
    accountMenu.append(element);
  }
  return [accountMenu];
}

const switchTo = Object(utils_async["h" /* mutex */])(async username => {
  const {
    storedPassword,
    requiresOtp
  } = accounts()[username];
  const logoutPromise = isLoggedIn() && ajax({
    method: 'POST',
    url: '/logout'
  });
  const password = storedPassword ? storedPassword : window.prompt(i18n('accountSwitcherPasswordPrompt', username));
  let otp;

  if (requiresOtp) {
    otp = {
      otp: window.prompt(i18n('accountSwitcherOptPrompt', username))
    };
  }

  await logoutPromise;
  const {
    success,
    jquery
  } = await ajax({
    method: 'POST',
    url: '/api/login',
    data: {
      user: username,
      passwd: password,
      ...otp,
      rem: accountSwitcher_module.options.keepLoggedIn.value ? 'on' : 'off'
    },
    type: 'json'
  }).catch(e => {
    notifications_showNotification({
      moduleID: 'accountSwitcher',
      message: i18n('accountSwitcherAccountSwitchError')
    });
    throw e;
  });

  if (accountSwitcher_module.options.updateOtherTabs.value) {
    switchedAccountElsewhere(success ? username : null);
  }

  if (success) {
    reloadPage();
  } else {
    const jqueryRpc = JSON.stringify(jquery);
    const message = jqueryRpc.includes('PASSWORD') && i18n('accountSwitcherLoginError', username) || jqueryRpc.includes('RATELIMIT') && i18n('accountSwitcherRateLimitError', username) || jqueryRpc.includes('WRONG_OTP') && i18n('accountSwitcherOTPError', username) || i18n('accountSwitcherUnknownError', username, jqueryRpc);
    alert_namespaceObject.open(message, {
      cancelable: true
    }).then(manageAccounts);
    throw new Error(message);
  }
});
const switchedAccountElsewhere = multicast(username => {
  const hasDraft = Array.from(document.getElementsByTagName('textarea')).some(textarea => textarea.value);

  if (!hasDraft && accountSwitcher_module.options.reloadOtherTabs.value) {
    reloadPage();
    return;
  }

  let message = username ? i18n('accountSwitcherUserSwitched', username) : i18n('accountSwitcherLoggedOut');

  if (hasDraft) {
    message += ` ${i18n('accountSwitcherDraft', loggedInUser() || '')}`;
  }

  message += ` <p><a class="RESNotificationButtonBlue" href="${location.pathname}">${i18n('accountSwitcherReload')}</a></p>`;
  notifications_showNotification({
    moduleID: 'accountSwitcher',
    optionKey: 'updateOtherTabs',
    message
  });
}, {
  name: 'switchedAccountElsewhere',
  local: false,
  crossContext: false
});

function manageAccounts() {
  hover.close();
  settingsNavigation_open(accountSwitcher_module.moduleID, 'accounts');
}

function reloadPage() {
  history.pushState({}, '');
  location.reload();
}
// CONCATENATED MODULE: ./lib/modules/submitIssue.js









const submitIssue_module = new Module('submitIssue');
submitIssue_module.moduleName = 'submitIssueName';
submitIssue_module.category = 'aboutCategory';
submitIssue_module.alwaysEnabled = true;
submitIssue_module.sort = -7;
submitIssue_module.description = 'submitIssueDesc';
submitIssue_module.include = ['submit'];
const submitIssue_subreddits = ['enhancement', 'resissues'];
const subredditsForDiagnostics = ['beta', 'help', 'resbetatesting'];

submitIssue_module.go = () => {
  checkIfSubmitting();
};

const submitWizardTemplate = ({
  foolin,
  settings,
  bugs,
  requests
}) => string_namespaceObject.html`
	<div>
		${foolin && string_namespaceObject._html`
			<h2>Enjoy April Fool's</h2>
			<p>RES can't turn off any of Reddit's shenanigans. However, <a href="/r/Enhancement/wiki/faq/srstyle" target="_blank" rel="noopener noreferer">you can turn off subreddit styles</a>.</p>
		`}

		<h2>Something is broken in RES. How do I fix it?</h2>

		<p>Take a minute to read through other posts. Someone might have already posted a solution.</p>

		<ol id="RESKnownBugs">
			${bugs.map(({
  url,
  title
}) => string_namespaceObject._html`
				<li>
					<a target="_blank" rel="noopener noreferer" href="${url}">${title}</a>
				</li>
			`)}
		</ol>

		<p><a href="/r/RESissues/submit/" class="blueButton">Ask how to fix RES</a></p>

		<p>Please write some text about:</p>
		<dl>

			<dt>What makes this happen?</dt>
			<dd>
				clicking a button, opening an image preview, ...
			</dd>


			<dt>Where does this happen?</dt>
			<dd>
				in a particular subreddit, on comments pages, on frontpage (reddit.com), on /r/all, ...
			</dd>

			<dt>Screenshot/video of problem</dt>
			<dd>
				<a href="https://www.take-a-screenshot.org/" target="_blank" rel="noreferer noopener">Take a screenshot</a>, <a href="https://imgur.com/upload">upload it</a>, and copy-paste the link here.
			</dd>
		</dl>


		<h2>How do I customize or use RES features?</h2>
		<p>If you want to disable certain features of RES, try searching in <a href="${settings}">RES settings</a>, your account's <a href="/prefs">reddit preferences</a>, or <a href="/r/Enhancement/search?q=restrict_sr=on">posts in r/Enhancement</a>.</p>

		<p><a href="/r/Enhancement/submit/" class="blueButton">Get guidance on using RES</a></p>


		<h2>I have a suggestion.</h2>

		<p>Look for similar ideas before posting:</p>
		<ol id="RESKnownFeatureRequests">
			${requests.map(({
  url,
  title
}) => string_namespaceObject._html`
				<li>
					<a target="_blank" rel="noopener noreferer" href="${url}">${title}</a>
				</li>
			`)}
		</ol>
		<p><a href="/r/Enhancement/submit/" class="blueButton">Post a request</a></p>


		<h2>I found a security issue.</h2>
		<p>Please report security issues privately using modmail.</p>
		<p><a href="/message/compose/?to=/r/Enhancement" class="blueButton">Report a security issue</a></p>
	</div>
`;

const submitIssueDefaultBody = `
*What's up?*
???


*Where does it happen?*
???


*Screenshots or mock-ups*
???


*What browser extensions are installed?*
???
`.trim();
const diagnostics = Object(once["a" /* default */])(() => `

- Night mode: ${String(nightModeActive())}
- RES Version: ${metadata_version}
- Browser: ${browserDetect_namespaceObject.browser}
- Browser Version: ${browserDetect_namespaceObject.version}
- Cookies Enabled: ${String(navigator.cookieEnabled)}
- Reddit beta: ${String(jquery_default()('.beta-hint').length > 0)}

`);

function checkIfSubmitting() {
  const subredditInput = document.getElementById('sr-autocomplete');
  const selfText = document.querySelector('.usertext-edit textarea');

  if (subredditInput) {
    function check() {
      const subreddit = subredditInput.value;

      if (submitIssue_subreddits.includes(subreddit.toLowerCase())) {
        showWizard();
        injectTemplate(selfText);
      } else {
        hideWizard();
      }
    }

    check();
    subredditInput.addEventListener('change', e => {
      if (e.res) return;
      check();
    });
    jquery_default()('#suggested-reddits .sr-suggestion').on('click', () => setTimeout(check, 500));
  }

  if (selfText && subredditInput) {
    jquery_default()(selfText).add(subredditInput).on('blur', () => {
      const subreddit = subredditInput.value;

      if ([...submitIssue_subreddits, ...subredditsForDiagnostics].includes(subreddit.toLowerCase())) {
        const diagnosticsStripped = diagnostics().replace(/\s/g, '');
        const selfTextStripped = selfText.value.replace(/\s/g, '');

        if (!selfTextStripped.includes(diagnosticsStripped)) {
          selfText.value += diagnostics();
          jquery_default()(selfText).trigger('input');
        }
      } else {
        selfText.value = selfText.value.replace(diagnostics(), '');
        jquery_default()(selfText).trigger('input');
      }
    });
  }
}

function updateSubreddit(subreddit) {
  const input = document.querySelector('#sr-autocomplete');
  input.value = subreddit;
  const e = new Event('change');
  e.res = true;
  input.dispatchEvent(e);
}

function injectTemplate(selfText) {
  if (selfText && !selfText.value) {
    selfText.value = submitIssueDefaultBody;
  }
}

async function wizard() {
  const [bugs, requests] = await Promise.all([fetchLinks('/r/Enhancement/wiki/knownbugs.json'), fetchLinks('/r/Enhancement/wiki/knownrequests.json')]);
  return submitWizardTemplate({
    foolin: submitIssue_foolin(),
    bugs,
    requests,
    settings: makeUrlHash()
  });
}

const guiderId = 'RESSubmitWizard';

async function showWizard() {
  const guider = guiders.get(guiderId);

  if (guider) {
    guiders.show(guider.id);
    return;
  }

  const description = await wizard();
  guiders.createGuider({
    attachTo: '.submit .usertext',
    description,
    buttonCustomHTML: `
		<footer>
			<small>
				<a href="/r/RESissues/wiki/knownissues">known issues</a>
				|  <a href="/r/RESissues/wiki/postanissue">troubleshooting</a>
			</small>
		</footer>
	`,
    id: guiderId,
    position: 3,
    title: 'What are you posting about?'
  }).show();
  jquery_default()(document.body).on('click', '#RESSubmitWizard a[href$="/submit/"]', e => {
    const match = e.currentTarget.pathname.match(utils_location["p" /* regexes */].submit);
    if (!match) return;
    updateSubreddit(match[1]);
    e.preventDefault();
  });
}

function hideWizard() {
  if (guiders.get(guiderId)) {
    guiders.hideAll();
  }
}

async function fetchLinks(url) {
  try {
    const {
      data
    } = await ajax({
      url,
      type: 'json'
    });
    return parseObjectList(data && data.content_md);
  } catch (e) {
    return [];
  }
}

function parseObjectList(text) {
  if (!text) {
    return [];
  }

  const items = text.split(/\s*-{3,}\s*/).filter(x => x.match(/[^\s\n]/));
  return items.map(dictText => {
    const item = {};
    const dictMapping = dictText.replace(/\r/g, '').split('\n');

    for (const rawLine of dictMapping) {
      const line = jquery_default.a.trim(rawLine).split(':');

      if (line.length > 0) {
        const key = line.shift();

        if (key) {
          item[key] = line.join(':');
        }
      }
    }

    return item;
  });
}

function submitIssue_foolin() {
  const now = new Date();
  return now.getMonth() === 2 && now.getDate() > 30 || now.getMonth() === 3 && now.getDate() <= 2;
}
// CONCATENATED MODULE: ./lib/modules/commentTools.js











const commentTools_module = new Module('commentTools');
commentTools_module.moduleName = 'commentToolsName';
commentTools_module.category = 'commentsCategory';
commentTools_module.description = 'commentToolsDesc';
commentTools_module.options = {
  userAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsUserAutoCompleteDesc',
    title: 'commentToolsUserAutoCompleteTitle',
    keywords: ['autosuggest'],
    advanced: true
  },
  subredditAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsSubredditAutocompleteDesc',
    title: 'commentToolsSubredditAutocompleteTitle',
    keywords: ['autosuggest'],
    advanced: true
  },
  wikiAutocomplete: {
    type: 'boolean',
    value: true,
    description: 'commentToolsWikiAutocompleteDesc',
    title: 'commentToolsWikiAutocompleteTitle',
    advanced: true
  },
  formattingToolButtons: {
    type: 'boolean',
    value: true,
    description: 'commentToolsFormattingToolButtonsDesc',
    title: 'commentToolsFormattingToolButtonsTitle'
  },
  keyboardShortcuts: {
    dependsOn: options => options.formattingToolButtons.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsKeyboardShortcutsDesc',
    title: 'commentToolsKeyboardShortcutsTitle'
  },
  boldKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [66, false, true, false, false],
    description: 'commentToolsBoldKeyDesc',
    title: 'commentToolsBoldKeyTitle'
  },
  italicKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [73, false, true, false, false],
    description: 'commentToolsItalicKeyDesc',
    title: 'commentToolsItalicKeyTitle'
  },
  strikeKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [83, false, true, false, false],
    description: 'commentToolsStrikeKeyDesc',
    title: 'commentToolsStrikeKeyTitle'
  },
  superKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [187, false, true, true, false],
    description: 'commentToolsSuperKeyDesc',
    title: 'commentToolsSuperKeyTitle'
  },
  linkKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [75, false, true, false, false],
    description: 'commentToolsLinkKeyDesc',
    title: 'commentToolsLinkKeyTitle'
  },
  quoteKey: {
    dependsOn: options => options.keyboardShortcuts.value,
    type: 'keycode',
    value: [190, false, true, true, false],
    description: 'commentToolsQuoteKeyDesc',
    title: 'commentToolsQuoteKeyTitle'
  },
  ctrlEnterSubmitsComments: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrlEnterSubmitsCommentsDesc',
    title: 'commentToolsCtrlEnterSubmitsCommentsTitle'
  },
  ctrlEnterSavesLiveThreads: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrlEnterSavesLiveThreadsDesc',
    title: 'commentToolsCtrlEnterSavesLiveThreadsTitle'
  },
  ctrlEnterSubmitsPosts: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCtrolEnterSubmitsPostsDesc',
    title: 'commentToolsCtrolEnterSubmitsPostsTitle'
  },
  commentingAs: {
    type: 'boolean',
    value: true,
    description: 'commentToolsCommentingAsDesc',
    title: 'commentToolsCommentingAsTitle'
  },
  highlightIfAltAccount: {
    dependsOn: options => options.commentingAs.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsHighlightIfAltAccountDesc',
    title: 'commentToolsHighlightIfAltAccountTitle'
  },
  showInputLength: {
    type: 'boolean',
    value: true,
    description: 'commentToolsShowInputLengthDesc',
    title: 'commentToolsShowInputLengthTitle',
    advanced: true,
    bodyClass: true
  },
  macroButtons: {
    type: 'boolean',
    value: true,
    description: 'commentToolsMacroButtonsDesc',
    title: 'commentToolsMacroButtonsTitle',
    bodyClass: true
  },
  macros: {
    dependsOn: options => options.macroButtons.value,
    type: 'table',
    addRowText: 'commentToolsAddShortcut',
    fields: [{
      key: 'label',
      name: 'commentToolsLabel',
      type: 'text'
    }, {
      key: 'text',
      name: 'commentToolsText',
      type: 'textarea'
    }, {
      key: 'category',
      name: 'commentToolsCategory',
      type: 'text'
    }, {
      key: 'key',
      name: 'commentToolsKey',
      type: 'keycode'
    }],
    value: [['reddiquette', '[reddiquette](/wiki/reddiquette) ', undefined, undefined], ['Promote RES', '[Reddit Enhancement Suite](https://redditenhancementsuite.com "also /r/Enhancement") ', undefined, undefined], ['Current timestamp', '{{now}} ', undefined, undefined]],
    description: 'commentToolsMacrosDesc',
    title: 'commentToolsMacrosTitle'
  },
  keepMacroListOpen: {
    dependsOn: options => options.macroButtons.value,
    type: 'boolean',
    value: false,
    description: 'commentToolsKeepMacroListOpenDesc',
    title: 'commentToolsKeepMacroListOpenTitle',
    advanced: true
  },
  macroPlaceholders: {
    dependsOn: options => options.macroButtons.value,
    type: 'boolean',
    value: true,
    description: 'commentToolsMacroPlaceholdersDesc',
    title: 'commentToolsMacroPlaceholdersTitle'
  },
  enabledOnBanMessages: {
    type: 'boolean',
    value: true,
    description: 'commentToolsEnableOnBanMessagesDesc',
    title: 'commentToolsEnableOnBanMessagesTitle',
    advanced: true
  }
};
commentTools_module.include = ['comments', 'inbox', 'submit', 'profile', 'modqueue', 'subredditAbout', 'liveThread', /^\/r\/[\-\w\.]+\/wiki\/(?:create|edit)(\/\w+)?/i];
const SUBMIT_LIMITS = {
  STYLESHEET: 128 * 1024,
  SIDEBAR: 10240,
  DESCRIPTION: 500,
  WIKI: 512 * 1024,
  COMMENT: 10000,
  LIVE_COMMENT: 4096,
  POST: 40000,
  POST_TITLE: 300,
  BAN_MESSAGE: 1000
};
const macroCallbackTable = [];
const macroKeyTable = [];

commentTools_module.contentStart = () => {
  jquery_default()(document.body).on('focus', commentTextareaSelector, attachEditorToUsertext);
  initializeCtrlEnterToSubmit();
  initializeLengthCounters();
  initializeAutocomplete();
};

function initializeCtrlEnterToSubmit() {
  if (commentTools_module.options.ctrlEnterSubmitsComments.value) {
    onCtrlEnter('.usertext-edit textarea, #BigEditor textarea, #wiki_page_content', e => {
      const currentForm = jquery_default()(e.currentTarget).closest('form');
      const saveButton = currentForm.find('.save')[0] || currentForm.find('#wiki_save_button')[0] || jquery_default()('.BEFoot button')[0];
      if (saveButton) Object(dom["c" /* click */])(saveButton);
    });
  }

  if (commentTools_module.options.ctrlEnterSavesLiveThreads.value) {
    onCtrlEnter('.usertext-edit textarea', () => {
      const saveButton = jquery_default()('#new-update-form .save-button button')[0];
      if (saveButton) Object(dom["c" /* click */])(saveButton);
    });
  }

  if (commentTools_module.options.ctrlEnterSubmitsPosts.value) {
    onCtrlEnter('#title-field textarea, #text-field textarea, #url, #sr-autocomplete, input.captcha', () => {
      const $captcha = jquery_default()('input.captcha:not(.cap-text)');

      if ($captcha.length && $captcha.val() === '') {
        $captcha.focus();
      } else {
        Object(dom["c" /* click */])(jquery_default()('.spacer .btn')[0]);
      }
    });
  }
}

function initializeLengthCounters() {
  if (commentTools_module.options.showInputLength.value) {
    jquery_default()(document.body).on('input', '.usertext-edit textarea, #title-field textarea, #BigEditor textarea, #wiki_page_content, #ban_message', function () {
      updateCounter(this);
    });
    jquery_default()('.submit-page #title-field span.title').prepend('<span class="RESCharCounter" title="character limit: 0/300">0/300</span>');
  }
}

const initializeEditorTools = Object(once["a" /* default */])(() => {
  jquery_default()(document.body).on('click', 'div.markdownEditor-wrapper a:not(.userTagLink)', function (e) {
    e.preventDefault();
    const index = parseInt(jquery_default()(this).attr('data-macro-index'), 10);
    const box = findTextareaForElement(this);

    if (!box) {
      console.error('Failed to locate textarea.');
      return;
    }

    const handler = macroCallbackTable[index];

    if (!handler) {
      throw new Error(`No macro callback at index: ${index}.`);
    }

    handler(box);
    box.focus();
    box.dispatchEvent(new Event('input', {
      bubbles: true,
      cancelable: true
    }));
  }).on('click', '.RESMacroDropdownTitle', function (e) {
    const thisCat = e.currentTarget;

    if (thisCat.classList.contains('openMacro')) {
      thisCat.classList.remove('openMacro');
    } else {
      jquery_default()('.RESMacroWrappingSpan span').removeClass('openMacro');
      thisCat.classList.add('openMacro');
    }

    jquery_default()(this).next().css({
      top: `${thisCat.offsetTop + thisCat.offsetHeight}px`,
      left: `${thisCat.offsetLeft + thisCat.offsetWidth - thisCat.nextSibling.offsetWidth}px`
    });
  });

  if (commentTools_module.options.keyboardShortcuts.value) {
    jquery_default()(document.body).on('keydown', '.usertext-edit textarea, #BigEditor textarea, #wiki_page_content, #ban_message', function (e) {
      if (e.key === NAMED_KEYS.Escape) {
        this.blur();
        e.preventDefault();
        return;
      }

      for (const [testedKeyArray, macroIndex] of macroKeyTable) {
        if (checkKeysForEvent(e, testedKeyArray)) {
          const handler = macroCallbackTable[macroIndex];
          handler(this);
          this.dispatchEvent(new Event('input', {
            bubbles: true,
            cancelable: true
          }));
          e.preventDefault();
          return;
        }
      }
    });
  }
});
const commentTextareaSelector = ['textarea[name=text]', 'textarea[name=description]', 'textarea[name=public_description]', 'textarea[name=body]', 'textarea[name=ban_message]', 'textarea[name=content]', 'textarea[name=title]'].join(':not([readonly]),');

function getFieldLimit(elem) {
  switch (elem.name) {
    case 'title':
      return SUBMIT_LIMITS.POST_TITLE;

    case 'text':
      if (Object(utils_location["n" /* isPageType */])('submit') || jquery_default()(elem).closest('.thing').hasClass('self')) {
        return SUBMIT_LIMITS.POST;
      }

      return SUBMIT_LIMITS.COMMENT;

    case 'description':
      return SUBMIT_LIMITS.SIDEBAR;

    case 'body':
      return SUBMIT_LIMITS.LIVE_COMMENT;

    case 'public_description':
      return SUBMIT_LIMITS.DESCRIPTION;

    case 'content':
      return SUBMIT_LIMITS.WIKI;

    case 'ban_message':
      return SUBMIT_LIMITS.BAN_MESSAGE;

    default:
      return 1337;
  }
}

function attachEditorToUsertext() {
  if (this.hasAttribute('commentTools-initialized')) return;
  this.setAttribute('commentTools-initialized', true);

  if (this.hasAttribute('data-max-length')) {
    return;
  }

  const limit = getFieldLimit(this);
  this.setAttribute('data-limit', limit);

  if (this.name === 'title') {
    return;
  }

  if (this.id === 'ban_message' && !commentTools_module.options.enabledOnBanMessages.value) {
    return;
  }

  if (this.id === 'ban_message') {
    this.style.width = '500px';
    this.style.height = '100px';
  }

  const bar = makeEditBar();

  if (this.id === 'wiki_page_content' || this.id === 'ban_message') {
    jquery_default()(this).parent().prepend(bar);
  } else {
    jquery_default()(this).parent().before(bar);
  }

  updateCounter(this);
}

function updateCounter(textarea) {
  const length = jquery_default()(textarea).val().length;
  const limit = textarea.getAttribute('data-limit');
  const counter = jquery_default()(textarea).parent().parent().find('.RESCharCounter');
  counter.attr('title', `character limit: ${length}/${limit}`);
  counter.text(`${length}/${limit}`);

  if (length > limit) {
    counter.addClass('tooLong');
  } else {
    counter.removeClass('tooLong');
  }
}
let cachedEditBar;
function makeEditBar() {
  initializeEditorTools();

  if (cachedEditBar) {
    return jquery_default()(cachedEditBar).clone();
  }

  const $editBar = jquery_default()('<div class="markdownEditor">');
  const wrappedEditBar = jquery_default()('<div class="markdownEditor-wrapper">').append($editBar);

  if (commentTools_module.options.commentingAs.value) {
    const commentingAsMessage = location.href.match(/^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned\/?/i) ? 'Moderating as' : 'Speaking as';
    const commentingAs = jquery_default()('<div class="commentingAs">').html(`${commentingAsMessage}: `).append(jquery_default()('#header-bottom-right .user a:first').clone().wrap('<span class="commentingAsUser"></span>').parent());
    const loggedIn = loggedInUser();

    if (loggedIn && isRunning(userTagger_namespaceObject)) {
      applyToUser(commentingAs.find('a')[0], {
        username: loggedIn,
        renderVoteWeight: false
      });
    }

    if (commentTools_module.options.highlightIfAltAccount.value && accountSwitcher_module.options.accounts.value.length && loggedIn && loggedIn.toLowerCase() !== accountSwitcher_module.options.accounts.value[0][0].toLowerCase()) {
      commentingAs.addClass('highlightedAltAccount');
    }

    wrappedEditBar.append(commentingAs);
  }

  if (commentTools_module.options.formattingToolButtons.value) {
    const shortcuts = commentTools_module.options.keyboardShortcuts.value;
    $editBar.append(makeEditButton('<b>Bold</b>', `bold${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.boldKey.value)})` : ''}`, commentTools_module.options.boldKey.value, 'btn-bold', box => {
      wrapSelection(box, '**', '**');
    }));
    $editBar.append(makeEditButton('<i>Italic</i>', `italic${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.italicKey.value)})` : ''}`, commentTools_module.options.italicKey.value, 'btn-italic', box => {
      wrapSelection(box, '*', '*');
    }));
    $editBar.append(makeEditButton('<del>strike</del>', `strike${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.strikeKey.value)})` : ''}`, commentTools_module.options.strikeKey.value, 'btn-strike', box => {
      wrapSelection(box, '~~', '~~');
    }));
    $editBar.append(makeEditButton('<sup>sup</sup>', `super${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.superKey.value)})` : ''}`, commentTools_module.options.superKey.value, 'btn-superscript', box => {
      wrapSelectedWords(box, '^');
    }));
    $editBar.append(makeEditButton('Link', `link${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.linkKey.value)})` : ''}`, commentTools_module.options.linkKey.value, 'btn-link', box => {
      linkSelection(box);
    }));
    $editBar.append(makeEditButton('>Quote', `quote${shortcuts ? ` (${keycode_niceKeyCode(commentTools_module.options.quoteKey.value)})` : ''}`, commentTools_module.options.quoteKey.value, 'btn-quote', box => {
      wrapSelectedLines(box, '> ', '');
    }));
    $editBar.append(makeEditButton('<span style="font-family: monospace">Code</span>', 'code', null, 'btn-code', box => {
      wrapSelectedLines(box, '    ', '');
    }));
    $editBar.append(makeEditButton('&bull;Bullets', 'bullet list', null, 'btn-list-unordered', box => {
      wrapSelectedLines(box, '* ', '');
    }));
    $editBar.append(makeEditButton('1.Numbers', 'number list', null, 'btn-list-ordered', box => {
      wrapSelectedLines(box, '1. ', '');
    }));
    $editBar.append(makeEditButton('<span style="border: 1px black solid;">Table</span>', 'table', null, 'btn-table', box => {
      const selectedText = box.value.substring(box.selectionStart, box.selectionEnd).replace(/^[\s]+/, '').replace(/[\s]+$/, '').split('\n');
      let isTable;

      if (selectedText.length >= 2) {
        if (selectedText[0].includes('|')) {
          selectedText[0] = selectedText[0].replace(/^\|/, '').replace(/\|\s+$/, '');
          const numSeparator = selectedText[0].split('|').length;
          isTable = true;
          selectedText[1] = selectedText[1].replace(/\|[^|\-]+$/, '');
          selectedText[1] = selectedText[1].replace(/-/g, '--');

          if (!selectedText[1].includes('-|') && !selectedText[1].includes('|-')) {
            isTable = false;
          }

          selectedText[1] = selectedText[1].replace(/^\]+/, '').replace(/[\s|]+$/, '');

          if (selectedText[1].split('-|-').length < numSeparator) {
            isTable = false;
          }

          if (/[^|\-]/.test(selectedText[1])) {
            isTable = false;
          }

          if (isTable) {
            for (const i of Object(generator["a" /* range */])(2, selectedText.length)) {
              if (!selectedText[i].includes('|')) {
                isTable = false;
                break;
              }

              selectedText[i] = selectedText[i].replace(/^\|/, '').replace(/[\s|]+$/, '');

              if (selectedText[i].split('|').length !== numSeparator) {
                isTable = false;
                break;
              }
            }
          }
        }
      }

      let startTable;

      if (isTable) {
        startTable = selectedText.reduce((prevTable, currText, i) => {
          if (i === 1) {
            return prevTable;
          }

          return `${prevTable}<tr><td>${escapeHTML(currText).replace(/\|/g, '</td><td>')}</td></tr>`;
        }, '');
      } else {
        startTable = '<tr><td>Foo</td><td>Bar</td></tr><tr><td>Foo</td><td>Bar</td></tr>';
      }

      const element = string_namespaceObject.html`<div><div class="buttonContainer"></div><table class="commentPreview" contenteditable="true">${string_namespaceObject.safe(startTable)}</table></div>`;
      alert_namespaceObject.open(element, {
        cancelable: true
      }).then(() => {
        let generatedTable = '\n\n';
        let generatedTableSeparation = '';
        jquery_default()('tr:first td', element).each(function () {
          const text = jquery_default()(this).text().replace(/[\n|]/g, '');
          generatedTable += `${text} | `;
          generatedTableSeparation += '-'.repeat(text.length);
          generatedTableSeparation += '|';
        });
        generatedTableSeparation = generatedTableSeparation.substr(0, generatedTableSeparation.length - 1);
        generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}\n${generatedTableSeparation}\n`;
        jquery_default()('tr:gt(0)', element).each(function () {
          jquery_default()(this).find('td').each(function () {
            generatedTable += `${jquery_default()(this).text().replace(/[\n|]/g, '')} | `;
          });
          generatedTable = `${generatedTable.substr(0, generatedTable.length - 3)}\n`;
        });

        if (isTable) {
          replaceSelection(box, generatedTable);
        } else {
          wrapSelection(box, generatedTable, '');
        }

        jquery_default()(box).trigger('input');
      });
      const addRow = alert_namespaceObject.makeButton('+ Row');
      const remRow = alert_namespaceObject.makeButton('- Row');
      const addCol = alert_namespaceObject.makeButton('+ Col');
      const remCol = alert_namespaceObject.makeButton('- Col');
      addRow.addEventListener('click', () => {
        const nbCol = jquery_default()('tr:first td', element).length;
        const newRow = '<td>text</td>'.repeat(nbCol);
        jquery_default()('table', element).append(`<tr>${newRow}</tr>`);
      });
      remRow.addEventListener('click', () => {
        if (jquery_default()('tr', element).length > 1) {
          jquery_default()('table tr:last', element).remove();
        }
      });
      addCol.addEventListener('click', () => {
        jquery_default()('table tr', element).append('<td>text</td>');
      });
      remCol.addEventListener('click', () => {
        if (jquery_default()('tr:first td', element).length > 1) {
          jquery_default()('table tr td:last-of-type', element).remove();
        }
      });
      const $buttonContainer = jquery_default()('.buttonContainer', element);
      $buttonContainer.append(addRow);
      $buttonContainer.append(remRow);
      $buttonContainer.append(addCol);
      $buttonContainer.append(remCol);
    }));
  }

  if (commentTools_module.options.showInputLength.value) {
    const $counter = jquery_default()('<span class="RESCharCounter" title="character limit: 0/?????">0/?????</span>');
    $editBar.prepend($counter);
  }

  if (commentTools_module.options.macroButtons.value) {
    buildMacroDropdowns(wrappedEditBar);
    const addMacroButton = makeEditButton(i18n(commentTools_module.options.macros.addRowText), null, null, 'btn-macro btn-macro-add', () => {
      settingsNavigation_open(commentTools_module.moduleID, 'macros');
      jquery_default()('.RESMacroWrappingSpan span').removeClass('openMacro');
    });
    addButtonToMacroGroup('', addMacroButton);
  }

  cachedEditBar = wrappedEditBar;
  return cachedEditBar;
}
const macroDropDownTable = new Map();

function getMacroGroup(groupName) {
  groupName = (groupName || '').toString().trim() || 'macros';
  let macroGroup = macroDropDownTable.get(groupName);

  if (macroGroup === undefined) {
    macroGroup = {};
    macroGroup.titleButton = jquery_default()(`<span class="RESMacroDropdownTitle">${groupName}</span>`);
    macroGroup.container = jquery_default()('<span class="RESMacroDropdown"></span>');
    macroGroup.dropdown = jquery_default()('<ul class="RESMacroDropdownList"></ul>');
    macroGroup.container.append(macroGroup.dropdown);
    macroDropDownTable.set(groupName, macroGroup);
  }

  return macroGroup;
}

function addButtonToMacroGroup(groupName, button) {
  const group = getMacroGroup(groupName);
  group.dropdown.append(jquery_default()('<li>').append(button));
}

function getDebugMacros() {
  if (!Object(utils_location["l" /* isCurrentSubreddit */])('Enhancement', 'RESissues')) return [];
  return [['RES modified settings', '\n\n{{resmodifiedsettings}}\n', null, null], ['RES diagnostics', '{{resdiagnostics}}', null, null]];
}

function buildMacroDropdowns(editBar) {
  const macros = [...commentTools_module.options.macros.value, ...getDebugMacros()];

  for (const [title, text, category, key] of macros) {
    const button = makeEditButton(title, null, key, 'btn-macro', box => {
      macroSelection(box, text);
    });
    addButtonToMacroGroup(category, button);
  }

  const $macroWrapper = jquery_default()('<span class="RESMacroWrappingSpan">');
  const defaultGroup = getMacroGroup('');
  $macroWrapper.append(defaultGroup.titleButton);
  $macroWrapper.append(defaultGroup.container);

  for (const [category, macroGroup] of macroDropDownTable) {
    if (category === 'macros') {
      continue;
    }

    $macroWrapper.append(macroGroup.titleButton);
    $macroWrapper.append(macroGroup.container);
  }

  editBar.append($macroWrapper);
}

function makeEditButton(label, title, key, cls, handler) {
  if (label === null) {
    label = 'unlabeled';
  }

  if (title === null) {
    title = '';
  }

  const macroButtonIndex = macroCallbackTable.length;
  const button = string_namespaceObject.html`<a class="edit-btn ${cls}" title="${title}" href="#" tabindex="1" data-macro-index="${macroButtonIndex}">${label}</a>`;

  if (key && key[0] !== null) {
    macroKeyTable.push([key, macroButtonIndex]);
  }

  macroCallbackTable[macroButtonIndex] = handler;
  return button;
}

function linkSelection(box) {
  let url = prompt('Enter the URL:', '');

  if (url) {
    url = url.replace(/[\(\)]/g, '\\$&');
    wrapSelection(box, '[', `](${url})`, text => text.replace(/[\[\]\(\)]/g, '\\$&'));
  }
}

function macroSelection(box, macroText) {
  if (!commentTools_module.options.keepMacroListOpen.value) {
    jquery_default()('.RESMacroWrappingSpan span').removeClass('openMacro');
  }

  if (commentTools_module.options.macroPlaceholders.value) {
    wrapSelection(box, '', '', selectedText => fillPlaceholders(box, macroText, selectedText));
  } else {
    wrapSelection(box, macroText, '');
  }
}

function fillPlaceholders(box, macroText, selectedText) {
  const placeholders = macroText.match(/\{\{\w+\}\}/g);

  if (placeholders) {
    const completedPlaceholders = new Set();

    for (const placeholder of placeholders) {
      if (completedPlaceholders.has(placeholder)) {
        continue;
      }

      completedPlaceholders.add(placeholder);
      const placeholderInnerText = placeholder.substring(2, placeholder.length - 2).toLowerCase();
      let value;

      try {
        value = getMagicPlaceholderValue(placeholderInnerText, macroText, selectedText, box);
      } catch (e) {
        console.error('Error getting magic placeholder value', placeholderInnerText);
        console.error(e);
      }

      if (value === undefined) {
        value = promptForPlaceholderValue(placeholder, macroText);
      }

      if (value === null) {
        break;
      }

      macroText = macroText.replace(new RegExp(placeholder, 'g'), value);
    }
  }

  return macroText;
}

function getMagicPlaceholderValue(placeholder, macroText, selectedText, box) {
  const handler = magicPlaceholders.find(current => current.matches.includes(placeholder));

  if (handler) {
    return handler.handle(macroText, selectedText, box);
  }
}

const magicPlaceholders = [{
  matches: ['subreddit'],

  handle(macroText, selectedText, box) {
    const thing = Thing["a" /* Thing */].from(box);
    const subreddit = thing && thing.getSubreddit();

    if (subreddit) {
      return `/r/${subreddit}`;
    }
  }

}, {
  matches: ['me', 'my_username'],

  handle() {
    const username = loggedInUser();

    if (username) {
      return `/u/${username}`;
    }
  }

}, {
  matches: ['op', 'op_username'],

  handle(macroText, selectedText, box) {
    let profile;

    if (Object(utils_location["n" /* isPageType */])('comments')) {
      profile = document.querySelector('.sitetable .author');
    } else {
      let $next = jquery_default()(box);
      let furthest = $next;

      do {
        if ($next && $next.length) furthest = $next;
        $next = $next.parent().closest('.sitetable');
      } while ($next.length);

      profile = furthest.find('.author')[0];
    }

    if (profile) {
      const match = profile.pathname.match(utils_location["p" /* regexes */].profile);
      if (!match) throw new Error(`Invalid profile link: ${profile.href}`);
      return `/u/${match[1]}`;
    }
  }

}, {
  matches: ['url'],

  handle() {
    return location.href;
  }

}, {
  matches: ['reply_to', 'reply_to_username'],

  handle(macroText, selectedText, box) {
    let $base = jquery_default()(box);
    const isEditing = $base.closest('.thing, .entry').hasClass('entry');

    if (isEditing) {
      $base = $base.closest('.thing').parent();
    }

    const profile = $base.closest('.thing').find('.entry .author')[0];

    if (!profile) {
      return getMagicPlaceholderValue('op', macroText, selectedText, box);
    } else {
      const match = profile.pathname.match(utils_location["p" /* regexes */].profile);
      if (!match) throw new Error(`Invalid profile link: ${String(profile)}`);
      return `/u/${match[1]}`;
    }
  }

}, {
  matches: ['selected', 'selection'],

  handle(macroText, selectedText) {
    return selectedText;
  }

}, {
  matches: ['now'],

  handle() {
    const date = new Date();
    return date.toTimeString();
  }

}, {
  matches: ['today'],

  handle() {
    const date = new Date();
    return date.toDateString();
  }

}, {
  matches: ['linkflair'],

  handle() {
    if (Object(utils_location["n" /* isPageType */])('comments')) {
      return document.querySelector('.linkflairlabel').textContent;
    }
  }

}, {
  matches: ['escaped'],

  handle(macroText, selectedText) {
    return selectedText.replace(/[\[\]()\\\*\^~\-_.]/g, '\\$&').replace(/^([ ]{0,3})>/gm, '$1\\>');
  }

}, {
  matches: ['resmodifiedsettings'],

  handle() {
    return getModifiedText();
  }

}, {
  matches: ['resdiagnostics'],

  handle() {
    return diagnostics();
  }

}];

function promptForPlaceholderValue(placeholder, macroText) {
  return prompt(`${macroText}\n\n\nEnter replacement for ${placeholder}:`, placeholder);
}

function wrapSelection(box, prefix, suffix, escapeFunction) {
  if (!box) {
    return;
  }

  const scrollTop = box.scrollTop;
  const selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  let selectedText = text.substring(selectionStart, selectionEnd);
  const afterSelection = text.substring(selectionEnd);
  let trailingSpace = '';
  let cursor = selectedText.length - 1;

  while (cursor > 0 && selectedText[cursor] === ' ') {
    trailingSpace += ' ';
    cursor--;
  }

  selectedText = selectedText.substring(0, cursor + 1);

  if (typeof escapeFunction === 'function') {
    selectedText = escapeFunction(selectedText);
  }

  box.value = beforeSelection + prefix + selectedText + suffix + trailingSpace + afterSelection;
  box.selectionEnd = beforeSelection.length + prefix.length + selectedText.length;

  if (selectionStart === selectionEnd) {
    box.selectionStart = box.selectionEnd;
  } else {
    box.selectionStart = beforeSelection.length + prefix.length;
  }

  box.scrollTop = scrollTop;
}

function replaceSelection(box, replacement) {
  if (!box) {
    return;
  }

  const scrollTop = box.scrollTop;
  const selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  const afterSelection = text.substring(selectionEnd);
  box.value = beforeSelection + replacement + afterSelection;
  box.selectionEnd = beforeSelection.length + replacement.length;
  box.scrollTop = scrollTop;
}

function wrapSelectedLines(box, prefix, suffix) {
  const scrollTop = box.scrollTop;
  let selectionStart = box.selectionStart;
  let selectionEnd = box.selectionEnd;
  const text = box.value;
  let startPosition = 0;
  const lines = text.split('\n');

  for (const i of Object(generator["a" /* range */])(0, lines.length)) {
    let lineStart = startPosition;
    let lineEnd = lineStart + lines[i].length;

    if (selectionStart <= lineStart && lineStart <= selectionEnd || selectionStart <= lineEnd && lineEnd <= selectionEnd || lineStart <= selectionStart && selectionStart <= lineEnd || lineStart <= selectionEnd && selectionEnd <= lineEnd) {
      lines[i] = prefix + lines[i] + suffix;
      let startMovement = 0;
      let endMovement = 0;

      if (lineStart < selectionStart) {
        startMovement += prefix.length;
      }

      if (lineEnd < selectionStart) {
        startMovement += suffix.length;
      }

      if (lineStart < selectionEnd) {
        endMovement += prefix.length;
      }

      if (lineEnd < selectionEnd) {
        endMovement += suffix.length;
      }

      selectionStart += startMovement;
      selectionEnd += endMovement;
      lineStart += prefix.length;
      lineEnd += prefix.length + suffix.length;
    }

    startPosition = lineEnd + 1;
  }

  box.value = lines.join('\n');
  box.selectionStart = selectionStart;
  box.selectionEnd = selectionEnd;
  box.scrollTop = scrollTop;
}

function wrapSelectedWords(box, prefix) {
  const scrollTop = box.scrollTop;
  let selectionStart = box.selectionStart;
  const selectionEnd = box.selectionEnd;
  const text = box.value;
  const beforeSelection = text.substring(0, selectionStart);
  const selectedWords = text.substring(selectionStart, selectionEnd).split(' ');
  const afterSelection = text.substring(selectionEnd);
  let selectionModify = 0;

  for (const i of Object(generator["a" /* range */])(0, selectedWords.length)) {
    if (selectedWords[i] !== '') {
      if (selectedWords[i].includes('\n')) {
        const newLinePosition = selectedWords[i].lastIndexOf('\n') + 1;
        selectedWords[i] = selectedWords[i].substring(0, newLinePosition) + prefix + selectedWords[i].substring(newLinePosition);
        selectionModify += prefix.length;
      }

      if (selectedWords[i].charAt(0) !== '\n') {
        selectedWords[i] = prefix + selectedWords[i];
      }

      selectionModify += prefix.length;
    } else if (selectedWords[i] === '' && selectedWords.length === 1) {
      selectedWords[i] = prefix + selectedWords[i];
      selectionModify += prefix.length;
      selectionStart += prefix.length;
    }
  }

  box.value = beforeSelection + selectedWords.join(' ') + afterSelection;
  box.selectionStart = selectionStart;
  box.selectionEnd = selectionEnd + selectionModify;
  box.scrollTop = scrollTop;
}

const autoCompleteMatchRegExp = /(^|\W)\/?(?:r\/([\w]+)\/)?(wiki|w|r|u)\/([-\w]+)$/;

function initializeAutocomplete() {
  if (!commentTools_module.options.subredditAutocomplete.value && !commentTools_module.options.userAutocomplete.value && !commentTools_module.options.wikiAutocomplete.value) return;
  jquery_default()(document.body).on('input', '.usertext .usertext-edit textarea, #BigText, #wiki_page_content', Object(debounce["a" /* default */])(async e => {
    const textarea = e.currentTarget;
    const prefixText = textarea.value.slice(0, textarea.selectionStart);
    const [,, subreddit, [type] = [], query] = autoCompleteMatchRegExp.exec(prefixText) || [];
    const completions = query && (type === 'u' && commentTools_module.options.userAutocomplete.value && (await getUserCompletions(query)) || type === 'r' && commentTools_module.options.subredditAutocomplete.value && (await getSubredditCompletions(query)) || type === 'w' && commentTools_module.options.wikiAutocomplete.value && (await getWikiCompletions(query, subreddit || Object(utils_location["d" /* currentSubreddit */])() || ''))) || [];
    autoComplete(textarea)(completions);
  }, 100));
}

const autoComplete = Object(memoize["a" /* default */])(textarea => {
  const element = string_namespaceObject.html`<div id="autocomplete_dropdown" class="drop-choices srdrop"></div>`;
  let entries = [];
  let index = 0;
  element.addEventListener('click', e => {
    const text = (e.target.closest('.choice') || e.target).textContent;
    const caretPos = textarea.selectionStart;
    let left = textarea.value.substr(0, caretPos);
    const right = textarea.value.substr(caretPos);
    left = left.replace(autoCompleteMatchRegExp, `$1${text} `);
    textarea.value = left + right;
    textarea.selectionStart = textarea.selectionEnd = left.length;
    textarea.focus();
    textarea.dispatchEvent(new Event('input', {
      bubbles: true,
      cancelable: true
    }));
  });

  const updateSelection = () => {
    for (const entry of entries) entry.classList.remove('selectedItem');

    entries[index % entries.length].classList.add('selectedItem');
  };

  const remove = () => {
    element.remove();
    textarea.removeEventListener('keydown', navigate);
    textarea.removeEventListener('blur', remove);
  };

  const navigate = e => {
    if (e.metaKey || e.shiftKey || e.ctrlKey || e.altKey) return;
    if (!document.contains(element)) return;

    switch (e.key) {
      case NAMED_KEYS.Down:
      case NAMED_KEYS.Right:
        e.preventDefault();
        index++;
        updateSelection();
        return;

      case NAMED_KEYS.Up:
      case NAMED_KEYS.Left:
        e.preventDefault();
        index--;
        updateSelection();
        return;

      case NAMED_KEYS.Tab:
      case NAMED_KEYS.Enter:
        e.preventDefault();
        entries[index % entries.length].click();
        return;

      case NAMED_KEYS.Escape:
        e.preventDefault();
        e.stopImmediatePropagation();
        remove();
        break;

      default:
        break;
    }
  };

  return matches => {
    if (!matches.length || document.activeElement !== textarea) {
      remove();
      return;
    }

    Object(dom["e" /* empty */])(element);
    entries = matches.slice(0, 20).map(text => string_namespaceObject.html`<a class="choice">${text}</a>`);
    element.append(...entries);
    index = 0;
    updateSelection();

    if (!document.contains(element)) {
      const textareaOffset = jquery_default()(textarea).offset();
      textareaOffset.left += jquery_default()(textarea).width();
      jquery_default()(element).css(textareaOffset);
      document.body.append(element);
      textarea.addEventListener('keydown', navigate);
      textarea.addEventListener('blur', () => {
        setTimeout(() => {
          if (document.activeElement !== textarea) remove();
        }, 200);
      });
    }
  };
});

async function getSubredditCompletions(query) {
  const {
    names
  } = await ajax({
    method: 'POST',
    url: '/api/search_reddit_names.json',
    query: {
      query
    },
    data: {
      query
    },
    type: 'json',
    cacheFor: utils_time["a" /* DAY */]
  });
  return names.map(name => `/r/${name}`);
}

const loadAllTags = Object(once["a" /* default */])(() => userTagger_Tag.getStored());

async function getUserCompletions(query) {
  await loadAllTags();
  return Array.from(tags.values()).filter(({
    id
  }) => id.toLowerCase().startsWith(query.toLowerCase())).filter(({
    text,
    votesUp,
    instances
  }) => text || votesUp || instances.length).sort((a, b) => Number(b.instances.length > a.instances.length) || a.id.localeCompare(b.id)).map(({
    id
  }) => `/u/${id}`);
}

async function getWikiCompletions(query, subreddit) {
  const {
    data: wikiPages
  } = await ajax({
    method: 'GET',
    url: `/r/${subreddit}/wiki/pages.json`,
    type: 'json',
    cacheFor: utils_time["a" /* DAY */]
  });
  return wikiPages.filter(wikiPage => wikiPage.toLowerCase().startsWith(query.toLowerCase())).map(wikiPage => `/r/${subreddit}/wiki/${wikiPage}`);
}

function findTextareaForElement(elem) {
  const textarea = jquery_default()(elem).closest('.usertext-edit, #BigEditor, .wiki-page-content, #banned').find('textarea').filter('#BigText, [name=text], [name=description], [name=public_description], [name=body], #wiki_page_content, #ban_message').get(0);
  return textarea;
}

function onCtrlEnter(selector, callback) {
  jquery_default()(document.body).on('keydown', selector, e => {
    if (e.key === NAMED_KEYS.Enter && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      callback(e);
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/usernameHider.js





const usernameHider_module = new Module('usernameHider');
usernameHider_module.moduleName = 'usernameHiderName';
usernameHider_module.category = 'myAccountCategory';
usernameHider_module.disabledByDefault = true;
usernameHider_module.description = 'usernameHiderDesc';
usernameHider_module.options = {
  displayText: {
    title: 'usernameHiderDisplayTextTitle',
    type: 'text',
    value: '~anonymous~',
    description: 'usernameHiderDisplayTextDesc'
  },
  perAccountDisplayText: {
    title: 'usernameHiderPerAccountDisplayTextTitle',
    type: 'table',
    addRowText: '+add account',
    fields: [{
      key: 'username',
      name: 'username',
      type: 'text'
    }, {
      key: 'displayText',
      name: 'displayText',
      type: 'text'
    }],
    value: [],
    description: 'usernameHiderPerAccountDisplayTextDesc'
  },
  hideAllUsernames: {
    title: 'usernameHiderHideAllUsernamesTitle',
    advanced: true,
    type: 'boolean',
    value: true,
    description: 'usernameHiderHideAllUsernamesDesc'
  },
  hideAccountSwitcherUsernames: {
    title: 'usernameHiderHideAccountSwitcherUsernamesTitle',
    advanced: true,
    type: 'boolean',
    value: true,
    description: 'usernameHiderHideAccountSwitcherUsernamesDesc'
  },
  showUsernameOnHover: {
    title: 'usernameHiderShowUsernameOnHoverTitle',
    type: 'boolean',
    value: false,
    description: 'usernameHiderShowUsernameOnHoverDesc'
  }
};
const substitutes = Object(once["a" /* default */])(() => new Map([[(loggedInUser() || '').toLowerCase(), usernameHider_module.options.displayText.value], ...usernameHider_module.options.perAccountDisplayText.value.map(([username, substitute]) => [username.toLowerCase(), substitute])]));
const getDisplayText = (username, alt = username) => substitutes().get(username.toLowerCase()) || alt;

usernameHider_module.contentStart = () => {
  for (const username of new Set([loggedInUser(), ...(usernameHider_module.options.hideAllUsernames.value ? usernameHider_module.options.perAccountDisplayText.value.map(([username]) => username) : []), ...(usernameHider_module.options.hideAccountSwitcherUsernames.value ? accountSwitcher_module.options.accounts.value.map(([username]) => username) : [])].filter(Boolean)).values()) {
    hideUsername(username, getDisplayText(username, usernameHider_module.options.displayText.value));
  }
};

function hideUsername(user, displayText) {
  if (!displayText || user === displayText) return;
  const userHref = `[href*="/user/${user}"]`;
  Object(dom["b" /* addCSS */])(`
		p.tagline > a${userHref},
		#header .user > a${userHref},
		.titlebox .tagline a.author${userHref},
		.commentingAsUser a${userHref},
		a.author${userHref},
		.bottom a${userHref} {
			line-height: 0;
			font-size: 0;
		}

		p.tagline > a${userHref}::after,
		#header .user > a${userHref}::after,
		.titlebox .tagline a.author${userHref}::after,
		.commentingAsUser a${userHref}::after,
		a.author${userHref}::after,
		.bottom a${userHref}::after {
			content: "${displayText}";
			letter-spacing: normal;
			font-size: 10px;
			background-color: inherit;
			border-radius: inherit;
			padding: inherit;
		}

		a.author${userHref}::after {
			margin-right: 0.5em;
		}

		.commentingAsUser a${userHref}::after {
			font-size: small;
		}
	`);

  if (usernameHider_module.options.showUsernameOnHover.value) {
    Object(dom["b" /* addCSS */])(`
			p.tagline > a${userHref}:hover,
			#header .user > a${userHref}:hover,
			.titlebox .tagline a.author${userHref}:hover,
			.commentingAsUser a${userHref}:hover,
			a.author${userHref}:hover,
			.bottom a${userHref}:hover {
				line-height: inherit;
				font-size: inherit;
			}

			p.tagline > a${userHref}:hover::after,
			#header .user > a${userHref}:hover::after,
			.titlebox .tagline a.author${userHref}:hover::after,
			.commentingAsUser a${userHref}:hover::after,
			a.author${userHref}:hover::after,
			.bottom a${userHref}:hover::after {
				content: none;
			}
		`);
  }

  const curatedBy = document.querySelector('.multi-details > h2 a');

  if (curatedBy) {
    const curatedByUsername = curatedBy.pathname.match(utils_location["p" /* regexes */].profile);

    if (curatedByUsername && curatedByUsername[1].toLowerCase() === user.toLowerCase()) {
      curatedBy.textContent = curatedBy.textContent.replace(user, displayText);

      if (usernameHider_module.options.showUsernameOnHover.value) {
        jquery_default()(curatedBy).on('mouseenter', function () {
          this.textContent = this.textContent.replace(displayText, user);
        }).on('mouseleave', function () {
          this.textContent = this.textContent.replace(user, displayText);
        });
      }
    }
  }
}
// CONCATENATED MODULE: ./lib/modules/quickMessage.js











const quickMessage_module = new Module('quickMessage');
quickMessage_module.moduleName = 'quickMessageName';
quickMessage_module.category = 'usersCategory';
quickMessage_module.description = 'quickMessageDesc';
quickMessage_module.options = {
  openQuickMessage: {
    title: 'quickMessageOpenQuickMessageTitle',
    type: 'keycode',
    value: [77, false, true, false, false],
    description: 'quickMessageOpenQuickMessageDesc'
  },
  defaultSubject: {
    title: 'quickMessageDefaultSubjectTitle',
    type: 'text',
    value: '',
    description: 'quickMessageDefaultSubjectDesc'
  },
  sendAs: {
    title: 'quickMessageSendAsTitle',
    type: 'enum',
    values: [{
      name: 'Current user',
      value: 'user'
    }, {
      name: 'Current subreddit',
      value: 'sub'
    }, {
      name: 'Last selected',
      value: 'last'
    }, {
      name: 'Last selected (this page load)',
      value: 'temporary'
    }],
    value: 'user',
    description: 'quickMessageSendAsDesc'
  },
  handleContentLinks: {
    title: 'quickMessageHandleContentLinksTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageHandleContentLinksDesc'
  },
  handleSideLinks: {
    title: 'quickMessageHandleSideLinksTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageHandleSideLinksDesc'
  },
  linkToCurrentPage: {
    title: 'quickMessageLinkToCurrentPageTitle',
    type: 'boolean',
    value: true,
    description: 'quickMessageLinkToCurrentPageDesc'
  }
};
const lastSentAsStorage = storage_namespaceObject.wrapPrefix('RESmodules.quickMessage.lastSentAs.', () => null);

quickMessage_module.contentStart = () => {
  registerCommand((cmd, val) => cmd === 'qm' && /^(?:([^\s]+)(?:\s(.*))?)?$/.exec(val), 'qm [recipient [message]] - open quick message dialog', (command, val, [, to, body]) => {
    if (body) {
      return `quick message to ${to}: ${body}`;
    } else if (to) {
      return `quick message to ${to}`;
    }

    return 'quick message';
  }, (command, val, [, to, body]) => {
    openQuickMessageDialog({
      to,
      body
    });
  });
  window.addEventListener('keydown', e => {
    if (checkKeysForEvent(e, quickMessage_module.options.openQuickMessage.value)) {
      e.preventDefault();
      openQuickMessageDialog();
    }
  }, true);

  if (quickMessage_module.options.handleContentLinks.value) {
    jquery_default()('div.content[role="main"]').on('click', 'a[href*="/message/compose"]', messageLinkEventHandler);
  }

  if (quickMessage_module.options.handleSideLinks.value) {
    jquery_default()('div.side').on('click', 'a[href*="/message/compose"]', messageLinkEventHandler);
  }
};

const quickMessageDialog = Object(once["a" /* default */])(() => {
  const $dialog = jquery_default()(string_namespaceObject.html`
		<div id="quickMessage">
			<div id="quickMessageDialog" class="RESDialogSmall">
				<h3>Send Message<a class="gearIcon" href="${makeUrlHash(quickMessage_module.moduleID)}"></a></h3>
				<div id="quickMessageDialogClose" class="RESCloseButton RESCloseButtonTopRight"></div>
				<div id="quickMessageDialogContents" class="RESDialogContents clear">
					<form name="quickMessageDialogForm" action="">
						<label for="quickMessageDialogFrom">From</label>
						<select id="quickMessageDialogFrom"></select>
						<label for="quickMessageDialogTo">To</label>
						<input type="text" id="quickMessageDialogTo" value=""/>
						<label for="quickMessageDialogSubject">Subject</label>
						<input type="text" id="quickMessageDialogSubject" value=""/>
						<label for="quickMessageDialogBody">Body</label>
						<textarea id="quickMessageDialogBody"></textarea>
						<div class="clear"></div>
						<input type="button" id="quickMessageDialogSend" value="✓ send message"/>
						<a href="/message/compose" class="fullMessageForm blueButton">open full message form</a>
					</form>
				</div>
			</div>
		</div>
	`);
  const from = Object(flow["a" /* downcast */])($dialog.find('#quickMessageDialogFrom').get(0), HTMLSelectElement);
  const to = Object(flow["a" /* downcast */])($dialog.find('#quickMessageDialogTo').get(0), HTMLInputElement);
  const subject = Object(flow["a" /* downcast */])($dialog.find('#quickMessageDialogSubject').get(0), HTMLInputElement);
  const body = Object(flow["a" /* downcast */])($dialog.find('#quickMessageDialogBody').get(0), HTMLTextAreaElement);
  $dialog.find('#quickMessageDialogClose').on('click', e => {
    e.preventDefault();
    closeQuickMessageDialog();
  });
  $dialog.get(0).addEventListener('keydown', e => {
    if (e.key === NAMED_KEYS.Escape) {
      e.preventDefault();
      closeQuickMessageDialog();
    }
  }, true);
  $dialog.find('#quickMessageDialogSend').get(0).addEventListener('click', e => {
    e.preventDefault();
    quickMessage_sendMessage();
  }, true);
  onCtrlEnter('#quickMessageDialog', quickMessage_sendMessage);
  $dialog.find('a.fullMessageForm').on('mousedown focus', e => {
    jquery_default()(e.currentTarget).attr('href', getFullMessageFormUrl());
  }).on('click', closeQuickMessageDialog);
  $dialog.find('a').on('keypress', e => {
    if (e.key === NAMED_KEYS.Enter) {
      e.currentTarget.click();
    }
  });
  from.addEventListener('change', () => {
    const val = from.value;
    updateModeratorIcon(val.startsWith('/r/'));
    const loggedIn = loggedInUser();
    if (loggedIn) lastSentAsStorage.set(loggedIn, val);
  });
  $dialog.appendTo(document.body);
  return {
    $dialog,
    from,
    to,
    subject,
    body
  };
});

function updateModeratorIcon(state) {
  quickMessageDialog().$dialog.find('label[for=quickMessageDialogFrom]').toggleClass('moderator', state);
}

function messageLinkEventHandler(e) {
  const {
    searchParams,
    pathname
  } = new URL(Object(flow["a" /* downcast */])(e.target, HTMLAnchorElement).href, location.href);
  const hasModifier = e.ctrlKey || e.altKey || e.metaKey || e.shiftKey;

  if (e.button === 0 && !hasModifier && utils_location["p" /* regexes */].composeMessage.test(pathname)) {
    e.preventDefault();
    const srMatch = utils_location["p" /* regexes */].subreddit.exec(pathname);
    openQuickMessageDialog({
      from: srMatch ? `/r/${srMatch[1]}` : undefined,
      to: searchParams.get('to') || '',
      subject: searchParams.get('subject') || '',
      body: searchParams.get('message') || ''
    });
    return true;
  }
}

async function getValidSendFrom() {
  const username = loggedInUser();

  if (!username) {
    return [];
  }

  const users = [{
    name: `/u/${username}`,
    displayText: `/u/${isRunning(usernameHider_namespaceObject) ? getDisplayText(username) : username}`
  }];

  if (isModeratorAnywhere()) {
    const {
      data
    } = await ajax({
      url: '/subreddits/mine/moderator.json',
      query: {
        limit: 1000,
        show: 'all',
        user: loggedInUser() || ''
      },
      type: 'json',
      cacheFor: utils_time["b" /* HOUR */]
    });
    const modSubs = data.children.map(({
      data
    }) => {
      const name = data.url.slice(0, -1);
      return {
        name,
        displayText: name
      };
    });
    users.push(...modSubs);
  }

  return users;
}

const setUpSendFromDropdown = Object(once["a" /* default */])(async () => {
  const senders = await getValidSendFrom();

  for (const {
    name,
    displayText
  } of senders) {
    const currentOption = document.createElement('option');
    currentOption.value = name;
    currentOption.text = displayText;
    quickMessageDialog().from.add(currentOption);
  }

  quickMessageDialog().from.disabled = senders.length < 2;
});

function focusFirstEmpty() {
  Array.from(quickMessageDialog().$dialog.find('input, textarea')).find((ele, i, {
    length
  }) => !ele.value || i === length - 1).focus();
}

async function updateSelectedSender(desiredUser, loggedIn) {
  const sendAsOptions = Array.from(quickMessageDialog().from.options).map(ele => jquery_default()(ele).text().toLowerCase());
  let indexToSelect = sendAsOptions.indexOf(desiredUser.toLowerCase());

  if (indexToSelect === -1) {
    switch (quickMessage_module.options.sendAs.value) {
      case 'sub':
        const sub = Object(utils_location["d" /* currentSubreddit */])();
        if (sub) indexToSelect = sendAsOptions.indexOf(`/r/${sub.toLowerCase()}`);
        break;

      case 'last':
        const lastSelected = await lastSentAsStorage.get(loggedIn);

        if (lastSelected) {
          indexToSelect = sendAsOptions.indexOf(lastSelected.toLowerCase());
        }

        break;

      case 'temporary':
        indexToSelect = quickMessageDialog().from.selectedIndex;
        break;

      default:
        indexToSelect = 0;
        break;
    }
  }

  quickMessageDialog().from.selectedIndex = indexToSelect !== -1 ? indexToSelect : 0;
  updateModeratorIcon(quickMessageDialog().from.value.startsWith('/r/'));
}

async function openQuickMessageDialog({
  from = '',
  to = '',
  subject = quickMessage_module.options.defaultSubject.value,
  body = quickMessage_module.options.linkToCurrentPage.value ? location.href : ''
} = {}) {
  const loggedIn = loggedInUser();

  if (!loggedIn) {
    notifications_showNotification({
      moduleID: 'quickMessage',
      notificationID: 'quickMessageNoUser',
      header: 'Not Logged In.',
      closeDelay: 3000,
      message: 'You must log in to use the quick message dialog.'
    });
    return;
  }

  await setUpSendFromDropdown();
  await updateSelectedSender(from, loggedIn);
  quickMessageDialog().to.value = to;
  quickMessageDialog().subject.value = subject;
  quickMessageDialog().body.value = body;
  quickMessageDialog().$dialog.fadeIn(300);
  focusFirstEmpty();
}

function closeQuickMessageDialog() {
  quickMessageDialog().$dialog.fadeOut(300);

  for (const ele of quickMessageDialog().$dialog.find('input, textarea, button')) {
    ele.blur();
  }
}

function getFullMessageFormUrl() {
  const subreddit = quickMessageDialog().from.value.startsWith('/r/') ? quickMessageDialog().from.value : '';
  return subreddit + string_namespaceObject.encode`/message/compose?to=${quickMessageDialog().to.value}&subject=${quickMessageDialog().subject.value}&message=${quickMessageDialog().body.value}`;
}

const presetSendErrors = {
  NO_USER: 'No recipient specified.',
  NO_SUBJECT: 'No subject specified.',
  NO_TEXT: 'Message body is empty.',
  BAD_CAPTCHA: '<p>Sorry, reddit requires you to enter a captcha to send messages. This is usually because your account is brand new or has low karma.</p><b>Click on "open full message form" and try again (your message will be preserved).</b>',
  TOO_LONG: 'Either your subject (max 100 characters) or body (max 10,000 characters) is too long.'
};

async function quickMessage_sendMessage() {
  const from = quickMessageDialog().from.value;

  try {
    const {
      json: {
        errors
      }
    } = await ajax({
      method: 'POST',
      url: '/api/compose',
      data: {
        api_type: 'json',
        from_sr: from.includes('/r/') ? from.slice(3) : '',
        subject: quickMessageDialog().subject.value,
        text: quickMessageDialog().body.value,
        to: quickMessageDialog().to.value
      },
      type: 'json'
    });

    if (errors[0]) {
      notifications_showNotification({
        moduleID: 'quickMessage',
        notificationID: 'quickMessageSendError',
        header: 'Message not sent.',
        closeDelay: 15000,
        message: presetSendErrors[errors[0][0]] || `${errors[0][0]} : ${errors[0][1]}`
      });
    } else {
      closeQuickMessageDialog();
    }
  } catch (e) {
    notifications_showNotification({
      moduleID: 'quickMessage',
      notificationID: 'failedToSendQuickMessage',
      header: 'Sending Failed!',
      closeDelay: 15000,
      message: 'Reddit is likely under heavy load. Either wait a minute or click on "open full message form" and try again (your message will be preserved).'
    });
    throw e;
  }
}
// CONCATENATED MODULE: ./lib/modules/userHighlight.js





const userHighlight_module = new Module('userHighlight');
userHighlight_module.moduleName = 'userHighlightName';
userHighlight_module.category = 'usersCategory';
userHighlight_module.description = 'userHighlightDesc';
userHighlight_module.bodyClass = true;
userHighlight_module.options = {
  highlightSelf: {
    title: 'userHighlightHighlightSelfTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightHighlightSelfDesc'
  },
  selfColor: {
    title: 'userHighlightSelfColorTitle',
    type: 'color',
    value: '#b8860b',
    description: 'userHighlightSelfColorDesc',
    advanced: true,
    dependsOn: options => options.highlightSelf.value
  },
  selfColorHover: {
    title: 'userHighlightSelfColorHoverTitle',
    type: 'color',
    value: '#8a6508',
    description: 'userHighlightSelfColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightSelf.value
  },
  highlightOP: {
    title: 'userHighlightHighlightOPTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightOPDesc'
  },
  OPColor: {
    title: 'userHighlightOPColorTitle',
    type: 'color',
    value: '#0055df',
    description: 'userHighlightOPColorDesc',
    advanced: true,
    dependsOn: options => options.highlightOP.value
  },
  OPColorHover: {
    title: 'userHighlightOPColorHoverTitle',
    type: 'color',
    value: '#4e7eab',
    description: 'userHighlightOPColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightOP.value
  },
  highlightAdmin: {
    title: 'userHighlightHighlightAdminTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightAdminDesc'
  },
  adminColor: {
    title: 'userHighlightAdminColorTitle',
    type: 'color',
    value: '#ff0011',
    description: 'userHighlightAdminColorDesc',
    advanced: true,
    dependsOn: options => options.highlightAdmin.value
  },
  adminColorHover: {
    title: 'userHighlightAdminColorHoverTitle',
    type: 'color',
    value: '#b3000c',
    description: 'userHighlightAdminColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightAdmin.value
  },
  highlightAlum: {
    title: 'userHighlightHighlightAlumTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightAlumDesc'
  },
  alumColor: {
    title: 'userHighlightAlumColorTitle',
    type: 'color',
    value: '#be1337',
    description: 'userHighlightAlumColorDesc',
    advanced: true,
    dependsOn: options => options.highlightAlum.value
  },
  alumColorHover: {
    title: 'userHighlightAlumColorHoverTitle',
    type: 'color',
    value: '#8f0e29',
    description: 'userHighlightAlumColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightAlum.value
  },
  highlightFriend: {
    title: 'userHighlightHighlightFriendTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightFriendDesc'
  },
  friendColor: {
    title: 'userHighlightFriendColorTitle',
    type: 'color',
    value: '#ff4500',
    description: 'userHighlightFriendColorDesc',
    advanced: true,
    dependsOn: options => options.highlightFriend.value
  },
  friendColorHover: {
    title: 'userHighlightFriendColorHoverTitle',
    type: 'color',
    value: '#b33000',
    description: 'userHighlightFriendColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightFriend.value
  },
  highlightMod: {
    title: 'userHighlightHighlightModTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightHighlightModDesc'
  },
  modColor: {
    title: 'userHighlightModColorTitle',
    type: 'color',
    value: '#228822',
    description: 'userHighlightModColorDesc',
    advanced: true,
    dependsOn: options => options.highlightMod.value
  },
  modColorHover: {
    title: 'userHighlightModColorHoverTitle',
    type: 'color',
    value: '#134913',
    description: 'userHighlightModColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightMod.value
  },
  highlightOpMentions: {
    title: 'userHighlightOpMentionsTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightOpMentionsDesc'
  },
  opMentionsColor: {
    title: 'userHighlightOpMentionsColorTitle',
    type: 'color',
    value: '#6d4731',
    description: 'userHighlightOpMentionsColorDesc',
    advanced: true,
    dependsOn: options => options.highlightOpMentions.value
  },
  opMentionsHover: {
    title: 'userHighlightOpMentionsHoverTitle',
    type: 'color',
    value: '#c4946e',
    description: 'userHighlightOpMentionsHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightOpMentions.value
  },
  highlightFirstCommenter: {
    title: 'userHighlightHighlightFirstCommenterTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightHighlightFirstCommenterDesc'
  },
  dontHighlightFirstComment: {
    title: 'userHighlightDontHighlightFirstCommentTitle',
    type: 'boolean',
    value: true,
    description: 'userHighlightDontHighlightFirstCommentDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  firstCommentColor: {
    title: 'userHighlightFirstCommentColorTitle',
    type: 'color',
    value: '#46b6cc',
    description: 'userHighlightFirstCommentColorDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  firstCommentColorHover: {
    title: 'userHighlightFirstCommentColorHoverTitle',
    type: 'color',
    value: '#72d2e5',
    description: 'userHighlightFirstCommentColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightFirstCommenter.value
  },
  fontColor: {
    title: 'userHighlightFontColorTitle',
    type: 'color',
    value: '#ffffff',
    description: 'userHighlightFontColorDesc',
    advanced: true
  },
  autoColorUsernames: {
    title: 'userHighlightAutoColorUsernamesTitle',
    type: 'boolean',
    value: false,
    description: 'userHighlightAutoColorUsernamesDesc'
  },
  autoColorUsing: {
    title: 'userHighlightAutoColorUsingTitle',
    description: 'userHighlightAutoColorUsingDesc',
    type: 'enum',
    value: 'hash-userid-notbright',
    values: [{
      name: 'Random color, not too bright, consistent for each user; night mode-friendly',
      value: 'hash-userid-notbright'
    }, {
      name: 'Simple random color, consistent for each user. (original)',
      value: 'hash-userid'
    }, {
      name: 'All black or, in night mode, all light gray.',
      value: 'monochrome'
    }],
    advanced: true,
    dependsOn: options => options.autoColorUsernames.value
  },
  generateHoverColors: {
    title: 'userHighlightGenerateHoverColorsTitle',
    type: 'button',
    text: 'Generate',
    callback: generateHoverColors,
    description: 'userHighlightGenerateHoverColorsDesc',
    advanced: true
  }
};

userHighlight_module.beforeLoad = () => {
  if (userHighlight_module.options.autoColorUsernames.value) {
    Object(watchers["watchForThings"])(['post', 'comment', 'message'], updateNewUsernames, {
      immediate: true
    });
  }

  if (userHighlight_module.options.highlightFirstCommenter.value) {
    Object(watchers["watchForThings"])(['comment'], updateFirstComments, {
      immediate: true
    });
  }

  if (userHighlight_module.options.highlightFriend.value) {
    highlight('friend', userHighlight_module.options.friendColor.value, userHighlight_module.options.friendColorHover.value);
  }

  if (userHighlight_module.options.highlightOP.value) {
    highlight('submitter', userHighlight_module.options.OPColor.value, userHighlight_module.options.OPColorHover.value);
  }

  if (userHighlight_module.options.highlightMod.value) {
    highlight('moderator', userHighlight_module.options.modColor.value, userHighlight_module.options.modColorHover.value);
  }

  if (userHighlight_module.options.highlightAdmin.value) {
    highlight('admin', userHighlight_module.options.adminColor.value, userHighlight_module.options.adminColorHover.value);
  }

  if (userHighlight_module.options.highlightAlum.value) {
    highlight('alum', userHighlight_module.options.alumColor.value, userHighlight_module.options.alumColorHover.value);
  }

  if (userHighlight_module.options.highlightOpMentions.value && Object(utils_location["n" /* isPageType */])('comments')) {
    Object(watchers["watchForElements"])(['selfText'], null, selftext => {
      const thing = Thing["a" /* Thing */].from(selftext);
      const author = thing && thing.getAuthor();
      highlightMentionedUsers(selftext, userHighlight_module.options.opMentionsColor.value, userHighlight_module.options.opMentionsHover.value, author);
    }, {
      immediate: true
    });
  }
};

userHighlight_module.contentStart = () => {
  const username = loggedInUser();

  if (userHighlight_module.options.highlightSelf.value && username) {
    highlight(`author[href$="/${username}"]`, userHighlight_module.options.selfColor.value, userHighlight_module.options.selfColorHover.value);
  }
};

function highlightMentionedUsers(element, color, hoverColor, ...exclude) {
  Array.from(element.querySelectorAll('a')).map(getUsernameFromLink).filter(Boolean).filter(user => !exclude.includes(user)).forEach(user => highlight(`author[href$="/${user}" i]`, color, hoverColor));
}

function updateFirstComments(thing) {
  if (!thing.isTopLevelComment()) return;
  const idClass = Array.from(thing.element.classList).find(cls => cls.startsWith('id-t1_'));
  if (!idClass) return;
  const author = thing.getAuthorElement();
  if (!author) return;
  const authorClass = Array.from(author.classList).find(cls => cls.startsWith('id-t2_'));

  if (authorClass) {
    const container = `.${idClass}${userHighlight_module.options.dontHighlightFirstComment.value ? ' .child' : ''}`;
    highlight(authorClass, userHighlight_module.options.firstCommentColor.value, userHighlight_module.options.firstCommentColorHover.value, container);
  }
}

function updateNewUsernames(thing) {
  const element = thing.getAuthorElement();
  if (!element) return;
  const idClass = Array.from(element.classList).find(cls => cls.startsWith('id-t2_'));
  if (!idClass) return;
  const colorGetter = autoColorUsing[userHighlight_module.options.autoColorUsing.value];
  const color = colorGetter(idClass);
  doTextColor(idClass, color);
}

const autoColorUsing = {
  'hash-userid-notbright'(idClass) {
    const hash = hashCode(idClass);
    const r = (hash & 0xFF0000) >> 16;
    const g = (hash & 0x00FF00) >> 8;
    const b = hash & 0x0000FF;
    const lum = Math.round(r * 0.299 + g * 0.587 + b * 0.114);
    const minLum = 0x66;
    const maxLum = 0xAA;
    let color = [r, g, b];
    let nightmodeColor = [r, g, b];

    if (lum < minLum) {
      const scale = minLum / lum;
      nightmodeColor = [Math.round(r * scale), Math.round(g * scale), Math.round(b * scale)];
    } else if (lum > maxLum) {
      const scale = maxLum / lum;
      color = [Math.round(r * scale), Math.round(g * scale), Math.round(b * scale)];
    }

    color = `rgb(${color.join(',')})`;
    nightmodeColor = `rgb(${nightmodeColor.join(',')})`;
    return {
      color,
      nightmodeColor
    };
  },

  'hash-userid'(idClass) {
    let hash = 5381;

    for (const char of idClass) {
      hash = (hash << 5) + hash + char.charCodeAt(0);
    }

    const r = (hash & 0xFF0000) >> 16;
    const g = (hash & 0x00FF00) >> 8;
    const b = hash & 0x0000FF;
    const color = `rgb(${[r, g, b].join(',')})`;
    return {
      color
    };
  },

  monochrome() {
    return {
      color: 'black',
      nightmodeColor: '#ccc'
    };
  }

};
function highlightUser(userid) {
  return highlight(`author.id-t2_${userid}`, userInfo_module.options.highlightColor.value, userInfo_module.options.highlightColorHover.value);
}
const userHighlight_css = [];
const throttled = Object(utils_async["i" /* throttle */])(() => {
  Object(dom["b" /* addCSS */])(userHighlight_css.splice(0, userHighlight_css.length).join('\n'));
});

const batch = v => {
  userHighlight_css.push(v);
  throttled();
};

function highlight(selector, color, hoverColor, container = '') {
  batch(`
${container} .tagline .author.${selector},
${container} .crosspost-preview-tagline .author.${selector} {
	color: ${userHighlight_module.options.fontColor.value} !important;
	font-weight: bold;
	padding: 0 2px 0 2px;
	border-radius: 3px;
	background-color: ${color} !important;
}
${container} .collapsed .tagline .author.${selector},
${container} .collapsed .crosspost-preview-tagline .author.${selector} {
	color: white !important;
	background-color: #AAA !important;
}
${container} .tagline .author.${selector}:hover,
${container} .crosspost-preview-tagline .author.${selector}:hover {
	background-color: ${hoverColor} !important;
	text-decoration: none !important;
}
	`);
}

function doTextColor(selector, colorData) {
  const color = colorData.color;
  const nightmodeColor = colorData.nightmodeColor || colorData.color;
  batch(`
.tagline .author.${selector} {
	color: ${color} !important;
}
.res-nightmode .tagline .author.${selector} {
	color: ${nightmodeColor} !important;
}
	`);
}

function generateHoverColor(color) {
  if (!/^#[0-9A-F]{6}$/i.test(color)) throw new Error('Input color must be a six digit hex value');
  let R = parseInt(color.substr(1, 2), 16);
  let G = parseInt(color.substr(3, 2), 16);
  let B = parseInt(color.substr(5, 2), 16);
  R = Math.round(0.75 * R) + 256;
  G = Math.round(0.75 * G) + 256;
  B = Math.round(0.75 * B) + 256;
  return `#${R.toString(16).substr(1)}${G.toString(16).substr(1)}${B.toString(16).substr(1)}`;
}

function generateHoverColors() {
  try {
    for (const option of ['selfColor', 'OPColor', 'adminColor', 'friendColor', 'modColor', 'firstCommentColor', 'alumColor']) {
      const current = (stage_namespaceObject.get(userHighlight_module.moduleID) || userHighlight_module.options)[option].value;
      options_storage_set(userHighlight_module.moduleID, option, generateHoverColor(current));
    }

    alert_namespaceObject.open('Saved, but not yet updated in settings console. Reload page without saving to see new values.');
  } catch (e) {
    alert_namespaceObject.open(i18n('userHighlightColorCouldNotBeGenerated'));
  }
}
// CONCATENATED MODULE: ./lib/modules/userInfo.js










const userInfo_module = new Module('userInfo');
userInfo_module.moduleName = 'userInfoName';
userInfo_module.category = 'usersCategory';
userInfo_module.description = 'userInfoDesc';
userInfo_module.options = {
  hoverInfo: {
    title: 'userInfoHoverInfoTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoHoverInfoDesc'
  },
  useQuickMessage: {
    title: 'userInfoUseQuickMessageTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoUseQuickMessageDesc',
    dependsOn: options => options.hoverInfo.value
  },
  hoverDelay: {
    title: 'userInfoHoverDelayTitle',
    type: 'text',
    value: '800',
    description: 'userInfoHoverDelayDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  fadeDelay: {
    title: 'userInfoFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'userInfoFadeDelayDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  fadeSpeed: {
    title: 'userInfoFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'userInfoFadeSpeedDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  gildComments: {
    title: 'userInfoGildCommentsTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoGildCommentsDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  highlightButton: {
    title: 'userInfoHighlightButtonTitle',
    type: 'boolean',
    value: true,
    description: 'userInfoHighlightButtonDesc',
    advanced: true,
    dependsOn: options => options.hoverInfo.value
  },
  highlightColor: {
    title: 'userInfoHighlightColorTitle',
    type: 'color',
    value: '#5544cc',
    description: 'userInfoHighlightColorDesc',
    advanced: true,
    dependsOn: options => options.highlightButton.value
  },
  highlightColorHover: {
    title: 'userInfoHighlightColorHoverTitle',
    type: 'color',
    value: '#6677aa',
    description: 'userInfoHighlightColorHoverDesc',
    advanced: true,
    dependsOn: options => options.highlightButton.value
  }
};
const highlightedUsers = {};

userInfo_module.contentStart = () => {
  if (userInfo_module.options.hoverInfo.value) {
    infocard(userInfo_module.moduleID).options({
      width: 475,
      openDelay: parseFloat(userInfo_module.options.hoverDelay.value),
      fadeDelay: parseFloat(userInfo_module.options.fadeDelay.value),
      fadeSpeed: parseFloat(userInfo_module.options.fadeSpeed.value)
    }).populateWith(showUserInfo).watch(usernameSelector);
  }
};

async function showUserInfo(card) {
  const username = getUsernameFromLink(card.getCheckedTarget());

  if (!username) {
    console.error(i18n('userInfoInvalidUsernameLink'));
    return;
  }

  const thing = Thing["a" /* Thing */].from(card.getCheckedTarget());
  let data;

  try {
    ({
      data
    } = await getUserInfo(username));
  } catch (e) {
    return [null, i18n('userInfoUserNotFound')];
  }

  if (data.is_suspended) {
    return [null, i18n('userInfoUserSuspended')];
  }

  const d = new Date(data.created_utc * 1000);
  const header = string_namespaceObject.html`
		<div>
			<a href="/user/${data.name}">/u/${data.name}</a>
		 	(<a href="/user/${data.name}/submitted/">${i18n('userInfoLinks')}</a>)
		 	(<a href="/user/${data.name}/comments/">${i18n('userInfoComments')}</a>)
		</div>
	`;

  if (loggedInUser()) {
    const button = createElement_namespaceObject.fancyToggleButton(i18n('userInfoAddRemoveFriends'), '', () => data.is_friend, async state => {
      ajax({
        method: 'POST',
        url: `/api/${state ? 'friend' : 'unfriend'}`,
        data: {
          type: 'friend',
          name: data.name,
          container: `t2_${(await getUserInfo()).data.id}`
        }
      });
      ajax.invalidate({
        url: `/user/${data.name}/about.json`
      });
    });
    button.style.marginLeft = '12px';
    header.appendChild(button);
  }

  card.populate([header]);
  const $body = jquery_default()('<div id="authorInfoToolTip" />');
  let userHTML = string_namespaceObject.escape`
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoRedditorSince')}</div> <div class="fieldPair-text">${formatDate(d)} (${formatDateDiff(d)})</div></div>
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoPostKarma')}</div> <div class="fieldPair-text">${formatNumber(data.link_karma)}</div></div>
		<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoCommentKarma')}</div> <div class="fieldPair-text">${formatNumber(data.comment_karma)}</div></div>
	`;
  const userTaggerEnabled = isRunning(userTagger_namespaceObject);
  const userTag = userTaggerEnabled && (await userTagger_Tag.get(data.name));

  if (userTaggerEnabled) {
    userHTML += `<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoUserTag')}</div> <div class="fieldPair-text" style="display:flex"><a class="author" style="display: none;" href="/u/${data.name}"/></div></div>`;
  }

  if (userTag && userTag.link) {
    const links = userTag.link.split(/\s/).reduce((acc, url) => acc + string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" href="${url}">${url.replace(/^https?:\/\/(www\.)?/, '')}</a>`, '');
    userHTML += `<div class="fieldPair"><div class="fieldPair-label">${i18n('userInfoLink')}</div> <div class="fieldPair-text">${links}</div></div>`;
  }

  userHTML += string_namespaceObject.escape`
		<div class="clear"></div>
		<div class="bottomButtons">
			<a target="_blank" rel="noopener noreferer" class="blueButton composeButton" href="/message/compose/?to=${data.name}"><img src="https://redditstatic.s3.amazonaws.com/mailgray.png"> ${i18n('userInfoSendMessage')}</a>
	`;

  if (data.is_gold) {
    userHTML += string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" class="blueButton" href="/gold/about">${i18n('userInfoUserHasRedditGold')}</a>`;
  } else {
    userHTML += string_namespaceObject.escape`<a target="_blank" rel="noopener noreferer" id="gildUser" class="blueButton" href="/gold?goldtype=gift&recipient=${data.name}">${i18n('userInfoGiftRedditGold')}</a>`;
  }

  if (userInfo_module.options.highlightButton.value) {
    const isHighlight = !highlightedUsers[data.id];
    userHTML += string_namespaceObject.escape`<div class="${isHighlight ? 'blueButton' : 'redButton'}" id="highlightUser" data-userid="${data.id}">${isHighlight ? i18n('userInfoHighlight') : i18n('userInfoUnhighlight')}</div>`;
  }

  if (userTag) {
    const getButton = () => string_namespaceObject.html`<div class="${userTag.ignored ? 'redButton' : 'blueButton'}" id="ignoreUser">&empty; ${userTag.ignored ? i18n('userInfoUnignore') : i18n('userInfoIgnore')}</div>`;

    $body.on('click', '#ignoreUser', e => {
      if (e.currentTarget.classList.contains('blueButton')) userTag.ignore();else userTag.unignore();
      e.currentTarget.replaceWith(getButton());
    });
    userHTML += getButton().outerHTML;
  }

  userHTML += '<div class="clear"></div></div>';
  $body.append(userHTML);

  if (userTag) {
    userTag.add(Object(flow["a" /* downcast */])($body.find('.author').get(0), HTMLAnchorElement), {
      renderTaggingIcon: true
    });
  }

  if (userInfo_module.options.highlightButton.value) {
    $body.find('#highlightUser').on('click', ({
      currentTarget
    }) => {
      const userid = currentTarget.getAttribute('data-userid');
      toggleUserHighlight(currentTarget, userid, thing);
    });
  }

  if (userInfo_module.options.gildComments.value && thing && thing.isComment()) {
    $body.find('#gildUser').on('click', e => {
      if (!thing || e.ctrlKey || e.metaKey || e.shiftKey) return;
      card.close();
      const giveGold = thing.entry.querySelector('.give-gold');
      Object(dom["c" /* click */])(giveGold);
      e.preventDefault();
    });
  }

  if (userInfo_module.options.useQuickMessage.value && isRunning(quickMessage_namespaceObject)) {
    $body.find('a.composeButton').on('click', e => {
      if (e.which === 1) {
        e.preventDefault();
        let entryUrl;

        if (quickMessage_module.options.linkToCurrentPage.value && thing) {
          const permalink = thing.getCommentPermalink();

          if (permalink) {
            entryUrl = permalink.href;
            if (!entryUrl.includes('?context=')) entryUrl += '?context=10';
          }
        }

        openQuickMessageDialog({
          to: data.name,
          body: entryUrl
        });
        card.close();
      }
    });
  }

  return [null, $body];
}

function toggleUserHighlight(authorInfoToolTipHighlight, userid, thing) {
  if (highlightedUsers[userid]) {
    highlightedUsers[userid].remove();
    delete highlightedUsers[userid];
    toggleUserHighlightButton(authorInfoToolTipHighlight, true);
  } else {
    highlightedUsers[userid] = highlightUser(userid);
    toggleUserHighlightButton(authorInfoToolTipHighlight, false);
  }

  if (isRunning(commentNavigator_namespaceObject) && commentNavigator_module.options.openOnHighlightUser.value) {
    setCategory('highlighted', true);
    if (thing) updateFromSelected(thing);
    commentNavigator_toggle(false, true);
  }
}

function toggleUserHighlightButton(authorInfoToolTipHighlight, canHighlight) {
  jquery_default()(authorInfoToolTipHighlight).toggleClass('blueButton', canHighlight).toggleClass('redButton', !canHighlight).text(canHighlight ? i18n('userInfoHighlight') : i18n('userInfoUnhighlight'));
}
// CONCATENATED MODULE: ./lib/modules/wheelBrowse.js




const wheelBrowse_module = new Module('wheelBrowse');
wheelBrowse_module.moduleName = 'wheelBrowseName';
wheelBrowse_module.category = 'browsingCategory';
wheelBrowse_module.description = 'wheelBrowseDesc';
let behavior;

wheelBrowse_module.contentStart = () => {
  if (!behavior && Object(utils_location["n" /* isPageType */])('linklist')) useLinklistBehavior();
  if (!behavior) return;
  const wheelBrowseWidget = string_namespaceObject.html`<div hidden class="res-wheel-browse"></div>`;
  const onWheel = behavior(wheelBrowseWidget);
  selectedThing_namespaceObject.addListener(current => {
    wheelBrowseWidget.hidden = !current;
  }, 'instantly');
  wheelBrowseWidget.addEventListener('wheel', e => {
    e.stopImmediatePropagation();
    e.preventDefault();
    onWheel(e.deltaY > 0 ? 'down' : 'up', e);
  });
  addFloater(wheelBrowseWidget, {
    order: -1
  });
};

function setCallback(v) {
  behavior = v;
}

function useLinklistBehavior() {
  const galleryPart = string_namespaceObject.html`<div hidden class="res-wheel-browse-gallery"></div>`;
  let media;

  function updateGalleryPart(direction) {
    const expando = expando_Expando.getEntryExpandoFrom(selectedThing_namespaceObject.current);
    media = expando && expando.media;
    galleryPart.hidden = !(media && media.element.classList.contains('res-gallery-slideshow') && !(direction === 'down' && media.element.querySelector('[last-piece=true]')) && !(direction === 'up' && media.element.querySelector('[first-piece=true]')));
  }

  setCallback(wheelBrowseWidget => {
    wheelBrowseWidget.addEventListener('click', () => settingsNavigation_open(wheelBrowse_module.moduleID));
    wheelBrowseWidget.addEventListener('mouseenter', () => {
      updateGalleryPart();
    });
    wheelBrowseWidget.append(galleryPart);
    return (direction, {
      target
    }) => {
      if (target === wheelBrowseWidget) {
        selectedThing_namespaceObject.move(direction, {
          allowMediaBrowse: true,
          scrollStyle: 'top'
        });
      } else if (target === galleryPart) {
        const clicker = media && media.element.querySelector(direction === 'down' ? '.res-gallery-next' : '.res-gallery-previous');
        if (clicker) clicker.click();
        updateGalleryPart(direction);
      }
    };
  });
}
// CONCATENATED MODULE: ./lib/modules/commentNavigator.js








const commentNavigator_module = new Module('commentNavigator');
commentNavigator_module.moduleName = 'commentNavName';
commentNavigator_module.category = 'commentsCategory';
commentNavigator_module.description = 'commentNavDesc';
commentNavigator_module.options = {
  showByDefault: {
    type: 'boolean',
    value: false,
    description: 'commentNavigatorShowByDefaultDesc',
    title: 'commentNavigatorShowByDefaultTitle'
  },
  showOnKeyboardMove: {
    type: 'boolean',
    value: false,
    description: 'commentNavigatorShowOnKeyboardMoveDesc',
    title: 'commentNavigatorShowOnKeyboardMoveTitle'
  },
  skipReadComments: {
    type: 'boolean',
    value: false,
    description: 'commentNavigatorSkipReadCommentsDesc',
    title: 'commentNavigatorSkipReadCommentsTitle'
  },
  openOnHighlightUser: {
    type: 'boolean',
    value: true,
    description: 'commentNavigatorOpenOnHighlightUserDesc',
    title: 'commentNavigatorOpenOnHighlightUserTitle',
    advanced: true
  },
  popularConditions: {
    type: 'text',
    value: JSON.stringify({
      type: 'commentLength',
      op: '>',
      kind: 'words',
      val: 0
    }),
    description: 'commentNavigatorPopularConditionsDesc',
    title: 'commentNavigatorPopularConditionsTitle',
    advanced: true
  }
};
commentNavigator_module.include = ['comments'];

commentNavigator_module.contentStart = () => {
  skipReadComments = commentNavigator_module.options.skipReadComments.value;
  selectedThing_namespaceObject.addListener(selected => {
    readComments.add(selected);
  }, 'instantly');
  installEntryElement();

  if (commentNavigator_module.options.showByDefault.value) {
    commentNav();
  }

  setCallback(wheelBrowseWidget => {
    wheelBrowseWidget.addEventListener('click', () => {
      commentNavigator_toggle();
    });
    return direction => {
      if (direction === 'up') commentNavigator_move('up');else commentNavigator_move('down');
    };
  });

  const getMatchingCategory = async val => val && (await getCategories()).find(({
    category
  }) => category.startsWith(val));

  registerCommand('nav', 'nav [sortType] - open the comment navigator', async (command, val) => {
    const {
      category: matchingCategory = ''
    } = (await getMatchingCategory(val)) || {};
    return `navigate comments by [(${(await getCategories()).map(({
      category
    }) => matchingCategory === category ? `<b>${category}</b>` : category).join('|')})]`;
  }, async (command, val) => {
    const {
      category: matchingCategory = ''
    } = (await getMatchingCategory(val)) || {};
    if (matchingCategory) setCategory(matchingCategory);
    commentNavigator_toggle(false, true);
  });
};

const commentNavigator_initialize = Object(once["a" /* default */])(source => {
  Object(watchers["watchForThings"])(['comment'], () => {
    getPosts.cache.clear();
  });
  selectedThing_namespaceObject.addListener(updateFromSelected, 'instantly');
  if (selectedThing_namespaceObject.current) updateFromSelected(selectedThing_namespaceObject.current);
  if (source === 'keyboard' && !commentNavigator_module.options.showOnKeyboardMove.value) commentNav().close();
});
const commentNavigator_sortTypes = {
  custom: {
    title: 'Navigate custom category',
    conditions: {
      type: 'false'
    }
  },
  comment: {
    title: 'Navigate comments',
    conditions: {
      type: 'true'
    }
  },
  submitter: {
    title: 'Navigate comments made by the post submitter',
    conditions: {
      type: 'userAttr',
      attr: 'submitter'
    }
  },
  moderator: {
    title: 'Navigate comments made by moderators',
    conditions: {
      type: 'userAttr',
      attr: 'moderator'
    }
  },
  friend: {
    title: 'Navigate comments made by users on your friends list',
    conditions: {
      type: 'userAttr',
      attr: 'friend'
    }
  },
  me: {
    title: 'Navigate comments made by you',
    conditions: {
      type: 'userAttr',
      attr: 'me'
    }
  },
  admin: {
    title: 'Navigate comments made by reddit admins',
    conditions: {
      type: 'userAttr',
      attr: 'admin'
    }
  },
  highlighted: {
    title: 'Navigate comments made by highlighted user',

    getElements() {
      const highlightedUserSelector = Object.keys(highlightedUsers).map(key => `.author.id-t2_${key}`).join(', ');
      return highlightedUserSelector ? document.querySelectorAll(highlightedUserSelector) : [];
    }

  },
  tagged: {
    title: 'Navigate comments made by tagged users',
    getElements: () => document.querySelectorAll('.tagline .userTagLink.hasTag')
  },
  gilded: {
    title: 'Navigate through gilded comments',
    getElements: () => document.querySelectorAll('.gilded-icon')
  },
  IAmA: {
    title: 'Navigate through questions that have been answered by the submitter (most useful in /r/IAmA)',
    getThings: async () => Object(utils_array["c" /* filterMap */])(await getPosts('submitter'), thing => thing.parent ? [thing.parent] : undefined)
  },
  images: {
    title: 'Navigate through comments with images',
    conditions: {
      type: 'hasExpando',
      types: ['image']
    }
  },
  videos: {
    title: 'Navigate through comments with videos',
    conditions: {
      type: 'hasExpando',
      types: ['video']
    }
  },
  popular: {
    title: 'Navigate through comments in order of highest vote total',

    async getThings() {
      return Object(utils_array["c" /* filterMap */])(await getPosts('comment'), thing => {
        const score = thing.getScore();

        if (typeof score === 'number') {
          return [[score, thing]];
        }
      }).sort((a, b) => b[0] - a[0]).map(([, thing]) => thing);
    },

    get conditions() {
      return JSON.parse(commentNavigator_module.options.popularConditions.value);
    },

    nonlinear: true
  },
  new: {
    title: 'Navigate through new comments (Reddit Gold users only)',
    getElements: () => document.querySelectorAll('.new-comment'),
    disabled: () => !document.body.querySelector('.gold-accent.comment-visits-box')
  },
  upvoted: {
    title: 'Navigate through comments you upvoted',
    conditions: {
      type: 'voteType',
      kind: 'upvote'
    }
  }
};
function updateCustomConditions(conditions) {
  commentNavigator_sortTypes.custom.conditions = conditions;
}

function getCategories() {
  return Promise.all(Object.entries(commentNavigator_sortTypes).filter(([, {
    disabled
  }]) => !disabled || !disabled()).map(async ([category, {
    title
  }]) => ({
    category,
    selected: category === currentCategory,
    size: (await getVisiblePosts(category)).length,
    title
  }))).then(v => v.filter(({
    size,
    selected
  }) => selected || size));
}

const getPosts = Object(memoize["a" /* default */])(async category => {
  const {
    getElements,
    getThings,
    conditions
  } = commentNavigator_sortTypes[category];
  let things;

  if (getThings) {
    things = [...new Set(await getThings())];
  } else if (getElements) {
    things = [...new Set(Array.from(getElements()).map(e => Thing["a" /* Thing */].from(e)).filter(Boolean))];
  } else {
    things = Thing["a" /* Thing */].things().filter(thing => thing.isComment());
  }

  return filterThings(things, conditions);
});

const getVisiblePosts = (category = currentCategory) => getPosts(category).then(v => v.filter(thing => (!skipReadComments || !readComments.has(thing)) && thing.isContentVisible()));

let lastNavigatedTo = null;
const readComments = new Set();
let skipReadComments;
let currentCategory = Object(utils_location["l" /* isCurrentSubreddit */])('IAmA', 'casualiama') ? 'IAmA' : 'popular';
let isOpen = false;
const commentNav = Object(once["a" /* default */])(() => {
  const box = string_namespaceObject.html`
		<div id="REScommentNavBox">
			<select id="commentNavBy">
				<option selected value="${currentCategory}">${currentCategory}</option>
			</select>
			<label style="margin-top: 2px; display: flex; align-items: center;"><input id="commentNavSkipReadComments" style="margin-right: 3px;" type="checkbox" ${skipReadComments && 'checked'}>Skip read</label>
			<details id="commentNavByConditions" hidden>
				<summary>Conditions</summary>
		<div class="builderItem"></div>
			</details>
			<hr style="margin-bottom: 0">
			<div id="commentNavButtons">
				<button id="commentNavUp">&#x25B2;</button>
				<div id="commentNavPostCount"></div>
				<button id="commentNavDown">&#x25BC;</button>
			</div>
		</div>
	`;
  const skipReadCommentsEle = Object(flow["a" /* downcast */])(box.querySelector('#commentNavSkipReadComments'), HTMLInputElement);
  skipReadCommentsEle.addEventListener('change', () => {
    skipReadComments = skipReadCommentsEle.checked;
    if (selectedThing_namespaceObject.current) updateFromSelected(selectedThing_namespaceObject.current);
  });
  const select = Object(flow["a" /* downcast */])(box.querySelector('#commentNavBy'), HTMLSelectElement);
  select.addEventListener('focus', async () => {
    Object(dom["e" /* empty */])(select);
    const categories = await getCategories();
    select.append(...categories.map(({
      category,
      selected,
      size
    }) => string_namespaceObject.html`
				<option ${selected && 'selected'} value="${category}">${category}<span> (${size})</span></option>
			`));
  }, true);
  select.addEventListener('keyup', ({
    which
  }) => {
    if (which === 27) select.blur();
  });
  select.addEventListener('change', () => {
    const selectedItem = select.options.item(select.selectedIndex);

    if (selectedItem !== null) {
      setCategory(selectedItem.value);
    }

    updateBuilder();
  });
  const postCount = box.querySelector('#commentNavPostCount');
  postCount.addEventListener('click', () => moveTo(lastNavigatedTo));
  const up = Object(flow["a" /* downcast */])(box.querySelector('#commentNavUp'), HTMLButtonElement);
  up.addEventListener('click', () => commentNavigator_move('up'));
  const down = Object(flow["a" /* downcast */])(box.querySelector('#commentNavDown'), HTMLButtonElement);
  down.addEventListener('click', () => commentNavigator_move('down'));
  addFloater(box, {
    separate: true
  });
  const ele = box.querySelector('#commentNavByConditions');
  ele.addEventListener('click', Object(once["a" /* default */])(() => {
    const builderCases = getByContext('comment');
    const group = resolveGroup(getGroup('any', [commentNavigator_sortTypes[currentCategory].conditions]), true, true);
    const $builderBlock = caseBuilder_namespaceObject.drawBuilderBlock(group, builderCases, false);
    $builderBlock.on('change input', Object(utils_async["e" /* frameThrottle */])(() => {
      commentNavigator_module.options.popularConditions.value = JSON.stringify(caseBuilder_namespaceObject.readBuilderBlock($builderBlock, builderCases));
      options_save(commentNavigator_module.options.popularConditions);
      setCategory(currentCategory, true);
    }));
    const wrapper = ele.querySelector('.builderItem');
    wrapper.append($builderBlock.get(0));
  }));

  const updateBuilder = () => {
    ele.hidden = currentCategory !== 'popular';
  };

  commentNavigator_initialize();
  updateBuilder();
  isOpen = true;
  return {
    select,
    refresh: function (index, length, lastNavigatedToIndex) {
      up.disabled = lastNavigatedToIndex <= 0;
      down.disabled = lastNavigatedToIndex >= length - 1;
      postCount.textContent = length ? `${lastNavigatedToIndex === index ? '' : '~'}${lastNavigatedToIndex + 1}/${length}` : 'none';
    },
    open: function () {
      isOpen = true;
      box.hidden = false;
    },
    close: function () {
      isOpen = false;
      box.hidden = true;
    }
  };
});

async function installEntryElement() {
  await new Promise(requestAnimationFrame);
  const location = await Object(dom["o" /* waitForDescendant */])(document.body, '.commentarea .panestack-title, .menuarea');
  const commentNavToggle = string_namespaceObject.html`<div class="res-commentNavToggle">navigate by</div>`;
  const choices = string_namespaceObject.html`<div class="res-commentNavToggle-choices"><div>`;
  commentNavToggle.append(choices);
  location.append(commentNavToggle);
  commentNavToggle.addEventListener('mouseenter', async () => {
    Object(dom["e" /* empty */])(choices);
    const categories = await getCategories();
    choices.append(...categories.map(({
      category,
      title,
      size
    }) => {
      const element = string_namespaceObject.html`
				<div class="res-commentNavToggle-type" title="${title}" category="${category}">${category} (${size})</div>
			`;
      element.addEventListener('click', () => {
        setCategory(category);
      });
      return element;
    }));
  });
}

async function updateFromSelected(selected) {
  const posts = await getVisiblePosts();

  if (posts.includes(selected) && (!commentNavigator_sortTypes[currentCategory].nonlinear || Math.abs(posts.indexOf(lastNavigatedTo) - posts.indexOf(selected)) <= 1)) {
    lastNavigatedTo = selected;
  }

  commentNav().refresh(posts.indexOf(selected), posts.length, posts.indexOf(lastNavigatedTo));
}
function setCategory(category, keepSelected = false) {
  currentCategory = category;
  lastNavigatedTo = null;
  commentNav().select.value = category;
  getPosts.cache.delete(currentCategory);

  if (keepSelected) {
    commentNavigator_move('refresh');
  } else {
    commentNavigator_move('top');
  }
}
function commentNavigator_toggle(focus = false, open = !isOpen) {
  if (!open) {
    commentNav().close();
  } else {
    commentNav().open();
    if (focus) commentNav().select.focus();
  }
}
async function commentNavigator_move(change, source) {
  commentNavigator_initialize(source);

  if (!commentNavigator_sortTypes[currentCategory].nonlinear) {
    const all = Thing["a" /* Thing */].things();
    const lastNavigatedToIndex = all.indexOf(lastNavigatedTo);
    const selectedIndex = all.indexOf(selectedThing_namespaceObject.current);

    if (change === 'down' && selectedIndex < lastNavigatedToIndex || change === 'up' && selectedIndex > lastNavigatedToIndex) {
      moveTo(lastNavigatedTo);
      return;
    }
  }

  const visible = await getVisiblePosts();

  if (change === 'top') {
    moveTo(visible[0]);
  } else {
    const all = [...(await getPosts(currentCategory))];
    if (change === 'up') all.reverse();
    const comment = all.slice(all.indexOf(lastNavigatedTo) + (change === 'refresh' ? 0 : 1)).find(v => visible.includes(v));
    moveTo(comment);
  }
}

function moveTo(thing) {
  if (!thing) return;
  lastNavigatedTo = thing;
  selectedThing_namespaceObject.set(thing, {
    scrollStyle: 'top'
  }, true);
}
// CONCATENATED MODULE: ./lib/modules/easterEgg.js



const easterEgg_module = new Module('easterEgg');
easterEgg_module.moduleName = 'easterEggName';
easterEgg_module.category = 'coreCategory';
easterEgg_module.description = 'easterEggDesc';
easterEgg_module.hidden = true;
let konami;

easterEgg_module.contentStart = () => {
  konami = createKonami(() => {
    const $baconBit = jquery_default()('<div>', {
      id: 'baconBit'
    }).appendTo(document.body);
    notifications_showNotification({
      header: 'RES Easter Eggies!',
      message: 'Mmm, bacon!',
      moduleID: easterEgg_module.moduleID,
      notificationID: 'konami'
    });
    setTimeout(() => $baconBit.addClass('makeitrain'), 500);
  });
};

function konamiActive() {
  return !!konami && konami.almostThere;
}

function createKonami(callback) {
  const konami = {
    input: '',
    pattern: '38384040373937396665',
    almostThere: false,
    prepattern: '383840403739373966',
    load: () => {
      document.addEventListener('keydown', event => {
        konami.input += event.keyCode;

        if (konami.input.length > konami.pattern.length) {
          konami.input = konami.input.substr(konami.input.length - konami.pattern.length);
        }

        if (konami.input === konami.pattern) {
          konami.code();
          konami.input = '';
          event.preventDefault();
        } else if (konami.input === konami.prepattern || konami.input.substr(2, konami.input.length) === konami.prepattern) {
          konami.almostThere = true;
          setTimeout(() => {
            konami.almostThere = false;
            konami.input = '';
          }, 2000);
        }
      }, false);
    },
    code: () => {}
  };

  if (typeof callback === 'function') {
    konami.code = callback;
    konami.load();
  }

  return konami;
}
// CONCATENATED MODULE: ./lib/modules/hideChildComments.js




const hideChildComments_module = new Module('hideChildComments');
hideChildComments_module.moduleName = 'hideChildCommentsName';
hideChildComments_module.category = 'commentsCategory';
hideChildComments_module.description = 'hideChildCommentsDesc';
hideChildComments_module.options = {
  automatic: {
    type: 'boolean',
    value: false,
    description: 'hideChildCommentsAutomaticDesc',
    title: 'hideChildCommentsAutomaticTitle'
  },
  nested: {
    type: 'boolean',
    value: true,
    description: 'hideChildCommentsNestedDesc',
    title: 'hideChildCommentsNestedTitle'
  },
  hideNested: {
    dependsOn: options => options.nested.value,
    type: 'boolean',
    value: false,
    description: 'hideChildCommentsHideNestedDesc',
    title: 'hideChildCommentsHideNestedTitle'
  }
};
hideChildComments_module.include = ['comments'];
let initialHide, toggleAllButton;

hideChildComments_module.beforeLoad = () => {
  initialHide = hideChildComments_module.options.automatic.value && !/\/comments\/(?:\w+)\/(?:\w+)\/(\w+)/.test(location.pathname);
  Object(watchers["watchForThings"])(['comment'], addToggleChildrenButton);
  Object(watchers["watchForThings"])(['post'], addToggleAllButton);
};

const addToggleAllButton = Object(once["a" /* default */])(thing => {
  const menu = thing.getButtons();
  if (!menu) return;

  function toggle(action) {
    const includeChildren = hideChildComments_module.options.nested.value && hideChildComments_module.options.hideNested.value;
    const selector = includeChildren ? '.thing.comment' : '.nestedlisting > .thing.comment';
    Object(utils_async["c" /* forEachChunked */])(document.querySelectorAll(`${selector} > .entry .toggleChildren[action=${action}]`), toggle => {
      toggle.click();
    });

    if (action === 'hide') {
      initialHide = true;
      a.setAttribute('action', 'show');
      a.setAttribute('title', 'Show all comments.');
      a.dataset.text = i18n('hideChildCommentsShowAllLinkLabel');
    } else {
      initialHide = false;
      a.setAttribute('action', 'hide');
      a.setAttribute('title', 'Show only replies to original poster.');
      a.dataset.text = i18n('hideChildCommentsHideAllLinkLabel');
    }
  }

  const li = document.createElement('li');
  const a = document.createElement('a');
  a.setAttribute('href', '#');
  a.setAttribute('class', 'noCtrlF res-toggleAllChildren');
  a.addEventListener('click', e => {
    e.preventDefault();
    toggle(a.getAttribute('action'));
  });
  toggleAllButton = a;
  toggle(initialHide ? 'hide' : 'show');
  li.appendChild(a);
  menu.appendChild(li);
});

function addToggleChildrenButton(comment) {
  if (!hideChildComments_module.options.nested.value && !comment.isTopLevelComment()) return;
  if (!comment.getNumberOfChildren()) return;
  const children = comment.element.querySelector('div.child > .sitetable');
  const menu = comment.getButtons();
  if (!children || !menu) return;

  function toggle(action) {
    if (action === 'hide') {
      children.style.display = 'none';
      a.dataset.text = i18n('hideChildCommentsShowLinkLabel', comment.getNumberOfChildren());
      a.setAttribute('action', 'show');
    } else {
      children.style.display = '';
      a.dataset.text = i18n('hideChildCommentsHideLinkLabel');
      a.setAttribute('action', 'hide');
    }

    comment.element.classList.toggle('res-children-hidden', action === 'hide');
  }

  const li = document.createElement('li');
  const a = document.createElement('a');
  a.setAttribute('href', '#');
  a.setAttribute('class', 'toggleChildren noCtrlF');
  a.addEventListener('click', e => {
    e.preventDefault();
    toggle(a.getAttribute('action'));
  });
  const hide = initialHide && (hideChildComments_module.options.hideNested.value || comment.isTopLevelComment());
  toggle(hide ? 'hide' : 'show');
  li.appendChild(a);
  menu.appendChild(li);
}

function toggleAll() {
  const button = toggleAllButton;
  if (!button) throw new Error('Toggle all button not found');
  button.click();
}
function hideChildComments_toggle(thing) {
  const button = thing.entry.querySelector('a.toggleChildren');
  if (!button) throw new Error('Toggle button not found');
  button.click();
}
// CONCATENATED MODULE: ./lib/modules/neverEndingReddit.js







const neverEndingReddit_module = new Module('neverEndingReddit');
neverEndingReddit_module.moduleName = 'nerName';
neverEndingReddit_module.category = 'browsingCategory';
neverEndingReddit_module.description = 'nerDesc';
neverEndingReddit_module.options = {
  returnToPrevPage: {
    type: 'boolean',
    value: true,
    description: 'nerReturnToPrevPageDesc',
    title: 'nerReturnToPrevPageTitle'
  },
  autoLoad: {
    type: 'boolean',
    value: true,
    description: 'nerAutoLoadDesc',
    title: 'nerAutoLoadTitle'
  },
  pauseAfterEvery: {
    dependsOn: options => options.autoLoad.value,
    type: 'text',
    value: '0',
    description: 'nerPauseAfterEveryDesc',
    title: 'nerPauseAfterEveryTitle'
  },
  showPauseButton: {
    dependsOn: options => options.autoLoad.value,
    type: 'boolean',
    value: true,
    description: 'nerShowPauseButtonDesc',
    title: 'nerShowPauseButtonTitle'
  },
  reversePauseIcon: {
    dependsOn: options => options.autoLoad.value && options.showPauseButton.value,
    type: 'boolean',
    value: false,
    description: 'nerReversePauseIconDesc',
    title: 'nerReversePauseIconTitle',
    advanced: true
  },
  showServerInfo: {
    type: 'boolean',
    value: false,
    description: 'nerShowServerInfoDesc',
    title: 'nerShowServerInfoTitle',
    advanced: true,
    bodyClass: true
  }
};
neverEndingReddit_module.exclude = ['wiki', 'comments', 'd2x'];

neverEndingReddit_module.shouldRun = () => !Object(utils_location["l" /* isCurrentSubreddit */])('dashboard');

const pauseReasonStorage = storage_namespaceObject.wrap('RESmodules.neverEndingReddit.pauseReason', undefined);
let neverEndingReddit_pauseReason;
let initialLoadPromise;

neverEndingReddit_module.contentStart = async () => {
  if (neverEndingReddit_module.options.returnToPrevPage.value) {
    const {
      ner: {
        number,
        url
      } = {}
    } = history.state || {};

    if (number && url && isNerUrl()) {
      initialLoadPromise = loadPage(url, number, pagePhases.contentLoaded).catch(console.error);
    }
  }

  if (neverEndingReddit_module.options.autoLoad.value) {
    setPause(await pauseReasonStorage.get());
  }
};

neverEndingReddit_module.go = async () => {
  pages[0] = {
    url: location.pathname,
    container: neverEndingReddit_container(),
    nextPageUrl: retrieveNextPageUrl(neverEndingReddit_container())
  };

  if (neverEndingReddit_module.options.returnToPrevPage.value) {
    selectedThing_namespaceObject.addListener(setReturnToPage, 'instantly');
  }

  await initialLoadPromise;
  prepareNextPageLoad(false);
};

const neverEndingReddit_container = Object(once["a" /* default */])(() => getLastSiteTable() || document.createElement('div'));
const pages = [];

function retrieveNextPageUrl(container) {
  const {
    buttons,
    next
  } = getNextPrevLinks(container);
  if (buttons) buttons.hidden = true;
  return next;
}

const getNextPageUrl = (page = pages.slice(-1)[0]) => page.nextPageUrl;

let loadNextPage = () => {};
let refreshAutoLoad;

function prepareNextPageLoad(displayEndBanner = true) {
  const nextPageUrl = getNextPageUrl();

  if (!nextPageUrl) {
    if (displayEndBanner) endNER('No more pages');
    return;
  }

  const pauseAfterPages = parseInt(neverEndingReddit_module.options.pauseAfterEvery.value, 10);

  if (neverEndingReddit_module.options.autoLoad.value && pauseAfterPages) {
    if (pages.length % pauseAfterPages === 0) setPause('pauseAfterEvery');else if (neverEndingReddit_pauseReason === 'pauseAfterEvery') setPause(null);
  }

  const startPromise = new Promise(res => {
    loadNextPage = res;
  });
  const donePromise = startPromise.then(() => loadPage(nextPageUrl, pages.length)).then(prepareNextPageLoad).catch(e => {
    endNER(`Could not load the next page: ${e.message}`);
    console.error(e);
  });
  createLoaderWidget(startPromise, donePromise);
  if (refreshAutoLoad) refreshAutoLoad(false);
}

const pauseButton = Object(once["a" /* default */])(() => {
  const element = string_namespaceObject.html`<span id="NREPause" title="Pause / Restart Never Ending Reddit"></span>`;
  element.addEventListener('click', () => setPause(neverEndingReddit_pauseReason ? null : 'manual'));
  addFloater(element, {
    container: 'visibleAfterScroll'
  });
  return element;
});

function setPause(source) {
  if (neverEndingReddit_module.options.showPauseButton.value) {
    pauseButton().classList.toggle('paused', neverEndingReddit_module.options.reversePauseIcon.value === !source);
  }

  neverEndingReddit_pauseReason = source;
  if (neverEndingReddit_pauseReason) pauseReasonStorage.set(source);else pauseReasonStorage.delete();
  if (refreshAutoLoad) refreshAutoLoad();
}

const pageMarkers = document.getElementsByClassName('NERPageMarker');

const isNerUrl = () => location.hash.startsWith(RES_NER_PAGE_HASH);

function setReturnToPage(selected) {
  if (!document.contains(selected.element)) return;
  let number = 0;
  const earlierMarkers = [...pageMarkers].filter(_marker => selected.element.compareDocumentPosition(_marker) & 0x03);
  if (earlierMarkers.length) number = parseInt(earlierMarkers.slice(-1)[0].dataset.number, 10);
  const {
    ner: saved
  } = history.state || {};
  if (saved && saved.number === number) return;
  if (earlierMarkers.length > 1) history.scrollRestoration = 'manual';
  const page = pages[number];
  history.replaceState({ ...history.state,
    ner: {
      number,
      url: page.url,
      nextPageUrl: page.nextPageUrl
    }
  }, `${document.title}${number ? `- page ${number + 1}` : ''}`, number ? `${RES_NER_PAGE_HASH}=${number + 1}` : `${location.pathname}${location.search}${isNerUrl() ? '' : location.hash}`);
}

function getLastSiteTable(body = document.body) {
  const selector = '.sitetable, .search-result-group';
  const elements = Array.from(body.querySelectorAll(selector)).reverse();

  for (const element of elements) {
    if (!element.parentElement || !element.parentElement.closest(selector)) return element;
  }
}

function getNextPrevLinks(ele = document.body) {
  const buttons = ele.matches('.modactionlisting') ? ele.nextElementSibling : ele.querySelector('.nav-buttons');
  return buttons ? {
    buttons,
    next: (buttons.querySelector('a[rel~=next]') || {}).href,
    prev: (buttons.querySelector('a[rel~=prev]') || {}).href
  } : {};
}

function setLoaderWidgetActionText(widget) {
  Object(dom["e" /* empty */])(widget);
  widget.append(...string_namespaceObject.html`<span>
		<h2>
			Never Ending Reddit
			${string_namespaceObject.safe(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon'))}
		</h2>
		<p>
			Click here to just load the next page;
			${neverEndingReddit_pauseReason ? string_namespaceObject.safe(`or click ${pauseButton().outerHTML} in the top right corner;`) : null}
		</p>
		<p>
			<a id="NERStaticLink" href="${getNextPageUrl() || ''}">or open next page</a> (and clear Never-Ending stream)
		</p>
	</span>`.children);
}

function createLoaderWidget(startPromise, donePromise) {
  const widget = document.createElement('div');
  widget.id = 'progressIndicator';
  widget.className = 'neverEndingReddit';
  widget.addEventListener('click', e => {
    if (e.target.tagName === 'A') return;
    loadNextPage();
  });
  startPromise.then(({
    scrollToLoadWidget = false
  } = {}) => {
    Object(dom["e" /* empty */])(widget);
    widget.append(string_namespaceObject.html`<span class="RESLoadingSpinner"></span>`);
    if (scrollToLoadWidget) Object(dom["l" /* scrollToElement */])(widget, null, {
      scrollStyle: 'middle',
      direction: 'down'
    });
  });
  donePromise.finally(() => widget.remove());
  const prefetchIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (!isIntersecting) return;
    prefetchNextPage();
  }, {
    rootMargin: '100%'
  });
  prefetchIo.observe(widget);
  const displayPauseReason = Object(once["a" /* default */])(pauseReason => notifications_showNotification({
    moduleID: neverEndingReddit_module.moduleID,
    notificationID: pauseReason,
    message: pauseReason === 'pauseAfterEvery' ? `
				<p>Time for a break!</p>
				<p>Never-Ending Reddit has been paused because you've passed ${neverEndingReddit_module.options.pauseAfterEvery.value} pages.</p>
			` : `<p>Never-Ending Reddit is paused. Click ${pauseButton().outerHTML} button in the top right corner to unpause it.</p>`
  }));
  const pauseReasonIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (isIntersecting && neverEndingReddit_pauseReason) displayPauseReason(neverEndingReddit_pauseReason);
  }, {
    threshold: [1]
  });
  const loadNextPageIo = new IntersectionObserver(([{
    isIntersecting
  }]) => {
    if (!isIntersecting) return;
    loadNextPage();
  }, {
    threshold: [1]
  });

  refreshAutoLoad = (updateWidget = true) => {
    const enabled = neverEndingReddit_module.options.autoLoad.value && !neverEndingReddit_pauseReason;
    if (enabled) loadNextPageIo.observe(widget);else loadNextPageIo.disconnect();
    if (updateWidget) setLoaderWidgetActionText(widget);
    pauseReasonIo.observe(widget);
  };

  setLoaderWidgetActionText(widget);
  startPromise.then(() => {
    prefetchIo.disconnect();
    loadNextPageIo.disconnect();
    pauseReasonIo.disconnect();
    refreshAutoLoad = null;
  });
  pages.slice(-1)[0].container.append(widget);
}

const fetchPage = Object(memoize["a" /* default */])(url => ajax({
  url,
  cacheFor: utils_time["b" /* HOUR */]
}));

const prefetchNextPage = () => {
  const url = getNextPageUrl();
  if (url) fetchPage(url);
};

async function loadPage(url, number, waitToAppendPromise) {
  var _slice$, _slice$2;

  const html = (await fetchPage(url)).replace(/<style(.|\s)*?>|<link(.|\s)*?>|<script(.|\s)*?\/script>/g, '');
  const document = new DOMParser().parseFromString(html, 'text/html');

  if (context_data.username && context_data.username !== documentLoggedInUser(document.body)) {
    throw new Error('Page loaded was not for current user');
  }

  const newSiteTable = getLastSiteTable(document.body);
  if (!newSiteTable) throw Error('Could not find any siteTable');
  const noresults = newSiteTable.querySelector('#noresults');
  if (noresults) throw new Error(noresults.textContent);

  for (const {
    name
  } of newSiteTable.attributes) newSiteTable.removeAttribute(name);

  pages[number] = {
    url,
    container: newSiteTable,
    nextPageUrl: retrieveNextPageUrl(newSiteTable)
  };
  await waitToAppendPromise;
  Object(watchers["registerPage"])(newSiteTable);
  const pageMarker = string_namespaceObject.html`<div class="NERPageMarker" data-number="${number}">
		<a href="${pages[number].url}">Page ${number + 1}</a>
		${string_namespaceObject.safe(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon'))}
	</div>`;
  const firstLen = ((_slice$ = [...neverEndingReddit_container().getElementsByClassName('rank')].slice(-1)[0]) === null || _slice$ === void 0 ? void 0 : _slice$.textContent.length) || 0;
  const lastLen = ((_slice$2 = [...newSiteTable.getElementsByClassName('rank')].slice(-1)[0]) === null || _slice$2 === void 0 ? void 0 : _slice$2.textContent.length) || 0;

  if (lastLen > firstLen) {
    Object(dom["b" /* addCSS */])(`body.res > .content .link .rank { width: ${(lastLen * 1.1).toFixed(1)}ex; }`);
  }

  neverEndingReddit_container().append(pageMarker, newSiteTable);
  window.dispatchEvent(new Event('neverEndingLoad', {
    bubbles: true,
    cancelable: true
  }));
}

function endNER(text) {
  neverEndingReddit_container().append(string_namespaceObject.html`<div class="NERPageMarker NERPageMarkerLast">
		${text}
		${string_namespaceObject.safe(makeUrlHashLink(neverEndingReddit_module.moduleID, undefined, ' ', 'gearIcon'))}
		<p class="nextprev">
			<a href="${location.href.split('#')[0]}">start over</a>
			<a href="${getNextPageUrl() || ''}">try again</a>
			<a target="_blank" rel="noopener noreferer" href="/r/Enhancement/wiki/faq/never_ending_reddit">learn more</a>
			<a href="/r/random">random subreddit</a>
		</p>
	</div>`);
}
// CONCATENATED MODULE: ./lib/modules/noParticipation.js






const noParticipation_module = new Module('noParticipation');
const noParticipation_urls = {
  moreinfo: 'https://www.reddit.com/r/NoParticipation/wiki/intro'
};
noParticipation_module.moduleName = 'noPartName';
noParticipation_module.description = 'noPartDesc';
noParticipation_module.category = 'subredditsCategory';
noParticipation_module.options = {
  disableVoteButtons: {
    type: 'boolean',
    value: false,
    description: 'noPartDisableVoteButtonsDesc',
    title: 'noPartDisableVoteButtonsTitle',
    bodyClass: true
  },
  disableCommentTextarea: {
    type: 'boolean',
    value: false,
    description: 'noPartDisableCommentTextareaDesc',
    title: 'noPartDisableCommentTextareaTitle',
    bodyClass: true
  },
  evenIfSubscriber: {
    type: 'boolean',
    value: false,
    description: 'noPartEvenIfSubscriberDesc',
    title: 'noPartEvenIfSubscriberTitle'
  },
  escapeNP: {
    type: 'boolean',
    value: true,
    description: 'noPartEscapeNPDesc',
    title: 'noPartEscapeNPTitle'
  }
};

noParticipation_module.shouldRun = () => isNpHostname(location.hostname);

const boilerplateNotificationText = `
	<p>
		<div class="RES-spoiler">
			<label class="RES-spoiler-title">Hover here for more details</label>
			<div class="RES-spoiler-contents">
				You came to this page by following a <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">NP</a> link, so you may be interfering with normal conversation.
				Please respect reddit's <a href="https://reddit.com/rules" target="_blank" rel="noopener noreferer">rules</a> by not commenting or voting. Violating these rules may get you banned.
				<a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">Find out more</a>
			</div>
		</div>
	</p>
`;
let noParticipationActive;

noParticipation_module.contentStart = () => {
  if (noParticipation_module.options.escapeNP.value) {
    jquery_default()(document.body).on('mousedown', 'a', removeNpFromLink);
  }

  if (isNPIrrelevant()) {
    notifyNpIrrelevant();
  } else if (loggedInUser()) {
    if (Object(utils_location["n" /* isPageType */])('comments', 'linklist') && !(document.body.classList.contains('front-page') || document.body.classList.contains('profile-page'))) {
      applyNoParticipationMode();
    } else {
      notifyNpIrrelevant();
    }
  }
};

function isNpHostname(hostname) {
  return /^(?:\w+-)?np(?:-\w+)?\./i.test(hostname);
}

function removeNpFromLink(e) {
  const target = e.currentTarget;
  if (!target.getAttribute('href').startsWith('/') && target.matches('.md a')) return;

  if (target.hostname.endsWith('np.reddit.com')) {
    target.hostname = 'www.reddit.com';
  }
}

function isNPIrrelevant() {
  return !Object(utils_location["n" /* isPageType */])('comments') || isSubscriber() && !noParticipation_module.options.evenIfSubscriber.value;
}

function isVotingBlocked() {
  return noParticipationActive && noParticipation_module.options.disableVoteButtons.value;
}

function isSubscriber() {
  return document.body.classList.contains('subscriber');
}

function nonNpLocation(href = location.href) {
  const nonNpUrl = new URL(href, location.href);
  if (isNpHostname(nonNpUrl.hostname)) nonNpUrl.hostname = 'www.reddit.com';
  return nonNpUrl.href;
}

function notifyNpIrrelevant() {
  const message = isSubscriber() ? `You're browsing in <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">No Participation</a> mode, but you're a subscriber here.` : `You're still browsing in <a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">No Participation</a> mode, but it's no longer necessary.`;
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    notificationID: 'ok-participation',
    closeDelay: 3000,
    header: 'Okay to Participate',
    message: `${message} <p><a href="${nonNpLocation()}">Click here to return to normal reddit</a></p>`
  });
}

function notifyNpActive() {
  const message = isSubscriber() ? `
			<span class="res-icon">&#xF15A;</span>
			Please think before you comment or vote, and remember the subreddit's rules.
			Although you subscribe to this subreddit, you can still derail a particular thread.
			<p><a href="${nonNpLocation()}">Click here to return to normal reddit.</a></p>
		` : `
			<strong>
				<span class="res-icon">&#xF15A;</span>
				Do not vote or comment.
			</strong>
		`;
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    notificationID: 'no-participation',
    closeDelay: 10000,
    header: 'No Participation',
    message: `${message}${boilerplateNotificationText}`
  });
}

const votedOnButtons = [];
async function notifyNoVote(voteButton) {
  const canUndoVote = voteButton && !voteButton.matches('.upmod, .downmod');
  if (voteButton) votedOnButtons.push(voteButton);
  const notification = await notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableVoteButtons',
    cooldown: 5000,
    header: 'No Participation',
    message: `
			<strong><span class="res-icon">&#xF15A;</span> Do not vote.</strong>
			${boilerplateNotificationText}
			${canUndoVote ? '<p><button type="button" class="redButton" data-action="revertvote">Undo vote</button></p>' : ''}
		`
  });

  if (notification) {
    jquery_default()(notification.element).find('[data-action=revertvote]').on('click', () => {
      revertVote(votedOnButtons);
      notification.close();
    });
  }
}
const notifyNoComment = Object(once["a" /* default */])(() => {
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableCommentTextarea',
    header: 'No Participation',
    message: `<strong><span class="res-icon">&#xF15A;</span> Do not comment.</strong>${boilerplateNotificationText}`
  });
});

function applyNoParticipationMode() {
  noParticipationActive = true;
  notifyNpActive();
  bodyClasses_namespaceObject.add('res-noParticipation');
  watchForVote();
  jquery_default()(document.body).on('keydown', commentTextareaSelector, e => {
    notifyNoComment();

    if (noParticipation_module.options.disableCommentTextarea.value) {
      Object(flow["a" /* downcast */])(e.currentTarget, HTMLTextAreaElement).disabled = true;
    }
  });
}

function watchForVote() {
  jquery_default()(document.body).on('click', '.arrow', e => {
    if (e.currentTarget.classList.contains('up') || e.currentTarget.classList.contains('down')) {
      notifyNoVote(e.currentTarget);
    }
  });
}

function revertVote(voteButtons) {
  voteButtons.forEach((voteButton, index) => {
    setTimeout(() => {
      if (voteButton.classList.contains('upmod') || voteButton.classList.contains('downmod')) {
        Object(dom["c" /* click */])(voteButton);
      }
    }, index * 2000);
  });
  notifications_showNotification({
    moduleID: noParticipation_module.moduleID,
    optionKey: 'disableVoteButtons',
    header: 'No Participation',
    message: `
			${voteButtons.length > 1 ? 'Your votes are being reverted.' : 'Your vote has been reverted.'}
			Please remember not to vote!
			<p><a href="${noParticipation_urls.moreinfo}" target="_blank" rel="noopener noreferer">Find out more</a></p>
		`
  });
}
// CONCATENATED MODULE: ./lib/modules/saveComments.js










const saveComments_module = new Module('saveComments');
saveComments_module.moduleName = 'saveCommentsName';
saveComments_module.description = 'saveCommentsDesc';
saveComments_module.category = 'commentsCategory';
saveComments_module.exclude = ['submit'];
const savedCommentStorage = storage_namespaceObject.wrapBlob('RESmodules.saveComments.savedComments', () => {
  throw new Error('Saved comment not found');
});

saveComments_module.beforeLoad = () => {
  Object(watchers["watchForThings"])(['comment'], thing => {
    const sibling = thing.entry.querySelector('.comment-save-button');
    if (!sibling) return;
    sibling.after(saveElement());
  });
};

saveComments_module.contentStart = () => {
  if (Object(utils_location["n" /* isPageType */])('profile')) {
    createElement_namespaceObject.tabMenuItem({
      text: 'saved - RES',
      onChange: () => {
        location.href = '/r/dashboard/#savedComments';
      }
    });
  }

  addDashboardTab('savedComments', 'Saved Comments', saveComments_module.moduleID, async tabPage => jquery_default()(tabPage).append(await drawSavedComments()));
};

const saveElement = (e => () => Object(dom["k" /* preventCloning */])(e().cloneNode(true)))(Object(once["a" /* default */])(() => {
  jquery_default()(document.body).on('click', 'li.saveComments', ({
    currentTarget
  }) => {
    if (currentTarget.classList.contains('saved-RES')) return;
    const thing = Thing["a" /* Thing */].checkedFrom(currentTarget);
    saveComment(thing);
    const a = currentTarget.firstElementChild;
    requestAnimationFrame(() => {
      a.dataset.text = 'saved-RES';
      a.href = '/r/dashboard#savedComments';
    });
  });
  return string_namespaceObject.html`
		<li class="saveComments">
			<a class="RES-save noCtrlF" href="javascript:void 0" title="Save using RES - which is local only, but preserves the full text in case someone edits/deletes it" data-text="save-RES"></a>
		</li>
	`;
}));

async function saveComment(thing) {
  const permaLink = thing.getCommentPermalink();
  if (!permaLink) throw new Error('Comment lacks permalink');
  const textBody = thing.getTextBody();
  if (!textBody) throw new Error('Comment text body not found');
  const id = thing.getFullname().split('_').slice(-1)[0];
  if ((await savedCommentStorage.getAll()).hasOwnProperty(id)) return;
  const comment = jquery_default()(textBody).clone();
  comment.find('.keyNavAnnotation, .expando-button, .res-expando-box, script, .userTagLink').remove();
  savedCommentStorage.set(id, {
    href: permaLink.href,
    username: thing.getAuthor() || '[deleted]',
    comment: comment.html(),
    timeSaved: new Date().toString()
  });
}

const savedCommentsTemplate = ({
  comments,
  keyNavTip,
  moduleDescription
}) => string_namespaceObject.html`
	<div id="res-saveComments" class="sitetable linklisting">
		${!comments.length && string_namespaceObject._html`
			<div class="res-module-description md">
				<h1>Saving comments with RES</h1>
				${string_namespaceObject.safe(snudown_es_markdown(moduleDescription))}
			</div>
		`}
		${keyNavTip && keyNavTip.map(({
  keyNavHash,
  savePostKey,
  saveCommentKey,
  saveRESKey
}) => string_namespaceObject._html`
			<div class="res-module-tip infobar">
				<p><i>Keyboard Shortcuts</i> <a class="gearIcon" href="${keyNavHash}" title="RES settings"></a></p>
				<ul>
					<li><b>${savePostKey}</b>: save a submission.</li>
					<li><b>${saveCommentKey}</b>: save a comment (to your reddit account).</li>
					<li><b>${saveRESKey}</b>: save a comment with RES.</li>
				</ul>
			</div>
		`)}
		<div class="res-saveComments-list">
			${comments.map(({
  id,
  link,
  username,
  dateTime,
  date,
  timeAgo,
  body
}) => string_namespaceObject._html`
				<div class="entry res-savedComment">
					<div class="savedCommentHeader">
						<a href="${link}">
							<b>${username}</b>
							- saved <date title="${dateTime}" datetime="${date}">${timeAgo}</date> ago
						</a>
					</div>
					<div class="savedCommentBody md">${string_namespaceObject.safe(body)}</div>
					<div class="savedCommentFooter">
						<ul class="flat-list buttons">
							<li><a href="${link}">permalink</a></li>
							<li><a class="unsaveComment" href="#" data-unsaveID="${id}">unsave-RES</a></li>
						</ul>
					</div>
				</div>
			`)}
		</div>
	</div>
`;

const drawSavedComments = Object(once["a" /* default */])(async () => {
  const savedComments = await savedCommentStorage.getAll();
  const comments = Object.entries(savedComments).map(([id, {
    comment,
    href,
    username,
    timeSaved
  }]) => {
    const date = new Date(timeSaved);
    return {
      id,
      link: href,
      username,
      date: formatDate(date),
      dateTime: formatDateTime(date),
      timeAgo: formatDateDiff(date),
      body: (typeof comment === 'string' ? comment : '').replace(/<(script|iframe|video)(.|\s)*?\/(script|iframe|video)>/g, '')
    };
  });
  return jquery_default()(savedCommentsTemplate({
    moduleDescription: i18n(saveComments_module.description),
    keyNavTip: modules_isEnabled(keyboardNav_namespaceObject) && [{
      keyNavHash: makeUrlHash(keyboardNav_module.moduleID, 'savePost'),
      savePostKey: keycode_niceKeyCode(keyboardNav_module.options.savePost.value),
      saveCommentKey: keycode_niceKeyCode(keyboardNav_module.options.saveComment.value),
      saveRESKey: keycode_niceKeyCode(keyboardNav_module.options.saveRES.value)
    }],
    comments
  })).on('click', '.unsaveComment', e => {
    e.preventDefault();
    savedCommentStorage.delete(e.currentTarget.dataset.unsaveid);
    e.currentTarget.textContent = 'removed';
  });
});
function showEducationalNotification() {
  notifications_showNotification({
    moduleID: saveComments_module.moduleID,
    optionKey: 'savePost',
    notificationID: 'saveRES-educational',
    closeDelay: 10000,
    cooldown: 3 * utils_time["d" /* WEEK */],
    header: 'Saving Posts and Comments',
    message: `
			<p>
				The keyboard shortcuts <b>"${keycode_niceKeyCode(keyboardNav_module.options.savePost.value)}"</b> (posts) and <b>"${keycode_niceKeyCode(keyboardNav_module.options.saveComment.value)}"</b> (comments) will save a post/comment to your reddit account (same as the "save" button).
				It will be accessible from anywhere that you're logged in, but the original text will not be preserved if it is edited or deleted.
			</p>
			<p>
				The keyboard shortcut <b>"${keycode_niceKeyCode(keyboardNav_module.options.saveRES.value)}"</b> will save a comment to RES (same as the "save-RES" button).
				It will only be available locally, but the original text will be preserved if the comment is edited or deleted.
			</p>
			<p>These shortcuts can be changed in the ${makeUrlHashLink(keyboardNav_module.moduleID, 'savePost', 'settings console')}.<p>
		`
  });
}
// CONCATENATED MODULE: ./lib/modules/showParent.js




const showParent_module = new Module('showParent');
showParent_module.moduleName = 'showParentName';
showParent_module.category = 'myAccountCategory';
showParent_module.description = 'showParentDesc';
showParent_module.options = {
  hoverDelay: {
    title: 'showParentHoverDelayTitle',
    type: 'text',
    value: '500',
    description: 'showParentHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'showParentFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'showParentFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'showParentFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'showParentFadeSpeedDesc',
    advanced: true
  },
  direction: {
    title: 'showParentDirectionTitle',
    type: 'enum',
    value: 'down',
    values: [{
      name: 'Above',
      value: 'up'
    }, {
      name: 'Below',
      value: 'down'
    }],
    description: 'showParentDirectionDesc',
    bodyClass: true
  }
};
showParent_module.include = ['comments'];
let showParent_hover;

showParent_module.contentStart = () => {
  showParent_hover = infocard(showParent_module.moduleID).options({
    openDelay: parseFloat(showParent_module.options.hoverDelay.value),
    fadeDelay: parseFloat(showParent_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(showParent_module.options.fadeSpeed.value)
  }).populateWith(card => showCommentHover(Thing["a" /* Thing */].checkedFrom(card.getCheckedTarget()))).watch('.comment .buttons :not(:first-child) .bylink');
};

function startHover(button) {
  if (showParent_hover) showParent_hover.target(button).begin();
}

function showParent_handleVoteClick() {
  const $this = jquery_default()(this);
  const voteClasses = {
    up: 'likes',
    none: 'unvoted',
    down: 'dislikes'
  };
  const id = $this.parent().parent().attr('data-fullname');
  let direction = /(up|down)(?:mod)?/.exec(this.className);
  if (!direction) return;
  direction = direction[1];
  const $targetButton = jquery_default()(`.content .thing.id-${id}`).children('.midcol').find(`.arrow.${direction}, .arrow.${direction}mod`);

  if ($targetButton.length !== 1) {
    console.error('When attempting to find %s arrow for comment %s %d elements were returned', direction, id, $targetButton.length);
    return;
  }

  function removeClickHandlers(event) {
    event.stopPropagation();
  }

  $targetButton.on('click', removeClickHandlers);
  $targetButton.click();
  $targetButton.off('click', removeClickHandlers);
  const $midcol = $this.parent();
  let startDir = 'none';

  for (const [key, value] of Object.entries(voteClasses)) {
    if ($midcol.hasClass(value)) {
      startDir = key;
      break;
    }
  }

  const newDir = direction === startDir ? 'none' : direction;
  $midcol.parent().children(`.${voteClasses[startDir]}`).removeClass(voteClasses[startDir]).addClass(voteClasses[newDir]);
  $midcol.find('.up, .upmod').toggleClass('upmod', newDir === 'up').toggleClass('up', newDir !== 'up');
  $midcol.find('.down, .downmod').toggleClass('downmod', newDir === 'down').toggleClass('down', newDir !== 'down');
}

function showCommentHover(thing) {
  const direction = showParent_module.options.direction.value;
  let $parents = jquery_default()(thing.element).parents('.thing').clone();
  let topParentURL = '';

  if ($parents.length === 0) {
    topParentURL = jquery_default()(thing.element).find('[data-event-action="parent"]').first().attr('data-href-url');
  } else {
    const topParentId = $parents.last().attr('data-fullname');
    topParentURL = jquery_default()(`[data-fullname="${topParentId}"] > .entry [data-event-action="parent"]`).first().attr('data-href-url');
  }

  if (direction === 'up') {
    $parents = jquery_default()($parents.get().reverse());
  }

  $parents.addClass('comment parentComment').removeClass('thing even odd');
  $parents.children('.child').remove();
  $parents.each(function () {
    const $this = jquery_default()(this);
    $this.off('click');
    let id = $this.attr('data-fullname');

    if (id) {
      id = id.slice(3);
      $this.find('> .entry .tagline').append(`<a class="bylink parentlink" href="#${id}">goto comment</a>`);
    }
  });
  $parents.find('.parent').remove();
  $parents.find('.usertext-body').show();
  $parents.find('.flat-list.buttons').remove();
  $parents.find('.usertext-edit').remove();
  $parents.find('.RESUserTag').remove();
  $parents.find('.voteWeight').remove();
  $parents.find('.collapsed').remove();
  $parents.find('.expand').remove();
  $parents.find('form').attr('id', '');
  $parents.find('.arrow').on('click', showParent_handleVoteClick);
  $parents.find('.res-expando-box, .expando-button').remove();
  $parents.find('.keyNavAnnotation').remove();
  const $container = jquery_default()('<div class="parentCommentWrapper">');
  $container.append($parents);

  if (topParentURL) {
    $container.append(`<a class="bylink" href="${topParentURL}">View parent comment</a>`);
  }

  $parents.slice(0, -1).after('<div class="parentArrow">reply to</div>');
  return ['Parents', $container];
}
// CONCATENATED MODULE: ./lib/modules/singleClick.js



const singleClick_module = new Module('singleClick');
singleClick_module.moduleName = 'singleClickName';
singleClick_module.category = 'browsingCategory';
singleClick_module.description = 'singleClickDesc';
singleClick_module.options = {
  openOrder: {
    title: 'singleClickOpenOrderTitle',
    type: 'enum',
    values: [{
      name: 'open comments then link',
      value: 'commentsfirst'
    }, {
      name: 'open link then comments',
      value: 'linkfirst'
    }],
    value: 'commentsfirst',
    description: 'singleClickOpenOrderDesc'
  },
  hideLEC: {
    title: 'singleClickHideLECTitle',
    type: 'boolean',
    value: true,
    description: 'singleClickHideLECDesc',
    advanced: true
  },
  openFrontpage: {
    title: 'singleClickOpenFrontpageTitle',
    type: 'boolean',
    value: false,
    description: 'singleClickOpenFrontpageDesc',
    dependsOn: options => !options.hideLEC.value
  },
  openBackground: {
    title: 'singleClickOpenBackgroundTitle',
    type: 'boolean',
    value: false,
    description: 'singleClickOpenBackgroundDesc'
  }
};
singleClick_module.exclude = ['comments'];
const invokeOnPostMap = new WeakMap();

singleClick_module.beforeLoad = () => {
  Object(watchers["watchForThings"])(['post'], thing => {
    const urls = new Set([thing.getPostUrl()]);

    if (thing.isLinkPost()) {
      const a = thing.getCommentsLink();
      if (a) urls.add(a.href);
    } else if (singleClick_module.options.openFrontpage.value) {
      const frontpageLink = thing.getSubredditLink();
      if (frontpageLink) urls.add(frontpageLink.href);
    }

    const ordered = (singleClick_module.options.openOrder.value === 'commentsfirst' ? [...urls].reverse() : [...urls]).filter(Boolean);

    const open = focused => {
      openNewTabs(focused, ...ordered);
    };

    invokeOnPostMap.set(thing, open);
    if (!ordered.length || singleClick_module.options.hideLEC.value && ordered.length === 1) return;
    const text = ordered.length === 1 ? '[l=c]' : '[l+c]';
    const ele = string_namespaceObject.html`<li><a href="javascript:void(0)" class="noCtrlF" data-text="${text}"></a></li>`;
    ele.firstElementChild.addEventListener('auxclick', e => {
      e.preventDefault();
    });
    ele.firstElementChild.addEventListener('mouseup', e => {
      if (e.button !== 0 && e.button !== 1) return;
      e.preventDefault();
      const focused = !e.button && !e.ctrlKey && !singleClick_module.options.openBackground.value;
      open(focused);
    });
    thing.getButtons().append(ele);
  });
};
// CONCATENATED MODULE: ./lib/modules/keyboardNav.js




















const keyboardNav_module = new Module('keyboardNav');
keyboardNav_module.moduleName = 'keyboardNavName';
keyboardNav_module.category = 'browsingCategory';
keyboardNav_module.description = 'keyboardNavDesc';
keyboardNav_module.options = {
  linearScrollStyle: {
    type: 'enum',
    values: [{
      name: 'directional',
      value: 'directional'
    }, {
      name: 'page up/down',
      value: 'page'
    }, {
      name: 'lock to top',
      value: 'top'
    }, {
      name: 'in middle',
      value: 'middle'
    }, {
      name: 'adopt top',
      value: 'adopt'
    }, {
      name: 'legacy',
      value: 'legacy'
    }],
    value: 'directional',
    description: 'keyboardNavLinearScrollStyleDesc',
    title: 'keyboardNavLinearScrollStyleTitle'
  },
  nonLinearScrollStyle: {
    type: 'enum',
    values: [{
      name: 'directional',
      value: 'directional'
    }, {
      name: 'page up/down',
      value: 'page'
    }, {
      name: 'lock to top',
      value: 'top'
    }, {
      name: 'in middle',
      value: 'middle'
    }, {
      name: 'adopt top',
      value: 'adopt'
    }, {
      name: 'legacy',
      value: 'legacy'
    }],
    value: 'legacy',
    description: 'keyboardNavNonLinearScrollStyleDesc',
    title: 'keyboardNavNonLinearScrollStyleTitle'
  },
  linkNumbers: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkNumbersDesc',
    title: 'keyboardNavLinkNumbersTitle'
  },
  linkNumberPosition: {
    dependsOn: options => options.linkNumbers.value,
    type: 'enum',
    values: [{
      name: 'Place on right',
      value: 'right'
    }, {
      name: 'Place on left',
      value: 'left'
    }],
    value: 'right',
    description: 'keyboardNavLinkNumberPositionDesc',
    title: 'keyboardNavLinkNumberPositionTitle',
    advanced: true
  },
  linkToggleExpando: {
    dependsOn: options => options.linkNumbers.value,
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkToggleExpandoDesc',
    title: 'keyboardNavLinkToggleExpandoTitle'
  },
  linkNumberAltModeModifier: {
    dependsOn: options => options.linkNumbers.value,
    type: 'enum',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'Shift',
      value: 'shift'
    }, {
      name: 'Alt',
      value: 'alt'
    }],
    value: 'alt',
    description: 'keyboardNavLinkNumberAltModeModifierDesc',
    title: 'keyboardNavLinkNumberAltModeModifierTitle',
    advanced: true
  },
  linkNewTab: {
    dependsOn: options => options.linkNumbers.value,
    type: 'boolean',
    value: true,
    description: 'keyboardNavLinkNewTabDesc',
    title: 'keyboardNavLinkNewTabTitle',
    advanced: true
  },
  onHideMoveDown: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavOnHideMoveDownDesc',
    title: 'keyboardNavOnHideMoveDownTitle',
    advanced: true
  },
  onVoteMoveDown: {
    type: 'boolean',
    value: false,
    description: 'keyboardNavOnVoteMoveDownDesc',
    title: 'keyboardNavOnVoteMoveDownTitle',
    advanced: true
  },
  onVoteCommentMoveDown: {
    type: 'boolean',
    value: false,
    description: 'keyboardNavOnVoteCommentMoveDownDesc',
    title: 'keyboardNavOnVoteCommentMoveDownTitle',
    advanced: true
  },
  followLinkNewTabFocus: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavFollowLinkNewTabFocusDesc',
    title: 'keyboardNavFollowLinkNewTabFocusTitle'
  },
  toggleHelp: {
    type: 'keycode',
    value: [191, false, false, true, false],
    description: 'keyboardNavToggleHelpDesc',
    title: 'keyboardNavToggleHelpTitle',

    callback() {
      toggleKeyNavHelp();
    }

  },
  toggleCmdLine: {
    type: 'keycode',
    requiresModules: [commandLine_namespaceObject],
    value: [190, false, false, false, false],
    description: 'keyboardNavToggleCmdLineDesc',
    title: 'keyboardNavToggleCmdLineTitle',

    callback() {
      commandLine_toggle();
    }

  },
  enterFilterCommandLine: {
    type: 'keycode',
    requiresModules: [commandLine_namespaceObject, filteReddit_namespaceObject],
    value: [70, false, false, false, false],
    description: 'keyboardNavEnterFilterCommandLineDesc',
    title: 'keyboardNavEnterFilterCommandLineTitle',

    callback() {
      commandLine_open('fl ');
    }

  },
  hide: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile'],
    value: [72, false, false, false, false],
    description: 'keyboardNavHideDesc',
    title: 'keyboardNavHideTitle',
    callback: hideLink
  },
  moveUp: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [75, false, false, false, false],
    description: 'keyboardNavMoveUpDesc',
    title: 'keyboardNavMoveUpTitle',

    callback() {
      selectedThing_namespaceObject.move('up', {
        allowMediaBrowse: true,
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveDown: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [74, false, false, false, false],
    description: 'keyboardNavMoveDownDesc',
    title: 'keyboardNavMoveDownTitle',

    callback() {
      selectedThing_namespaceObject.move('down', {
        allowMediaBrowse: true,
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      }, moveDownFallback);
    }

  },
  moveUpComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [75, false, false, false, false],
    description: 'keyboardNavMoveUpCommentDesc',
    title: 'keyboardNavMoveUpCommentTitle',

    callback() {
      selectedThing_namespaceObject.move('up', {
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveDownComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [74, false, false, false, false],
    description: 'keyboardNavMoveDownCommentDesc',
    title: 'keyboardNavMoveDownCommentTitle',

    callback() {
      selectedThing_namespaceObject.move('down', {
        scrollStyle: keyboardNav_module.options.linearScrollStyle.value
      });
    }

  },
  moveTop: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'],
    value: [75, false, false, true, false],
    description: 'keyboardNavMoveTopDesc',
    title: 'keyboardNavMoveTopTitle',

    callback() {
      selectedThing_namespaceObject.move('top', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveBottom: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'],
    value: [74, false, false, true, false],
    description: 'keyboardNavMoveBottomDesc',
    title: 'keyboardNavMoveBottomTitle',

    callback() {
      selectedThing_namespaceObject.move('bottom', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveUpSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [75, false, false, true, false],
    description: 'keyboardNavMoveUpSiblingDesc',
    title: 'keyboardNavMoveUpSiblingTitle',

    callback() {
      selectedThing_namespaceObject.move('upSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [74, false, false, true, false],
    description: 'keyboardNavMoveDownSiblingDesc',
    title: 'keyboardNavMoveDownSiblingTitle',

    callback() {
      selectedThing_namespaceObject.move('downSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownParentSibling: {
    type: 'keycode',
    include: ['comments'],
    value: [74, true, false, false, false],
    description: 'keyboardNavMoveDownParentSiblingDesc',
    title: 'keyboardNavMoveDownParentSiblingTitle',

    callback() {
      selectedThing_namespaceObject.move('downParentSibling', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveUpThread: {
    type: 'keycode',
    include: ['comments'],
    value: [75, true, false, true, false],
    description: 'keyboardNavMoveUpThreadDesc',
    title: 'keyboardNavMoveUpThreadTitle',

    callback() {
      selectedThing_namespaceObject.move('upThread', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveDownThread: {
    type: 'keycode',
    include: ['comments'],
    value: [74, true, false, true, false],
    description: 'keyboardNavMoveDownThreadDesc',
    title: 'keyboardNavMoveDownThreadTitle',

    callback() {
      selectedThing_namespaceObject.move('downThread', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveToTopComment: {
    type: 'keycode',
    include: ['comments'],
    value: [84, false, false, false, false],
    description: 'keyboardNavMoveToTopCommentDesc',
    title: 'keyboardNavMoveToTopCommentTitle',

    callback() {
      selectedThing_namespaceObject.move('toTopComment', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  moveToParent: {
    type: 'keycode',
    include: ['comments'],
    value: [80, false, false, false, false],
    description: 'keyboardNavMoveToParentDesc',
    title: 'keyboardNavMoveToParentTitle',

    callback() {
      selectedThing_namespaceObject.move('toParent', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  undoMove: {
    type: 'keycode',
    value: [90, false, true, false, false],
    description: 'keyboardNavUndoMoveDesc',
    title: 'keyboardNavUndoMoveTitle',

    callback() {
      selectedThing_namespaceObject.move('previous', {
        scrollStyle: keyboardNav_module.options.nonLinearScrollStyle.value
      });
    }

  },
  showParents: {
    type: 'keycode',
    requiresModules: [showParent_namespaceObject],
    value: [80, false, false, true, false],
    description: 'keyboardNavShowParentsDesc',
    title: 'keyboardNavShowParentsTitle',

    callback(selected = getSelected()) {
      startHover(assertElement(selected.element.querySelector('.buttons .bylink[href^="#"]')));
    }

  },
  followLink: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments', 'search'],
    value: [13, false, false, false, false],
    description: 'keyboardNavFollowLinkDesc',
    title: 'keyboardNavFollowLinkTitle',

    callback() {
      followLink();
    }

  },
  followLinkNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments', 'search'],
    value: [13, false, false, true, false],
    description: 'keyboardNavFollowLinkNewTabDesc',
    title: 'keyboardNavFollowLinkNewTabTitle',

    callback() {
      followLink(true);
    }

  },
  toggleExpando: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [88, false, false, false, false],
    description: 'keyboardNavToggleExpandoDesc',
    title: 'keyboardNavToggleExpandoTitle',

    callback(selected = getSelected()) {
      toggleThingExpandos(selected, {
        scrollOnToggle: keyboardNav_module.options.scrollOnExpando.value
      });
    }

  },
  scrollOnExpando: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavScrollOnExpandoDesc',
    title: 'keyboardNavScrollOnExpandoTitle',
    advanced: true
  },
  imageSizeUp: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [187, false, false, false, false],
    description: 'keyboardNavImageSizeUpDesc',
    title: 'keyboardNavImageSizeUpTitle',

    callback() {
      imageResize({
        factor: 1.3
      });
    }

  },
  imageSizeDown: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [189, false, false, false, false],
    description: 'keyboardNavImageSizeDownDesc',
    title: 'keyboardNavImageSizeDownTitle',

    callback() {
      imageResize({
        factor: 1 / 1.3
      });
    }

  },
  imageSizeUpFine: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [187, false, false, true, false],
    description: 'keyboardNavImageSizeUpFineDesc',
    title: 'keyboardNavImageSizeUpFineTitle',

    callback() {
      imageResize({
        factor: 1.1
      });
    }

  },
  imageSizeDownFine: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [189, false, false, true, false],
    description: 'keyboardNavImageSizeDownFineDesc',
    title: 'keyboardNavImageSizeDownFineTitle',

    callback() {
      imageResize({
        factor: 1 / 1.1
      });
    }

  },
  imageSizeAnyHeight: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [39, false, false, true, false],
    description: 'keyboardNavImageSizeAnyHeightDesc',
    title: 'keyboardNavImageSizeAnyHeightTitle',

    callback() {
      imageResize({
        removeHeightRestriction: true
      });
    }

  },
  imageMoveUp: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [38, false, true, false, false],
    description: 'keyboardNavImageMoveUpDesc',
    title: 'keyboardNavImageMoveUpTitle',

    callback() {
      imageMove(0, -50);
    }

  },
  imageMoveDown: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [40, false, true, false, false],
    description: 'keyboardNavImageMoveDownDesc',
    title: 'keyboardNavImageMoveDownTitle',

    callback() {
      imageMove(0, 50);
    }

  },
  imageMoveLeft: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [37, false, true, false, false],
    description: 'keyboardNavImageMoveLeftDesc',
    title: 'keyboardNavImageMoveLeftTitle',

    callback() {
      imageMove(-50, 0);
    }

  },
  imageMoveRight: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [39, false, true, false, false],
    description: 'keyboardNavImageMoveRightDesc',
    title: 'keyboardNavImageMoveRightTitle',

    callback() {
      imageMove(50, 0);
    }

  },
  previousGalleryImage: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [219, false, false, false, false],
    description: 'keyboardNavPreviousGalleryImageDesc',
    title: 'keyboardNavPreviousGalleryImageTitle',

    callback() {
      navigateGallery('previous');
    }

  },
  nextGalleryImage: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [221, false, false, false, false],
    description: 'keyboardNavNextGalleryImageDesc',
    title: 'keyboardNavNextGalleryImageTitle',

    callback() {
      navigateGallery('next');
    }

  },
  scrollOnGalleryNavigate: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavScrollOnGalleryNavigateDesc',
    title: 'keyboardNavScrollOnGalleryNavigateTitle',
    advanced: true
  },
  toggleViewImages: {
    type: 'keycode',
    requiresModules: [showImages_namespaceObject],
    value: [88, false, false, true, false],
    description: 'keyboardNavToggleViewImagesDesc',
    title: 'keyboardNavToggleViewImagesTitle',

    callback() {
      viewImagesButton().click();
    }

  },
  toggleChildren: {
    type: 'keycode',
    include: ['comments', 'inbox'],
    value: [13, false, false, false, false],
    description: 'keyboardNavToggleChildrenDesc',
    title: 'keyboardNavToggleChildrenTitle',
    callback: toggleChildren
  },
  followComments: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [67, false, false, false, false],
    description: 'keyboardNavFollowCommentsDesc',
    title: 'keyboardNavFollowCommentsTitle',

    callback() {
      followComments();
    }

  },
  followCommentsNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [67, false, false, true, false],
    description: 'keyboardNavFollowCommentsNewTabDesc',
    title: 'keyboardNavFollowCommentsNewTabTitle',

    callback() {
      followComments(true);
    }

  },
  followLinkAndCommentsNewTab: {
    type: 'keycode',
    requiresModules: [singleClick_namespaceObject],
    value: [76, false, false, false, false],
    description: 'keyboardNavFollowLinkAndCommentsNewTabDesc',
    title: 'keyboardNavFollowLinkAndCommentsNewTabTitle',

    callback() {
      invokeOnPostMap.get(getSelected())(true);
    }

  },
  followLinkAndCommentsNewTabBG: {
    type: 'keycode',
    requiresModules: [singleClick_namespaceObject],
    value: [76, false, false, true, false],
    description: 'keyboardNavFollowLinkAndCommentsNewTabBGDesc',
    title: 'keyboardNavFollowLinkAndCommentsNewTabBGTitle',

    callback() {
      invokeOnPostMap.get(getSelected())(false);
    }

  },
  upVote: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [65, false, false, false, false],
    description: 'keyboardNavUpVoteDesc',
    title: 'keyboardNavUpVoteTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('upmod');
    }

  },
  downVote: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [90, false, false, false, false],
    description: 'keyboardNavDownVoteDesc',
    title: 'keyboardNavDownVoteTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('downmod');
    }

  },
  upVoteWithoutToggling: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [65, false, false, true, false],
    description: 'keyboardNavUpVoteWithoutTogglingDesc',
    title: 'keyboardNavUpVoteWithoutTogglingTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('upmod', true);
    }

  },
  downVoteWithoutToggling: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'comments', 'inbox', 'search'],
    value: [90, false, false, true, false],
    description: 'keyboardNavDownVoteWithoutTogglingDesc',
    title: 'keyboardNavDownVoteWithoutTogglingTitle',
    mustBeLoggedIn: true,

    callback() {
      vote('downmod', true);
    }

  },
  savePost: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'comments'],
    value: [83, false, false, false, false],
    description: 'keyboardNavSavePostDesc',
    title: 'keyboardNavSavePostTitle',
    mustBeLoggedIn: true,

    callback() {
      Object(dom["c" /* click */])(getFirstElementInThingByQuery('.link-save-button a, .link-unsave-button a', ASSERT));
    }

  },
  saveComment: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist'],
    value: [83, false, false, true, false],
    description: 'keyboardNavSaveCommentDesc',
    title: 'keyboardNavSaveCommentTitle',
    mustBeLoggedIn: true,

    callback() {
      Object(dom["c" /* click */])(getFirstElementInThingByQuery('.comment-save-button > a', ASSERT));
    }

  },
  saveRES: {
    type: 'keycode',
    requiresModules: [saveComments_namespaceObject],
    value: [83, false, false, false, false],
    description: 'keyboardNavSaveRESDesc',
    title: 'keyboardNavSaveRESTitle',

    callback() {
      Object(dom["c" /* click */])(getFirstElementInThingByQuery('.saveComments, .unsaveComments', ASSERT));
      showEducationalNotification();
    }

  },
  reply: {
    type: 'keycode',
    include: ['comments', 'inbox'],
    value: [82, false, false, false, false],
    description: 'keyboardNavReplyDesc',
    title: 'keyboardNavReplyTitle',
    mustBeLoggedIn: true,
    callback: reply
  },
  edit: {
    type: 'keycode',
    include: ['comments', 'profile'],
    value: [69, false, false, false, false],
    description: 'keyboardNavEditDesc',
    title: 'keyboardNavEditTitle',
    mustBeLoggedIn: true,

    callback() {
      Object(dom["c" /* click */])(getFirstElementInThingByQuery('.entry .edit-usertext', ASSERT, getSelected()));
    }

  },
  showChildComments: {
    type: 'keycode',
    requiresModules: [hideChildComments_namespaceObject],
    value: [67, false, false, false, false],
    description: 'keyboardNavShowChildCommentsDesc',
    title: 'keyboardNavShowChildCommentsTitle',

    callback(selected = getSelected()) {
      hideChildComments_toggle(selected);
    }

  },
  showAllChildComments: {
    type: 'keycode',
    requiresModules: [hideChildComments_namespaceObject],
    value: [67, false, false, true, false],
    description: 'keyboardNavShowAllChildCommentsDesc',
    title: 'keyboardNavShowAllChildCommentsTitle',

    callback() {
      toggleAll();
    }

  },
  followPermalink: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [89, false, false, false, false],
    description: 'keyboardNavFollowPermalinkDesc',
    title: 'keyboardNavFollowPermalinkTitle',

    callback() {
      followPermalink();
    }

  },
  followPermalinkNewTab: {
    type: 'keycode',
    include: ['comments', 'commentsLinklist', 'inbox'],
    value: [89, false, false, true, false],
    description: 'keyboardNavFollowPermalinkNewTabDesc',
    title: 'keyboardNavFollowPermalinkNewTabTitle',

    callback() {
      followPermalink(true);
    }

  },
  followSubreddit: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [82, false, false, false, false],
    description: 'keyboardNavFollowSubredditDesc',
    title: 'keyboardNavFollowSubredditTitle',

    callback() {
      followSubreddit();
    }

  },
  followSubredditNewTab: {
    type: 'keycode',
    include: ['linklist', 'modqueue', 'profile', 'search'],
    value: [82, false, false, true, false],
    description: 'keyboardNavFollowSubredditNewTabDesc',
    title: 'keyboardNavFollowSubredditNewTabTitle',

    callback() {
      followSubreddit(true);
    }

  },
  followProfile: {
    type: 'keycode',
    include: ['linklist', 'comments', 'commentsLinklist', 'inbox', 'modqueue', 'search'],
    value: [85, false, false, false, false],
    description: 'keyboardNavFollowProfileDesc',
    title: 'keyboardNavFollowProfileTitle',

    callback() {
      followProfile();
    }

  },
  followProfileNewTab: {
    type: 'keycode',
    include: ['linklist', 'comments', 'commentsLinklist', 'inbox', 'modqueue', 'search'],
    value: [85, false, false, true, false],
    description: 'keyboardNavFollowProfileNewTabDesc',
    title: 'keyboardNavFollowProfileNewTabTitle',

    callback() {
      followProfile(true);
    }

  },
  toggleCommentNavigator: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [78, false, false, false, false],
    description: 'keyboardNavToggleCommentNavigatorDesc',
    title: 'keyboardNavToggleCommentNavigatorTitle',

    callback() {
      commentNavigator_toggle(true);
    }

  },
  commentNavigatorMoveUp: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [38, false, false, true, false],
    description: 'keyboardNavCommentNavigatorMoveUpDesc',
    title: 'keyboardNavCommentNavigatorMoveUpTitle',

    callback() {
      commentNavigator_move('up', 'keyboard');
    }

  },
  commentNavigatorMoveDown: {
    type: 'keycode',
    requiresModules: [commentNavigator_namespaceObject],
    value: [40, false, false, true, false],
    description: 'keyboardNavCommentNavigatorMoveDownDesc',
    title: 'keyboardNavCommentNavigatorMoveDownTitle',

    callback() {
      commentNavigator_move('down', 'keyboard');
    }

  },
  focusOnSearchBox: {
    type: 'keycode',
    value: [191, true, false, false, false],
    description: 'keyboardNavFocusOnSearchBoxDesc',
    title: 'keyboardNavFocusOnSearchBoxTitle',

    callback() {
      document.querySelector('#search input[name="q"]').focus();
    }

  },
  useGoMode: {
    type: 'boolean',
    value: true,
    description: 'keyboardNavUseGoModeDesc',
    title: 'keyboardNavUseGoModeTitle'
  },
  goMode: {
    type: 'keycode',
    value: [71, false, false, false, false],
    description: 'keyboardNavGoModeDesc',
    title: 'keyboardNavGoModeTitle',
    dependsOn: options => options.useGoMode.value,

    callback() {
      if (keyboardNav_module.options.useGoMode.value) toggleGoMode();
    }

  },
  inbox: {
    type: 'keycode',
    value: [73, false, false, false, false],
    description: 'keyboardNavInboxDesc',
    title: 'keyboardNavInboxTitle',

    callback() {
      keyboardNav_navigateTo('/message/inbox/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  inboxNewTab: {
    type: 'keycode',
    value: [73, false, false, true, false],
    description: 'keyboardNavInboxNewTabDesc',
    title: 'keyboardNavInboxNewTabTitle',

    callback() {
      keyboardNav_navigateTo('/message/inbox/', {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  modmail: {
    type: 'keycode',
    value: [77, false, false, false, false],
    description: 'keyboardNavModmailDesc',
    title: 'keyboardNavModmailTitle',

    callback() {
      keyboardNav_navigateTo('/message/moderator/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  modmailNewTab: {
    type: 'keycode',
    value: [77, false, false, true, false],
    description: 'keyboardNavModmailNewTabDesc',
    title: 'keyboardNavModmailNewTabTitle',

    callback() {
      keyboardNav_navigateTo('/message/moderator/', {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  profile: {
    type: 'keycode',
    value: [85, false, false, false, false],
    description: 'keyboardNavProfileDesc',
    title: 'keyboardNavProfileTitle',

    callback() {
      const user = loggedInUser();
      if (user) keyboardNav_navigateTo(`/user/${user}`, {
        leaveNP: true
      });
    },

    goMode: true
  },
  profileNewTab: {
    type: 'keycode',
    value: [85, false, false, true, false],
    description: 'keyboardNavProfileNewTabDesc',
    title: 'keyboardNavProfileNewTabTitle',

    callback() {
      const user = loggedInUser();
      if (user) keyboardNav_navigateTo(`/user/${user}`, {
        newWindow: true,
        leaveNP: true
      });
    },

    goMode: true
  },
  frontPage: {
    type: 'keycode',
    value: [70, false, false, false, false],
    description: 'keyboardNavFrontPageDesc',
    title: 'keyboardNavFrontPageTitle',

    callback() {
      keyboardNav_navigateTo('/', {
        leaveNP: true
      });
    },

    goMode: true
  },
  slashAll: {
    type: 'keycode',
    value: [65, true, false, false, false],
    description: 'keyboardNavSlashAllDesc',
    title: 'keyboardNavSlashAllTitle',

    callback() {
      keyboardNav_navigateTo('/r/all', {
        leaveNP: true
      });
    },

    goMode: true
  },
  subredditFrontPage: {
    type: 'keycode',
    value: [70, false, false, true, false],
    description: 'keyboardNavsSubredditFrontPageDesc',
    title: 'keyboardNavsSubredditFrontPageTitle',

    callback() {
      const sub = Object(utils_location["d" /* currentSubreddit */])();
      if (sub) keyboardNav_navigateTo(`/r/${sub}`, {
        leaveNP: false
      });
    },

    goMode: true
  },
  random: {
    type: 'keycode',
    value: [89, true, false, false, false],
    description: 'keyboardNavRandomDesc',
    title: 'keyboardNavRandomTitle',

    callback() {
      keyboardNav_navigateTo('/r/random', {
        leaveNP: true
      });
    },

    goMode: true
  },
  nextPage: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox'],
    value: [78, false, false, false, false],
    description: 'keyboardNavNextPageDesc',
    title: 'keyboardNavNextPageTitle',

    callback() {
      if (isRunning(neverEndingReddit_namespaceObject)) {
        loadNextPage({
          scrollToLoadWidget: true
        });
      } else {
        const next = getNextPrevLinks().next;
        if (next) location.href = next;
      }
    },

    goMode: true
  },
  prevPage: {
    type: 'keycode',
    include: ['linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox'],
    value: [80, false, false, false, false],
    description: 'keyboardNavPrevPageDesc',
    title: 'keyboardNavPrevPageTitle',

    callback() {
      if (!isRunning(neverEndingReddit_namespaceObject)) {
        const prev = getNextPrevLinks().prev;
        if (prev) location.href = prev;
      }
    },

    goMode: true
  },
  overviewLegacy: {
    type: 'keycode',
    include: ['d2x', 'profile'],
    value: [79, false, false, true, false],
    description: 'keyboardNavOverviewLegacyDesc',
    title: 'keyboardNavOverviewLegacyTitle',

    callback() {
      const currentUser = Object(utils_location["e" /* currentUserProfile */])();
      if (currentUser) keyboardNav_navigateTo(`/user/${currentUser}/overview`, {
        leaveNP: true
      });
    },

    goMode: true
  },
  profileView: {
    type: 'keycode',
    include: ['d2x', 'profile'],
    value: [80, false, false, true, false],
    description: 'keyboardNavProfileViewDesc',
    title: 'keyboardNavProfileViewTitle',

    callback() {
      const currentUser = Object(utils_location["e" /* currentUserProfile */])();
      if (currentUser) keyboardNav_navigateTo(`/user/${currentUser}`, {
        leaveNP: true
      });
    },

    goMode: true
  }
};

keyboardNav_module.beforeLoad = () => {
  keyboardNav_registerCommandLine();

  if (keyboardNav_module.options.linkNumbers.value) {
    selectedThing_namespaceObject.addListener(updateLinkAnnotations, 'instantly');
    Object(watchers["watchForElements"])(['selfText'], null, element => {
      const thing = Thing["a" /* Thing */].from(element);
      if (selectedThing_namespaceObject.current === thing) updateLinkAnnotations(thing);
    });
  }
};

keyboardNav_module.contentStart = () => {
  window.addEventListener('keydown', handleKeyPress, true);
};

function keyboardNav_registerCommandLine() {
  registerCommand(/\d+/, '[number] - navigates to the link with that number (if annotation exists) or rank (link pages)', () => {}, command => {
    const number = parseInt(command, 10);
    const annotation = linkAnnotations[number - 1];

    if (annotation) {
      if (!document.contains(annotation.link)) {
        console.log('Annotation refers to removed link; ignoring');
        return;
      }

      openLink(number - 1);
    } else {
      followLinkByRank(number);
    }
  });
}

let linkAnnotations = [];

function updateLinkAnnotations(selected) {
  for (const {
    annotation
  } of linkAnnotations) annotation.remove();

  linkAnnotations = Array.from(selected && selected.entry.querySelectorAll('div.md a:not(.noKeyNav)') || []).filter(link => !Object(utils_location["j" /* isCommentCode */])(link) && !Object(utils_location["m" /* isEmptyLink */])(link)).map((link, i) => {
    const number = i + 1;
    const title = number < 10 ? `press ${number} to open link` : number === 10 ? 'press 0 to open link' : `press ${keycode_niceKeyCode(keyboardNav_module.options.toggleCmdLine.value)} then ${number} and Enter to open link`;
    const annotation = string_namespaceObject.html`<span class="noCtrlF keyNavAnnotation" data-text="[${number}]" title="${title}"></span>`;
    if (keyboardNav_module.options.linkNumberPosition.value === 'right') link.after(annotation);else link.before(annotation);
    return {
      annotation,
      link
    };
  });
}

function toggleKeyNavHelp() {
  const slideSpeed = 400;

  if (!drawHelp().attr('shown')) {
    drawHelp().attr('shown', 'false');
    drawHelp().css({
      right: '-350px'
    });
    drawHelp().show();
  }

  if (drawHelp().attr('shown') === 'true') {
    drawHelp().animate({
      right: '-350px'
    }, slideSpeed);
    drawHelp().attr('shown', 'false');
  } else {
    drawHelp().animate({
      right: '20px'
    }, slideSpeed);
    drawHelp().attr('shown', 'true');
  }
}

const drawHelp = Object(once["a" /* default */])(() => {
  const keys = Object(utils_array["c" /* filterMap */])(getActiveCommandOptions(), opt => {
    let keyCode = keycode_niceKeyCode(opt.value);

    if (opt.goMode && keyboardNav_module.options.useGoMode.value) {
      keyCode = `${keycode_niceKeyCode(keyboardNav_module.options.goMode.value)} → ${keyCode}`;
    }

    return [{
      keyCode,
      description: i18n(opt.description)
    }];
  });
  return jquery_default()(string_namespaceObject.html`
		<div id="keyHelp">
			<table>
				<thead>
					<tr><th>Key</th><th>Function</th></tr>
				</thead>
				<tbody>
					${keys.map(({
    keyCode,
    description
  }) => string_namespaceObject._html`
						<tr><td>${keyCode}</td><td>${description}</td></tr>
					`)}
				</tbody>
			</table>
		</div>
	`).appendTo(document.body);
});

function getLinkKeys() {
  const altModeModifier = keyboardNav_module.options.linkNumberAltModeModifier.value;
  const keys = [];

  function addKey(key, index) {
    keys.push({
      value: [key, false, false, false, false],

      callback() {
        openLink(index);
      }

    });

    if (altModeModifier !== 'none') {
      keys.push({
        value: [key, altModeModifier === 'alt', false, altModeModifier === 'shift', false],

        callback() {
          openLink(index, true);
        }

      });
    }
  }

  if (keyboardNav_module.options.linkNumbers.value) {
    [49, 50, 51, 52, 53, 54, 55, 56, 57, 48].forEach(addKey);
    [97, 98, 99, 100, 101, 102, 103, 104, 105, 96].forEach(addKey);
  }

  return keys;
}

const getActiveCommandOptions = Object(once["a" /* default */])(() => Object(utils_array["c" /* filterMap */])(Object.values(keyboardNav_module.options), option => {
  if (option.type === 'keycode' && option.callback && (!option.dependsOn || option.dependsOn(keyboardNav_module.options)) && (!option.include || Object(utils_location["o" /* matchesPageLocation */])(option.include)) && (!option.mustBeLoggedIn || loggedInUser()) && (!option.requiresModules || option.requiresModules.every(isRunning))) {
    return [option];
  }
}));

const _commandLookup = Object(once["a" /* default */])(() => {
  const lookup = {};

  for (const option of [...getActiveCommandOptions(), ...getLinkKeys()]) {
    const hash = hashKeyArray(option.value);

    if (!lookup[hash]) {
      lookup[hash] = [];
    }

    lookup[hash].push(option);
  }

  return lookup;
});

function handleKeyPress(e) {
  if (konamiActive()) return;

  if (document.activeElement && ['A', 'BUTTON'].includes(document.activeElement.tagName)) {
    const hasDefaultBehavior = [NAMED_KEYS.Tab, NAMED_KEYS.Enter, NAMED_KEYS.Space].includes(e.key);
    if (hasDefaultBehavior) return;
  } else if (document.activeElement && document.activeElement.tagName !== 'BODY') {
    return;
  }

  const hash = hashKeyEvent(e);
  const options = (_commandLookup()[hash] || []).filter(v => {
    if (v.goMode) return keyboardNav_module.options.useGoMode.value === goModeActive;else return !goModeActive;
  });

  if (options.length) {
    handleCallbacks(options);
    e.preventDefault();
    e.target.blur();
  }
}

async function handleCallbacks(options) {
  if (options.some(v => v.goMode)) {
    if (goModeActive) toggleGoMode();

    if (options.length > 1) {
      const shortcut = keycode_niceKeyCode(options[0].value);
      options = await promptUniqueShortcut(shortcut, options);
    }
  }

  for (const option of options) {
    try {
      option.callback();
    } catch (e) {
      console.error('Could not execute callback', i18n(option.title), e);
    }
  }
}

const promptUniqueShortcut = Object(memoize["a" /* default */])(async (shortcut, options) => {
  const question = i18n('keyboardNavAmbiguousShortcutPrompt', i18n(keyboardNav_module.moduleName), `<i>${shortcut}</i>`, '<br><br>', `<i>${shortcut}</i>`);
  const optionButtons = options.map(option => [option, jquery_default()(`<button style="width: 100%; margin-top: 2px;">${i18n(option.description)}</button>`).get(0)]);
  const followUp = i18n('keyboardNavAmbiguousShortcutPromptFollowUp', makeUrlHashLink(keyboardNav_module.moduleID, undefined, i18n(keyboardNav_module.moduleName)));
  const message = jquery_default()(`<div>${question}</div>`).append(optionButtons.map(([, button]) => button)).append(`<br><br><small>(${followUp})</small>`).get(0);
  const notification = notifications_showNotification({
    moduleID: keyboardNav_module.moduleID,
    header: 'Ambiguous shortcut',
    message,
    noDisable: true,
    closeDelay: Infinity
  });
  const preservedOption = await Promise.race(optionButtons.map(([option, button]) => Object(dom["r" /* waitForEvent */])(button, 'click').then(() => option)));

  for (const option of lodash_es_without(options, preservedOption)) {
    option.value = [-1, false, false, false, false];
    options_save(option);
  }

  notification.close();
  return [preservedOption];
});

function getSelected() {
  const selected = selectedThing_namespaceObject.current;
  if (!selected) throw new Error('A entry must be selected');
  if (!selected.isVisible()) throw new Error('Entry must be visible');
  return selected;
}

const ASSERT = true;
const NOASSERT = false;

function assertElement(element) {
  if (!element) throw new Error('Element not available');
  return element;
}

function getFirstElementInThingByQuery(query, assertExistance, thing = getSelected()) {
  const element = thing.entry.querySelector(query);
  return assertExistance ? assertElement(element) : element;
}

function getElementsInThingByQuery(query, assertLength, thing = getSelected()) {
  const elements = Array.from(thing.entry.querySelectorAll(query));
  if (assertLength) assertElement(elements[0]);
  return elements;
}

function getMostVisibleElementInThingByQuery(query, assertLength, thing) {
  return lodash_es_maxBy(getElementsInThingByQuery(query, assertLength, thing), dom["h" /* getPercentageVisibleYAxis */]);
}

function hideLink(selected = getSelected()) {
  const hide = assertElement(selected.getHideElement());

  if (keyboardNav_module.options.onHideMoveDown.value) {
    selectedThing_namespaceObject.move('down', {
      allowMediaBrowse: true,
      scrollStyle: 'none'
    }, moveDownFallback);
  }

  Object(dom["c" /* click */])(hide);
}

function followSubreddit(newWindow = false, selected = getSelected()) {
  const a = Object(flow["a" /* downcast */])(assertElement(selected.getSubredditLink()), HTMLAnchorElement);
  keyboardNav_navigateTo(a.href, {
    newWindow,
    leaveNP: true
  });
}

function followProfile(newWindow = false, selected = getSelected()) {
  keyboardNav_navigateTo(selected.getAuthorUrl(), {
    newWindow,
    leaveNP: true
  });
}

function toggleChildren(selected = getSelected()) {
  if (selected.element.classList.contains('link')) return;
  Object(dom["c" /* click */])(assertElement(getFirstElementInThingByQuery('span.deepthread > a', NOASSERT, selected) || getFirstElementInThingByQuery('span.morecomments > a', NOASSERT, selected) || getFirstElementInThingByQuery('a.expand', NOASSERT, selected)));
}

function imageResize({
  factor = 1,
  removeHeightRestriction = false
}) {
  const mostVisible = getMostVisibleElementInThingByQuery('.res-media-zoomable', ASSERT);
  if (removeHeightRestriction) mostVisible.style.maxHeight = 'none';
  resize(mostVisible, mostVisible.clientWidth * factor);
}

function imageMove(deltaX, deltaY) {
  const mostVisible = getMostVisibleElementInThingByQuery('.res-media-movable', ASSERT);
  showImages_move(mostVisible, deltaX, deltaY);
}

function navigateGallery(direction) {
  const gallery = getMostVisibleElementInThingByQuery('.res-gallery', ASSERT);
  assertElement(gallery.querySelector(`.res-step-${direction}`)).click();

  if (keyboardNav_module.options.scrollOnGalleryNavigate.value) {
    Object(dom["l" /* scrollToElement */])(assertElement(gallery.querySelector('.res-gallery-pieces')), null, {
      scrollStyle: 'directional',
      restrictDirectionTo: 'up'
    });
  }
}

function followLink(newWindow = false, selected = getSelected()) {
  if (Object(utils_location["n" /* isPageType */])('comments') && !selected.element.classList.contains('link')) return;
  const a = selected.getPostLink();
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function followLinkByRank(num) {
  const target = Thing["a" /* Thing */].visibleThings().find(v => v.getRank() === num);
  if (!target) throw new Error(`Could not find visible entry at rank ${num}`);
  selectedThing_namespaceObject.set(target);
  followLink();
}

function followPermalink(newWindow = false) {
  const a = Object(flow["a" /* downcast */])(getFirstElementInThingByQuery('a.bylink', ASSERT), HTMLAnchorElement);
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function followComments(newWindow = false, selected = getSelected()) {
  const a = assertElement(selected.getCommentsLink());
  keyboardNav_navigateTo(a.href, {
    newWindow
  });
}

function vote(way, preventToggle = false, selected = getSelected()) {
  const button = assertElement(way === 'upmod' ? selected.getUpvoteButton() : selected.getDownvoteButton());

  if (button.classList.contains('archived')) {} else if (isVotingBlocked()) {
    notifyNoVote();
  } else if (!preventToggle || !button.classList.contains(way)) {
    Object(dom["c" /* click */])(button);
  }

  if (selected.isComment()) {
    if (keyboardNav_module.options.onVoteCommentMoveDown.value) keyboardNav_module.options.moveDownComment.callback();
  } else {
    if (keyboardNav_module.options.onVoteMoveDown.value) keyboardNav_module.options.moveDown.callback();
  }
}

function reply(selected = getSelected()) {
  if (selected.element.classList.contains('link') && Object(utils_location["n" /* isPageType */])('comments')) {
    const $target = jquery_default()('.usertext-edit textarea[name=text]:first');

    if ($target.filter(':visible').length) {
      $target.focus();
      return;
    }
  }

  Object(dom["c" /* click */])(assertElement(getFirstElementInThingByQuery('.buttons a[onclick*=reply]', NOASSERT, selected) || getFirstElementInThingByQuery('.buttons a.comments, .buttons a.bylink', NOASSERT, selected)));
}

function keyboardNav_navigateTo(href, options) {
  if (options.leaveNP && modules_isEnabled(noParticipation_namespaceObject) && noParticipation_module.options.escapeNP.value) {
    href = nonNpLocation(href);
  }

  if (options.newWindow) {
    openNewTab(href, keyboardNav_module.options.followLinkNewTabFocus.value);
  } else {
    location.href = href;
  }
}

const goModePanel = Object(once["a" /* default */])(() => {
  const goModes = getActiveCommandOptions().filter(opt => opt.goMode).map(opt => ({
    key: i18n(opt.title),
    niceKeyCode: keycode_niceKeyCode(opt.value)
  }));
  return jquery_default()(string_namespaceObject.html`
		<div id="goModePanel" class="RESDialogSmall">
			<h3>Press a key to go:</h3>
			<div class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESDialogContents">
				<table>
					${goModes.map(({
    niceKeyCode,
    key
  }) => string_namespaceObject._html`
						<tr>
							<td>${niceKeyCode}</td>
							<td class="arrow">&rarr;</td>
							<td>${key}</td>
						</tr>
					`)}
				</table>
			</div>
		</div>
	`).find('.RESCloseButton').click(toggleGoMode).end();
});
let goModeActive = false;

function toggleGoMode() {
  goModeActive = !goModeActive;

  if (goModeActive) {
    jquery_default()(document.body).on('keyup', handleGoModeEscapeKey);
    goModePanel().appendTo(document.body).fadeIn();
  } else {
    goModePanel().fadeOut();
    jquery_default()(document.body).off('keyup', handleGoModeEscapeKey);
  }
}

function handleGoModeEscapeKey(event) {
  if (event.key === NAMED_KEYS.Escape) {
    toggleGoMode();
  }
}

function moveDownFallback() {
  const bump = isRunning(neverEndingReddit_namespaceObject) && (!selectedThing_namespaceObject.current || [selectedThing_namespaceObject.current, undefined].includes(Thing["a" /* Thing */].visibleThings().slice(-1)[0]));
  if (bump) loadNextPage({
    scrollToLoadWidget: true
  });
}

function openLink(index, altMode = false) {
  const link = linkAnnotations[index] && linkAnnotations[index].link;
  if (!link) throw Error(`Link annotation ${index} is not available`);
  const expando = getLinkExpando(link);

  if (expando && keyboardNav_module.options.linkToggleExpando.value !== altMode) {
    Object(dom["c" /* click */])(expando.button);
  } else if (isSettingsUrl(link.href)) {
    settingsNavigation_update(link);
  } else if (keyboardNav_module.options.linkNewTab.value) {
    openNewTab(link.href, keyboardNav_module.options.followLinkNewTabFocus.value);
  } else {
    location.href = link.href;
  }
}
// CONCATENATED MODULE: ./lib/modules/RESTips.js













const RESTips_module = new Module('RESTips');
RESTips_module.moduleName = 'resTipsName';
RESTips_module.category = 'aboutCategory';
RESTips_module.description = 'resTipsDesc';
RESTips_module.options = {
  menuItem: {
    title: 'RESTipsMenuItemTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsMenuItemDesc'
  },
  dailyTip: {
    title: 'RESTipsDailyTipTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsDailyTipDesc'
  },
  newFeatureTips: {
    title: 'RESTipsNewFeatureTipsTitle',
    type: 'boolean',
    value: true,
    description: 'RESTipsNewFeatureTipsDesc'
  }
};
RESTips_module.include = ['r2'];
const featureTipsStorage = storage_namespaceObject.wrapPrefix('RESTips.featureTips.', () => ({
  enabled: true
}));
const lastTooltipStorage = storage_namespaceObject.wrap('RESLastToolTip', 0);

RESTips_module.contentStart = () => {
  if (RESTips_module.options.menuItem.value) {
    menu_addMenuItem(() => string_namespaceObject.html`<span>${i18n('tipsAndTricks')}</span>`, () => {
      showOrdinaryTip('random');
    });
  }
};

let allowFeatureTips;
const RESTips_featureTips = new Map();
const featureTipReadyPromise = new Promise(resolve => {
  allowFeatureTips = () => resolve(true);
});

RESTips_module.afterLoad = async () => {
  const showsDailyTip = RESTips_module.options.dailyTip.value && (await dailyTip());
  if (RESTips_module.options.newFeatureTips.value && !showsDailyTip) allowFeatureTips();
};

const newFeatureTipsCheckbox = Object(once["a" /* default */])(() => jquery_default()('<label><input type="checkbox" name="disableNewFeatureTipsCheckbox" checked />Show these tips when new features appear</label>').click(e => {
  RESTips_module.options.newFeatureTips.value = e.currentTarget.querySelector('input').checked;
  options_save(RESTips_module.options.newFeatureTips);
}));
const addFeatureTip = Object(memoize["a" /* default */])(async (id, tip) => {
  tip.onHide = () => {
    featureTipsStorage.set(id, {
      enabled: false
    });
  };

  RESTips_featureTips.set(id, tip);
  tips.push(tip);
  if (!tip.quiet && (await featureTipReadyPromise) && (await featureTipsStorage.get(id).then(({
    enabled
  }) => enabled))) showFeatureTip(id);
});
const showFeatureTip = Object(utils_async["h" /* mutex */])(id => {
  const tip = RESTips_featureTips.get(id);

  if (!tip) {
    console.error('Feature tip is not added', id);
    return;
  }

  if (tip.attachTo instanceof Element && !Object(dom["d" /* elementInViewport */])(tip.attachTo)) {
    console.log('Ignoring feature tip whose attachment element is not visible:', tip);
    return;
  }

  return showTip(tip, {
    title: 'New feature',
    classString: 'res-featureTip',
    buttonCustomHTML: newFeatureTipsCheckbox(),
    buttons: []
  });
});

async function dailyTip() {
  const lastCheck = await lastTooltipStorage.get();
  const now = Date.now();
  const delay = penalizedDelay(RESTips_module.moduleID, 'dailyTip', {
    value: utils_time["a" /* DAY */],
    default: utils_time["a" /* DAY */]
  });

  if (now - lastCheck > delay) {
    lastTooltipStorage.set(now);

    if (lastCheck === 0) {
      await showOrdinaryTip();
    } else {
      alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', lodash_es_clamp(MAX_PENALTY / tips.length, 3, 8));
      await showOrdinaryTip('random');
    }

    return true;
  }

  return false;
}

function generateContent({
  message,
  keyboard,
  options
}) {
  const description = [];
  if (typeof message === 'function') description.push(message());else if (typeof message === 'string') description.push(message);

  if (keyboard) {
    const disabled = !modules_isEnabled(keyboardNav_namespaceObject);
    description.push(`<h2 class="keyboardNav${disabled ? 'keyboardNavDisabled' : ''}">`);
    description.push(`Keyboard Navigation${disabled ? ' (disabled)' : ''}`);
    description.push('</h2>');
    const keyboardTable = createElement_namespaceObject.table(keyboard, generateContentKeyboard);
    if (keyboardTable) description.push(keyboardTable);
  }

  if (options) {
    for (const option of options) {
      description.push('<h2 class="settingsPointer">');
      description.push('<span class="gearIcon"></span> RES Settings');
      description.push('</h2>');
      const optionTable = createElement_namespaceObject.table(option, generateContentOption);
      if (optionTable) description.push(optionTable);
    }
  }

  return jquery_default()('<div />').html(description.join('\n'));
}

function generateContentKeyboard(keyboardNavOption) {
  const keyCode = keycode_niceKeyCode(keyboardNav_module.options[keyboardNavOption].value);
  if (!keyCode) return false;
  const description = [];
  description.push('<tr>');
  description.push(`<td><code>${keyCode.toLowerCase()}</code></td>`);
  description.push(`<td>${keyboardNavOption}</td>`);
  description.push('</tr><tr>');
  description.push('<td>&nbsp;</td>');
  description.push(`<td>${i18n(keyboardNav_module.options[keyboardNavOption].description)}</td>`);
  description.push('</tr>');
  return description;
}

function generateContentOption(option) {
  const mod = getUnchecked(option.moduleID);
  if (!mod) return false;
  const description = [];
  description.push('<tr>');
  description.push(`<td>${i18n(mod.category)}</td>`);
  description.push('<td>');
  description.push(makeUrlHashLink(option.moduleID, undefined, i18n(mod.moduleName)));
  description.push('</td>');
  description.push('<td>');
  description.push(option.key ? makeUrlHashLink(option.moduleID, option.key) : '&nbsp;');
  description.push('</td>');

  if (option.key && mod.options[option.key]) {
    description.push('</tr><tr>');
    description.push(`<td colspan="3">${i18n(mod.options[option.key].description)}</td>`);
  }

  description.push('</tr>');
  return description;
}

const tips = [{
  message: `
		Welcome to RES, a community-driven unofficial browser extension for Reddit. You can turn on, turn off, or change options for RES features using the gear icon link at the top right.
		<p>For feature requests, or just help getting a question answered, be sure to subscribe to <a href="/r/Enhancement">/r/Enhancement</a>.</p>
		<p>If RES has enhanced your reddit experience, please show your appreciation by <a href="${RES_SETTINGS_HASH}/contribute">donating or contributing!</a></p>
		`,
  attachTo: '#RESSettingsButton',
  position: 5
}, {
  message: 'Click the tag icon next to a user to tag that user with any name you like - you can also color code the tag.',
  attachTo: '.RESUserTagImage',
  position: 3,
  options: [{
    moduleID: 'userTagger'
  }]
}, {
  message: 'If your RES data gets deleted or you move to a new computer, you can restore it from backup. <br><br><b>Firefox</b> especially sometimes loses your RES settings and data. <br><br><a href="/r/Enhancement/wiki/backing_up_res_settings" target="_blank" rel="noopener noreferer">Learn where RES stores your data and settings</a></p>',
  title: 'Back up your RES data!'
}, {
  message: 'Don\'t forget to subscribe to <a href="/r/Enhancement">/r/Enhancement</a> to keep up to date on the latest versions of RES or suggest features! For bug reports, submit to <a href="/r/RESIssues">/r/RESIssues</a>'
}, {
  message: 'Don\'t want to see posts containing certain keywords? Want to filter out certain subreddits from /r/all? Try the filteReddit module!',
  options: [{
    moduleID: 'filteReddit'
  }]
}, {
  message: 'Keyboard Navigation is one of the most underutilized features in RES. You should try it!',
  options: [{
    moduleID: 'keyboardNav'
  }],
  keyboard: 'toggleHelp'
}, {
  message: 'Did you know you can configure the appearance of a number of things in RES? For example: Selected Entry lets you configure the look of the "selected" box, and commentBoxes lets you configure the borders / shadows.',
  options: [{
    moduleID: 'selectedEntry',
    key: 'setColors'
  }, {
    moduleID: 'commentStyle',
    key: 'commentBoxes'
  }]
}, {
  message: 'Do you subscribe to a ton of subreddits? Give the subreddit tagger a try; it can make your homepage a bit more readable.',
  options: [{
    moduleID: 'subRedditTagger'
  }]
}, {
  message: 'If you haven\'t tried it yet, Keyboard Navigation is great. Just hit ? while browsing for instructions.',
  options: [{
    moduleID: 'keyboardNav'
  }],
  keyboard: 'toggleHelp'
}, {
  message: 'Roll over a user\'s name to get information about them such as their karma, and how long they\'ve been a reddit user.',
  options: [{
    moduleID: 'userInfo',
    key: 'hoverInfo'
  }]
}, {
  message: 'Hover over the "parent" link in comments pages to see the text of the parent being referred to.',
  options: [{
    moduleID: 'showParent'
  }]
}, {
  message: 'You can configure the color and style of the User Highlighter module if you want to change how the highlights look.',
  options: [{
    moduleID: 'userHighlight'
  }]
}, {
  message: 'Not a fan of how comments pages look? You can change the appearance in the Style Tweaks module',
  options: [{
    moduleID: 'styleTweaks'
  }]
}, {
  message: 'Don\'t like the style in a certain subreddit? RES gives you a checkbox to disable styles individually - check the right sidebar!'
}, {
  message: 'Looking for posts by submitter, post with photos, or posts in IAmA form? Try out the comment navigator.'
}, {
  message: 'Have you seen the <a href="/r/Dashboard">RES Dashboard</a>? It allows you to do all sorts of great stuff, like keep track of lower traffic subreddits, and manage your <a href="/r/Dashboard#userTaggerContents">user tags</a> and <a href="/r/Dashboard#newCommentsContents">thread subscriptions</a>!',
  options: [{
    moduleID: 'dashboard'
  }]
}, {
  message: 'Sick of seeing these tips?  They only show up once every 24 hours, but you can disable that in the RES Tips and Tricks preferences.',
  options: [{
    moduleID: 'RESTips'
  }]
}, {
  message: 'Did you know that there is now a "keep me logged in" option in the Account Switcher? Turn it on if you want to stay logged in to Reddit when using the switcher!',
  options: [{
    moduleID: 'accountSwitcher',
    key: 'keepLoggedIn'
  }]
}, {
  message: 'See that little [vw] next to users you\'ve voted on?  That\'s their vote weight - it moves up and down as you vote the same user up / down.',
  options: [{
    moduleID: 'userTagger',
    key: 'vwNumber'
  }]
}];
const dailyTipsCheckbox = Object(once["a" /* default */])(() => jquery_default()(`<label><input type="checkbox" name="disableDailyTipsCheckbox" ${RESTips_module.options.dailyTip.value ? 'checked' : ''} />Show these tips once every 24 hours</label>`).click(e => {
  RESTips_module.options.dailyTip.value = e.currentTarget.querySelector('input').checked;
  options_save(RESTips_module.options.dailyTip);
}));
let lastTip;

function showOrdinaryTip(change) {
  alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', 1);
  let currTipIndex = Math.max(tips.indexOf(lastTip), 0);
  let tip;

  while (!tip || tip.attachTo && !jquery_default()(tip.attachTo).is(':visible')) {
    if (change === 'random') currTipIndex = lodash_es_random(tips.length);else if (change === 'prev') currTipIndex -= 1;else if (change === 'next') currTipIndex += 1;else change = 'next';
    currTipIndex = positiveModulo(currTipIndex, tips.length);
    tip = tips[currTipIndex];
  }

  return showTip(tip, {
    buttons: [{
      name: 'Prev',
      onclick: () => showOrdinaryTip('prev')
    }, {
      name: 'Next',
      onclick: () => showOrdinaryTip('next')
    }],

    onClose() {
      alterFeaturePenalty(RESTips_module.moduleID, 'dailyTip', 4);
    },

    classString: 'res-ordinaryTip',
    buttonCustomHTML: dailyTipsCheckbox(),
    title: 'RES Tips and Tricks'
  });
}

function showTip(tip, guiderObj) {
  const {
    continuation
  } = lastTip = tip;

  if (continuation) {
    const origGuiderObj = { ...guiderObj
    };
    guiderObj.buttons = [...guiderObj.buttons, {
      name: 'More',
      onclick: async () => {
        const upcomingId = continuation();
        let nextTip;

        while (!(nextTip = RESTips_featureTips.get(upcomingId))) {
          await new Promise(r => {
            setTimeout(r, 100);
          });
        }

        showTip(nextTip, origGuiderObj);
      }
    }];
  }

  const attachTo = tip.attachTo && jquery_default()(tip.attachTo).get(0) || null;

  const toggleIncreasedZIndex = state => {
    if (attachTo) attachTo.classList.toggle('restips-increased-z-index', state);
  };

  return new Promise(resolve => {
    guiders.hideAll();
    guiders.createGuider({
      id: `res-guider-${performance.now()}`,
      closeOnEscape: true,
      xButton: true,
      description: generateContent(tip),
      ...guiderObj,
      ...tip,

      onHide() {
        if (tip.onHide) tip.onHide();
        toggleIncreasedZIndex(false);
        resolve();
      },

      attachTo
    });
    toggleIncreasedZIndex(true);
    guiders.show();
  });
}
// CONCATENATED MODULE: ./lib/modules/about.js


const about_module = new Module('about');
about_module.moduleName = 'aboutName';
about_module.category = 'aboutCategory';
about_module.sort = -10;
about_module.alwaysEnabled = true;
about_module.description = 'aboutDesc';
about_module.options = {
  presets: {
    type: 'button',
    description: 'aboutOptionsPresets',
    title: 'aboutOptionsPresetsTitle',
    text: createElement_namespaceObject.icon(0xF142),
    callback: {
      moduleID: 'presets'
    }
  },
  backup: {
    type: 'button',
    description: 'aboutOptionsBackup',
    title: 'aboutOptionsBackupTitle',
    text: createElement_namespaceObject.icon(0xF059),
    callback: {
      moduleID: 'backupAndRestore'
    }
  },
  searchSettings: {
    type: 'button',
    description: 'aboutOptionsSearchSettings',
    title: 'aboutOptionsSearchSettingsTitle',
    text: createElement_namespaceObject.icon(0xF097),
    callback: {
      moduleID: 'search'
    }
  },
  announcements: {
    type: 'button',
    description: 'aboutOptionsAnnouncements',
    title: 'aboutOptionsAnnouncementsTitle',
    text: createElement_namespaceObject.icon(0xF108),
    callback: '/r/RESAnnouncements/new'
  },
  donate: {
    type: 'button',
    description: 'aboutOptionsDonate',
    title: 'aboutOptionsDonateTitle',
    text: createElement_namespaceObject.icon(0xF104),
    callback: 'https://redditenhancementsuite.com/contribute/'
  },
  bugs: {
    type: 'button',
    description: 'aboutOptionsBugs',
    title: 'aboutOptionsBugsTitle',
    text: createElement_namespaceObject.icon(0xF003),
    callback: '/r/RESIssues/wiki/postanissue'
  },
  suggestions: {
    type: 'button',
    description: 'aboutOptionsSuggestions',
    title: 'aboutOptionsSuggestionsTitle',
    text: createElement_namespaceObject.icon(0xF076),
    callback: '/r/Enhancement'
  },
  faq: {
    type: 'button',
    description: 'aboutOptionsFAQ',
    title: 'aboutOptionsFAQTitle',
    text: createElement_namespaceObject.icon(0xF0D3),
    callback: '/r/Enhancement/wiki/index'
  },
  code: {
    type: 'button',
    description: 'aboutOptionsCode',
    title: 'aboutOptionsCodeTitle',
    text: createElement_namespaceObject.icon(0xF063),
    callback: 'https://github.com/honestbleeps/Reddit-Enhancement-Suite'
  },
  contributors: {
    type: 'button',
    description: 'aboutOptionsContributors',
    title: 'aboutOptionsContributorsTitle',
    text: createElement_namespaceObject.icon(0xF048),
    callback: 'https://redditenhancementsuite.com/about'
  },
  privacy: {
    type: 'button',
    description: 'aboutOptionsPrivacy',
    title: 'aboutOptionsPrivacyTitle',
    text: createElement_namespaceObject.icon(0xF0C2),
    callback: '/r/Enhancement/wiki/about/privacy'
  },
  license: {
    type: 'button',
    description: 'aboutOptionsLicense',
    title: 'aboutOptionsLicenseTitle',
    text: createElement_namespaceObject.icon(0xF0D3),
    callback: 'https://www.gnu.org/licenses/gpl-3.0.html'
  }
};
// CONCATENATED MODULE: ./lib/modules/announcements.js






const announcements_module = new Module('announcements');
announcements_module.moduleName = 'announcementsName';
announcements_module.category = 'coreCategory';
announcements_module.description = 'announcementsDesc';
announcements_module.hidden = true;
const announcements_subreddit = announcementsSubreddit;
const sourceUrl = `/r/${announcements_subreddit}/new.json?limit=1`;
const viewUrl = `/r/${announcements_subreddit}/new`;
const markedReadDate = storage_namespaceObject.wrap('RESmodules.announcement.markedReadDate', 0);
const lastUnreadDate = storage_namespaceObject.wrap('RESmodules.announcement.lastUnreadDate', 0);
const lastID = storage_namespaceObject.wrap('RESModules.announcement.lastAnnouncementID', null);
const archiveAfter = 31 * utils_time["a" /* DAY */];
const pizzazzAfter = 29 * utils_time["a" /* DAY */];
const recheckPostAfter = utils_time["b" /* HOUR */];
const announcements_now = Date.now();
let biff;

announcements_module.go = async () => {
  if (Object(utils_location["l" /* isCurrentSubreddit */])(announcements_subreddit)) {
    setMarkedRead();
  } else {
    const post = await postForNotification();

    if (post) {
      notify(post);
    }
  }
};

async function postForNotification() {
  const post = await getLatestPost();

  if (!post) {
    return false;
  }

  cacheLatestPost(post);
  const result = await shouldNotify(post);
  return result ? post : false;
}

async function shouldNotify(post) {
  const createdDate = post.created_utc * 1000;

  if (createdDate + archiveAfter <= announcements_now) {
    return false;
  }

  if (createdDate <= (await markedReadDate.get())) {
    return false;
  }

  if (!isPostRelevant(post)) {
    return false;
  }

  return true;
}

const notify = Object(once["a" /* default */])(async post => {
  const url = post.id ? `/comments/${post.id}` : viewUrl;
  const withPizzazz = (await lastUnreadDate.get()) + pizzazzAfter < announcements_now;
  const title = post.author ? i18n('announcementsNewPostByUser', announcements_subreddit, post.author) : i18n('announcementsNewPost', announcements_subreddit);
  addAnnouncementBiff(post, url, title, withPizzazz);
  const hasSeenNotification = await lastUnreadDate.has();

  if (hasSeenNotification) {
    menu_addMenuItem(() => string_namespaceObject.html`<span title="${title}">
				new announcement!
				<span data-action="preventOpenNewTab" class="RESMenuItemButton res-icon"></span> // TODO Restore title="i18n('announcementsMarkAsRead')"
			</span>`, e => {
      setMarkedRead();
      if (e.target.closest('[data-action="preventOpenNewTab"]')) return;
      openNewTab(url);
    }, -8);
  }
});

async function cacheLatestPost(post) {
  if (post.id !== (await lastID.get())) {
    lastID.set(post.id);
    lastUnreadDate.set(announcements_now);
  }
}

function addAnnouncementBiff(post, url, title, withPizzazz) {
  biff = string_namespaceObject.html`<a id="RESAnnouncementAlert" class="${withPizzazz ? 'important' : ''} href="${url}" target="_blank">`;
  biff.append(createElement_namespaceObject.icon(0xF076, 'span', '', title));
  biff.addEventListener('click', setMarkedRead);
  addFloater(biff, {
    container: 'inNavbar'
  });
}

async function getLatestPost() {
  const {
    data: {
      children: [{
        data
      }]
    }
  } = await ajax({
    url: sourceUrl,
    type: 'json',
    cacheFor: recheckPostAfter
  });
  return data;
}

function setMarkedRead() {
  markedReadDate.set(announcements_now);
  if (biff) biff.remove();
}

function isPostRelevant(post) {
  if (!/chrome|safari|firefox|opera|edge/i.test(post.title)) {
    return true;
  }

  if (post.title.toLowerCase().includes("chrome".toLowerCase())) {
    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./lib/modules/autoHide.js






const autoHide_module = new Module('autoHide');
autoHide_module.moduleName = 'autoHideName';
autoHide_module.category = 'browsingCategory';
autoHide_module.description = 'autoHideDesc';
autoHide_module.options = {
  mustBeVisibleDuration: {
    type: 'text',
    value: '2000',
    description: 'autoHideMustBeVisibleDurationDesc',
    title: 'autoHideMustBeVisibleDurationTitle'
  },
  types: {
    type: 'enum',
    values: [{
      name: 'All',
      value: ''
    }, {
      name: 'Only comments',
      value: 'comment'
    }, {
      name: 'Only link posts',
      value: 'post'
    }],
    value: 'comment',
    description: 'autoHideTypesDesc',
    title: 'autoHideTypesTitle'
  }
};
const autoHide_thingType = Object(utils_location["n" /* isPageType */])('comments', 'commentsLinklist') ? 'comment' : 'post';
const hidePost = Object(utils_async["a" /* batch */])(posts => send(HIDE, posts), {
  size: 50,
  delay: 5000,
  flushBeforeUnload: true
});

autoHide_module.shouldRun = () => !isPrivateBrowsing();

autoHide_module.beforeLoad = () => {
  if (autoHide_module.options.types.value && autoHide_thingType !== autoHide_module.options.types.value) return;

  if (autoHide_thingType === 'comment' && !isRunning(readComments_namespaceObject)) {
    console.warn('Auto-hiding comments requires readComments');
    return;
  }

  const mustBeVisibleDuration = parseFloat(autoHide_module.options.mustBeVisibleDuration.value) || 0;
  const pending = new Map();
  const io = new IntersectionObserver(entries => {
    for (const {
      target,
      isIntersecting
    } of entries) {
      const thing = Thing["a" /* Thing */].checkedFrom(target);
      const id = pending.get(thing);

      if (isIntersecting) {
        pending.set(thing, setTimeout(() => {
          if (autoHide_thingType === 'post') hidePost(thing);else readComments_add(thing);
          io.unobserve(target);
          pending.delete(thing);
        }, mustBeVisibleDuration));
      } else if (id) {
        pending.delete(thing);
        clearTimeout(id);
      }
    }
  }, {
    threshold: [0],
    rootMargin: '0px 0px -30px 0px'
  });
  Object(watchers["watchForThings"])([autoHide_thingType], thing => {
    if (autoHide_thingType === 'post' && !isLoggedIn()) return;
    io.observe(thing.entry);
  });
};
// CONCATENATED MODULE: ./node_modules/lodash-es/mapValues.js
function mapValues(object,iteratee){var result={};iteratee=Object(_baseIteratee["a" /* default */])(iteratee,3);Object(_baseForOwn["a" /* default */])(object,function(value,key,object){Object(_baseAssignValue["a" /* default */])(result,key,iteratee(value,key,object));});return result;}/* harmony default export */ var lodash_es_mapValues = (mapValues);
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/serialization.js

function serialize(settings) {
  return JSON.stringify({
    SCHEMA_VERSION: 2,
    data: settings
  });
}
function deserialize(string) {
  const object = JSON.parse(string);

  switch (object.SCHEMA_VERSION) {
    case 1:
      {
        const {
          SCHEMA_VERSION,
          ...settings
        } = object;
        return settings;
      }

    case 2:
      {
        const {
          data: settings
        } = object;
        return settings;
      }

    default:
      {
        const {
          SCHEMA_VERSION,
          ...encoded
        } = object;
        return lodash_es_mapValues(encoded, (v, k) => {
          try {
            return JSON.parse(v);
          } catch (e) {
            console.warn('Could not parse:', k, 'falling back to raw string.');
            return v;
          }
        });
      }
  }
}
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/Provider.js
class Provider {
  init({}) {
    return Promise.resolve(this);
  }

  read() {
    throw new Error('unimplemented');
  }

  write() {
    throw new Error('unimplemented');
  }

}
Provider.key = 'abstract';
Provider.text = 'Abstract';
Provider.notifyBackupDone = true;
Provider.supportsAutomaticBackups = false;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/File.js



class File_File extends Provider {
  read() {
    return new Promise((resolve, reject) => {
      const link = document.createElement('input');
      link.type = 'file';
      link.accept = '.resbackup, .json';
      let loading = false;
      link.addEventListener('change', () => {
        loading = true;
        const file = link.files[0];
        const reader = new FileReader();

        reader.onload = () => {
          resolve(reader.result);
        };

        reader.readAsText(file);
      });
      Promise.all([Object(dom["r" /* waitForEvent */])(window, 'mousemove'), Object(dom["r" /* waitForEvent */])(window, 'focus')]).then(() => requestIdleCallback(() => {
        if (loading) return;
        if (!link.files.length) reject(new Error('No file selected.'));
      }));
      link.click();
    });
  }

  write(data) {
    const blob = new Blob([data], {
      type: 'application/json'
    });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const date = new Date();
    link.download = `RES-${date.getUTCFullYear()}-${date.getMonth() + 1}-${date.getDate()}-${Math.round(date.getTime() / 1000)}-${metadata_version.replace(/\./g, '_')}.resbackup`;
    Object(dom["c" /* click */])(link);
    return Promise.resolve();
  }

}
File_File.key = 'file';
File_File.text = 'backupAndRestoreProvidersFile';
File_File.notifyBackupDone = false;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/GoogleDrive.js



const FILE = 'res-storage.json';
const FOLDER = 'appDataFolder';
class GoogleDrive_GoogleDrive extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({
    googleLoginHint
  }) {
    this.accessToken = await launchAuthFlow({
      domain: `https://accounts.google.com/signin/oauth?login_hint=${googleLoginHint}`,
      clientId: '568759524377-nv0o2u4afuuulkfcjd7f6guf27qkevpt.apps.googleusercontent.com',
      scope: 'https://www.googleapis.com/auth/drive.appdata',
      permissions: ['https://www.googleapis.com/drive/v3/*', 'https://accounts.google.com/signin/oauth']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to Google Drive.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async getExistingFile() {
    const {
      files: [file]
    } = await ajax({
      method: 'GET',
      url: 'https://www.googleapis.com/drive/v3/files',
      query: {
        fields: 'files(id)',
        q: `name="${FILE}"`,
        spaces: FOLDER
      },
      headers: {
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
    return file;
  }

  async getOrCreateFile() {
    const existingFile = await this.getExistingFile();
    if (existingFile) return existingFile;
    return ajax({
      method: 'POST',
      url: 'https://www.googleapis.com/drive/v3/files',
      query: {
        fields: 'id'
      },
      data: JSON.stringify({
        name: FILE,
        parents: [FOLDER]
      }),
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

  async read() {
    const file = await this.getExistingFile();
    if (!file) throw new Error('Could not find backup.');
    return ajax({
      method: 'GET',
      url: `https://www.googleapis.com/drive/v3/files/${file.id}`,
      query: {
        alt: 'media'
      },
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      }
    });
  }

  async write(data) {
    const {
      id
    } = await this.getOrCreateFile();
    await ajax({
      method: 'PATCH',
      url: `https://www.googleapis.com/upload/drive/v3/files/${id}`,
      query: {
        uploadType: 'media'
      },
      data,
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
GoogleDrive_GoogleDrive.key = 'googledrive';
GoogleDrive_GoogleDrive.text = 'Google Drive';
GoogleDrive_GoogleDrive.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/OneDrive.js



const OneDrive_FILE = 'res-storage.json';
class OneDrive_OneDrive extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({}) {
    this.accessToken = await launchAuthFlow({
      domain: 'https://login.live.com/oauth20_authorize.srf',
      clientId: 'a1f95f80-0129-475b-9894-dfbb94f5ff1c',
      scope: 'onedrive.appfolder',
      permissions: ['https://login.live.com/oauth20_authorize.srf']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to OneDrive.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async getMetadata() {
    try {
      return await ajax({
        method: 'GET',
        url: `https://api.onedrive.com/v1.0/drive/special/approot:/${OneDrive_FILE}`,
        query: {
          select: 'id,@content.downloadUrl'
        },
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        },
        type: 'json'
      });
    } catch (e) {
      if (e.status === 404) {
        throw new Error('Could not find backup.');
      } else {
        throw e;
      }
    }
  }

  async read() {
    const file = await this.getMetadata();
    return ajax({
      method: 'GET',
      url: file['@content.downloadUrl']
    });
  }

  async write(data) {
    await ajax({
      method: 'PUT',
      url: `https://api.onedrive.com/v1.0/drive/special/approot:/${OneDrive_FILE}:/content`,
      data,
      headers: {
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
OneDrive_OneDrive.key = 'onedrive';
OneDrive_OneDrive.text = 'OneDrive';
OneDrive_OneDrive.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/Dropbox.js



const Dropbox_FILE = '/res-storage.json';
class Dropbox_Dropbox extends Provider {
  constructor(...args) {
    super(...args);
    this.accessToken = void 0;
  }

  async init({}) {
    this.accessToken = await launchAuthFlow({
      domain: 'https://www.dropbox.com/oauth2/authorize',
      clientId: 'tdevom9o5xn0hnt',
      permissions: ['https://www.dropbox.com/oauth2/authorize']
    }, async message => {
      await alert_namespaceObject.open(`
				<p><b>RES needs your permission to backup to Dropbox.</b></p>
				<p>${message}</p>
			`, {
        cancelable: true
      });
    });
    return this;
  }

  async read() {
    try {
      return await ajax({
        method: 'POST',
        url: 'https://content.dropboxapi.com/2/files/download',
        query: {
          arg: JSON.stringify({
            path: Dropbox_FILE
          })
        },
        headers: {
          Authorization: `Bearer ${this.accessToken}`
        }
      });
    } catch (e) {
      if (e.status === 409) {
        throw new Error('Could not find backup.');
      } else {
        throw e;
      }
    }
  }

  async write(data) {
    await ajax({
      method: 'POST',
      url: 'https://content.dropboxapi.com/2/files/upload',
      query: {
        arg: JSON.stringify({
          path: Dropbox_FILE,
          mode: 'overwrite',
          mute: true
        })
      },
      data,
      headers: {
        'Content-Type': 'application/octet-stream',
        Authorization: `Bearer ${this.accessToken}`
      },
      type: 'json'
    });
  }

}
Dropbox_Dropbox.key = 'dropbox';
Dropbox_Dropbox.text = 'Dropbox';
Dropbox_Dropbox.supportsAutomaticBackups = true;
// CONCATENATED MODULE: ./lib/modules/backupAndRestore/providers/index.js




// CONCATENATED MODULE: ./lib/modules/backupAndRestore.js








const backupAndRestore_module = new Module('backupAndRestore');
backupAndRestore_module.moduleName = 'backupName';
backupAndRestore_module.category = 'aboutCategory';
backupAndRestore_module.sort = -8;
backupAndRestore_module.alwaysEnabled = true;
backupAndRestore_module.description = 'backupDesc';
backupAndRestore_module.options = {
  backup: {
    type: 'button',
    values: Object.values(providers_namespaceObject).map(p => ({
      text: p.text,
      callback: () => getProvider(p).then(backup)
    })),
    description: 'backupAndRestoreBackupDesc',
    title: 'backupAndRestoreBackupTitle'
  },
  restore: {
    type: 'button',
    values: Object.values(providers_namespaceObject).map(p => ({
      text: p.text,
      callback: () => getProvider(p).then(restore)
    })),
    description: 'backupAndRestoreRestoreDesc',
    title: 'backupAndRestoreRestoreTitle'
  },
  reloadWarning: {
    type: 'enum',
    value: 'warn',
    values: [{
      name: 'backupAndRestoreReloadWarningNone',
      value: 'none'
    }, {
      name: 'backupAndRestoreReloadWarningWarn',
      value: 'warn'
    }, {
      name: 'backupAndRestoreReloadWarningAuto',
      value: 'auto'
    }],
    description: 'backupAndRestoreReloadWarningDesc',
    title: 'backupAndRestoreReloadWarningTitle'
  },
  automaticBackups: {
    type: 'enum',
    value: 'none',
    values: [{
      name: 'backupAndRestoreAutomaticBackupsNone',
      value: 'none'
    }, ...Object.values(providers_namespaceObject).filter(p => p.supportsAutomaticBackups).map(p => ({
      name: p.text,
      value: p.key
    }))],
    description: 'backupAndRestoreAutomaticBackupsDesc',
    title: 'backupAndRestoreAutomaticBackupsTitle',

    onChange() {
      lastCheckStorage.set(0);
      handleAutomaticSync();
    }

  },
  syncFrequency: {
    type: 'text',
    value: '0.25',
    description: 'backupAndRestoreSyncFrequencyDesc',
    title: 'backupAndRestoreSyncFrequencyTitle',
    dependsOn: options => options.automaticBackups.value !== 'none'
  },
  automaticRestore: {
    type: 'boolean',
    value: true,
    description: 'backupAndRestoreAutomaticRestoreDesc',
    title: 'backupAndRestoreAutomaticRestoreTitle',
    dependsOn: options => options.automaticBackups.value !== 'none'
  },
  warnBeforeAutomaticRestore: {
    type: 'boolean',
    value: true,
    description: 'backupAndRestoreWarnBeforeAutomaticRestoreDesc',
    title: 'backupAndRestoreWarnBeforeAutomaticRestoreTitle',
    dependsOn: options => options.automaticBackups.value !== 'none' && options.automaticRestore.value
  },
  googleAccount: {
    type: 'text',
    value: '',
    description: 'backupAndRestoreGoogleAccountDesc',
    title: 'backupAndRestoreGoogleAccountTitle',
    advanced: true
  }
};

backupAndRestore_module.afterLoad = async () => {
  await handleAutomaticSync();
};

function getProvider(providerClass) {
  return new providerClass().init({
    googleLoginHint: backupAndRestore_module.options.googleAccount.value
  });
}

const lastModifiedStorage = storage_namespaceObject.wrapPrefix('backup.lastModified.', () => 0);
const lastCheckStorage = storage_namespaceObject.wrap('backup.lastCheck', 0);

async function handleAutomaticSync() {
  const automaticProviderKey = backupAndRestore_module.options.automaticBackups.value;
  if (automaticProviderKey === 'none') return;
  const providerClass = Object.values(providers_namespaceObject).find(p => p.key === automaticProviderKey);
  if (!providerClass) throw new Error(`Can't find provider with key ${automaticProviderKey}`);
  const now = Date.now();
  const lastCheck = await lastCheckStorage.get();
  if (now - lastCheck < parseFloat(backupAndRestore_module.options.syncFrequency.value) * utils_time["b" /* HOUR */]) return;
  if (!(await lastCheckStorage.compareAndSet(lastCheck, now))) return;
  const provider = await getProvider(providerClass);
  let restored = false;

  if (backupAndRestore_module.options.automaticRestore.value) {
    let remoteBackup;

    const lastModifiedKey = lastModifiedStorage._keyGen(providerClass.key);

    try {
      remoteBackup = deserialize(await provider.read());
    } catch (e) {
      console.warn('Failed to read automatic backup:', e);
      remoteBackup = {
        [lastModifiedKey]: 0
      };
    }

    if (remoteBackup[lastModifiedKey] > (await lastModifiedStorage.get(providerClass.key))) {
      await restore(provider, backupAndRestore_module.options.warnBeforeAutomaticRestore.value ? 'automatic' : 'none');
      restored = true;
    }
  }

  if (!restored) {
    await backup(provider);
  }
}

async function backup(provider) {
  const {
    key,
    text,
    notifyBackupDone
  } = provider.constructor;
  await lastModifiedStorage.set(key, Date.now());
  const storage = await storage_namespaceObject.getAll();
  await provider.write(serialize(storage));

  if (notifyBackupDone) {
    notifications_showNotification({
      message: i18n('backupAndRestoreSavedNotification', text),
      notificationID: 'backupAndRestoreSaved',
      moduleID: backupAndRestore_module.moduleID,
      closeDelay: 1000
    });
  }
}

async function restore(provider, alertType = 'normal') {
  const {
    key,
    name
  } = provider.constructor;
  const data = await provider.read();
  const storage = deserialize(data);
  const isAutomatic = alertType === 'automatic';

  if (alertType !== 'none') {
    const lastModifiedKey = lastModifiedStorage._keyGen(key);

    const backupDate = storage[lastModifiedKey];
    let size;

    try {
      size = new Intl.NumberFormat(i18n_locale, {
        style: 'unit',
        unit: 'byte',
        notation: 'compact',
        unitDisplay: 'narrow'
      }).format(data.length);
    } catch (e) {
      size = `${data.length / 1e6} MB`;
    }

    try {
      await alert_namespaceObject.open(`
			${isAutomatic ? `
				<p><b>${i18n('backupAndRestoreFoundBackup', name)}</b></p>
				<br>
			` : ''}
			<p>${i18n('backupAndRestoreBackupOverwriteWarning')}</p>
			<br>
			${isAutomatic ? `
				<p>${i18n('backupAndRestoreAfterCancel')}</p>
				<br>
			` : ''}
			${backupDate ? `
				<p>${i18n('backupAndRestoreBackupDate', formatDateTime(new Date(backupDate)))}</p>
			` : ''}
			<p>${i18n('backupAndRestoreBackupSize', size)}</p>
		`, {
        cancelable: true
      });
    } catch (e) {
      if (isAutomatic) {
        settingsNavigation_open(backupAndRestore_module.moduleID, 'automaticBackups');
      }

      return;
    }
  }

  await storage_namespaceObject.setMultiple(storage);
  await lastCheckStorage.set(Date.now());
  await sendMessage('runMigrations');
  postRestore(backupAndRestore_module.options.reloadWarning.value);
  await alert_namespaceObject.open(i18n('backupAndRestoreImported'));
  postRestore.local('auto');
}

const postRestore = multicast(operation => {
  switch (operation) {
    case 'warn':
      alert_namespaceObject.open(i18n('backupAndRestoreImportedOtherTabs'), {
        cancelable: true
      }).then(() => location.reload(), () => {});
      break;

    case 'auto':
      location.reload();
      break;

    case 'none':
    default:
      break;
  }
}, {
  name: 'restore-settings-warning',
  local: false
});
// CONCATENATED MODULE: ./lib/modules/subredditManager.js







const subredditManager_module = new Module('subredditManager');
subredditManager_module.moduleName = 'subredditManName';
subredditManager_module.category = 'subredditsCategory';
subredditManager_module.description = 'subredditManDesc';
subredditManager_module.include = ['r2'];
subredditManager_module.bodyClass = true;
subredditManager_module.options = {
  subredditShortcut: {
    title: 'subredditManagerSubredditShortcutTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerSubredditShortcutDesc'
  },
  shortcutsPerAccount: {
    title: 'subredditManagerShortcutsPerAccountTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerShortcutsPerAccountDesc'
  },
  alwaysApplySuffixToMulti: {
    title: 'subredditManagerAlwaysApplySuffixToMultiTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerAlwaysApplySuffixToMultiDesc'
  },
  dropdownEditButton: {
    title: 'subredditManagerDropdownEditButtonTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerDropdownEditButtonDesc'
  },
  shortcutDropdownDelay: {
    title: 'subredditManagerShortcutDropdownDelayTitle',
    type: 'text',
    value: '200',
    description: 'subredditManagerShortcutDropdownDelayDesc'
  },
  shortcutEditDropdownDelay: {
    title: 'subredditManagerShortcutEditDropdownDelayTitle',
    dependsOn: options => options.dropdownEditButton.value,
    type: 'text',
    value: '3000',
    description: 'subredditManagerShortcutEditDropdownDelayDesc'
  },
  allowLowercase: {
    title: 'subredditManagerAllowLowercaseTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerAllowLowercaseDesc',
    bodyClass: true
  },
  linkDashboard: {
    title: 'subredditManagerLinkDashboardTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkDashboardDesc'
  },
  linkAll: {
    title: 'subredditManagerLinkAllTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkAllDesc'
  },
  linkFront: {
    title: 'subredditManagerLinkFrontTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkFrontDesc'
  },
  linkPopular: {
    title: 'subredditManagerLinkPopularTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkPopularDesc'
  },
  linkProfilePosts: {
    title: 'subredditManagerLinkProfilePostsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkProfilePostsDesc'
  },
  linkRandom: {
    title: 'subredditManagerLinkRandomTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkRandomDesc'
  },
  linkMyRandom: {
    title: 'subredditManagerLinkMyRandomTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkMyRandomDesc'
  },
  linkRandNSFW: {
    title: 'subredditManagerLinkRandNSFWTitle',
    type: 'boolean',
    value: false,
    description: 'subredditManagerLinkRandNSFWDesc'
  },
  linkUsers: {
    title: 'subredditManagerLinkUsersTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkUsersDesc'
  },
  linkFriends: {
    title: 'subredditManagerLinkFriendsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkFriendsDesc'
  },
  linkMod: {
    title: 'subredditManagerLinkModTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkModDesc'
  },
  linkModqueue: {
    title: 'subredditManagerLinkModqueueTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkModqueueDesc'
  },
  linkSaved: {
    title: 'subredditManagerLinkSavedTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLinkSavedDesc'
  },
  buttonEdit: {
    title: 'subredditManagerButtonEditTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerButtonEditDesc'
  },
  lastUpdate: {
    title: 'subredditManagerLastUpdateTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerLastUpdateDesc'
  },
  storeSubredditVisit: {
    title: 'subredditManagerStoreSubredditVisitTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerStoreSubredditVisitDesc',
    advanced: true
  },
  storeSubredditVisitIncognito: {
    title: 'subredditManagerStoreSubredditVisitIncognitoTitle',
    dependsOn: options => options.storeSubredditVisit.value,
    type: 'boolean',
    value: false,
    description: 'subredditManagerStoreSubredditVisitIncognitoDesc',
    advanced: true
  },
  displayMultiCounts: {
    title: 'subredditManagerDisplayMultiCountsTitle',
    type: 'boolean',
    value: true,
    description: 'subredditManagerDisplayMultiCountsDesc'
  }
};
let subredditBar, shortcutsContainer, $subredditGroupDropdown, subredditGroupDropdownUL, subredditGroupDropdownRefItem, $editShortcutDialog, deleteButton, originalShortcuts;
let mySubredditShortcuts = [];
const subredditsLastViewedStorage = storage_namespaceObject.wrap(() => `RESmodules.subredditManager.subredditsLastViewed.${loggedInUser() || 'null'}`, {});
const subredditShortcutsStorage = storage_namespaceObject.wrap(() => {
  const username = subredditManager_module.options.shortcutsPerAccount.value ? loggedInUser() : null;
  return `RESmodules.subredditManager.subredditShortcuts.${username || 'null'}`;
}, []);

const loadShortcuts = async () => {
  mySubredditShortcuts = await subredditShortcutsStorage.get();
};

const initialShortcutsLoad = Object(once["a" /* default */])(loadShortcuts);

subredditManager_module.beforeLoad = () => {
  pagePhases.bodyStart.then(body => Object(dom["o" /* waitForDescendant */])(body, '#sr-header-area')).then(createSubredditBar);
};

subredditManager_module.contentStart = () => {
  fillStaticShortcuts();
  initialShortcutsLoad().then(redrawShortcuts);

  if (subredditManager_module.options.subredditShortcut.value) {
    createElement_namespaceObject.sidebarSubscribeButtonWrappers().forEach(wrapper => {
      const button = createShortcutToggleButton(wrapper.getAttribute('subreddit'));
      initialShortcutsLoad().then(() => button.dispatchEvent(new CustomEvent('refresh')));
      button.classList.add('RESshortcutside');
      wrapper.append(button);
    });
  }

  Object(watchers["watchForThings"])(['subreddit'], async thing => {
    await initialShortcutsLoad();
    const titleElement = thing.getTitleElement();
    const container = thing.element.querySelector('.midcol');
    if (!titleElement || !container) return;
    const [, subreddit] = utils_location["p" /* regexes */].subreddit.exec(titleElement.pathname) || [];
    if (!subreddit) return;
    container.append(createShortcutToggleButton(subreddit));
  });
};

subredditManager_module.afterLoad = () => {
  if (subredditManager_module.options.lastUpdate.value && document.getElementsByClassName('listing-chooser').length) {
    subredditManager_lastUpdate();
  }

  const subreddit = Object(utils_location["d" /* currentSubreddit */])();

  if (subreddit) {
    requestAnimationFrame(() => {
      setLastViewtime(subreddit);
    });
  }
};

function createShortcutToggleButton(subreddit) {
  return createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveShortcut'), i18n('subredditInfoAddThisSubredditToShortcuts'), () => mySubredditShortcuts.some(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase()), state => {
    if (state) addSubredditShortcut(subreddit);else removeSubredditShortcut(subreddit);
    redrawShortcuts();
  });
}
const followSubredditShortcut = Object(debounce["a" /* default */])(url => {
  location.href = url;
}, 300);
let hideSubredditGroupDropdownTimer, showSubredditGroupDropdownTimer, dragSrc;

function redrawShortcuts() {
  shortcutsContainer.textContent = '';
  const currentSub = (Object(utils_location["d" /* currentSubreddit */])() || '').toLowerCase().split('+').sort().join('+');

  const isCurrent = sub => {
    const sortedSubs = sub.replace(/\?\+/g, '+').split('+').sort();
    return sortedSubs.some(v => Object(utils_location["l" /* isCurrentSubreddit */])(v)) || currentSub === sortedSubs.join('+');
  };

  for (const shortcut of mySubredditShortcuts) {
    const thisShortCut = document.createElement('a');
    thisShortCut.setAttribute('data-subreddit', shortcut.subreddit);
    thisShortCut.classList.add('subbarlink');
    if (isCurrent(shortcut.subreddit)) thisShortCut.classList.add('RESShortcutsCurrentSub');
    thisShortCut.setAttribute('href', `/r/${shortcut.subreddit.replace(/(?:\?\+.*|\?$)/, '')}`);
    thisShortCut.textContent = shortcut.displayName;
    thisShortCut.addEventListener('click', e => {
      if (e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
        return true;
      } else {
        e.preventDefault();
        followSubredditShortcut(e.currentTarget.href);
      }
    });
    thisShortCut.addEventListener('dblclick', e => {
      e.preventDefault();
      followSubredditShortcut.cancel();
      hideSubredditGroupDropdown();
      editSubredditShortcut(e.currentTarget, e);
    });
    thisShortCut.addEventListener('mouseover', e => {
      clearTimeout(hideSubredditGroupDropdownTimer);
      showSubredditGroupDropdown(e.currentTarget);
    });
    thisShortCut.addEventListener('mouseout', () => {
      clearTimeout(showSubredditGroupDropdownTimer);
      hideSubredditGroupDropdownTimer = setTimeout(() => hideSubredditGroupDropdown(), 500);
    });
    thisShortCut.addEventListener('dragstart', function (e) {
      this.style.opacity = '0.4';
      followSubredditShortcut.cancel();
      dragSrc = this;
      e.dataTransfer.effectAllowed = 'move';
      addTrashBin(this);
    });
    thisShortCut.addEventListener('dragenter', () => {
      thisShortCut.style.outline = '1px dashed black';
    });
    thisShortCut.addEventListener('dragleave', () => {
      thisShortCut.style.outline = '';
    });
    thisShortCut.addEventListener('dragover', e => {
      e.preventDefault();

      if ($subredditGroupDropdown) {
        $subredditGroupDropdown.hide();
      }

      e.dataTransfer.dropEffect = 'move';
    });
    thisShortCut.addEventListener('drop', function () {
      const srcSubreddit = dragSrc.dataset.subreddit;
      const dstSubreddit = this.dataset.subreddit;
      const src = mySubredditShortcuts.find(({
        subreddit
      }) => srcSubreddit === subreddit);
      const dst = mySubredditShortcuts.find(({
        subreddit
      }) => dstSubreddit === subreddit);
      if (!src || !dst) throw new Error();
      Object(pull["a" /* default */])(mySubredditShortcuts, src);
      mySubredditShortcuts.splice(mySubredditShortcuts.indexOf(dst), 0, src);
      redrawShortcuts();
      saveLatestShortcuts();
    });
    thisShortCut.addEventListener('dragend', function () {
      this.style.opacity = '';
      this.classList.remove('srOver');
      removeTrashBin();
    });
    const sep = document.createElement('span');
    sep.setAttribute('class', 'separator');
    sep.textContent = '-';
    shortcutsContainer.append(sep);
    shortcutsContainer.append(thisShortCut, sep);
  }

  if (mySubredditShortcuts.length) {
    shortcutsContainer.style.textTransform = '';
  } else {
    shortcutsContainer.style.textTransform = 'none';
    shortcutsContainer.textContent = 'add shortcuts from the my subreddits menu at left or click the button by the subreddit name, drag and drop to sort';
  }
}

function showSubredditGroupDropdown(obj) {
  let subreddits = [];
  let suffix = '';

  if (obj.getAttribute && obj.getAttribute('data-subreddit').includes('+')) {
    let cleanSubreddits = obj.getAttribute('data-subreddit');

    if (cleanSubreddits.indexOf('/') > cleanSubreddits.lastIndexOf('+') || subredditManager_module.options.alwaysApplySuffixToMulti.value) {
      let pos;

      if ((pos = cleanSubreddits.lastIndexOf('?')) > cleanSubreddits.lastIndexOf('+')) {
        suffix = cleanSubreddits.substr(pos);
        cleanSubreddits = cleanSubreddits.substr(0, pos);
      }

      if ((pos = cleanSubreddits.lastIndexOf('/')) > cleanSubreddits.lastIndexOf('+')) {
        suffix = cleanSubreddits.substr(pos) + suffix;
        cleanSubreddits = cleanSubreddits.substr(0, pos);
      }
    }

    subreddits = cleanSubreddits.replace(/\?\+/g, '+').split('+');
  }

  if (!(subreddits.length || subredditManager_module.options.dropdownEditButton.value)) {
    return;
  }

  let delay;

  if (subreddits.length) {
    delay = parseInt(subredditManager_module.options.shortcutDropdownDelay.value, 10);
  } else {
    delay = parseInt(subredditManager_module.options.shortcutEditDropdownDelay.value, 10);
  }

  clearTimeout(showSubredditGroupDropdownTimer);
  showSubredditGroupDropdownTimer = setTimeout(() => _showSubredditGroupDropdown(obj, subreddits, suffix), delay);
}

function _showSubredditGroupDropdown(obj, subreddits, suffix) {
  subredditGroupDropdownRefItem = obj;

  if (!$subredditGroupDropdown) {
    $subredditGroupDropdown = jquery_default()('<div>', {
      id: 'RESSubredditGroupDropdown'
    });
    subredditGroupDropdownUL = document.createElement('ul');
    $subredditGroupDropdown.append(subredditGroupDropdownUL);

    if (subredditManager_module.options.dropdownEditButton.value) {
      $subredditGroupDropdown.append(`
				<div class="RESShortcutsEditButtons">
					<a href="#" class="delete res-icon" title="delete">&#xF155;</a>
					<a href="#" class="edit res-icon" title="edit">&#xF139;</a>
				</div>
			`);
    }

    $subredditGroupDropdown.appendTo(document.body);
    $subredditGroupDropdown.on('mouseout', () => {
      hideSubredditGroupDropdownTimer = setTimeout(() => {
        hideSubredditGroupDropdown();
      }, 500);
    });
    $subredditGroupDropdown.on('mouseover', () => {
      clearTimeout(hideSubredditGroupDropdownTimer);
    });
    $subredditGroupDropdown.on('click', '.edit', e => {
      e.preventDefault();
      hideSubredditGroupDropdown();
      editSubredditShortcut(subredditGroupDropdownRefItem, e);
    });
    $subredditGroupDropdown.on('click', '.delete', e => {
      e.preventDefault();
      hideSubredditGroupDropdown();
      editSubredditShortcut(subredditGroupDropdownRefItem, e);
      deleteButton.click();
    });
  }

  jquery_default()(subredditGroupDropdownUL).find('li:not(.RESShortcutsEditButtons)').remove();

  if (subreddits) {
    const $rows = subreddits.reduce(($collection, subreddit) => {
      const $thisLI = jquery_default()(`<li><a href="/r/${subreddit}${suffix}">${subreddit}<span class="shortcutSuffix">${suffix}</span></a></li>`);

      if (Object(utils_location["l" /* isCurrentSubreddit */])(subreddit)) {
        $thisLI.addClass('RESShortcutsCurrentSub');
      }

      return $collection.add($thisLI);
    }, jquery_default()());
    jquery_default()(subredditGroupDropdownUL).prepend($rows);
  }

  const {
    left
  } = jquery_default()(obj).offset();
  const {
    bottom
  } = document.querySelector('#sr-header-area').getBoundingClientRect();
  $subredditGroupDropdown.css({
    top: `${bottom}px`,
    left: `${left}px`
  }).show();
}

function hideSubredditGroupDropdown() {
  hideSubredditGroupDropdownTimer = undefined;

  if ($subredditGroupDropdown) {
    $subredditGroupDropdown.hide();
  }
}

function editSubredditShortcut(ele, event) {
  const subreddit = ele.getAttribute('data-subreddit');
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit === subreddit);

  if (!$editShortcutDialog) {
    $editShortcutDialog = jquery_default()('<div>', {
      id: 'editShortcutDialog'
    }).appendTo(document.body);
  }

  const unsortable = !subreddit.includes('+');
  const thisForm = `
		<form name="editSubredditShortcut">
			<h3>Edit Shortcut</h3>
			<div id="editShortcutClose" class="RESCloseButton RESCloseButtonTopRight"></div>
			<div class="RESFormItem">
				<label for="subreddit">Subreddit:</label>
				<div class="RESFieldItem">
					<input type="text" name="subreddit" value="${subreddit}" id="shortcut-subreddit" class="${unsortable ? 'unsortable' : ''}"><!-- no whitespace
					--><button type="submit" id="sortButton" title="Sort subreddits">A-Z</button>

					<div class="RESDescription">Put a + between subreddits to make a drop-down menu.<br/>Put ?+ to make subreddits after it only show in dropdown.</div>
				</div>
			</div>
			<div class="RESFormItem">
				<label for="displayName">Display Name:</label>
				<div class="RESFieldItem">
					<input type="text" name="displayName" value="${ele.textContent}" id="shortcut-displayname">
				</div>
			</div>
			<input type="hidden" name="idx" value="${idx}">
			<button type="button" name="shortcut-save" id="shortcut-save">save</button>
			<button type="button" name="shortcut-delete" id="shortcut-delete">delete</button>
		</form>
	`;
  $editShortcutDialog.html(thisForm);
  $editShortcutDialog.find('#shortcut-subreddit').on('keyup', lodash_es_throttle(({
    currentTarget: shortcut
  }) => {
    if (!shortcut.value.includes('+')) {
      shortcut.classList.add('unsortable');
    } else {
      shortcut.classList.remove('unsortable');
    }
  }, 500));
  const subredditInput = Object(flow["a" /* downcast */])($editShortcutDialog.get(0).querySelector('input[name=subreddit]'), HTMLInputElement);
  const displayNameInput = Object(flow["a" /* downcast */])($editShortcutDialog.get(0).querySelector('input[name=displayName]'), HTMLInputElement);
  $editShortcutDialog.find('FORM').on('submit', e => e.preventDefault());
  const saveButton = $editShortcutDialog.find('button[name=shortcut-save]').click(() => {
    const idx = $editShortcutDialog.find('input[name=idx]').val();
    const subreddit = $editShortcutDialog.find('input[name=subreddit]').val();
    const displayName = $editShortcutDialog.find('input[name=displayName]').val();
    saveSubredditShortcut(subreddit, displayName, idx);
    $editShortcutDialog.hide();
  }).get(0);
  deleteButton = $editShortcutDialog.find('button[name=shortcut-delete]').get(0);
  deleteButton.addEventListener('click', () => {
    const idx = $editShortcutDialog.find('input[name=idx]').val();

    if (confirm('Are you sure you want to delete this shortcut?')) {
      saveSubredditShortcut('', '', idx);
      $editShortcutDialog.hide();
    }
  });
  $editShortcutDialog.find('#sortButton').click(({
    currentTarget
  }) => {
    const currStr = subredditInput.value;
    const ascArr = currStr.split('+').sort((a, b) => a.localeCompare(b, undefined, {
      sensitivity: 'base'
    }));
    const ascStr = ascArr.join('+');
    const descStr = ascArr.reverse().join('+');
    subredditInput.value = currStr === ascStr ? descStr : ascStr;
    currentTarget.textContent = currStr === ascStr ? 'A-Z' : 'Z-A';
  });
  subredditInput.addEventListener('keydown', e => {
    if (e.key === NAMED_KEYS.Enter) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  subredditInput.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) {
      $editShortcutDialog.hide().blur();
    } else if (e.key === NAMED_KEYS.Enter) {
      Object(dom["c" /* click */])(saveButton);
    }
  });
  displayNameInput.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) {
      $editShortcutDialog.hide().blur();
    } else if (e.key === NAMED_KEYS.Enter) {
      Object(dom["c" /* click */])(saveButton);
    }
  });
  $editShortcutDialog.find('#editShortcutClose').click(() => {
    $editShortcutDialog.hide();
  });
  $editShortcutDialog.show();
  const thisLeft = Math.min(event.clientX, window.innerWidth - ($editShortcutDialog.get(0).offsetWidth + 20));
  $editShortcutDialog.css('left', `${thisLeft}px`);
  setTimeout(() => subredditInput.focus(), 200);
}

async function saveSubredditShortcut(subreddit, displayName, idx) {
  if (subreddit === '' || displayName === '') {
    subreddit = mySubredditShortcuts[idx].subreddit;
    await removeSubredditShortcut(subreddit);
  } else {
    mySubredditShortcuts[idx] = {
      subreddit,
      displayName,
      addedDate: Date.now()
    };
    saveLatestShortcuts();
  }

  redrawShortcuts();
}

function createSubredditBar(_subredditBar) {
  originalShortcuts = Array.from(_subredditBar.querySelectorAll('.sr-list a.choice'));
  subredditBar = _subredditBar;
  subredditBar.innerHTML = `
		<div id="srLeftContainer" class="sr-bar">
			<div id="srDropdown">
					<div id="srDropdownContainer"><a href="javascript:void 0">My Subreddits</a></div>
			</div>
			<div id="RESStaticShortcuts"></div>
			<span class="srSep">|</span>
		</div>
		<div id="RESShortcutsViewport">
			<div id="RESShortcuts" class="sr-bar"></div>
		</div>
		<div id="RESShortcutsEditContainer">
			<div id="RESShortcutsSort" title="sort subreddit shortcuts">↑↓</div>
			<div id="RESShortcutsRight">&gt;</div>
			<div id="RESShortcutsAdd" class="res-icon" title="add shortcut"></div>
			<div id="RESShortcutsLeft">&lt;</div>
		</div>
	`;
  subredditBar.querySelector('#srDropdownContainer').addEventListener('click', e => {
    e.stopImmediatePropagation();
    toggleSubredditDropdown();
  });
  shortcutsContainer = subredditBar.querySelector('#RESShortcuts');
  const shortcutsEditContainer = document.createElement('div');
  shortcutsEditContainer.classList.add('res-sr-edit');
  subredditBar.querySelector('#RESShortcutsSort').addEventListener('click', async ({
    currentTarget
  }) => {
    const menu = sortMenu();
    document.body.append(menu);
    const {
      bottom,
      left
    } = currentTarget.getBoundingClientRect();
    menu.style.top = `${bottom}px`;
    menu.style.left = `${Math.min(document.body.getBoundingClientRect().width - menu.getBoundingClientRect().width, left)}px`;
    await Object(dom["r" /* waitForEvent */])(menu, 'mouseleave');
    menu.remove();
  });
  const addButton = subredditBar.querySelector('#RESShortcutsAdd');
  addButton.addEventListener('click', () => {
    toggleShortCutsAddForm();
  });
  const leftButton = subredditBar.querySelector('#RESShortcutsLeft');
  leftButton.addEventListener('click', () => {
    const firstChild = shortcutsContainer.firstChild;
    const containerMargin = parseInt(firstChild.style.marginLeft, 10) || 0;
    const shiftWidth = Math.floor(jquery_default()('#RESShortcutsViewport').width()) - 80;
    const marginLeft = containerMargin + shiftWidth;

    if (marginLeft <= 0) {
      firstChild.style.marginLeft = `${marginLeft}px`;
    }
  });
  const rightButton = subredditBar.querySelector('#RESShortcutsRight');
  rightButton.addEventListener('click', () => {
    const firstChild = shortcutsContainer.firstChild;
    let marginLeft = firstChild.style.marginLeft;
    marginLeft = parseInt(marginLeft.replace('px', ''), 10);
    if (isNaN(marginLeft)) marginLeft = 0;
    const shiftWidth = jquery_default()('#RESShortcutsViewport').width() - 80;

    if (shortcutsContainer.offsetWidth > shiftWidth) {
      marginLeft -= shiftWidth;
      firstChild.style.marginLeft = `${marginLeft}px`;
    }
  });
}

function fillStaticShortcuts() {
  const myRandom = subredditManager_module.options.linkMyRandom.value && originalShortcuts.find(({
    pathname
  }) => pathname === '/r/myrandom/');
  const myRandomGold = myRandom && myRandom.classList.contains('gold');
  const users = subredditManager_module.options.linkUsers.value && originalShortcuts.find(({
    pathname
  }) => pathname === '/users/');
  const originalFrontpage = originalShortcuts.find(({
    pathname
  }) => pathname === '/');
  const originalPopular = originalShortcuts.find(({
    pathname
  }) => pathname === '/r/popular/');
  const originalProfilePosts = originalShortcuts.find(({
    pathname
  }) => pathname === '/r/profileposts/');
  const originalMod = originalShortcuts.find(({
    pathname
  }) => pathname.startsWith('/r/mod'));
  let shortcuts = [subredditManager_module.options.linkDashboard.value && '<a class="subbarlink" href="/r/Dashboard/">Dashboard</a>', subredditManager_module.options.linkFront.value && originalFrontpage && `<a class="subbarlink" href="/">${originalFrontpage.textContent}</a>`, subredditManager_module.options.linkPopular.value && originalPopular && `<a class="subbarlink" href="/r/popular/">${originalPopular.textContent}</a>`, subredditManager_module.options.linkProfilePosts.value && originalProfilePosts && `<a class="subbarlink" href="/r/profileposts/">${originalProfilePosts.textContent}</a>`, subredditManager_module.options.linkAll.value && '<a class="subbarlink" href="/r/all/">All</a>', subredditManager_module.options.linkRandom.value && '<a class="subbarlink" href="/r/random/">Random</a>', subredditManager_module.options.linkMyRandom.value && myRandom && `<a class="subbarlink ${myRandomGold ? 'gold' : ''}" href="/r/myrandom/">MyRandom</a>`, subredditManager_module.options.linkUsers.value && users && '<a class="subbarlink" href="/users/">Users</a>', subredditManager_module.options.linkRandNSFW.value && '<a class="over18 subbarlink" href="/r/randnsfw/">RandNSFW</a>', isLoggedIn() && [subredditManager_module.options.linkFriends.value && '<a class="subbarlink" href="/r/friends/">Friends</a>', originalMod && [subredditManager_module.options.linkMod.value && '<a class="subbarlink" href="/r/mod/">Mod</a>', subredditManager_module.options.linkModqueue.value && '<a class="subbarlink" href="/r/mod/about/modqueue">Modqueue</a>'], subredditManager_module.options.linkSaved.value && '<a class="subbarlink" href="/user/me/saved">Saved</a>'], subredditManager_module.options.buttonEdit.value && makeUrlHashLink(subredditManager_module.moduleID, '', 'edit', 'subbarlink res-sr-options-link')].flat(3).filter(Boolean).join('<span class="separator">-</span>');
  if (shortcuts) shortcuts = `<span class="separator">-</span>${shortcuts}`;
  const container = Object(flow["a" /* downcast */])(subredditBar.querySelector('#RESStaticShortcuts'), HTMLElement);
  container.innerHTML = shortcuts;
  const choice = [...container.querySelectorAll('.subbarlink:not(.res-sr-options-link)')].find(link => link instanceof HTMLAnchorElement && Object(utils_location["g" /* fullLocation */])(link.pathname) === Object(utils_location["g" /* fullLocation */])());
  if (choice) choice.classList.add('RESShortcutsCurrentSub');
}

const trashBin = Object(once["a" /* default */])(() => {
  const $title = jquery_default()('<div>', {
    class: 'res-shortcut-trash-title'
  });
  const $trashZone = jquery_default()('<div>', {
    id: 'res-shortcut-trash-zone',
    class: 'res-icon'
  });
  const shortCutsTrash = $trashZone.get(0);
  shortCutsTrash.addEventListener('dragenter', () => {
    shortCutsTrash.style.borderColor = 'rgb(200, 50, 50)';
  });
  shortCutsTrash.addEventListener('dragleave', () => {
    shortCutsTrash.style.borderColor = '';
  });
  shortCutsTrash.addEventListener('dragover', e => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  });
  shortCutsTrash.addEventListener('drop', () => {
    const srcSubreddit = dragSrc.dataset.subreddit;
    removeSubredditShortcut(srcSubreddit);
  });
  const $wrapper = jquery_default()('<div>', {
    id: 'res-shortcut-trash'
  }).append($title, $trashZone, jquery_default()('<div>', {
    id: 'res-dragDrop-tip',
    text: 'Did you know? You can arrange shortcuts by dragging them left & right along the top bar.'
  }));
  return {
    $wrapper,
    $trashZone,
    $title
  };
});

function toggleShortCutsAddForm() {
  let shortCutsAddFormContainer = document.querySelector('#RESShortcutsAddFormContainer');

  const close = () => shortCutsAddFormContainer.remove();

  if (shortCutsAddFormContainer) {
    close();
    return;
  }

  shortCutsAddFormContainer = document.createElement('div');
  shortCutsAddFormContainer.setAttribute('id', 'RESShortcutsAddFormContainer');
  shortCutsAddFormContainer.append(string_namespaceObject.html`
		<form id="shortCutsAddForm">
			<div><strong>Add Shortcut</strong></div>
			<div class="res-shortcuts-add-tip">Put a &plus; between subreddits to make a multireddit.</div>
			<div><label for="newShortcut">Subreddit:</label><input type="text" id="newShortcut"></div>
			<div><label for="displayName">Display Name:</label><input type="text" id="displayName"></div>
			<input type="submit" name="submit" value="add" id="addSubreddit">
			<div class="res-shortcuts-add-footer">
				<a href="/subreddits/">manage subscribed</a>
				|
				<a class="res-trash-open" href="javascript: void 0" title="Choose which shortcuts to remove"><span class="res-icon">&#xF155;</span> remove shortcuts...</a>
			</div>
		</form>
	`);
  const shortCutsAddFormField = shortCutsAddFormContainer.querySelector('#newShortcut');
  const shortCutsAddFormFieldDisplayName = shortCutsAddFormContainer.querySelector('#displayName');
  shortCutsAddFormContainer.querySelector('.res-trash-open').addEventListener('click', () => {
    addTrashBin();
  });
  shortCutsAddFormField.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) close();
  });
  shortCutsAddFormFieldDisplayName.addEventListener('keyup', e => {
    if (e.key === NAMED_KEYS.Escape) close();
  });
  const shortCutsAddForm = shortCutsAddFormContainer.querySelector('#shortCutsAddForm');
  shortCutsAddForm.addEventListener('submit', e => {
    e.preventDefault();
    let subreddit = shortCutsAddFormField.value;
    let displayname = shortCutsAddFormFieldDisplayName.value;
    if (displayname === '') displayname = subreddit;
    subreddit = subreddit.replace(/^\/?r\//i, '');

    if (subreddit) {
      addSubredditShortcut(subreddit, displayname);
    }

    close();
  });
  document.body.append(shortCutsAddFormContainer);
  shortCutsAddFormField.focus();
}

const $pageOverlay = Object(once["a" /* default */])(() => {
  const srHeaderArea = document.querySelector('#sr-header-area');
  return jquery_default()('<div>', {
    id: 'res-trash-overlay'
  }).css({
    top: `${srHeaderArea.offsetHeight}px`
  }).click(() => removeTrashBin());
});

function addTrashBin(shortcut) {
  if ($subredditGroupDropdown) {
    $subredditGroupDropdown.hide();
  }

  if (shortcut) {
    trashBin().$title.html(string_namespaceObject.escape`Drop here to delete shortcut <strong>${jquery_default()(shortcut).text()}</strong>`);
  } else {
    trashBin().$title.text('Drag and drop shortcuts to delete them');
  }

  trashBin().$wrapper.appendTo(document.body).show();
  $pageOverlay().appendTo(document.body).show();
}

function removeTrashBin() {
  $pageOverlay().hide();
  trashBin().$wrapper.hide();
  trashBin().$trashZone.removeClass('srOver');
}

const sortMenu = Object(once["a" /* default */])(() => {
  const element = string_namespaceObject.html`
	<div id="sort-menu" style="display: block" class="drop-choices">
		<p>&nbsp;sort by:</p>
		<a class="choice" data-field="displayName" href="javascript:void 0">display name</a>
		<a class="choice" data-field="addedDate" href="javascript:void 0">added date</a>
	</div>`;
  let lastField;
  jquery_default()(element).find('a').click(({
    currentTarget
  }) => {
    const field = currentTarget.dataset.field;
    const sameField = lastField === field;
    lastField = field;
    sortShortcuts(sameField ? null : field, sameField);
  });
  return element;
});

function sortShortcuts(field, reverse) {
  if (field) mySubredditShortcuts.sort((a, b) => String(a[field]).localeCompare(String(b[field]), undefined, {
    numeric: true,
    sensitivity: 'base'
  }));
  if (reverse) mySubredditShortcuts.reverse();
  redrawShortcuts();
  saveLatestShortcuts();
}

const srList = Object(once["a" /* default */])(() => {
  const element = document.createElement('div');
  element.id = 'srList';
  const user = loggedInUser();

  if (!user) {
    element.append(string_namespaceObject.html`<div>Error: You must be logged in to load your own list of subreddits.</div>`);
    return element;
  }

  element.append(string_namespaceObject.html`<div>Loading subreddits ... (may take a a few seconds)</div>`);
  getMySubredditsTable(user).then(table => {
    Object(dom["e" /* empty */])(element);
    element.append(string_namespaceObject.html`<a style="float: right;" href="/subreddits/">View all &raquo;</a>`, table);
  }).catch(e => {
    console.error(e);
    element.append(string_namespaceObject.html`<span>There was an error getting your subreddits. You may have third party cookies disabled by your browser. For this function to work, you\'ll need to add an exception for cookies from reddit.com'</span>`);
  });
  return element;
});

async function toggleSubredditDropdown(e) {
  const ele = await srList();
  if (ele && e && (ele.contains(e.target) || !document.contains(e.target))) return;

  if (document.body.contains(ele)) {
    ele.remove();
    document.body.removeEventListener('click', toggleSubredditDropdown);
  } else {
    document.body.append(ele);
    Object(dom["o" /* waitForDescendant */])(ele, 'input').then(e => {
      e.focus();
    });
    document.body.addEventListener('click', toggleSubredditDropdown);
  }
}

async function getMySubredditsTable(user) {
  const headers = {
    subreddit: 'subreddit',
    ...(subredditManager_module.options.storeSubredditVisit.value ? {
      lastVisited: 'last visited'
    } : {}),
    shortcutToggle: ''
  };
  const mySubreddits = new Map();
  let after = '';

  do {
    const {
      data
    } = await ajax({
      url: '/subreddits/mine.json',
      query: {
        after,
        limit: 100,
        user
      },
      type: 'json',
      cacheFor: utils_time["a" /* DAY */]
    });

    if (data && data.children) {
      for (const {
        data: sub
      } of data.children) mySubreddits.set(sub.display_name, sub);

      after = data.after;
    } else if (!after) {
      throw new Error('No subreddits feched?');
    }
  } while (after);

  const subredditsLastViewed = await subredditsLastViewedStorage.get();
  const data = [...mySubreddits.values()];
  const table = new table_namespaceObject.RESTable(headers, data, ({
    display_name: displayName,
    url
  }) => {
    const lv = subredditsLastViewed[displayName.toLowerCase()];
    const ts = lv && parseInt(lv.last_visited, 10);
    const theLV = document.createElement('span');

    if (ts) {
      const dateVisited = new Date(ts);
      theLV.textContent = formatRelativeTime(dateVisited);
      theLV.setAttribute('title', formatDate(dateVisited));
      theLV.setAttribute('sort-value', String(Number.MAX_SAFE_INTEGER - dateVisited.getTime()));
    } else {
      theLV.textContent = 'N/A';
    }

    const shortcutToggle = createShortcutToggleButton(displayName);
    shortcutToggle.style.cursor = 'pointer';
    shortcutToggle.className = '';
    return {
      subreddit: string_namespaceObject.html`<a href="${url}">${displayName}</a>`,
      lastVisited: theLV,
      shortcutToggle
    };
  }, {
    pageSize: Infinity,
    sortBy: 'subreddit'
  });
  const ele = document.createElement('div');
  ele.append(table.createSearchElement(({
    display_name: displayName
  }) => displayName, i18n('subredditManagerFilterPlaceholder')), table.element);
  return ele;
}

async function getMultiCounts(displayName) {
  if (!subredditManager_module.options.displayMultiCounts.value) return '';
  const user = loggedInUser();
  if (!user) return '';
  const multis = await ajax({
    url: `/api/multi/user/${user}`,
    type: 'json',
    cacheFor: utils_time["a" /* DAY */]
  });
  const count = multis.filter(multi => multi.data.subreddits.some(sr => sr.name === displayName)).length;
  if (count) return string_namespaceObject.escape`<span class="multi-count" title="${i18n('subredditManagerMultiCountTitle', displayName, count)}">${count}</span>`;else return '';
}

function saveLatestShortcuts() {
  subredditShortcutsStorage.set(mySubredditShortcuts || []);
}

async function addSubredditShortcut(subreddit, displayname) {
  await loadShortcuts();
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase());

  if (idx !== -1) {
    alert_namespaceObject.open('Whoops, you already have a shortcut for that subreddit');
  } else {
    displayname = displayname || subreddit;
    const subredditObj = {
      subreddit,
      displayName: displayname.toLowerCase(),
      addedDate: Date.now()
    };
    mySubredditShortcuts.push(subredditObj);
    saveLatestShortcuts();
    redrawShortcuts();
    notifications_showNotification({
      moduleID: 'subredditManager',
      message: 'Subreddit shortcut added. You can edit by double clicking the shortcut.'
    });
  }
}

async function removeSubredditShortcut(subreddit) {
  await loadShortcuts();
  const idx = mySubredditShortcuts.findIndex(shortcut => shortcut.subreddit.toLowerCase() === subreddit.toLowerCase());

  if (idx !== -1) {
    mySubredditShortcuts.splice(idx, 1);
    saveLatestShortcuts();
    redrawShortcuts();
  }
}

function setLastViewtime(subreddit) {
  if (!subredditManager_module.options.storeSubredditVisit.value) return;
  if (!subredditManager_module.options.storeSubredditVisitIncognito.value && isPrivateBrowsing()) return;
  subredditsLastViewedStorage.patch({
    [subreddit.toLowerCase()]: {
      last_visited: Date.now()
    }
  });
}

function subscribeToSubreddit(subredditName, subscribe = true) {
  return ajax({
    method: 'POST',
    url: '/api/subscribe',
    data: {
      sr: subredditName,
      action: subscribe ? 'sub' : 'unsub'
    }
  });
}

async function subredditManager_lastUpdate() {
  const mySubredditList = jquery_default()('.drop-choices.srdrop a').map(function () {
    return this.textContent;
  }).toArray().join();
  const mySubredditListCachedObject = (await session_namespaceObject.get('RESmodules.subredditManager.mySubredditList')) || {};
  const mySubredditListCached = mySubredditListCachedObject[loggedInUser() || 'null'];

  let _lastUpdate;

  if (mySubredditListCached && mySubredditListCached.list === mySubredditList) {
    _lastUpdate = parseInt((new Date().getTime() - mySubredditListCached.time) / 60000, 10);

    if (_lastUpdate > 31) {
      _lastUpdate = false;
      mySubredditListCached.time = new Date().getTime() - 32 * 60000;
    } else {
      _lastUpdate += _lastUpdate > 1 ? ' minutes ago' : ' minute ago';
    }
  } else {
    mySubredditListCachedObject[loggedInUser() || 'null'] = {
      list: mySubredditList,
      time: new Date().getTime()
    };
    _lastUpdate = 'just now';
  }

  if (_lastUpdate !== false && mySubredditListCached) {
    jquery_default()('.listing-chooser a:first .description').after(`<br /><span class="description"><b>last update:</b><br />${_lastUpdate}</span>`);
  }

  const inactiveThreshold = new Date().getTime() - 2592000000;

  for (const [user, cachedObject] of Object.entries(mySubredditListCachedObject)) {
    if (cachedObject.time < inactiveThreshold) {
      delete mySubredditListCachedObject[user];
    }
  }

  session_namespaceObject.set('RESmodules.subredditManager.mySubredditList', mySubredditListCachedObject);
}
// CONCATENATED MODULE: ./lib/modules/betteReddit.js










const betteReddit_module = new Module('betteReddit');
betteReddit_module.moduleName = 'betteRedditName';
betteReddit_module.category = 'appearanceCategory';
betteReddit_module.description = 'betteRedditDesc';
betteReddit_module.options = {
  commentsLinksNewTabs: {
    type: 'boolean',
    value: false,
    description: 'betteRedditCommentsLinksNewTabDesc',
    title: 'betteRedditCommentsLinksNewTabTitle'
  },
  fixHideLinks: {
    type: 'boolean',
    value: true,
    description: 'betteRedditFixHideLinksDesc',
    title: 'betteRedditFixHideLinksTitle'
  },
  hideLinkInstant: {
    type: 'boolean',
    value: false,
    description: 'betteRedditHideLinkInstantDesc',
    title: 'betteRedditHideLinkInstantTitle',
    dependsOn: options => options.fixHideLinks.value
  },
  hideLinkFadeDelay: {
    type: 'text',
    value: '5000',
    description: 'betteRedditHideLinkFadeDelayDesc',
    title: 'betteRedditHideLinkFadeDelayTitle',
    advanced: true,
    dependsOn: options => options.fixHideLinks.value && !options.hideLinkInstant.value
  },
  videoTimes: {
    type: 'boolean',
    value: true,
    description: 'betteRedditVideoTimesDesc',
    title: 'betteRedditVideoTimesTitle',
    advanced: true
  },
  videoUploaded: {
    type: 'boolean',
    value: false,
    description: 'betteRedditVideoUploadedDesc',
    title: 'betteRedditVideoUploadedTitle',
    advanced: true
  },
  videoViewed: {
    type: 'boolean',
    value: false,
    description: 'betteRedditVideoViewedDesc',
    title: 'betteRedditVideoViewedTitle',
    advanced: true
  },
  pinHeader: {
    type: 'enum',
    values: [{
      name: 'None',
      value: 'none'
    }, {
      name: 'Subreddit Bar only',
      value: 'sub'
    }, {
      name: 'User Bar',
      value: 'userbar'
    }, {
      name: 'Subreddit Bar and User bar',
      value: 'subanduser'
    }, {
      name: 'Full Header',
      value: 'header'
    }],
    value: 'none',
    description: 'betteRedditPinHeaderDesc',
    title: 'betteRedditPinHeaderTitle',
    bodyClass: 'pinHeader'
  },
  permanentVerticalScrollbar: {
    type: 'boolean',
    value: true,
    description: 'betteRedditPermanentVerticalScrollbarDesc',
    title: 'betteRedditPermanentVerticalScrollbarTitle',
    bodyClass: true
  },
  showLastEditedTimestamp: {
    type: 'boolean',
    value: true,
    description: 'betteRedditShowLastEditedTimestampDesc',
    title: 'betteRedditShowLastEditedTimestampTitle',
    bodyClass: true
  },
  scoreHiddenTimeLeft: {
    type: 'boolean',
    value: true,
    description: 'betteRedditScoreHiddenTimeLeftDesc',
    title: 'betteRedditScoreHiddenTimeLeftTitle'
  },
  showTimestampPosts: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampPostsDesc',
    title: 'betteRedditShowTimestampPostsTitle',
    bodyClass: true
  },
  showTimestampComments: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampCommentsDesc',
    title: 'betteRedditShowTimestampCommentsTitle',
    bodyClass: true
  },
  showTimestampSidebar: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampSidebarDesc',
    title: 'betteRedditShowTimestampSidebarTitle',
    bodyClass: true
  },
  showTimestampWiki: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampWikiDesc',
    title: 'betteRedditShowTimestampWikiTitle',
    bodyClass: true
  },
  showTimestampModerationLog: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowTimestampModerationLogDesc',
    title: 'betteRedditShowTimestampModerationLogTitle',
    bodyClass: true
  },
  restoreSavedTab: {
    type: 'boolean',
    value: false,
    description: 'betteRedditRestoreSavedTabDesc',
    title: 'betteRedditRestoreSavedTabTitle'
  },
  doNoCtrlF: {
    type: 'boolean',
    value: false,
    description: 'betteRedditDoNoCtrlFDesc',
    title: 'betteRedditDoNoCtrlFTitle'
  },
  showHiddenSortOptions: {
    type: 'boolean',
    value: false,
    description: 'betteRedditShowHiddenSortOptionsDesc',
    title: 'betteRedditShowHiddenSortOptionsTitle',
    bodyClass: true
  },
  truncateLongLinks: {
    type: 'boolean',
    value: false,
    description: 'betteRedditTruncateLongLinksDesc',
    title: 'betteRedditTruncateLongLinksTitle',
    bodyClass: true
  },
  commentCollapseInInbox: {
    type: 'boolean',
    value: false,
    description: 'betteRedditCommentCollapseInInboxDesc',
    title: 'betteRedditCommentCollapseInInboxTitle',
    bodyClass: true
  },
  blankPageUntilMeaningfulContent: {
    type: 'boolean',
    value: false,
    description: 'betteRedditBlankPageUntilMeaningfulContentDesc',
    title: 'betteRedditBlankPageUntilMeaningfulContentTitle'
  },
  restrictScrollEvents: {
    type: 'boolean',
    value: false,
    description: 'betteRedditRestrictScrollEventsDesc',
    title: 'betteRedditRestrictScrollEventsTitle',
    advanced: true
  }
};
betteReddit_module.exclude = ['d2x'];

betteReddit_module.beforeLoad = () => {
  if (betteReddit_module.options.blankPageUntilMeaningfulContent.value) {
    document.documentElement.classList.add('res-hide-body');
  }

  if (betteReddit_module.options.commentsLinksNewTabs.value) {
    Object(watchers["watchForThings"])(['comment'], comment => {
      const body = comment.getTextBody();
      if (body) for (const link of body.querySelectorAll('a')) commentsLinksNewTabs(link);
    });
  }

  if (betteReddit_module.options.fixHideLinks.value) {
    Object(watchers["watchForThings"])(['post'], fixHideLinks);
  }

  if (betteReddit_module.options.doNoCtrlF.value) {
    Object(watchers["watchForElements"])(['page'], '.side a.reddit-comment-link', applyNoCtrlF);
    Object(watchers["watchForThings"])(null, thing => {
      for (const link of thing.entry.querySelectorAll('ul.flat-list.buttons li a')) applyNoCtrlF(link);
    });
  }

  if (betteReddit_module.options.videoTimes.value || betteReddit_module.options.videoUploaded.value || betteReddit_module.options.videoViewed.value) {
    Object(watchers["watchForThings"])(['post'], showVideoData, {
      immediate: true
    });
  }

  switch (betteReddit_module.options.pinHeader.value) {
    case 'userbar':
      Object(dom["a" /* _addHeaderId */])('header-bottom-right', true);

      break;

    case 'sub':
      Object(dom["a" /* _addHeaderId */])('sr-header-area');

      break;

    case 'subanduser':
      Object(dom["a" /* _addHeaderId */])('sr-header-area');

      Object(dom["a" /* _addHeaderId */])('header-bottom-right', true);

      break;

    case 'header':
      Object(dom["a" /* _addHeaderId */])('header');

      break;

    case 'none':
    default:
      break;
  }

  if (betteReddit_module.options.restrictScrollEvents.value) {
    const scr = document.createElement('script');
    scr.innerHTML = `{
			// Prevents overzealous Reddit scroll listeners from constantly mutating the DOM while scrolling
			let debounce, lastEvent;
			window.addEventListener('scroll', e => {
				// Note that '_.debounce' uses Reddit's instance of Lodash
				if (!debounce) debounce = _.debounce(e => window.dispatchEvent(e), 300);
				if (e === lastEvent) return;
				lastEvent = e;
				debounce(e);
				e.stopImmediatePropagation();
			}, true);
		}`;
    document.documentElement.append(scr);
  }
};

betteReddit_module.contentStart = () => {
  if (betteReddit_module.options.blankPageUntilMeaningfulContent.value) {
    document.documentElement.classList.remove('res-hide-body');
  }

  if (betteReddit_module.options.scoreHiddenTimeLeft.value && Object(utils_location["n" /* isPageType */])('comments', 'commentsLinklist')) {
    jquery_default()(document.body).on('mouseenter', '.score-hidden', function () {
      const timeNode = jquery_default()(this).siblings('time').get(0);

      if (timeNode) {
        if (!this.getAttribute('title').includes('revealed')) {
          const scoreHiddenDuration = parseInt(this.getAttribute('title').match(/[0-9]+/)[0], 10);
          const postTime = new Date(timeNode.getAttribute('datetime')).getTime();
          const minutesLeft = Math.ceil((postTime + scoreHiddenDuration * 60000 - new Date().getTime()) / 60000);

          if (minutesLeft >= 1) {
            this.setAttribute('title', `score will be revealed in ${minutesLeft} minute${minutesLeft > 1 ? 's' : ''}`);
          } else {
            this.setAttribute('title', 'reload page to reveal score');
          }
        }
      }
    });
  }

  const user = loggedInUser();

  if (betteReddit_module.options.restoreSavedTab.value && user && document.querySelector('.with-listing-chooser:not(.profile-page)')) {
    restoreSavedTab(user);
  }

  switch (betteReddit_module.options.pinHeader.value) {
    case 'header':
      betteReddit_pinHeader();
      break;

    case 'sub':
      pinSubredditBar();
      break;

    case 'subanduser':
      pinSubredditBar();
      pinUserBar();
      break;

    case 'userbar':
      pinUserBar();
      break;

    default:
      break;
  }
};

function commentsLinksNewTabs(link) {
  link.target = '_blank';
  link.rel = 'noopener noreferer';
}

function fixHideLinks(thing) {
  const orig = thing.getHideElement();
  if (!orig) return;
  const a = document.createElement('a');
  a.className = 'noCtrlF';
  a.href = 'javascript:void 0';
  a.dataset.eventAction = orig.dataset.eventAction;
  a.dataset.text = i18n(orig.dataset.eventAction === 'hide' ? 'betteRedditHideLinkLabel' : 'betteRedditUnhideLinkLabel');
  a.addEventListener('click', () => betteReddit_hideLink(a));
  orig.replaceWith(a);
}

const betteReddit_hideTimer = new Map();

async function betteReddit_hideLink(clickedLink, action = clickedLink.dataset.eventAction) {
  const timeout = betteReddit_module.options.hideLinkInstant.value ? null : parseInt(betteReddit_module.options.hideLinkFadeDelay.value, 10);
  const thing = Thing["a" /* Thing */].checkedFrom(clickedLink);

  if (action === 'hide') {
    const expando = expando_Expando.getEntryExpandoFrom(thing);
    if (expando && expando.types.includes('native')) expando.collapse();

    if (timeout === null) {
      if (!Object(utils_location["n" /* isPageType */])('comments')) jquery_default()(thing.element).hide();
    } else {
      betteReddit_hideTimer.set(clickedLink, setTimeout(() => {
        if (clickedLink.dataset.eventAction === action) return;
        jquery_default()(thing.element).fadeOut(300);
      }, timeout));
    }
  }

  try {
    if (action === 'hide') await thingHide_hide(thing);else await unhide(thing);
  } catch (e) {
    alert_namespaceObject.open(i18n(action === 'hide' ? 'betteRedditHideSubmissionError' : 'betteRedditUnhideSubmissionError'));
    jquery_default()(thing.element).show();
    throw e;
  }
}

async function showVideoData(thing) {
  const url = new URL(thing.getPostUrl(), location.origin);
  if (!youtube.domains.some(domain => url.hostname.endsWith(domain))) return;
  const [id] = youtube.detect(url) || [];
  const data = await (youtube.getVideoData && youtube.getVideoData(id));
  if (!data) return;
  const {
    title,
    duration,
    publishedAt,
    viewCount
  } = data;
  const link = thing.getPostLink();
  const info = [];

  if (betteReddit_module.options.videoUploaded.value) {
    const uploaded = new Date(publishedAt);
    const dt = `${uploaded.toDateString()} ${uploaded.toTimeString()}`;
    const timeAgo = i18n('submitHelperTimeAgo', formatDateDiff(uploaded));
    info.push(`[<time title="${dt}" datetime="${publishedAt}" class="live-timestamp">${timeAgo}</time>]`);
  }

  if (betteReddit_module.options.videoViewed.value && viewCount) {
    info.push(i18n('betteRedditVideoViewed', viewCount));
  }

  const timeMatch = /\/?[&|\?]?(?:t|time_continue)=([\w\-][a-z0-9]*)/i.exec(link.href);
  const titleMatch = /[\[|\(][0-9]*:[0-9]*[\]|\)]/.test(link.textContent);
  let startTime;

  if (timeMatch && !titleMatch) {
    const seconds = fromYoutubeTimecodeToSeconds(timeMatch[1]);
    startTime = Object(utils_time["e" /* fromSecondsToTime */])(seconds);
  }

  if (info.length) {
    link.appendChild(string_namespaceObject.html`<span class="gray pay-link">${string_namespaceObject.safe(info.join(' '))}</span>`);
  }

  link.setAttribute('title', i18n('betteRedditVideoYouTubeTitle', title));

  if (betteReddit_module.options.videoTimes.value) {
    const thumbnail = thing.element.querySelector('a.thumbnail');

    if (thumbnail) {
      thumbnail.appendChild(string_namespaceObject.html`<div class="duration-overlay">${duration}${startTime ? ` (@${startTime})` : ''}</div>`);
    }
  }
}

function fromYoutubeTimecodeToSeconds(tc) {
  let timeSeconds = Number(tc);

  if (Number.isNaN(timeSeconds)) {
    const tcobj = tc.split(/(\d+[hms])/).filter(Boolean).reduce((acc, match) => {
      acc[match.slice(-1)] = Number(match.slice(0, -1));
      return acc;
    }, {});
    timeSeconds = (tcobj.h || 0) * 3600 + (tcobj.m || 0) * 60 + (tcobj.s || 0);
  }

  return timeSeconds;
}

function pinSubredditBar() {
  const sm = isRunning(subredditManager_namespaceObject);
  const sb = document.getElementById('sr-header-area');

  if (!sb) {
    return;
  }

  const header = document.getElementById('header');
  const spacer = document.createElement('div');
  spacer.style.paddingTop = window.getComputedStyle(sb, null).paddingTop;
  spacer.style.paddingBottom = window.getComputedStyle(sb, null).paddingBottom;

  if (sm) {
    spacer.style.height = `${parseInt(window.getComputedStyle(sb, null).height, 10) / 3 - 3}px`;
  } else {
    spacer.style.height = window.getComputedStyle(sb, null).height;
  }

  header.insertBefore(spacer, sb);
  document.body.insertBefore(sb, header);
  Object(dom["b" /* addCSS */])(`
		#header-bottom-left {
			margin-top: 19px;
		}

		div#sr-header-area {
			position: fixed;
			z-index: 10000 !important;
			left: 0;
			right: 0;
		}
	`);
  pinCommonElements(sm);
}

function pinUserBar() {
  const header = document.getElementById('header-bottom-left');
  const userbar = document.getElementById('header-bottom-right');
  window.addEventListener('scroll', Object(debounce["a" /* default */])(() => {
    if (header.getBoundingClientRect().top > 0) {
      userbar.classList.remove('res-floating-userbar');
    } else {
      userbar.classList.add('res-floating-userbar');
    }
  }, 300));
  pinCommonElements();
}

function betteReddit_pinHeader() {
  const sm = isRunning(subredditManager_namespaceObject);
  const header = document.getElementById('header');

  if (!header) {
    console.error('No element found with ID "header".');
    return;
  }

  const headerHeight = jquery_default()('#header').outerHeight(true);
  Object(dom["b" /* addCSS */])(`
		#header,
		#RESAccountSwitcherDropdown {
			position: fixed;
		}
	`);
  pinCommonElements(sm);
  Object(dom["b" /* addCSS */])(`
		#header {
			top: 0;
			left: 0;
			right: 0;
			bottom: auto;
		}
	`);
  jquery_default()('<div>', {
    id: 'RESPinnedHeaderSpacer',
    height: headerHeight
  }).insertBefore(header);
}

function pinCommonElements(sm) {
  if (sm) {
    Object(dom["b" /* addCSS */])(`
			#RESSubredditGroupDropdown,
			#srList,
			#RESShortcutsAddFormContainer,
			#editShortcutDialog {
				position: fixed !important;
			}
		`);
  } else {
    Object(dom["b" /* addCSS */])(`
			#sr-more-link {
				position: fixed;
			}
		`);
  }
}

function restoreSavedTab(user) {
  createElement_namespaceObject.tabMenuItem({
    text: 'saved',
    onChange: () => {
      location.href = `/user/${user}/saved/`;
    }
  });
}

function applyNoCtrlF(element) {
  if (element.classList.contains('noCtrlF')) return;
  element.classList.add('noCtrlF');
  element.dataset.text = element.textContent;
  element.textContent = '';
}
// CONCATENATED MODULE: ./lib/modules/commentDepth.js



const commentDepth_module = new Module('commentDepth');
commentDepth_module.moduleName = 'commentDepthName';
commentDepth_module.category = 'commentsCategory';
commentDepth_module.disabledByDefault = true;
commentDepth_module.description = 'commentDepthDesc';
commentDepth_module.options = {
  defaultCommentDepth: {
    type: 'text',
    value: '4',
    description: 'commentDepthDefaultCommentDepthDesc',
    title: 'commentDepthDefaultCommentDepthTitle'
  },
  defaultMinimumComments: {
    type: 'text',
    value: '50',
    description: 'commentDepthDefaultMinimumCommentsDesc',
    title: 'commentDepthDefaultMinimumCommentsTitle'
  },
  commentPermalinks: {
    type: 'boolean',
    value: false,
    description: 'commentDepthCommentPermaLinksDesc',
    title: 'commentDepthCommentPermaLinksTitle'
  },
  commentPermalinksContext: {
    dependsOn: options => options.commentPermalinks.value,
    type: 'boolean',
    value: false,
    description: 'commentDepthCommentPermalinksContextDesc',
    title: 'commentDepthCommentPermalinksContextTitle'
  },
  subredditCommentDepths: {
    type: 'table',
    addRowText: 'commentDepthAddSubreddit',
    fields: [{
      key: 'subreddits',
      name: 'commentDepthSubreddit',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'commentDepth',
      name: 'commentDepthCommentDepth',
      type: 'text',
      value: '4'
    }, {
      key: 'minimumComments',
      name: 'commentDepthMinimumComments',
      type: 'text',
      value: '50'
    }],
    value: [],
    description: 'commentDepthSubredditCommentDepthsDesc',
    title: 'commentDepthSubredditCommentDepthsTitle'
  }
};

commentDepth_module.contentStart = () => {
  jquery_default()(document.body).on('mousedown', 'a[href*="/comments"]', e => {
    const target = e.currentTarget;
    const url = new URL(target.href, location.href);
    if (url.searchParams.has('depth')) return;

    if (utils_location["p" /* regexes */].commentPermalink.test(url.pathname)) {
      if (!commentDepth_module.options.commentPermalinks.value) return;
      if (!commentDepth_module.options.commentPermalinksContext.value && url.searchParams.has('context')) return;
    }

    const matches = utils_location["f" /* execRegexes */].comments(url.pathname);
    if (!matches) return;
    const subreddit = matches[1].toLowerCase();
    const [, commentDepth, minimumComments] = commentDepth_module.options.subredditCommentDepths.value.find(([subreddits]) => subreddits.toLowerCase().split(',').includes(subreddit)) || [null, commentDepth_module.options.defaultCommentDepth.value, commentDepth_module.options.defaultMinimumComments.value];
    if (!parseInt(commentDepth, 10)) return;
    const minimumCount = parseInt(minimumComments, 10);

    if (minimumCount) {
      const thing = Thing["a" /* Thing */].from(e.currentTarget);
      if (thing && thing.isPost() && (thing.getCommentCount() || 0) < minimumCount) return;
    }

    url.searchParams.set('depth', commentDepth);
    target.removeAttribute('data-inbound-url');
    target.href = url.href;
  });
};
// CONCATENATED MODULE: ./lib/modules/commentHidePersistor.js




const commentHidePersistor_module = new Module('commentHidePersistor');
commentHidePersistor_module.moduleName = 'commentHidePerName';
commentHidePersistor_module.category = 'commentsCategory';
commentHidePersistor_module.description = 'commentHidePerDesc';
commentHidePersistor_module.include = ['comments', 'inbox'];
const COLLAPSE_REASON = 'commentHidePersistor';
const commentHidePersistor_currentId = (utils_location["f" /* execRegexes */].comments(location.pathname) || [])[2];
const commentHidePersistor_entryStorage = storage_namespaceObject.wrapPrefix('commentHidePersistor.', () => ({
  updateTime: Date.now()
}));
const commentHidePersistor_initial = commentHidePersistor_currentId && commentHidePersistor_entryStorage.get(commentHidePersistor_currentId);

commentHidePersistor_module.beforeLoad = async () => {
  const {
    collapsedThings
  } = (await commentHidePersistor_initial) || {};
  if (!collapsedThings) return;
  Object(watchers["watchForThings"])(['comment'], thing => {
    if (collapsedThings.hasOwnProperty(thing.getFullname())) thing.setCommentCollapse(true, COLLAPSE_REASON);
  }, {
    immediate: true
  });
};

commentHidePersistor_module.contentStart = () => {
  listenToCommentCollapse();
  maybePruneOldEntries('commentHidePersistor', commentHidePersistor_entryStorage);
};

function listenToCommentCollapse() {
  jquery_default()(document.body).on('click', 'a.expand', e => {
    const thing = Thing["a" /* Thing */].checkedFrom(e.currentTarget);
    const collapsed = thing.isCollapsed();

    if (collapsed) {
      const currentCollapseReason = e.currentTarget.getAttribute('collapse-reason');
      if (currentCollapseReason && currentCollapseReason !== COLLAPSE_REASON) return;
      commentHidePersistor_entryStorage.patch(commentHidePersistor_currentId, {
        collapsedThings: {
          [thing.getFullname()]: true
        },
        updateTime: Date.now()
      });
    } else {
      e.currentTarget.removeAttribute('collapse-reason');
      commentHidePersistor_entryStorage.deletePath(commentHidePersistor_currentId, 'collapsedThings', thing.getFullname());
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/commentPreview.js










const commentPreview_module = new Module('commentPreview');
commentPreview_module.moduleName = 'commentPrevName';
commentPreview_module.category = 'commentsCategory';
commentPreview_module.description = 'commentPrevDesc';
commentPreview_module.options = {
  enableBigEditor: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableBigEditorDesc',
    title: 'commentPreviewEnableBigEditorTitle'
  },
  swapBigEditorLayout: {
    type: 'boolean',
    value: false,
    description: 'commentPreviewSwapBigEditorLayoutDesc',
    title: 'commentPreviewSwapBigEditorLayoutTitle',
    bodyClass: true
  },
  openBigEditor: {
    type: 'keycode',
    value: [69, false, true, false, false],
    description: 'commentPreviewOpenBigEditorDesc',
    title: 'commentPreviewOpenBigEditorTitle'
  },
  draftStyle: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewDraftStyleDesc',
    title: 'commentPreviewDraftStyleTitle',
    advanced: true,
    bodyClass: true
  },
  enableForComments: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForCommentsDesc',
    title: 'commentPreviewEnableForCommentsTitle',
    advanced: true
  },
  enableForPosts: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForPostsDesc',
    title: 'commentPreviewEnableForPostsTitle',
    advanced: true
  },
  enableForWiki: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForWikiDesc',
    title: 'commentPreviewEnableForWikiTitle',
    advanced: true
  },
  enableForSubredditConfig: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForSubredditConfigDesc',
    title: 'commentPreviewEnableForSubredditConfigTitle',
    advanced: true
  },
  enableForBanMessages: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewEnableForBanMessagesDesc',
    title: 'commentPreviewEnableForBanMessagesTitle',
    advanced: true
  },
  sidebarPreview: {
    type: 'boolean',
    value: true,
    description: 'commentPreviewSidebarPreviewDesc',
    title: 'commentPreviewSidebarPreviewTitle',
    advanced: true
  }
};
commentPreview_module.include = ['comments', 'inbox', 'submit', 'profile', 'modqueue', 'subredditAbout', 'wiki'];
commentPreview_module.exclude = ['d2x', /^\/(?:r\/[\-\w\.]+\/)?wiki\/edit\/config\/automoderator\b/i];
const subredditImages = new Map();
let isWiki, isBan;

commentPreview_module.beforeLoad = () => {
  isWiki = Object(utils_location["n" /* isPageType */])('wiki');
  isBan = /^https?:\/\/(?:[\-\w\.]+\.)?reddit\.com\/r\/[\-\w\.]+\/about\/banned/i.test(location.href);
  const subreddit = Object(utils_location["d" /* currentSubreddit */])();
  if (isWiki && subreddit) initWikiImages(subreddit);
};

commentPreview_module.contentStart = () => {
  if (commentPreview_module.options.enableBigEditor.value) {
    if (isRunning(keyboardNav_namespaceObject)) {
      jquery_default()(document.body).on('keydown', '.usertext-edit textarea, #wiki_page_content', e => {
        if (checkKeysForEvent(e, commentPreview_module.options.openBigEditor.value)) {
          showBigEditor(e);
        }
      });
    }
  }

  if (isWiki) {
    attachWikiPreview();
    addBigEditorButton(document.querySelector('.markhelp'));
  } else {
    jquery_default()(document.body).on('focus', commentTextareaSelector, e => {
      addBigEditorButton(e.currentTarget);
      attachPreview(e.currentTarget);
    });
  }
};

async function initWikiImages(subreddit) {
  const {
    data
  } = await ajax({
    url: `/r/${subreddit}/about/stylesheet.json`,
    type: 'json'
  });

  if (data && data.images) {
    for (const {
      name,
      url
    } of data.images) {
      subredditImages.set(name, url);
    }
  }
}

function markdownToHTML(md) {
  if (isBan && md.length) {
    md = generateBanMessage(md, Object(utils_location["d" /* currentSubreddit */])() || '');
  }

  if (!isWiki) {
    return snudown_es_markdown(md);
  } else {
    const $doc = jquery_default()('<body>').html(markdownWiki(md));

    for (const img of $doc.find('img')) {
      const src = img.getAttribute('src');
      const imgKey = src && src.startsWith('%%') && src.endsWith('%%') && src.slice('%%'.length, -'%%'.length);
      const resolvedSrc = imgKey && subredditImages.get(imgKey);

      if (resolvedSrc) {
        img.src = resolvedSrc;
      } else {
        img.remove();
      }
    }

    const headerIds = new Map();
    const headers = $doc.find('h1, h2, h3, h4, h5, h6');
    const tocDiv = jquery_default()('<div>').addClass('toc');
    let $parent = jquery_default()('<ul>');
    $parent.data('level', 1);
    tocDiv.append($parent);
    let level = 1;
    let previous = 1;
    headers.each(function () {
      const contents = jquery_default()(this).text();
      let aid = jquery_default()('<div>').html(contents).text();
      aid = `${'wiki'}_${aid.replace(/ /g, '_').toLowerCase()}`;
      aid = aid.replace(/[^\w\.\-]/g, s => `.${s.charCodeAt(0).toString(16).toUpperCase()}`);
      const idNum = (headerIds.get(aid) || 0) + 1;
      headerIds.set(aid, idNum);

      if (idNum > 1) {
        aid += idNum;
      }

      jquery_default()(this).attr('id', aid);
      const li = jquery_default()('<li>').addClass(aid);
      const a = jquery_default()('<a>').attr('href', `#${aid}`).text(contents);
      li.append(a);
      const thisLevel = +this.tagName.slice(-1);

      if (thisLevel > previous) {
        const $newUL = jquery_default()('<ul>');
        $newUL.data('level', thisLevel);
        $parent.append($newUL);
        $parent = $newUL;
        level++;
      } else if (thisLevel < previous) {
        while (level > 1 && $parent.data('level') > thisLevel) {
          $parent = $parent.parent();
          level--;
        }
      }

      previous = thisLevel;
      $parent.append(li);
    });
    $doc.prepend(tocDiv);
    return $doc.html();
  }
}

const addBigEditorButton = ele => {
  if (!commentPreview_module.options.enableBigEditor.value) return;
  const container = ele.closest('#editform, .usertext-edit, #banned');
  if (!container) return;
  const bigEditorButton = container.querySelector('.RESBigEditorPop') || string_namespaceObject.html`
		<button type="button" class="RESBigEditorPop" tabIndex="3">
			<span class="res-icon res-icon-12">&#xF0A4;</span> big editor
		</button>
	`;

  if (isBan || isWiki) {
    ele.after(bigEditorButton);
  } else {
    const bottom = container.querySelector('.bottom-area');
    bottom.prepend(bigEditorButton);
  }

  bigEditorButton.addEventListener('click', showBigEditor);
};

const attachPreview = textarea => {
  if (!commentPreview_module.options.enableForComments.value && textarea.closest('.commentarea, .message') || !commentPreview_module.options.enableForPosts.value && (Object(utils_location["n" /* isPageType */])('submit') || textarea.closest('.link')) || !commentPreview_module.options.enableForSubredditConfig.value && /^\/r\/[\-\w.]+\/about\/edit/i.test(location.pathname) || !commentPreview_module.options.enableForBanMessages.value && isBan) {
    return;
  }

  const container = textarea.closest('.usertext-edit, #banned');
  if (!container) return;
  const preview = container.querySelector('.livePreview') || makePreviewBox();
  const elements = [preview.querySelector('.RESDialogContents')];

  if (commentPreview_module.options.sidebarPreview.value && textarea.getAttribute('name') === 'description') {
    elements.push(document.querySelector('.side .usertext-body .md'));
  }

  jquery_default()(textarea).on('input', Object(debounce["a" /* default */])(() => onTextareaInput(textarea, preview, elements), 100));
  onTextareaInput(textarea, preview, elements);
  jquery_default()(textarea.closest('form')).on('submit', () => {
    preview.remove();
  });
  container.append(preview);
};

function attachWikiPreview() {
  if (!commentPreview_module.options.enableForWiki.value) return;
  const preview = makePreviewBox();
  preview.querySelector('.md').classList.add('wiki');
  document.querySelector('#editform > br').after(preview);
  const contents = preview.querySelector('.RESDialogContents');
  jquery_default()('#wiki_page_content').on('input focus', Object(debounce["a" /* default */])(e => onTextareaInput(e.currentTarget, preview, [contents]), 100));
}

function onTextareaInput(textarea, preview, elements) {
  const markdownText = Object(flow["a" /* downcast */])(textarea, HTMLTextAreaElement).value;

  if (markdownText.length) {
    if (preview) preview.hidden = false;

    for (const ele of elements) ele.innerHTML = markdownToHTML(markdownText);
  } else {
    if (preview) preview.hidden = true;

    for (const ele of elements) Object(dom["e" /* empty */])(ele);
  }
}

function makePreviewBox() {
  return string_namespaceObject.html`
		<div class="RESDialogSmall livePreview">
			<h3>Live Preview</h3>
			${string_namespaceObject.safe(makeUrlHashLink(commentPreview_module.moduleID, undefined, ' ', 'gearIcon'))}
			<div class="md RESDialogContents"></div>
		</div>
	`;
}

const createBigEditor = Object(once["a" /* default */])(() => {
  const $editor = jquery_default()('<div id="BigEditor">');
  const $left = jquery_default()('<div class="BELeft RESDialogSmall"><h3>Editor</h3></div>');
  const $contents = jquery_default()('<div class="RESDialogContents"><textarea id="BigText" name="text" class=""></textarea></div>');
  const $textarea = $contents.find('textarea');
  const $foot = jquery_default()('<div class="BEFoot">');

  if (!isBan) {
    $foot.append(jquery_default()('<button type="button">save</button>').on('click', () => {
      const len = $textarea.val().length;
      const max = $textarea.data('max-length');

      if (len > max) {
        jquery_default()('#BigEditor .errorList .error').hide().filter('.TOO_LONG').text(`this is too long (max: ${max})`).show();
      } else if (len === 0) {
        jquery_default()('#BigEditor .errorList .error').hide().filter('.NO_TEXT').show();
      } else {
        hideBigEditor(true);
      }
    }));
  }

  $foot.append(jquery_default()('<button type="button">close</button>').on('click', () => hideBigEditor()));
  $foot.append(jquery_default()(`
		<span class="errorList">
			<span style="display: none;" class="error NO_TEXT">we need something here</span>
			<span style="display: none;" class="error TOO_LONG">this is too long (max: 10000)</span>
		</span>
	`));
  $contents.append($foot);
  $left.append($contents);
  const $right = jquery_default()(`
		<div class="BERight RESDialogSmall"><h3>Preview</h3><div class="RESCloseButton RESCloseButtonTopRight"></div>
		<div class="RESDialogContents"><div id="BigPreview" class=" md"></div></div></div>
	`);
  $editor.append($left).append($right);
  $right.find('.RESCloseButton').on('click', () => hideBigEditor());
  const $preview = $right.find('#BigPreview');
  $textarea.on('input', Object(debounce["a" /* default */])(() => onTextareaInput($textarea.get(0), null, [$preview.get(0)]), 100));
  $editor.on('keydown', e => {
    if (e.key === NAMED_KEYS.Escape) {
      hideBigEditor();
      e.preventDefault();
      return false;
    }
  });
  return $editor;
});
let $bigTextTarget;

function showBigEditor(e) {
  e.preventDefault();
  const $editor = createBigEditor();
  jquery_default()(document.body).append($editor).addClass('RESScrollLock');
  const $textarea = $editor.find('textarea');
  let $baseText;

  if (!isWiki && !isBan) {
    $baseText = jquery_default()(e.currentTarget).parents('.usertext-edit:first').find('textarea');
    const limit = $baseText.attr('data-limit');
    $textarea.attr('data-limit', limit);
    jquery_default()('#BigPreview').removeClass('wiki');
    jquery_default()('.BERight .RESDialogContents').removeClass('wiki-page-content');
  } else if (isBan) {
    $baseText = jquery_default()('#ban_message');
    const limit = $baseText.attr('data-limit');
    $textarea.attr('data-limit', limit);
    jquery_default()('#BigPreview').removeClass('wiki');
    jquery_default()('.BERight .RESDialogContents').removeClass('wiki-page-content');
  } else {
    $baseText = jquery_default()('#wiki_page_content');
    jquery_default()('#BigPreview').addClass('wiki');
    jquery_default()('.BERight .RESDialogContents').addClass('wiki-page-content');
  }

  const markdown = $baseText.val();
  const maxLength = $baseText.data('max-length');
  $textarea.data('max-length', maxLength).val(markdown).focus();
  $bigTextTarget = $baseText;
  $textarea.get(0).dispatchEvent(new Event('input', {
    bubbles: true,
    cancelable: true
  }));
}

function hideBigEditor(save = false) {
  if (!$bigTextTarget) throw new Error();
  const $editor = createBigEditor();
  const $textarea = $editor.find('textarea');
  $bigTextTarget.val($textarea.val());
  $bigTextTarget.get(0).dispatchEvent(new Event('input', {
    bubbles: true,
    cancelable: true
  }));

  if (save) {
    $bigTextTarget.closest('form').find('input[type=submit], button[type=submit]').click();
  } else {
    $bigTextTarget.focus();
  }

  $editor.get(0).remove();
  jquery_default()(document.body).removeClass('RESScrollLock');
  $bigTextTarget = null;
}

function generateBanMessage(message, subreddit) {
  return [`you have been banned from posting to [/r/${subreddit}](/r/${subreddit}).`, '', 'note from the moderators:', '', message.replace(/^/gm, '> '), '', 'you can contact the moderators regarding your ban by replying to this message. **warning**: using other accounts to circumvent a subreddit ban is considered a violation of reddit\'s [site rules](/rules) and can result in being banned from reddit entirely.'].join('\r\n');
}
// CONCATENATED MODULE: ./lib/modules/commentQuickCollapse.js




const commentQuickCollapse_module = new Module('commentQuickCollapse');
commentQuickCollapse_module.moduleName = 'commentQuickCollapseName';
commentQuickCollapse_module.category = 'commentsCategory';
commentQuickCollapse_module.description = 'commentQuickCollapseDesc';
commentQuickCollapse_module.options = {
  hideCommentsOnHeaderDoubleClick: {
    type: 'boolean',
    value: true,
    description: 'hideCommentsOnHeaderDoubleClickDesc',
    title: 'hideCommentsOnHeaderDoubleClickTitle'
  },
  toggleCommentsOnClickLeftEdge: {
    type: 'boolean',
    value: false,
    bodyClass: true,
    description: 'toggleCommentsOnClickLeftEdgeDesc',
    title: 'toggleCommentsOnClickLeftEdgeTitle'
  },
  leftEdgeColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#d1d1d1',
    description: 'toggleCommentsLeftEdgeColorDesc',
    title: 'toggleCommentsLeftEdgeColorTitle'
  },
  leftEdgeHoverColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#b1b1b1',
    description: 'toggleCommentsLeftEdgeHoverColorDesc',
    title: 'toggleCommentsLeftEdgeHoverColorTitle'
  },
  leftEdgeCollapsedColor: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'color',
    value: '#b1b1b1',
    description: 'toggleCommentsLeftEdgeCollapsedColorDesc',
    title: 'toggleCommentsLeftEdgeCollapsedColorTitle'
  },
  leftEdgeWidth: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'text',
    value: '50',
    description: 'toggleCommentsLeftEdgeWidthDesc',
    title: 'toggleCommentsLeftEdgeWidthTitle'
  },
  hideCollapseButton: {
    dependsOn: options => options.toggleCommentsOnClickLeftEdge.value,
    type: 'boolean',
    value: false,
    bodyClass: true,
    description: 'toggleCommentsLeftEdgeHideButtonDesc',
    title: 'toggleCommentsLeftEdgeHideButtonTitle'
  },
  scrollOnCollapse: {
    type: 'boolean',
    value: false,
    description: 'scrollOnCollapseDesc',
    title: 'scrollOnCollapseTitle'
  }
};
commentQuickCollapse_module.include = ['comments'];

commentQuickCollapse_module.beforeLoad = () => {
  if (commentQuickCollapse_module.options.toggleCommentsOnClickLeftEdge.value) {
    toggleCommentsOnClickLeftEdge();
  }
};

commentQuickCollapse_module.contentStart = () => {
  if (commentQuickCollapse_module.options.hideCommentsOnHeaderDoubleClick.value) {
    hideCommentsOnHeaderDoubleClick();
  }

  if (commentQuickCollapse_module.options.scrollOnCollapse.value) {
    scrollOnCollapse();
  }
};

function hideCommentsOnHeaderDoubleClick() {
  jquery_default()(document.body).on('dblclick', '.tagline', e => {
    const thing = Thing["a" /* Thing */].checkedFrom(e.currentTarget);
    thing.setCommentCollapse(!thing.isCollapsed(), 'commentQuickCollapse');

    if (window.getSelection()) {
      window.getSelection().removeAllRanges();
    }
  });
}

function toggleCommentsOnClickLeftEdge() {
  const leftEdgeWidth = lodash_es_clamp(parseInt(commentQuickCollapse_module.options.leftEdgeWidth.value, 10), 0, parseInt(commentQuickCollapse_module.options.leftEdgeWidth.default, 10)) / 100;
  Object(dom["b" /* addCSS */])(`
		.commentarea .comment {
			padding-left: ${2.5 * leftEdgeWidth}em !important;
		}

		.commentarea .comment > .entry > .tagline > .expand:hover {
			background-color: ${commentQuickCollapse_module.options.leftEdgeHoverColor.value};
		}

		.commentarea .entry > .tagline > .expand {
			width: ${2 * leftEdgeWidth}em !important;
			background-color: ${commentQuickCollapse_module.options.leftEdgeColor.value};
		}

		.commentarea .collapsed > .entry > .tagline > .expand {
			background-color: ${commentQuickCollapse_module.options.leftEdgeCollapsedColor.value};
		}
	`);
}

function scrollOnCollapse() {
  jquery_default()(document.body).on('click', '.expand', event => {
    if (dom["c" /* click */].isProgrammaticEvent(event)) return;
    const thing = Thing["a" /* Thing */].checkedFrom(event.target);
    if (thing.element.classList.contains('noncollapsed')) return;
    const target = thing.getClosest(Thing["a" /* Thing */].prototype.getNextSibling, {
      direction: 'down'
    });
    if (!target) return;
    selectedThing_namespaceObject.set(target, {
      scrollStyle: 'adopt',
      from: thing.entry
    });
  });
}
// CONCATENATED MODULE: ./lib/modules/commentSortBy.js


const commentSortBy_module = new Module('commentSortBy');
commentSortBy_module.moduleName = 'commentSortByTitle';
commentSortBy_module.category = 'commentsCategory';
commentSortBy_module.description = 'commentSortByDesc';
commentSortBy_module.include = ['d2x'];

commentSortBy_module.beforeLoad = () => {
  watchForRedditEvents('postModTools', (element, {
    _: {
      update
    }
  }) => {
    if (update) return;

    const _base = document.querySelector('#CommentSort--SortPicker');

    const base = _base && _base.parentElement;
    if (!base || base.querySelector('.sortByPrefLink')) return;
    base.append(string_namespaceObject.html`
			<a
				class="sortByPrefLink gearIcon"
				style="opacity: 0.3;"
				title="Go to comment sort preferences"
				href="https://old.reddit.com/prefs/#default_comment_sort"
				target="_blank"
			>${'\u00A0'}</a>
		`);
  });
};
// CONCATENATED MODULE: ./lib/modules/commentStyle.js


const commentStyle_module = new Module('commentStyle');
commentStyle_module.moduleName = 'commentStyleName';
commentStyle_module.category = 'appearanceCategory';
commentStyle_module.description = 'commentStyleDesc';
commentStyle_module.options = {
  commentBoxes: {
    type: 'boolean',
    value: true,
    description: 'commentStyleCommentBoxesDesc',
    title: 'commentStyleCommentBoxesTitle',
    bodyClass: 'res-commentBoxes'
  },
  commentRounded: {
    type: 'boolean',
    value: true,
    description: 'commentStyleCommentRoundedDesc',
    title: 'commentStyleCommentRoundedTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-commentBoxes-rounded'
  },
  commentHoverBorder: {
    type: 'boolean',
    value: false,
    description: 'commentStyleCommentHoverBorderDesc',
    title: 'commentStyleCommentHoverBorderTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-commentHoverBorder'
  },
  commentIndent: {
    type: 'text',
    value: '10',
    description: 'commentStyleCommentIndentDesc',
    title: 'commentStyleCommentIndentTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value
  },
  continuity: {
    type: 'boolean',
    value: false,
    description: 'commentStyleContinuityDesc',
    title: 'commentStyleContinuityTitle',
    advanced: true,
    dependsOn: options => options.commentBoxes.value,
    bodyClass: 'res-continuity'
  }
};
commentStyle_module.include = ['comments', 'commentsLinklist'];
commentStyle_module.exclude = ['d2x'];

commentStyle_module.beforeLoad = () => {
  if (commentStyle_module.options.commentBoxes.value && commentStyle_module.options.commentIndent.value) {
    Object(dom["b" /* addCSS */])(`
			.res-commentBoxes .comment {
				margin-left: ${commentStyle_module.options.commentIndent.value}px !important;
			}
		`);
  }
};
// CONCATENATED MODULE: ./lib/modules/context.js




const context_module = new Module('context');
context_module.moduleName = 'contextName';
context_module.category = 'commentsCategory';
context_module.description = 'contextDesc';
context_module.options = {
  viewFullContext: {
    type: 'boolean',
    value: true,
    description: 'contextViewFullContextDesc',
    title: 'contextViewFullContextTitle'
  },
  defaultContext: {
    type: 'text',
    value: '3',
    description: 'contextDefaultContextDesc',
    title: 'contextDefaultContextTitle'
  }
};
context_module.include = ['comments', 'commentsLinklist', 'inbox', 'profile', 'modqueue'];

context_module.beforeLoad = () => {
  const [,,, id] = utils_location["p" /* regexes */].commentPermalink.exec(location.pathname) || [];

  if (context_module.options.viewFullContext.value && id) {
    Object(watchers["watchForThings"])(['comment'], Object(once["a" /* default */])(thing => {
      if (thing.getButtons().querySelectorAll('.bylink').length < 2) return;
      const pInfobar = document.querySelector('.infobar:not(#searchexpando) p');
      if (pInfobar) pInfobar.append('\u00A0', string_namespaceObject.html`<a href="?context=10000">view the full context</a>`, '\u00A0→');
    }));
  }
};

context_module.contentStart = () => {
  const defaultContextDepth = parseInt(context_module.options.defaultContext.value, 10);

  if (Object(utils_location["n" /* isPageType */])('commentsLinklist', 'inbox', 'profile', 'modqueue') && defaultContextDepth >= 0) {
    jquery_default()(document.body).on('mousedown', 'a.bylink', e => {
      const target = e.currentTarget;
      target.href = target.href.replace(/(\?|&|;)context=\d+\b/, `$1context=${defaultContextDepth}`);
    });
  }
};
// CONCATENATED MODULE: ./lib/modules/contribute.js




const contribute_module = new Module('contribute');
contribute_module.moduleName = 'contributeName';
contribute_module.category = 'aboutCategory';
contribute_module.sort = -9;
contribute_module.alwaysEnabled = true;
contribute_module.description = 'contributeDesc';

contribute_module.contentStart = () => {
  menu_addMenuItem(() => string_namespaceObject.html`<span>${i18n('donateToRES')} &#8679;</span>`, () => {
    openNewTab('https://redditenhancementsuite.com/contribute/');
  });
};
// CONCATENATED MODULE: ./lib/modules/dashboard.js








const dashboard_module = new Module('dashboard');
dashboard_module.moduleName = 'dashboardName';
dashboard_module.category = 'productivityCategory';
dashboard_module.description = 'dashboardDesc';
dashboard_module.options = {
  menuItem: {
    type: 'boolean',
    value: true,
    description: 'dashboardMenuItemDesc',
    title: 'dashboardMenuItemTitle'
  },
  defaultPosts: {
    type: 'text',
    value: '3',
    description: 'dashboardDefaultPostsDesc',
    title: 'dashboardDefaultPostsTitle',
    advanced: true
  },
  defaultSort: {
    type: 'enum',
    values: [{
      name: 'hot',
      value: 'hot'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'rising',
      value: 'rising'
    }, {
      name: 'controversial',
      value: 'controversial'
    }, {
      name: 'top',
      value: 'top'
    }],
    value: 'hot',
    description: 'dashboardDefaultSortDesc',
    title: 'dashboardDefaultSortTitle'
  },
  defaultSortSearch: {
    type: 'enum',
    values: [{
      name: 'relevance',
      value: 'relevance'
    }, {
      name: 'top',
      value: 'top'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'comments',
      value: 'comments'
    }],
    value: 'relevance',
    description: 'dashboardDefaultSortSearchDesc',
    title: 'dashboardDefaultSortSearchTitle'
  },
  dashboardShortcut: {
    type: 'boolean',
    value: true,
    description: 'dashboardDashboardShortcutDesc',
    title: 'dashboardDashboardShortcutTitle'
  }
};
const initialWidgetLoad = Object(once["a" /* default */])(getLatestWidgets);

dashboard_module.beforeLoad = () => {
  if (dashboard_module.options.menuItem.value) {
    const dashboardUrl = Object(utils_location["i" /* isAppType */])('d2x') ? 'https://old.reddit.com/r/Dashboard' : '/r/Dashboard';
    menu_addMenuItem(() => string_namespaceObject.html`<a href="${dashboardUrl}">${i18n('myDashboard')}</a>`, undefined, -7);
  }
};

dashboard_module.contentStart = () => {
  addDashboardTab('dashboardContents', 'My dashboard', dashboard_module.moduleID, dashboard_addDashboardFunctionality);

  if (dashboard_module.options.dashboardShortcut.value) {
    createElement_namespaceObject.sidebarSubscribeButtonWrappers().forEach(wrapper => {
      const button = createSubredditToggleButton(wrapper.getAttribute('subreddit'));
      initialWidgetLoad().then(() => button.dispatchEvent(new CustomEvent('refresh')));
      button.classList.add('RESDashboardToggle');
      wrapper.append(button);
    });
  }
};

const MAX_ROWS = 100;
const dashboardStorage = storage_namespaceObject.wrap(() => `RESmodules.dashboard.${loggedInUser() || 'null'}`, []);
let widgets = [];

async function getLatestWidgets() {
  widgets = (await dashboardStorage.get()).filter(Boolean);
}

async function dashboard_addDashboardFunctionality(tabPage) {
  await initialWidgetLoad();
  attachAddComponent(jquery_default()(tabPage));
  attachEditComponent();
  initUpdateQueue();
}

function initUpdateQueue() {
  for (const widget of widgets) {
    if (widget) addWidget(widget);
  }

  sortable_core_esm.create(document.querySelector('#RESDashboard'), {
    handle: 'div.RESDashboardComponentHeader',
    onChange: () => saveOrder()
  });
}

const updateQueue = [];
let updateQueueTimer;

function addToUpdateQueue(updateFunction) {
  updateQueue.push(updateFunction);

  if (!updateQueueTimer) {
    updateQueueTimer = setInterval(processUpdateQueue, 2000);
    setTimeout(processUpdateQueue, 100);
  }
}

function processUpdateQueue() {
  const thisUpdate = updateQueue.pop();
  thisUpdate();

  if (updateQueue.length < 1) {
    clearInterval(updateQueueTimer);
    updateQueueTimer = undefined;
  }
}

function saveOrder() {
  const data = jquery_default()('#siteTable li.RESDashboardComponent').toArray().map(e => jquery_default()(e).attr('id'));
  data.reverse();
  const newOrder = [];

  for (const widget of widgets) {
    const newIndex = data.indexOf(widget.basePath.replace(/(\/|\+)/g, '_'));
    newOrder[newIndex] = widget;
  }

  widgets = newOrder;
  dashboardStorage.set(widgets);
}

let widgetBeingEdited;

function attachEditComponent() {
  const $dashboardEditComponent = jquery_default()('<div id="RESDashboardEditComponent" class="RESDashboardComponent" />');
  $dashboardEditComponent.html(`
		<div class="editWidget">Edit widget</div>
		<div id="editRedditFormContainer" class="editRedditForm">
			<form id="editRedditForm">
				<input type="text" id="editReddit" placeholder="subreddit / multireddit">
				<input type="text" id="editRedditDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="updateButton" value="save changes">
				<input type="cancel" class="cancelButton" value="cancel">
			</form>
			<form id="editSearchForm">
				<input type="text" id="editSearch" placeholder="search terms">
				<input type="text" id="editSearchDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="updateButton" value="save changes">
				<input type="cancel" class="cancelButton" value="cancel">
			</form>
		</div>
	`);
  $dashboardEditComponent.find('#editRedditForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    let thisBasePath = jquery_default()('#editReddit').val();

    if (thisBasePath !== '') {
      thisBasePath = thisBasePath.replace(/,|\s/g, '+');
      widgetBeingEdited.formerBasePath = widgetBeingEdited.basePath;
      widgetBeingEdited.basePath = `/r/${thisBasePath}`;
      widgetBeingEdited.displayName = jquery_default()('#editRedditDisplayName').val();
      widgetBeingEdited.update();
      jquery_default()('#RESDashboardEditComponent').fadeOut(() => jquery_default()('#editReddit').blur());
      widgetBeingEdited.widgetEle.find('.widgetPath').text(widgetBeingEdited.displayName).attr('title', `/r/${thisBasePath}`);
      dashboard_updateWidget();
    }
  });
  $dashboardEditComponent.find('#editSearchForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = jquery_default()('#editSearch').val();
    widgetBeingEdited.formerBasePath = widgetBeingEdited.basePath;
    widgetBeingEdited.basePath = string_namespaceObject.encode`/search?q=${thisBasePath}`;
    widgetBeingEdited.displayName = jquery_default()('#editSearchDisplayName').val();
    widgetBeingEdited.update();
    jquery_default()('#RESDashboardEditComponent').fadeOut(() => {
      jquery_default()('#editSearch').val('').blur();
      jquery_default()('#editSearchDisplayName').val('').blur();
    });
    widgetBeingEdited.widgetEle.find('.widgetPath').text(widgetBeingEdited.displayName).attr('title', thisBasePath);
    dashboard_updateWidget();
  });
  $dashboardEditComponent.find('.cancelButton').click(() => {
    if (widgetBeingEdited.basePath.startsWith('/search?q=')) {
      jquery_default()('#RESDashboardEditComponent').fadeOut(() => jquery_default()('#editSearchDisplayName').val('').blur());
    } else {
      jquery_default()('#RESDashboardEditComponent').fadeOut(() => jquery_default()('#editReddit').blur());
    }
  });
  jquery_default()(document.body).append($dashboardEditComponent);
}

function showEditForm() {
  const basePath = widgetBeingEdited.basePath;
  const widgetEle = widgetBeingEdited.widgetEle;
  const eleTop = jquery_default()(widgetEle).position().top;
  const eleWidth = jquery_default()(widgetEle).width();
  jquery_default()('#RESDashboardEditComponent').css('top', `${eleTop}px`).css('left', '5px').css('width', `${eleWidth + 2}px`);

  if (basePath.startsWith('/search?q=')) {
    jquery_default()('#editSearchDisplayName').val(widgetBeingEdited.displayName);
    jquery_default()('#editSearch').val(decodeURIComponent(basePath.substr(10)));
    jquery_default()('#editSearchForm').show();
    jquery_default()('#editRedditForm').hide();
    jquery_default()('#RESDashboardEditComponent').fadeIn('fast');
  } else {
    jquery_default()('#editReddit').val(widgetBeingEdited.basePath.substr(3));
    jquery_default()('#editRedditDisplayName').val(widgetBeingEdited.displayName);
    jquery_default()('#editRedditForm').show();
    jquery_default()('#editSearchForm').hide();
    jquery_default()('#RESDashboardEditComponent').fadeIn('fast');
  }
}

let $dashboardUL;

function attachAddComponent($tabPage) {
  const $dashboardAddComponent = jquery_default()('<div id="RESDashboardAddComponent" class="RESDashboardComponent" />');
  $dashboardAddComponent.html(`
		<div class="addNewWidget">Add a new widget</div>
		<div id="addWidgetButtons">
			<div class="addButton" id="addSearchWidget">+search widget</div>
			<div class="addButton" id="addMailWidget">+mail widget</div>
			<div class="addButton" id="addUserWidget">+user widget</div>
			<div class="addButton" id="addRedditWidget">+subreddit widget</div>
		</div>
		<div id="addSearchFormContainer" class="addSearchForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addSearchForm">
				<input type="text" id="addSearch" placeholder="search terms">
				<input type="text" id="addSearchDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
		<div id="addMailWidgetContainer">
			<div class="backToWidgetTypes">&laquo; back</div>
			<div class="addButton widgetShortcut" widgetPath="/message/inbox/">+inbox</div>
			<div class="addButton widgetShortcut" widgetPath="/message/unread/">+unread</div>
			<div class="addButton widgetShortcut" widgetPath="/message/messages/">+messages</div>
			<div class="addButton widgetShortcut" widgetPath="/message/comments/">+comment replies</div>
			<div class="addButton widgetShortcut" widgetPath="/message/selfreply/">+post replies</div>
			<div class="addButton widgetShortcut" widgetPath="/message/moderator/">+modmail</div>
		</div>
		<div id="addUserFormContainer" class="addUserForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addUserForm">
				<input type="text" id="addUser">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
		<div id="addRedditFormContainer" class="addRedditForm">
			<div class="backToWidgetTypes">&laquo; back</div>
			<form id="addRedditForm">
				<input type="text" id="addReddit" placeholder="subreddit / multireddit">
				<input type="text" id="addRedditDisplayName" placeholder="display name (e.g. stuff)">
				<input type="submit" class="addButton" value="+add">
			</form>
		</div>
	`);
  $dashboardAddComponent.find('.backToWidgetTypes').click(function () {
    jquery_default()(this).parent().fadeOut(() => jquery_default()('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('.widgetShortcut').click(function () {
    const thisBasePath = jquery_default()(this).attr('widgetPath');
    addWidget({
      basePath: thisBasePath
    }, true);
    jquery_default()('#addMailWidgetContainer').fadeOut(() => jquery_default()('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('#addRedditWidget').click(() => {
    jquery_default()('#addWidgetButtons').fadeOut(() => {
      jquery_default()('#addRedditFormContainer').fadeIn(() => {
        jquery_default()('#token-input-addReddit').focus();
      });
    });
  });
  $dashboardAddComponent.find('#addMailWidget').click(() => {
    jquery_default()('#addWidgetButtons').fadeOut(() => jquery_default()('#addMailWidgetContainer').fadeIn());
  });
  $dashboardAddComponent.find('#addUserWidget').click(() => {
    jquery_default()('#addWidgetButtons').fadeOut(() => jquery_default()('#addUserFormContainer').fadeIn());
  });
  $dashboardAddComponent.find('#addSearchWidget').click(() => {
    jquery_default()('#addWidgetButtons').fadeOut(() => jquery_default()('#addSearchFormContainer').fadeIn());
  });
  $dashboardAddComponent.find('#addRedditForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    let thisBasePath = jquery_default()('#addReddit').val();

    if (thisBasePath !== '') {
      thisBasePath = thisBasePath.replace(/,|\s/g, '+');
      const thisDisplayName = jquery_default()('#addRedditDisplayName').val() ? jquery_default()('#addRedditDisplayName').val() : thisBasePath;
      addWidget({
        basePath: thisBasePath,
        displayName: thisDisplayName
      }, true);
      jquery_default()('#addReddit').val('').blur();
      jquery_default()('#addRedditFormContainer').fadeOut(() => {
        jquery_default()('#addWidgetButtons').fadeIn();
      });
    }
  });
  $dashboardAddComponent.find('#addUserForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = `/user/${jquery_default()('#addUser').val()}`;
    addWidget({
      basePath: thisBasePath
    }, true);
    jquery_default()('#addUser').val('').blur();
    jquery_default()('#addUserFormContainer').fadeOut(() => jquery_default()('#addWidgetButtons').fadeIn());
  });
  $dashboardAddComponent.find('#addSearchForm').get(0).addEventListener('submit', e => {
    e.preventDefault();
    const thisBasePath = string_namespaceObject.encode`/search?q=${jquery_default()('#addSearch').val()}`;
    const thisDisplayName = jquery_default()('#addSearchDisplayName').val() ? jquery_default()('#addSearchDisplayName').val() : thisBasePath;
    addWidget({
      basePath: thisBasePath,
      displayName: thisDisplayName
    }, true);
    jquery_default()('#addSearch').val('').blur();
    jquery_default()('#addSearchFormContainer').fadeOut(() => jquery_default()('#addWidgetButtons').fadeIn());
  });
  $dashboardUL = jquery_default()('<ul id="RESDashboard"></ul>');
  $tabPage.append($dashboardAddComponent, $dashboardUL);
}

function addWidget(optionsObject, isNew) {
  if (!optionsObject.basePath.startsWith('/')) {
    optionsObject.basePath = `/r/${optionsObject.basePath}`;
  }

  const exists = widgets.some(widget => widget.basePath === optionsObject.basePath);
  setTimeout(() => {
    jquery_default()(`.widgetShortcut[widgetPath="${optionsObject.basePath}"]`).hide();
  }, 1000);

  if (exists && isNew) {
    alert_namespaceObject.open(`A widget for ${optionsObject.basePath} already exists!`);
  } else {
    const thisWidget = new WidgetObject(optionsObject);
    if ($dashboardUL) thisWidget.init();
    saveWidget(thisWidget.optionsObject());
  }
}

async function removeWidget(optionsObject) {
  await getLatestWidgets();
  let exists;
  widgets = widgets.filter(widget => {
    if (widget.basePath === optionsObject.basePath) {
      exists = true;
      jquery_default()(document.getElementById(widget.basePath.replace(/\/|\+/g, '_'))).fadeOut('slow', function () {
        jquery_default()(this).detach();
      });
      setTimeout(() => {
        jquery_default()(`.widgetShortcut[widgetPath="${optionsObject.basePath}"]`).show();
      }, 1000);
      return false;
    }

    return true;
  });

  if (!exists) {
    notifications_showNotification({
      moduleID: 'dashboard',
      message: 'The widget you just tried to remove does not seem to exist.'
    });
  }

  dashboardStorage.set(widgets);
}

async function saveWidget(optionsObject) {
  await getLatestWidgets();
  let index = widgets.findIndex(widget => widget.basePath === optionsObject.basePath);

  if (index === -1) {
    index = widgets.length;
  }

  widgets[index] = optionsObject;
  dashboardStorage.set(widgets);
}

async function dashboard_updateWidget() {
  await getLatestWidgets();
  widgets = widgets.map(widget => {
    if (widget.basePath === widgetBeingEdited.formerBasePath) {
      delete widgetBeingEdited.formerBasePath;
      widget = widgetBeingEdited.optionsObject();
    }

    return widget;
  });
  dashboardStorage.set(widgets);
}

function WidgetObject(widgetOptions) {
  this.basePath = widgetOptions.basePath;

  if (widgetOptions.displayName === undefined || widgetOptions.displayName === null) {
    widgetOptions.displayName = this.basePath;
  }

  this.displayName = widgetOptions.displayName;
  this.numPosts = widgetOptions.numPosts || parseInt(dashboard_module.options.defaultPosts.value, 10);
  this.sortBy = widgetOptions.sortBy || dashboard_module.options.defaultSort.value;
  this.sortSearchBy = widgetOptions.sortSearchBy || dashboard_module.options.defaultSortSearch.value;
  this.minimized = widgetOptions.minimized || false;
  this.widgetEle = jquery_default()(`
		<li class="RESDashboardComponent" id="${this.basePath.replace(/\/|\+/g, '_')}">
			<div class="RESDashboardComponentScrim">
				<div class="RESDashboardComponentLoader">
					<span class="dashboardLoader"/><span>querying the server. one moment please.</span>
				</div>
			</div>
		</li>
	`);
  this.header = jquery_default()(`<div class="RESDashboardComponentHeader"><a class="widgetPath" title="${this.basePath}" href="${this.basePath}"></a></div>`);
  this.header.find('.widgetPath').text(this.displayName);
  this.sortControls = jquery_default()('<ul class="widgetSortButtons"><li sort="hot">hot</li><li sort="new">new</li><li sort="rising">rising</li><li sort="controversial">controversial</li><li sort="top">top</li></ul>');
  this.sortSearchControls = jquery_default()('<ul class="widgetSortButtons"><li sort="relevance">relevance</li><li sort="top">top</li><li sort="new">new</li><li sort="comments">comments</li></ul>');

  this.optionsObject = () => ({
    basePath: this.basePath,
    displayName: this.displayName,
    numPosts: this.numPosts,
    sortBy: this.sortBy,
    sortSearchBy: this.sortSearchBy,
    minimized: this.minimized
  });

  jquery_default()(this.sortControls).find(`li[sort=${this.sortBy}]`).addClass('active');
  jquery_default()(this.sortControls).find('li').click(e => {
    this.sortChange(jquery_default()(e.currentTarget).attr('sort'));
  });
  jquery_default()(this.sortSearchControls).find(`li[sort=${this.sortSearchBy}]`).addClass('active');
  jquery_default()(this.sortSearchControls).find('li').click(e => {
    this.sortChange(jquery_default()(e.currentTarget).attr('sort'));
  });
  jquery_default()(this.header).append(this.sortControls);

  if (!this.basePath.startsWith('/r/') && !this.basePath.startsWith('/user/')) {
    setTimeout(() => jquery_default()(this.sortControls).hide(), 100);
  }

  jquery_default()(this.header).append(this.sortSearchControls);

  if (!this.basePath.startsWith('/search?q=')) {
    setTimeout(() => jquery_default()(this.sortSearchControls).hide(), 100);
  }

  this.stateControls = jquery_default()('<ul class="widgetStateButtons"><li class="updateTime"></li><li action="refresh" class="refresh"><span class="res-icon">&#xF0B0;</span></li><li action="refreshAll" class="refreshAll">Refresh All</li><li action="addRow">+row</li><li action="subRow">-row</li><li action="edit" class="editButton"><span class="res-icon">&#xF139;</span></li><li action="minimize" class="minimize">-</li><li action="delete" class="RESClose">&times;</li></ul>');
  jquery_default()(this.stateControls).find('li').click(e => {
    switch (jquery_default()(e.currentTarget).attr('action')) {
      case 'refresh':
        this.update();
        break;

      case 'refreshAll':
        jquery_default()('li[action="refresh"]').click();
        break;

      case 'addRow':
        if (this.numPosts === MAX_ROWS) break;
        this.numPosts++;
        if (this.numPosts === MAX_ROWS) jquery_default()(this.stateControls).find('li[action=addRow]').addClass('disabled');
        jquery_default()(this.stateControls).find('li[action=subRow]').removeClass('disabled');
        saveWidget(this.optionsObject());
        this.update();
        break;

      case 'subRow':
        if (this.numPosts === 0) break;
        this.numPosts--;
        if (this.numPosts === 1) jquery_default()(this.stateControls).find('li[action=subRow]').addClass('disabled');
        jquery_default()(this.stateControls).find('li[action=addRow]').removeClass('disabled');
        saveWidget(this.optionsObject());
        this.update();
        break;

      case 'minimize':
        jquery_default()(this.widgetEle).toggleClass('minimized');

        if (jquery_default()(this.widgetEle).hasClass('minimized')) {
          jquery_default()(e.currentTarget).text('+');
          this.minimized = true;
        } else {
          jquery_default()(e.currentTarget).text('-');
          this.minimized = false;
          this.update();
        }

        jquery_default()(this.contents).parent().slideToggle();
        saveWidget(this.optionsObject());
        break;

      case 'delete':
        removeWidget(this.optionsObject());
        break;

      default:
        break;
    }
  });
  jquery_default()(this.header).append(this.stateControls);

  this.sortChange = sortBy => {
    this.sortBy = sortBy;
    this.sortSearchBy = sortBy;
    jquery_default()(this.header).find('ul.widgetSortButtons li').removeClass('active');
    jquery_default()(this.header).find(`ul.widgetSortButtons li[sort=${sortBy}]`).addClass('active');
    this.update();
    saveWidget(this.optionsObject());
  };

  this.edit = () => {
    widgetBeingEdited = this;
    showEditForm();
  };

  jquery_default()(this.header).find('.editButton').click(this.edit);

  this.update = () => {
    if (this.basePath.includes('/user/')) {
      this.sortPath = this.sortBy === 'hot' ? '/' : `?sort=${this.sortBy}`;
    } else if (this.basePath.includes('/r/')) {
      this.sortPath = this.sortBy === 'hot' ? '/' : `/${this.sortBy}/`;
    } else if (this.basePath.includes('/search?q=')) {
      this.sortPath = `&sort=${this.sortSearchBy}`;
    } else {
      this.sortPath = '';
    }

    this.url = new URL(`${this.basePath}${this.sortPath}`, location.origin).href;
    jquery_default()(this.contents).fadeTo('fast', 0.25);
    jquery_default()(this.scrim).fadeIn();
    ajax({
      method: 'GET',
      url: this.url,
      query: {
        limit: this.numPosts
      }
    }).then(this.populate).catch(this.error);
  };

  this.container = jquery_default()('<div class="RESDashboardComponentContainer"><div class="RESDashboardComponentContents"></div></div>');

  if (this.minimized) {
    jquery_default()(this.container).addClass('minimized');
    jquery_default()(this.stateControls).find('li.minimize').addClass('minimized').text('+');
  }

  this.scrim = jquery_default()(this.widgetEle).find('.RESDashboardComponentScrim');
  this.contents = jquery_default()(this.container).find('.RESDashboardComponentContents');

  this.init = () => {
    this.draw();
    if (!this.minimized) addToUpdateQueue(this.update);
  };

  this.draw = () => {
    jquery_default()(this.widgetEle).append(this.header);
    jquery_default()(this.widgetEle).append(this.container);
    if (this.minimized) jquery_default()(this.widgetEle).addClass('minimized');
    $dashboardUL.prepend(this.widgetEle);
  };

  this.populate = response => {
    let $widgetContent = jquery_default()(response).find('#siteTable, .search-result-group>.contents:last');
    const $thisWidgetContents = jquery_default()(this.contents);
    $widgetContent.attr('id', `siteTable_${this.basePath.replace(/\/|\+/g, '_')}`);
    if ($widgetContent.length === 2) $widgetContent = jquery_default()($widgetContent[1]);
    $widgetContent.attr('url', `${this.url}?limit=${this.numPosts}`);

    if ($widgetContent.length > 0 && $widgetContent.html() !== '') {
      $widgetContent.html($widgetContent.html().replace(/<script(.|\s)*?\/script>/g, ''));
      const $noResults = $widgetContent.find('#noresults.error');

      if ($noResults.length) {
        $widgetContent.html('<span class="error">No results found for this widget. Some sort methods, such as rising, may not always have results. Please try a different method.</span>');
      }

      try {
        $thisWidgetContents.empty().append($widgetContent);
      } catch (e) {}

      $thisWidgetContents.fadeTo('fast', 1);
      jquery_default()(this.scrim).fadeOut(function () {
        jquery_default()(this).hide();
      });
    } else {
      if (this.url.includes('/message/')) {
        $thisWidgetContents.html('<div class="widgetNoMail">No messages were found.</div>');
      } else {
        $thisWidgetContents.html('<div class="error">There were no results returned for this widget. If you made a typo, simply close the widget to delete it. If reddit is just under heavy load, try clicking refresh in a few moments.</div>');
      }

      $thisWidgetContents.fadeTo('fast', 1);
      jquery_default()(this.scrim).fadeOut();
    }

    jquery_default()(this.stateControls).find('.updateTime').text(`updated: ${formatDateTime()}`);

    if ($widgetContent[0]) {
      Object(watchers["registerPage"])($widgetContent[0]);
    }
  };

  this.error = e => {
    if (e.status === 404) {
      jquery_default()(this.contents).html('<div class="error">This widget received a 404 not found error. You may have made a typo when adding it.</div>');
    } else {
      jquery_default()(this.contents).html('<div class="error">There was an error loading data for this widget. Reddit may be under heavy load, or you may have provided an invalid path.</div>');
    }

    jquery_default()(this.scrim).fadeOut();
    jquery_default()(this.contents).fadeTo('fast', 1);
  };
}

function createSubredditToggleButton(subreddit) {
  const basePath = `/r/${subreddit.toLowerCase()}`;
  return createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveDashboard'), i18n('subredditInfoAddThisSubredditToDashboard'), () => widgets.some(widget => widget && widget.basePath.toLowerCase() === basePath), state => {
    if (state) {
      addWidget({
        basePath
      });
      notifications_showNotification({
        header: 'Dashboard Notification',
        moduleID: 'dashboard',
        message: `
						Dashboard widget added for ${basePath}
						<p><a class="RESNotificationButtonBlue" href="/r/Dashboard">view the dashboard</a></p>
						<div class="clear"></div>
					`
      });
    } else {
      removeWidget({
        basePath
      });
    }
  });
}
// CONCATENATED MODULE: ./lib/modules/disableChat.js


const disableChat_module = new Module('disableChat');
disableChat_module.moduleName = 'disableChatName';
disableChat_module.category = 'productivityCategory';
disableChat_module.description = 'disableChatDesc';
disableChat_module.disabledByDefault = true;

disableChat_module.contentStart = () => {
  stopPageContextScript(script => /^\/_chat/.test(new URL(script.src, location.origin).pathname), document.body, true);
  const icon = document.body.querySelector('#chat');

  if (icon) {
    if (icon.nextElementSibling) icon.nextElementSibling.remove();
    icon.remove();
  }
};
// CONCATENATED MODULE: ./lib/modules/localDate.js


const localDate_module = new Module('localDate');
localDate_module.moduleName = 'localDateName';
localDate_module.category = 'myAccountCategory';
localDate_module.description = 'localDateDesc';

localDate_module.contentStart = () => {
  jquery_default()(document.body).on('mouseenter', 'time', function () {
    const $this = jquery_default()(this);

    if (!$this.data('originalTitle')) {
      $this.data('originalTitle', $this.attr('title'));
    }

    $this.attr('title', new Date($this.attr('datetime')));
  }).on('mouseleave', 'time', function () {
    const $this = jquery_default()(this);
    $this.attr('title', $this.data('originalTitle'));
  });
};
// CONCATENATED MODULE: ./lib/modules/logoLink.js


const logoLink_module = new Module('logoLink');
logoLink_module.moduleName = 'logoLinkName';
logoLink_module.category = 'browsingCategory';
logoLink_module.description = 'logoLinkDesc';
logoLink_module.options = {
  redditLogoDestination: {
    type: 'enum',
    value: 'frontpage',
    description: 'logoLinkRedditLogoDestinationDesc',
    title: 'logoLinkRedditLogoDestinationTitle',
    values: [{
      name: 'logoLinkFrontpage',
      value: 'frontpage'
    }, {
      name: 'logoLinkAll',
      value: 'all'
    }, {
      name: 'logoLinkHot',
      value: 'hot'
    }, {
      name: 'logoLinkDashboard',
      value: 'dashboard'
    }, {
      name: 'logoLinkCurrent',
      value: 'subreddit'
    }, {
      name: 'logoLinkMyUserPage',
      value: '/u/me'
    }, {
      name: 'logoLinkInbox',
      value: '/message/inbox'
    }, {
      name: 'logoLinkCustom',
      value: 'custom'
    }]
  },
  customDestination: {
    dependsOn: options => options.redditLogoDestination.value === 'custom',
    type: 'text',
    value: '/',
    description: 'logoLinkCustomDestinationDesc',
    title: 'logoLinkCustomDestinationTitle'
  }
};

logoLink_module.contentStart = () => {
  const redditLogoNode = document.getElementById('header-img-a') || document.getElementById('header-img') || document.querySelector('header a[href="/"]');

  if (redditLogoNode) {
    const url = getLogoLinkUrl();

    if (url) {
      redditLogoNode.href = url;
    }
  }
};

function getLogoLinkUrl() {
  const destination = logoLink_module.options.redditLogoDestination.value;

  switch (destination) {
    case 'frontpage':
      return false;

    case 'all':
      return '/r/all';

    case 'hot':
      return '/hot/';

    case 'dashboard':
      return '/r/Dashboard';

    case 'subreddit':
      return jquery_default()('.redditname > a').attr('href');

    case 'custom':
      return logoLink_module.options.customDestination.value;

    default:
      return destination;
  }
}
// CONCATENATED MODULE: ./lib/modules/messageMenu.js







const messageMenu_module = new Module('messageMenu');
messageMenu_module.moduleName = 'messageMenuName';
messageMenu_module.category = 'browsingCategory';
messageMenu_module.description = 'messageMenuDesc';
messageMenu_module.options = {
  links: {
    type: 'table',
    addRowText: 'messageMenuAddShortcut',
    fields: [{
      key: 'label',
      name: 'messageMenuLabel',
      type: 'text'
    }, {
      key: 'url',
      name: 'messageMenuUrl',
      type: 'text'
    }],
    value: [['compose', '/message/compose'], ['all', '/message/inbox'], ['unread', '/message/unread'], ['messages', '/message/messages'], ['comment replies', '/message/comments'], ['post replies', '/message/selfreply'], ['/u/ mentions', '/message/mentions']],
    description: 'messageMenuLinksDesc',
    title: 'messageMenuLinksTitle'
  },
  useQuickMessage: {
    type: 'boolean',
    description: 'messageMenuUseQuickMessageDesc',
    title: 'messageMenuUseQuickMessageTitle',
    value: true
  },
  hoverDelay: {
    type: 'text',
    value: '1000',
    description: 'messageMenuHoverDelayDesc',
    title: 'messageMenuHoverDelayTitle',
    advanced: true
  },
  fadeDelay: {
    type: 'text',
    value: '200',
    description: 'messageMenuFadeDelayDesc',
    title: 'messageMenuFadeDelayTitle',
    advanced: true
  },
  fadeSpeed: {
    type: 'text',
    value: '0.7',
    description: 'messageMenuFadeSpeedDesc',
    title: 'messageMenuFadeSpeedTitle',
    advanced: true
  }
};

messageMenu_module.contentStart = () => {
  dropdownList(messageMenu_module.moduleID).options({
    openDelay: parseFloat(messageMenu_module.options.hoverDelay.value),
    fadeDelay: parseFloat(messageMenu_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(messageMenu_module.options.fadeSpeed.value)
  }).populateWith(() => [getListFragment()]).watch('#mail, .mail-count, #NREMail, #NREMailCount');
};

function getListFragment() {
  const fragment = document.createDocumentFragment();

  for (const link of messageMenu_module.options.links.value) {
    const label = link[0] || '';
    const url = link[1] || '';
    const li = string_namespaceObject.html`<li><a href="${url}">${label}</a></li>`;
    li.addEventListener('click', e => {
      if (messageMenu_module.options.useQuickMessage.value && isRunning(quickMessage_namespaceObject) && messageLinkEventHandler(e)) return;
      dropdownList(messageMenu_module.moduleID).close();
    });
    if (url.includes('/message/compose')) li.append(string_namespaceObject.html`<span class="RESMenuItemButton res-icon">&#xF139;</span>`);
    fragment.append(li);
  }

  fragment.append(string_namespaceObject.html`<li><a href=${makeUrlHash(messageMenu_module.moduleID, 'sectionMenu')}>
		<i>${i18n(messageMenu_module.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
  return fragment;
}
// CONCATENATED MODULE: ./lib/modules/modhelper.js




const modhelper_module = new Module('modHelper');
modhelper_module.moduleName = 'modhelperName';
modhelper_module.category = 'coreCategory';
modhelper_module.description = 'modhelperDesc';
modhelper_module.hidden = true;
modhelper_module.alwaysEnabled = true;
modhelper_module.include = ['stylesheet'];

modhelper_module.go = () => {
  doStyleSheetCheck();
};

const modhelper_tips = {
  'no-res-styles': 'It appears you haven\'t done any styling specific to RES.  If you are interested in a quick overview on styling for RES users, please see [our wiki article](/r/Enhancement/wiki/subredditstyling)',
  keyNav: 'Styling `RES-keyNav-activeElement`? This is the element RES uses for Keyboard Navigation - it indicates the currently selected post, and is crucial to RES functionality. If you don\'t like the way it looks with your theme, you may style it however you want, as long as Keyboard Navigation remains usable for your visitors.',
  'keyNav-benice': `It appears that you are hiding \`RES-keyNav-activeElement\`. This negatively affects RES users by rendering keyboard navigation unusable. It's understandable that you may not care for the default appearance, but we politely request that you consider styling it to fit your subreddit, perhaps using a particular background color or border. Even just a one-sided border, e.g. \`border-right: 3px solid blue;\` - thank you for your consideration.\n\n For convenience we've included \`RES-keyNav-activeThing\` which can be used as an alternative to \`RES-keyNav-activeElement\`. It applies to elements with the class \`thing\` as opposed to \`entry\`. If you choose to use this, make sure keyboard navigation is usable when [commentBoxes](${makeUrlHash('styleTweaks', 'commentBoxes')}) is turned off.`,
  nightmode: 'Want your subreddit to be night mode friendly? Please have a look at [the night mode section of our wiki](/r/Enhancement/wiki/subredditstyling#wiki_res_night_mode_and_your_subreddit)'
};

function doStyleSheetCheck() {
  const $stylesheetTextarea = jquery_default()('.stylesheet-customize-container textarea');
  const stylesheet = $stylesheetTextarea.length ? jquery_default()($stylesheetTextarea).val() : '';
  createTipPane();

  if (stylesheet.length) {
    if (!stylesheet.includes('.res') && !stylesheet.includes('.RES')) {
      addTipToPane('no-res-styles');
    }

    if (!stylesheet.includes('.res-nightmode')) {
      addTipToPane('nightmode');
    }

    const keyNavIdx = stylesheet.indexOf('.RES-keyNav-activeElement');

    if (keyNavIdx !== -1) {
      let keyNavRule = '';
      let i = keyNavIdx;

      while (i < stylesheet.length) {
        const thisChar = stylesheet.charAt(i);
        keyNavRule += thisChar;

        if (thisChar === '}') {
          i = stylesheet.length;
        }

        i++;
      }

      if ((keyNavRule.includes('transparent') || keyNavRule.includes('background: none') || keyNavRule.includes('background-color: none')) && !keyNavRule.includes('border') && !stylesheet.includes('.RES-keyNav-activeThing')) {
        addTipToPane('keyNav-benice');
      } else {
        addTipToPane('keyNav');
      }
    }
  }
}

let $tipPane, $tipPaneHeader, $tipPaneContents, $tipPaneList;

function createTipPane() {
  const $sheetsDiv = jquery_default()('div.sheets');
  $tipPane = jquery_default()('<div>', {
    id: 'RESStyleSheetTipPane'
  });
  $tipPaneHeader = jquery_default()('<div>', {
    id: 'RESStyleSheetTipPane-header',
    class: 'minimized',
    text: 'RES specific styling tips',
    click: toggleTipPane
  });
  const $tipPaneCloseButton = jquery_default()('<span>', {
    id: 'RESStyleSheetTipPane-close',
    class: 'RESCloseButton RESCloseButtonTopRight',
    title: 'Close for this session',
    click: hideTipPane
  });
  const $tipPaneHeaderSpan = jquery_default()('<span>', {
    class: 'details',
    text: '[click for details]'
  });
  $tipPaneHeader.append($tipPaneCloseButton).append($tipPaneHeaderSpan);
  $tipPaneContents = jquery_default()('<div>', {
    id: 'RESStyleSheetTipPane-contents'
  });
  $tipPaneList = jquery_default()('<ul>', {
    id: 'RESStyleSheetTipPane-list'
  });
  $tipPaneContents.append($tipPaneList);
  $tipPane.append($tipPaneHeader).append($tipPaneContents);
  $sheetsDiv.before($tipPane);
}

function hideTipPane() {
  sessionStorage.setItem('hideTipPane', 'true');
  $tipPane.hide();
}

function toggleTipPane() {
  if ($tipPaneHeader.hasClass('minimized')) {
    openTipPaneContents();
  } else {
    closeTipPaneContents();
  }
}

function openTipPaneContents() {
  $tipPaneHeader.removeClass('minimized');
  $tipPaneContents.slideDown();
}

function closeTipPaneContents() {
  $tipPaneHeader.addClass('minimized');
  $tipPaneContents.slideUp();
}

function addTipToPane(key) {
  const tipText = modhelper_tips[key];
  const $tip = jquery_default()('<li>', {
    html: snudown_es_markdown(tipText)
  });

  if (!sessionStorage.getItem('hideTipPane')) {
    $tipPane.show();
  }

  $tipPaneList.append($tip);
}
// CONCATENATED MODULE: ./lib/modules/multiredditNavbar.js






const multiredditNavbar_module = new Module('multiredditNavbar');
multiredditNavbar_module.moduleName = 'multiredditNavbarName';
multiredditNavbar_module.description = 'multiredditNavbarDesc';
multiredditNavbar_module.category = 'subredditsCategory';
multiredditNavbar_module.include = ['linklist'];
multiredditNavbar_module.options = {
  sectionMenu: {
    type: 'boolean',
    value: true,
    description: 'multiredditNavbarSectionMenuDesc',
    title: 'multiredditNavbarSectionMenuTitle'
  },
  sectionLinks: {
    dependsOn: options => options.sectionMenu.value,
    type: 'table',
    addRowText: 'multiredditNavbarAddShortcut',
    fields: [{
      key: 'label',
      name: 'multiredditNavbarLabel',
      type: 'text'
    }, {
      key: 'url',
      name: 'multiredditNavbarUrl',
      type: 'text'
    }],
    value: [['new', './new'], ['rising', './rising'], ['controversial', './controversial'], ['top', './top'], ['top this month', './top?t=month'], ['gilded', './gilded'], ['promoted', './ads']],
    description: 'multiredditNavbarSectionLinksDesc',
    title: 'multiredditNavbarSectionLinksTitle'
  },
  hoverDelay: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '1000',
    description: 'multiredditNavbarHoverDelayDesc',
    title: 'multiredditNavbarHoverDelayTitle',
    advanced: true
  },
  fadeDelay: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '200',
    description: 'multiredditNavbarFadeDelayDesc',
    title: 'multiredditNavbarFadeDelayTitle',
    advanced: true
  },
  fadeSpeed: {
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '0.7',
    description: 'multiredditNavbarFadeSpeedDesc',
    title: 'multiredditNavbarFadeSpeedTitle',
    advanced: true
  }
};

multiredditNavbar_module.contentStart = () => {
  if (multiredditNavbar_module.options.sectionMenu.value) {
    dropdownList(multiredditNavbar_module.moduleID).options({
      openDelay: penalizedDelay(multiredditNavbar_module.moduleID, 'sectionMenu', multiredditNavbar_module.options.hoverDelay),
      fadeDelay: parseFloat(multiredditNavbar_module.options.fadeDelay.value),
      fadeSpeed: parseFloat(multiredditNavbar_module.options.fadeSpeed.value),
      pin: pin.right,
      offsetWidth: -10,
      offsetHeight: 1,
      bottomPadding: 0
    }).populateWith(card => [multiredditNavbar_getListFragment(card.getCheckedTarget().href)]).watch('.listing-chooser .multis li a');
  }
};

const multiredditNavbar_getListFragment = baseUrl => {
  alterFeaturePenalty(multiredditNavbar_module.moduleID, 'sectionMenu', 5);
  const fragment = document.createDocumentFragment();

  for (const link of multiredditNavbar_module.options.sectionLinks.value) {
    const label = link[0] || '';
    const url = link[1] || '';
    const li = string_namespaceObject.html`<li><a href="${baseUrl}${url}">${label}</a></li>`;
    li.addEventListener('click', () => {
      dropdownList(multiredditNavbar_module.moduleID).close();
      alterFeaturePenalty(multiredditNavbar_module.moduleID, 'sectionMenu', -30);
    });
    fragment.append(li);
  }

  fragment.append(string_namespaceObject.html`<li><a href=${makeUrlHash(multiredditNavbar_module.moduleID, 'sectionMenu')}>
		<i>${i18n(multiredditNavbar_module.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
  return fragment;
};
// CONCATENATED MODULE: ./lib/modules/neverEndingComments.js


const neverEndingComments_module = new Module('neverEndingComments');
neverEndingComments_module.moduleName = 'necName';
neverEndingComments_module.category = 'commentsCategory';
neverEndingComments_module.description = 'necDescription';
neverEndingComments_module.options = {
  loadChildComments: {
    type: 'boolean',
    value: false,
    description: 'necLoadChildCommentsDesc',
    title: 'necLoadChildCommentsTitle'
  }
};
neverEndingComments_module.include = ['comments'];

neverEndingComments_module.afterLoad = () => {
  const context = document.body.querySelector(neverEndingComments_module.options.loadChildComments.value ? '.nestedlisting' : '.nestedlisting > .thing.morechildren');
  if (!context) return;
  const visibleLoaders = new Set();
  const io = new IntersectionObserver(entries => {
    for (const {
      isIntersecting,
      target
    } of entries) {
      if (!context.contains(target)) io.unobserve(target);
      if (isIntersecting) visibleLoaders.add(target);else visibleLoaders.delete(target);
    }

    if (visibleLoaders.size) {
      window.addEventListener('scroll', loadFirst);
      loadFirst();
    } else {
      window.removeEventListener('scroll', loadFirst);
    }
  }, {
    rootMargin: '-10% 0px 10% 0px'
  });
  const loadFirst = Object(utils_async["d" /* frameDebounce */])(Object(utils_async["h" /* mutex */])(async () => {
    const loader = Array.from(visibleLoaders.values()).sort((a, b) => 3 - (a.compareDocumentPosition(b) & 6)).find(e => {
      const thing = Thing["a" /* Thing */].from(e);
      return !selectedThing_namespaceObject.current || !thing || selectedThing_namespaceObject.current.getDirectionOf(thing) === 'down';
    });

    if (loader) {
      loader.click();
      await Object(dom["q" /* waitForDetach */])(loader, new Promise(res => {
        setTimeout(res, 3000);
      }));
      loadFirst();
    }
  }), 5);
  Object(dom["u" /* watchForDescendants */])(context, '.morecomments a', ele => {
    io.observe(ele);
  });
};
// CONCATENATED MODULE: ./lib/modules/onboarding.js





const onboarding_module = new Module('onboarding');
onboarding_module.moduleName = 'onboardingName';
onboarding_module.category = 'aboutCategory';
onboarding_module.description = 'onboardingDesc';
onboarding_module.alwaysEnabled = true;
onboarding_module.options = {
  updateNotification: {
    title: 'onboardingUpdateNotificationName',
    description: 'onboardingUpdateNotificationDescription',
    type: 'enum',
    value: 'notification',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'nothing'
    }]
  },
  patchUpdateNotification: {
    title: 'onboardingPatchUpdateNotificationName',
    description: 'onboardingPatchUpdateNotificationDescription',
    type: 'enum',
    value: 'notification',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'none'
    }]
  },
  betaUpdateNotification: {
    title: 'onboardingBetaUpdateNotificationName',
    description: 'onboardingBetaUpdateNotificationDescription',
    type: 'enum',
    value: 'releaseNotes',
    values: [{
      name: 'onboardingUpdateNotifictionReleaseNotes',
      value: 'releaseNotes'
    }, {
      name: 'onboardingUpdateNotifictionNotification',
      value: 'notification'
    }, {
      name: 'onboardingUpdateNotifictionNothing',
      value: 'none'
    }]
  }
};
const highestVersionStorage = storage_namespaceObject.wrap('highestVersion', null);

onboarding_module.go = async () => {
  const highestVersion = await highestVersionStorage.get();

  if (!highestVersion) {
    highestVersionStorage.set(metadata_version);
    return;
  }

  if (highestVersion === metadata_version || __webpack_require__(125)(highestVersion, metadata_version)) return;

  const diff = __webpack_require__(127)(metadata_version, highestVersion);

  const infoTypes = Object(utils_array["c" /* filterMap */])([isBeta && 'betaUpdateNotification', diff === 'patch' && 'patchUpdateNotification', (diff === 'major' || diff === 'minor') && 'updateNotification'], notificationOption => notificationOption ? [onboarding_module.options[notificationOption].value] : undefined);

  if (infoTypes.includes('releaseNotes')) {
    openNewTab(updatedURL, false);
  } else if (infoTypes.includes('notification')) {
    notifications_showNotification({
      moduleID: onboarding_module.moduleID,
      notificationID: diff,
      message: `
				${i18n('onboardingUpgradeMessage', metadata_version)}
				<p><a class="RESNotificationButtonBlue" href="${updatedURL}" target="_blank">
					${i18n('onboardingUpgradeCta')}
				</a></p>
			`.trim(),
      closeDelay: 15000
    });
  } else {
    console.log(`RES upgraded to v${metadata_version}.`);
  }

  highestVersionStorage.set(metadata_version);
};
// EXTERNAL MODULE: ./node_modules/favico.js/favico.js
var favico = __webpack_require__(107);
var favico_default = /*#__PURE__*/__webpack_require__.n(favico);

// EXTERNAL MODULE: ./lib/images/legacyFavicon.png
var legacyFavicon = __webpack_require__(108);
var legacyFavicon_default = /*#__PURE__*/__webpack_require__.n(legacyFavicon);

// CONCATENATED MODULE: ./lib/modules/orangered.js









const orangered_module = new Module('orangered');
orangered_module.moduleName = 'orangeredName';
orangered_module.category = 'myAccountCategory';
orangered_module.description = 'orangeredDesc';
orangered_module.options = {
  openMailInNewTab: {
    description: 'orangeredOpenMailInNewTabDesc',
    title: 'orangeredOpenMailInNewTabTitle',
    type: 'boolean',
    value: false
  },
  updateCurrentTab: {
    description: 'orangeredUpdateCurrentTabDesc',
    title: 'orangeredUpdateCurrentTabTitle',
    type: 'boolean',
    value: true
  },
  updateOtherTabs: {
    description: 'orangeredUpdateOtherTabsDesc',
    keywords: ['favicon', 'sync'],
    title: 'orangeredUpdateOtherTabsTitle',
    type: 'boolean',
    value: true
  },
  showFloatingEnvelope: {
    description: 'orangeredShowFloatingEnvelopeDesc',
    title: 'orangeredShowFloatingEnvelopeTitle',
    type: 'boolean',
    value: true
  },
  retroUnreadCount: {
    description: 'orangeredRetroUnreadCountDesc',
    title: 'orangeredRetroUnreadCountTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  showUnreadCountInTitle: {
    description: 'orangeredShowUnreadCountInTitleDesc',
    title: 'orangeredShowUnreadCountInTitleTitle',
    type: 'boolean',
    value: false
  },
  faviconUseLegacy: {
    description: 'faviconUseLegacyDesc',
    title: 'faviconUseLegacyTitle',
    type: 'boolean',
    value: false
  },
  showUnreadCountInFavicon: {
    description: 'orangeredShowUnreadCountInFaviconDesc',
    title: 'orangeredShowUnreadCountInFaviconTitle',
    type: 'boolean',
    value: true
  },
  faviconNotificationBGColor: {
    description: 'faviconNotificationBGColorDesc',
    title: 'faviconNotificationBGColorTitle',
    advanced: true,
    type: 'color',
    value: '#5f99cf',
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  faviconNotificationTextColor: {
    description: 'faviconNotificationTextColorDesc',
    title: 'faviconNotificationTextColorTitle',
    advanced: true,
    type: 'color',
    value: '#ffffff',
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  resetFaviconOnLeave: {
    description: 'orangeredResetFaviconOnLeaveDesc',
    title: 'orangeredResetFaviconOnLeaveTitle',
    type: 'boolean',
    value: true,
    dependsOn: options => options.showUnreadCountInFavicon.value
  },
  unreadLinksToInbox: {
    description: 'orangeredUnreadLinksToInboxDesc',
    title: 'orangeredUnreadLinksToInboxTitle',
    type: 'boolean',
    value: false,
    advanced: true
  },
  hideEmptyMail: {
    description: 'orangeredHideEmptyMailDesc',
    title: 'orangeredHideEmptyMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideModMail: {
    description: 'orangeredHideModMailDesc',
    title: 'orangeredHideModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideEmptyModMail: {
    description: 'orangeredHideEmptyModMailDesc',
    title: 'orangeredHideEmptyModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true,
    dependsOn: options => !options.hideModMail.value
  },
  hideNewModMail: {
    description: 'orangeredHideNewModMailDesc',
    title: 'orangeredHideNewModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true
  },
  hideEmptyNewModMail: {
    description: 'orangeredHideEmptyNewModMailDesc',
    title: 'orangeredHideEmptyNewModMailTitle',
    type: 'boolean',
    value: false,
    bodyClass: true,
    dependsOn: options => !options.hideNewModMail.value
  }
};

orangered_module.contentStart = () => {
  if (orangered_module.options.faviconUseLegacy.value) setupFavicon();

  if (!loggedInUser()) {
    return;
  }

  floatingButtons();

  if (orangered_module.options.openMailInNewTab.value) {
    $orangeredElements().attr('target', '_blank').attr('rel', 'noopener noreferer');
  }

  updateFromPage();
};

async function updateFromPage(doc = document.body) {
  if (!isRunning(orangered_module)) return;
  if (!orangered_module.options.updateCurrentTab.value) return;
  if (!loggedInUser()) return;
  const debuginfoElement = doc.querySelector('.debuginfo');
  const [timestamp] = debuginfoElement && /(\d{4})-(\d{2})-(\d{2}) (\d{2})\:(\d{2})\:(\d{2})\.(\d+)[+-](\d{2})\:(\d{2})/.exec(debuginfoElement.textContent) || [];

  if (Date.parse(timestamp)) {
    const lastUpdate = await session_namespaceObject.get('orangered.last-update');
    session_namespaceObject.set('orangered.last-update', timestamp);
    if (lastUpdate && new Date(lastUpdate) >= new Date(timestamp)) return;
  }

  setUnreadCount(getUnreadCount(doc));
}
let lastCount = 0;

const _setUnreadCount = multicast(count => {
  if (count === lastCount) return;
  lastCount = count;
  updateFaviconBadge(count);
  updateTitle(count);
  updateInboxElements(count);
  updateMailCountElements(count);

  if (count > 0) {
    window.dispatchEvent(new Event('orangered'));
  }
}, {
  name: 'setUnreadCount',
  crossContext: false
});

function setUnreadCount(count) {
  if (orangered_module.options.updateOtherTabs.value) {
    _setUnreadCount(count);
  } else {
    _setUnreadCount.local(count);
  }
}

function updateTitle(count) {
  if (!orangered_module.options.showUnreadCountInTitle.value) return;

  if (count > 0) {
    document.title = `[${count}] ${document.title.replace(/^\[[\d]+\]\s/, '')}`;
  } else {
    document.title = document.title.replace(/^\[[\d]+\]\s/, '');
  }
}

function updateInboxElements(count) {
  const {
    nativeInboxButton,
    $floatingInboxButton
  } = orangeredElements();
  jquery_default()().add($floatingInboxButton).add(nativeInboxButton).attr('title', count ? 'new mail!' : 'No new mail').toggleClass('havemail', !!count).toggleClass('nohavemail', !count).attr('href', getInboxLink(count));
}

function updateMailCountElements(count) {
  const {
    nativeInboxCount,
    $floatingInboxCount
  } = orangeredElements();
  jquery_default()().add($floatingInboxCount).add(nativeInboxCount).css('display', count ? 'inline-block' : 'none').attr('href', getInboxLink(count)).attr('title', count ? 'new mail!' : 'No new mail').text(count).addClass('message-count');
}

function updateFaviconBadge(count) {
  if (orangered_module.options.showUnreadCountInFavicon.value) {
    setupFavicon().badge(count);
  }
}

const setupFavicon = Object(once["a" /* default */])(() => {
  const favicons = Array.from(document.head.querySelectorAll('link[rel="icon"]'));
  const selectedFavicon = favicons.find(f => f.getAttribute('sizes') === '96x96') || favicons.slice(-1)[0];

  for (const f of favicons) {
    if (f !== selectedFavicon) f.remove();
  }

  if (orangered_module.options.faviconUseLegacy.value) {
    selectedFavicon.setAttribute('href', legacyFavicon_default.a);
  }

  const favicon = new favico_default.a({
    bgColor: orangered_module.options.faviconNotificationBGColor.value,
    textColor: orangered_module.options.faviconNotificationTextColor.value
  });

  if (orangered_module.options.resetFaviconOnLeave.value) {
    window.addEventListener('beforeunload', () => favicon.reset());
  }

  return favicon;
});

const orangeredElements = () => ({ ...nativeButtons(),
  ...floatingButtons(),
  modmailButtonSelector: '#modmail'
});

const $orangeredElements = () => Object.values(orangeredElements()).reduce(($all, ele) => $all.add(ele), jquery_default()());

const nativeButtons = Object(once["a" /* default */])(() => {
  const nativeInboxButton = document.querySelector('#header-bottom-right #mail');
  let nativeInboxCount = document.querySelector('#header-bottom-right .message-count');

  if (!nativeInboxCount && (orangered_module.options.updateCurrentTab.value || orangered_module.options.updateOtherTabs.value)) {
    nativeInboxCount = document.createElement('a');
    nativeInboxCount.style.display = 'none';
    nativeInboxButton.after(nativeInboxCount);
  }

  return {
    nativeInboxButton,
    nativeInboxCount
  };
});
const floatingButtons = Object(once["a" /* default */])(() => {
  if (!orangered_module.options.showFloatingEnvelope.value) {
    return {
      $floatingInboxButton: undefined,
      $floatingInboxCount: undefined
    };
  }

  let $floatingInboxButton, $floatingInboxCount;
  const pinHeader = betteReddit_module.options.pinHeader.value;

  if (pinHeader === 'sub' || pinHeader === 'none') {
    $floatingInboxButton = jquery_default()('<a>', {
      id: 'NREMail',
      class: 'nohavemail'
    });
    addFloater($floatingInboxButton.get(0));
    $floatingInboxCount = jquery_default()('<a>', {
      id: 'NREMailCount'
    });
    $floatingInboxCount.css('display', 'none');
    $floatingInboxCount.attr('href', getInboxLink(true));
    addFloater($floatingInboxCount.get(0));
  }

  return {
    $floatingInboxButton,
    $floatingInboxCount
  };
});

function getInboxLink(havemail) {
  if (havemail && !orangered_module.options.unreadLinksToInbox.value) {
    return '/message/unread/';
  }

  return '/message/inbox/';
}

function getUnreadCount(container) {
  const mailCount = container.querySelector('.message-count');
  return mailCount && parseInt(mailCount.textContent, 10) || 0;
}
// CONCATENATED MODULE: ./lib/modules/pageNavigator.js






const pageNavigator_module = new Module('pageNavigator');
pageNavigator_module.moduleName = 'pageNavName';
pageNavigator_module.category = 'browsingCategory';
pageNavigator_module.description = 'pageNavDesc';
pageNavigator_module.options = {
  toTop: {
    type: 'boolean',
    value: true,
    description: 'pageNavToTopDesc',
    title: 'pageNavToTopTitle'
  },
  toComment: {
    type: 'boolean',
    value: true,
    description: 'pageNavToCommentDesc',
    title: 'pageNavToCommentTitle'
  },
  showLink: {
    type: 'boolean',
    value: true,
    description: 'pageNavShowLinkDesc',
    title: 'pageNavShowLinkTitle'
  },
  showLinkNewTab: {
    type: 'boolean',
    value: true,
    description: 'pageNavShowLinkNewTabDesc',
    title: 'pageNavShowLinkNewTabTitle',
    dependsOn: options => options.showLink.value
  }
};

pageNavigator_module.beforeLoad = () => {
  if (pageNavigator_module.options.showLink.value && Object(utils_location["n" /* isPageType */])('comments')) {
    Object(watchers["watchForThings"])(['post'], showLinkTitle);
  }
};

pageNavigator_module.contentStart = () => {
  if (pageNavigator_module.options.toComment.value && Object(utils_location["n" /* isPageType */])('comments')) {
    backToNewCommentArea();
  }

  if (pageNavigator_module.options.toTop.value) {
    backToTop();
  }
};

function backToTop() {
  const element = string_namespaceObject.html`<a class="pageNavigator res-icon" data-id="top" href="#header" title="${i18n('pageNavToTopTitle')}">&#xF148;</a>`;
  element.addEventListener('click', e => {
    e.preventDefault();
    window.scrollTo(0, 0);
    selectedThing_namespaceObject.move('top');
  });
  addFloater(element, {
    order: 9
  });
}

const showLinkTitleTemplate = ({
  thumbnailSrc,
  linkId,
  settingsHash,
  linkHref,
  linkNewTab,
  title,
  domainHref,
  domain,
  time,
  author,
  authorHref
}) => string_namespaceObject.html`
	<div class="res-show-link hide">
		${thumbnailSrc && string_namespaceObject._html`
			<span class="res-show-link-thumb"><img src="${thumbnailSrc}" alt="thumbnail" /></span>
		`}
		<a href="#${linkId}" class="res-icon toTop" title="Jump to title">&#xF148;</a>
		<a href="${settingsHash}" class="gearIcon" title="Configure this widget"></a>
		<div class="res-show-link-content">
			<div class="res-show-link-header">
				<a href="${linkHref}" ${linkNewTab && string_namespaceObject._html`target="_blank" rel="noopener noreferer"`} class="res-show-link-title">${title}</a>
				<a href="${domainHref}" class="res-show-link-domain">(<span>${domain}</span>)</a>
			</div>
			<div class="res-show-link-tagline">
				Submitted ${time} by
				<a href="${authorHref}" class="res-show-link-author">${author}</a>
			</div>
		</div>
	</div>
`;

function backToNewCommentArea() {
  const commentArea = document.querySelector('.commentarea > form.usertext textarea:not([disabled])');
  if (!commentArea) return;
  const element = string_namespaceObject.html`<a class="pageNavigator res-icon" data-id="addComment" href="#comments" title="${i18n('pageNavToCommentTitle')}">&#xF003;</a>`;
  element.addEventListener('click', e => {
    e.preventDefault();
    commentArea.focus();
  });
  addFloater(element, {
    container: 'visibleAfterScroll'
  });
}

const showLinkTitle = Object(once["a" /* default */])(submissionThing => {
  let $widget;
  let belowSubmission = true;
  let baseHeight, hoverHeight;

  function showWidget() {
    $widget.css({
      top: Object(dom["g" /* getHeaderOffset */])(true)
    }).removeClass('hide');
  }

  function hideWidget() {
    $widget.css({
      top: -baseHeight
    }).addClass('hide');
  }

  function renderWidget() {
    return jquery_default()(showLinkTitleTemplate({
      linkId: submissionThing.element.id,
      thumbnailSrc: submissionThing.getPostThumbnailUrl(),
      linkHref: submissionThing.getTitleUrl(),
      linkNewTab: pageNavigator_module.options.showLinkNewTab.value,
      title: submissionThing.getTitle(),
      domainHref: submissionThing.getPostDomainUrl(),
      domain: submissionThing.getPostDomainText(),
      time: submissionThing.getPostTime(),
      authorHref: submissionThing.getAuthorUrl(),
      author: submissionThing.getAuthor(),
      settingsHash: makeUrlHash(pageNavigator_module.moduleID, 'showLink')
    }));
  }

  const updateWidget = Object(utils_async["e" /* frameThrottle */])(e => {
    const scrollingUp = e.deltaY < 0;

    if (scrollingUp && belowSubmission) {
      initialize();
      showWidget();
    } else if ($widget) {
      hideWidget();
    }
  });
  const initialize = Object(once["a" /* default */])(() => {
    $widget = renderWidget().on('mouseenter', () => $widget.css({
      height: hoverHeight
    })).on('mouseleave', () => $widget.css({
      height: baseHeight
    })).appendTo(document.body);
    baseHeight = $widget.get(0).getBoundingClientRect().height;
    hoverHeight = $widget.get(0).scrollHeight;
    new IntersectionObserver(entries => {
      belowSubmission = !entries[0].isIntersecting;
      if (!belowSubmission) hideWidget();
    }, {
      rootMargin: '100px 0px 0px 0px'
    }).observe(submissionThing.element);
    window.addEventListener('scroll', () => {
      if (dom["l" /* scrollToElement */].isProgrammaticEvent()) hideWidget();
    });
  });
  window.addEventListener('wheel', updateWidget, {
    passive: true
  });
});
// CONCATENATED MODULE: ./lib/modules/troubleshooter.js







const troubleshooter_module = new Module('troubleshooter');
troubleshooter_module.moduleName = 'troubleshooterName';
troubleshooter_module.alwaysEnabled = true;
troubleshooter_module.sort = -7;
troubleshooter_module.description = 'troubleshooterDesc';
troubleshooter_module.category = 'aboutCategory';
troubleshooter_module.options = {
  clearCache: {
    title: 'troubleshooterClearCacheTitle',
    type: 'button',
    text: 'troubleshooterClearLabel',
    callback: clearCache,
    description: 'troubleshooterClearCacheDesc'
  },
  clearTags: {
    title: 'troubleshooterClearTagsTitle',
    type: 'button',
    text: 'troubleshooterClearLabel',
    callback: clearTags,
    description: 'troubleshooterClearTagsDesc'
  },
  resetToFactory: {
    title: 'troubleshooterResetToFactoryTitle',
    type: 'button',
    text: 'troubleshooterResetLabel',
    callback: resetToFactory,
    description: 'troubleshooterResetToFactoryDesc'
  },
  disableRES: {
    title: 'troubleshooterDisableRESTitle',
    type: 'button',
    text: 'troubleshooterDisableLabel',

    callback() {
      const url = new URL(context_data.pathname, context_data.origin);
      url.hash = RES_DISABLED_HASH;
      window.top.location.href = url.href;
    },

    description: 'troubleshooterDisableRESDesc'
  },
  breakpoint: {
    title: 'troubleshooterBreakpointTitle',
    type: 'button',
    text: 'troubleshooterBreakpointLabel',

    callback() {
      debugger;
    },

    description: 'troubleshooterBreakpointDesc'
  },
  testEnvironment: {
    title: 'troubleshooterTestEnvironmentTitle',
    type: 'button',
    text: 'troubleshooterTestEnvironmentLabel',
    callback: testEnvironment,
    description: 'troubleshooterTestEnvironmentDesc'
  },
  testNotifications: {
    title: 'troubleshooterTestNotificationsTitle',
    type: 'button',
    text: 'troubleshooterTestNotificationsLabel',
    callback: testNotifications,
    description: 'troubleshooterTestNotificationsDesc'
  }
};

function clearCache() {
  xhrCache_namespaceObject.clear();
  session_namespaceObject.clear();
  localStorage.removeItem(CACHED_LANG_KEY);
  localStorage.removeItem(CACHED_MESSAGES_TOKEN_KEY);
  localStorage.removeItem(CACHED_MESSAGES_KEY);
  notifications_showNotification(i18n('troubleshooterCachesCleared'), 2500);
}

async function clearTags() {
  const confirm = window.confirm(i18n('troubleshooterAreYouPositive'));

  if (confirm) {
    const toDelete = (await userTagger_Tag.getStored()).filter(({
      text,
      votesUp = 0,
      votesDown = 0
    }) => !text && votesUp <= 1 && votesDown <= 1);

    for (const tag of toDelete) tag.delete();

    notifications_showNotification(i18n('troubleshooterEntriesRemoved', toDelete.length), 2500);
  } else {
    notifications_showNotification(i18n('troubleshooterNoActionTaken'), 2500);
  }
}

function resetToFactory() {
  const confirm = window.prompt(i18n('troubleshooterThisWillKillYourSettings', 'trash'));

  if (confirm === 'trash' || confirm === '"trash"') {
    clearCache();
    storage_namespaceObject.clear();
    notifications_showNotification(i18n('troubleshooterSettingsReset'), 2500);
  } else {
    notifications_showNotification(i18n('troubleshooterNoActionTaken'), 2500);
  }
}

function testNotifications() {
  notifications_showNotification({
    moduleID: troubleshooter_module.moduleID,
    header: 'Template test',
    message: '<p>Hello, FakeUsername</p>'
  });
}

const testMulticast = multicast(val => {
  alert_namespaceObject.open(`Multicast: ${val}`);
}, {
  name: 'testMulticast',
  local: false,
  crossContext: false
});

async function testEnvironment() {
  const testKey = '__test__';
  const rows = [];

  try {
    let rand;
    rows.push(`Private browsing: ${String(isPrivateBrowsing())}`, '');
    rand = Math.random();
    rows.push(`Sending multicast: ${rand}`, '');
    testMulticast(rand);
    rand = Math.random();
    rows.push(`Storage.set(): ${rand}`);
    storage_namespaceObject.set(testKey, rand);
    rows.push(`Storage.get(): ${await storage_namespaceObject.get(testKey)}`);
    rows.push(`Storage.has(): ${await storage_namespaceObject.has(testKey)}`);
    rows.push('Storage.delete()');
    storage_namespaceObject.delete(testKey);
    rows.push(`Storage.get(): ${await storage_namespaceObject.get(testKey)}`);
    rows.push(`Storage.has(): ${await storage_namespaceObject.has(testKey)}`, '');
    rand = Math.random();
    rows.push(`Session.set(): ${rand}`);
    session_namespaceObject.set(testKey, rand);
    rows.push(`Session.get(): ${await session_namespaceObject.get(testKey)}`);
    rows.push(`Session.has(): ${await session_namespaceObject.has(testKey)}`);
    rows.push('Session.delete()');
    session_namespaceObject.delete(testKey);
    rows.push(`Session.get(): ${await session_namespaceObject.get(testKey)}`);
    rows.push(`Session.has(): ${await session_namespaceObject.has(testKey)}`, '');
    rand = Math.random();
    const wrapped = storage_namespaceObject.wrap(testKey, 'default');
    rows.push(`wrapped.set(): ${rand}`);
    wrapped.set(rand);
    rows.push(`wrapped.get(): ${await wrapped.get()}`);
    rows.push(`wrapped.has(): ${await wrapped.has()}`);
    rows.push('wrapped.delete()');
    wrapped.delete();
    rows.push(`wrapped.get(): ${await wrapped.get()}`);
    rows.push(`wrapped.has(): ${await wrapped.has()}`, '');
    rand = Math.random();
    const domain = storage_namespaceObject.wrapPrefix(testKey, () => 'default');
    rows.push(`prefix.set(): ${rand}`);
    domain.set('1', rand);
    rows.push(`prefix.get(): ${await domain.get('1')}`);
    rows.push(`prefix.has(): ${await domain.has('1')}`);
    rows.push('prefix.delete()');
    domain.delete('1');
    rows.push(`prefix.get(): ${await domain.get('1')}`);
    rows.push(`prefix.has(): ${await domain.has('1')}`, '');
    rand = Math.random();
    const blob = storage_namespaceObject.wrapBlob(testKey, () => 'default');
    rows.push(`blob.set(): ${rand}`);
    blob.set('1', rand);
    rows.push(`blob.get(): ${await blob.get('1')}`);
    rows.push(`blob.has(): ${await blob.has('1')}`);
    rows.push('blob.delete()');
    blob.delete('1');
    rows.push(`blob.get(): ${await blob.get('1')}`);
    rows.push(`blob.has(): ${await blob.has('1')}`, '');
  } catch (e) {
    rows.push('', `Errored: ${e}`);
    console.error(e);
  }

  alert_namespaceObject.open(rows.join('<br>'));
}
// CONCATENATED MODULE: ./lib/modules/presets.js






const presets_module = new Module('presets');
presets_module.moduleName = 'presetsName';
presets_module.category = 'coreCategory';
presets_module.alwaysEnabled = true;
presets_module.description = 'presetsDesc';
presets_module.options = {
  lite: {
    title: 'presetsLiteTitle',
    description: 'presetsLiteDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(() => toggleModules(['notifications', 'hover', 'announcements', 'orangered', 'onboarding', 'selectedEntry', 'showImages', 'submitHelper', 'neverEndingReddit', 'accountSwitcher', 'filteReddit', 'quickMessage', 'subredditInfo', 'userInfo', 'userHighlight', 'searchHelper', 'betteReddit', 'styleTweaks', 'pageNavigator', 'commandLine', 'commentHidePersistor', 'commentTools', 'commentPreview', 'localDate', 'noParticipation'], '*'))
  },
  cleanSlate: {
    title: 'presetsCleanSlateTitle',
    description: 'presetsCleanSlateDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(() => toggleModules(undefined, '*'))
  },
  noPopups: {
    title: 'presetsNoPopupsTitle',
    description: 'presetsNoPopupsDesc',
    type: 'button',
    text: 'apply preset',
    callback: confirmPreset(async () => {
      await toggleModules(undefined, 'hover RESTips showParent subredditInfo'.split(/[,\s]/));
      await toggleOptions(undefined, 'userTagger.hoverInfo'.split(/[,\s]/));
    })
  },
  resetToFactory: troubleshooter_module.options.resetToFactory
};

function confirmPreset(callback) {
  return async function () {
    const confirmation = prompt(`Are you sure you want to apply the "${i18n(this.title)}" preset? Type "yes" to continue.`);

    if (/^"?yes"?$/.test(confirmation)) {
      await callback();
      const shouldReload = confirm(`Applied preset: ${i18n(this.title)}\nYou must reload the page to see results.\n\nWould you like to reload now?`);

      if (shouldReload) {
        location.reload();
      }
    } else {
      notifications_showNotification({
        moduleID: presets_module.moduleID,
        header: 'Preset cancelled',
        message: 'If you really wanted to apply this preset, make sure to type in "yes" when prompted.'
      });
    }
  };
}

function sanitizeModulesList(unsanitized) {
  let sanitized;

  if (unsanitized === '*') {
    sanitized = allModules();
  } else if (typeof unsanitized === 'string') {
    sanitized = unsanitized.split(/[,\s]/);
  } else if (unsanitized && unsanitized.length) {
    sanitized = unsanitized;
  }

  return sanitized ? [].concat(sanitized) : [];
}

async function toggleModules(requestEnable, requestDisable) {
  let enable = sanitizeModulesList(requestEnable);
  let disable = sanitizeModulesList(requestDisable);
  disable = requestEnable !== '*' ? disable.filter(moduleID => !enable.includes(moduleID)) : disable;
  enable = requestDisable !== '*' ? enable.filter(moduleID => !disable.includes(moduleID)) : enable;

  for (const modId of disable) await setEnabled(modId, false);

  for (const modId of enable) await setEnabled(modId, true);
}

function allModules() {
  return modules_all().map(mod => mod.moduleID);
}

async function toggleOptions(requestEnable, requestDisable) {
  const enable = requestEnable ? [].concat(requestEnable) : [];
  const disable = requestDisable ? [].concat(requestDisable) : [];

  for (const option of enable) await setOptionValue(true, option);

  for (const option of disable) await setOptionValue(false, option);
}

async function setOptionValue(value, path) {
  if (typeof path === 'string') {
    path = path.split('.');
  }

  const [id, optName] = path;
  await options_storage_set(id, optName, value);
}
// CONCATENATED MODULE: ./lib/modules/profileNavigator.js






const profileNavigator_module = new Module('profileNavigator');
profileNavigator_module.moduleName = 'profileNavigatorName';
profileNavigator_module.description = 'profileNavigatorDesc';
profileNavigator_module.category = 'myAccountCategory';
profileNavigator_module.options = {
  sectionMenu: {
    title: 'profileNavigatorSectionMenuTitle',
    type: 'boolean',
    value: true,
    description: 'profileNavigatorSectionMenuDesc'
  },
  sectionLinks: {
    title: 'profileNavigatorSectionLinksTitle',
    dependsOn: options => options.sectionMenu.value,
    description: 'profileNavigatorSectionLinksDesc',
    type: 'table',
    addRowText: '+add profile section shortcut',
    fields: [{
      key: 'label',
      name: 'label',
      type: 'text'
    }, {
      key: 'url',
      name: 'url',
      type: 'text'
    }],
    value: [['saved', './saved'], ['comments', './comments'], ['submitted', './submitted'], ['gilded', './gilded'], ['upvoted', './upvoted'], ['downvoted', './downvoted']]
  },
  hoverDelay: {
    title: 'profileNavigatorHoverDelayTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '1000',
    description: 'profileNavigatorHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'profileNavigatorFadeDelayTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '200',
    description: 'profileNavigatorFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'profileNavigatorFadeSpeedTitle',
    dependsOn: options => options.sectionMenu.value,
    type: 'text',
    value: '0.7',
    description: 'profileNavigatorFadeSpeedDesc',
    advanced: true
  }
};

profileNavigator_module.contentStart = () => {
  const username = loggedInUser();

  if (profileNavigator_module.options.sectionMenu.value && username) {
    dropdownList(profileNavigator_module.moduleID).options({
      openDelay: penalizedDelay(profileNavigator_module.moduleID, 'sectionMenu', profileNavigator_module.options.hoverDelay),
      fadeDelay: parseFloat(profileNavigator_module.options.fadeDelay.value),
      fadeSpeed: parseFloat(profileNavigator_module.options.fadeSpeed.value),
      pin: pin.bottom
    }).populateWith(() => [profileNavigator_getListFragment(username)]).watch('#header .user a');
  }
};

const profileNavigator_getListFragment = username => {
  alterFeaturePenalty(profileNavigator_module.moduleID, 'sectionMenu', 5);
  const fragment = document.createDocumentFragment();

  for (const link of profileNavigator_module.options.sectionLinks.value) {
    const label = link[0] || '';
    const url = link[1] || '';
    const li = string_namespaceObject.html`<li><a href="/user/${username}/${url}">${label}</a></li>`;
    li.addEventListener('click', () => {
      dropdownList(profileNavigator_module.moduleID).close();
      alterFeaturePenalty(profileNavigator_module.moduleID, 'sectionMenu', -30);
    });
    fragment.append(li);
  }

  fragment.append(string_namespaceObject.html`<li><a href=${makeUrlHash(profileNavigator_module.moduleID, 'sectionMenu')}>
		<i>${i18n(profileNavigator_module.moduleName)}</i>
		<span class="RESMenuItemButton gearIcon"></span>
	</a></li>`);
  return fragment;
};
// CONCATENATED MODULE: ./lib/modules/profileRedirect.js





const profileRedirect_module = new Module('profileRedirect');
profileRedirect_module.moduleName = 'profileRedirectName';
profileRedirect_module.category = 'usersCategory';
profileRedirect_module.description = 'profileRedirectDesc';
profileRedirect_module.keywords = ['legacy', 'overview'];
profileRedirect_module.include = ['profile', 'profile2x'];
profileRedirect_module.options = {
  fromLandingPage: {
    title: 'profileRedirectFromLandingPageTitle',
    description: 'profileRedirectFromLandingPageDesc',
    keywords: ['legacy', 'overview'],
    type: 'enum',
    value: 'none',
    values: [{
      name: 'Do nothing',
      value: 'none'
    }, {
      name: 'Overview (legacy)',
      value: 'overview'
    }, {
      name: 'Comments',
      value: 'comments'
    }, {
      name: 'Submitted (legacy)',
      value: 'submitted'
    }, {
      name: 'Gilded',
      value: 'gilded'
    }, {
      name: 'Custom',
      value: 'custom'
    }]
  },
  customFromLandingPage: {
    dependsOn: options => options.fromLandingPage.value === 'custom',
    title: 'profileRedirectCustomFromLandingPageTitle',
    description: 'profileRedirectCustomFromLandingPageDesc',
    type: 'text',
    value: ''
  }
};

profileRedirect_module.beforeLoad = function () {
  const [, username, currentSection] = utils_location["p" /* regexes */].profile2x.exec(location.pathname) || [];

  if (username && !currentSection) {
    if (profileRedirect_module.options.fromLandingPage.value !== 'none') {
      const preferredSection = profileRedirect_module.options.fromLandingPage.value === 'custom' ? profileRedirect_module.options.customFromLandingPage.value : profileRedirect_module.options.fromLandingPage.value;
      window.location.replace(`/user/${username}/${preferredSection}`);
    } else if (Object(utils_location["n" /* isPageType */])('profile2x')) {
      const message = string_namespaceObject.html`
				<div>
					<p>${i18n('profileRedirectFromLandingPageNotificationText')}</p>
					<p><a class="RESNotificationButtonBlue" href="${makeUrlHash(profileRedirect_module.moduleID, 'fromLandingPage')}">${i18n('profileRedirectFromLandingPageNotificationButton')}</a></p>
				</div>
			`;
      const notification = notifications_showNotification({
        moduleID: profileRedirect_module.moduleID,
        optionKey: 'fromLandingPage',
        header: i18n('profileRedirectFromLandingPageNotificationTitle'),
        message,
        cooldown: utils_time["d" /* WEEK */]
      });
      message.querySelector('.RESNotificationButtonBlue').addEventListener('click', () => {
        notification.close();
      });
    }
  }
};
// CONCATENATED MODULE: ./lib/modules/quarantineHide.js




const quarantineHide_module = new Module('quarantineHide');
quarantineHide_module.moduleName = 'quarantineHideName';
quarantineHide_module.category = 'appearanceCategory';
quarantineHide_module.description = 'quarantineHideDesc';
quarantineHide_module.options = {
  hideFlair: {
    title: 'quarantineHideFlairTitle',
    type: 'boolean',
    value: false,
    description: 'quarantineHideFlairDesc'
  },
  hideQuarantinedInSub: {
    title: 'quarantineHideInSubTitle',
    type: 'boolean',
    value: false,
    description: 'quarantineHideInSubDesc'
  }
};
quarantineHide_module.include = ['linklist', 'comments', 'wiki'];

quarantineHide_module.contentStart = () => {
  if (quarantineHide_module.options.hideFlair.value) {
    Object(watchers["watchForThings"])(['post'], Object(utils_async["e" /* frameThrottle */])(() => {
      jquery_default()('.quarantine-stamp').parent().remove();
    }));
  }

  if (Object(utils_location["h" /* inQuarantinedSubreddit */])() && quarantineHide_module.options.hideQuarantinedInSub.value) {
    bodyClasses_namespaceObject.remove('quarantine');
    jquery_default()('.quarantine-notice').hide();
  }
};
// CONCATENATED MODULE: ./lib/modules/redditUserInfo.js

const redditUserInfo_module = new Module('redditUserInfo');
redditUserInfo_module.moduleName = 'redditUserInfoName';
redditUserInfo_module.category = 'usersCategory';
redditUserInfo_module.description = 'redditUserInfoDesc';
redditUserInfo_module.options = {
  hideAuthorTooltip: {
    type: 'boolean',
    value: false,
    description: 'redditUserInfoHideDesc',
    title: 'redditUserInfoHideTitle',
    bodyClass: true
  }
};
// CONCATENATED MODULE: ./lib/modules/requestPermissions.js

const requestPermissions_module = new Module('requestPermissions');
requestPermissions_module.moduleName = 'requestPermissionsName';
requestPermissions_module.description = 'requestPermissionsDesc';
requestPermissions_module.category = 'aboutCategory';
requestPermissions_module.disabledByDefault = true;
requestPermissions_module.permissions = {
  get requiredPermissions() {
    return chrome.runtime.getManifest().optional_permissions;
  }

};
// CONCATENATED MODULE: ./lib/modules/search.js








const search_module = new Module('search');
search_module.moduleName = 'searchName';
search_module.category = 'aboutCategory';
search_module.alwaysEnabled = true;
search_module.sort = -9;
search_module.description = `
	<p>Search for settings within RES.</p>
	<div id="SearchRES-results-container">
		<div id="SearchRES-count"></div>
		<ul id="SearchRES-results"></ul>
		<p id="SearchRES-results-hidden">Some results have been hidden because advanced options are currently hidden. <a href="#">Show advanced options.</a></p>
	</div>
	<div id="SearchRES-boilerplate">
		<p>You can search for RES options by module name, option name, and description. For example, try searching for "daily trick" in one of the following ways:</p>
		<ul>
			<li>type <code>daily trick</code> in the search box to the left and click the magnifying glass button</li>
			<li>press <code>.</code> to open the RES console, type in <code>search <em>daily trick</em></code>, and press Enter</li>
		</ul>
	</div>
`;
search_module.descriptionRaw = true;
const PRESERVE_SPACES = true;
function search_search(query = search_input().value) {
  search_input().value = query;

  if (!query) {
    drawSearchResults(query, []);
    return;
  }

  const sanitizedQuery = sanitizeString(query, PRESERVE_SPACES);
  const queryTerms = sanitizedQuery && sanitizedQuery.length ? sanitizedQuery.split(' ') : [];
  let results = [];

  if (queryTerms && queryTerms.length) {
    results = searchDomain().map(item => ({
      rank: item.getRank(queryTerms, item.context),
      context: item.context
    })).filter(item => item.rank !== Infinity).sort((a, b) => b.rank - a.rank).map(item => item.context);
  }

  drawSearchResults(query, results);
}
const searchDomain = Object(once["a" /* default */])(() => {
  const results = [];

  for (const mod of modules_all()) {
    if (mod === search_module) continue;
    if (mod.hidden) continue;
    const moduleName = i18n(mod.moduleName);
    const category = i18n(mod.category);
    results.push({
      getRank: rankModule,
      context: {
        title: moduleName,
        description: mod.descriptionRaw ? mod.description : snudown_es_markdown(i18n(mod.description)),
        category,
        moduleID: mod.moduleID,
        moduleName,
        keywords: mod.keywords
      }
    });
    if (lodash_es_isEmpty(mod.options)) continue;

    for (const [optionKey, option] of Object.entries(mod.options)) {
      if (option.noconfig) continue;
      const optionName = i18n(option.title);
      results.push({
        getRank: rankOption,
        context: {
          title: optionName,
          description: snudown_es_markdown(i18n(option.description).split('\n')[0]),
          advanced: option.advanced,
          category,
          moduleID: mod.moduleID,
          moduleName,
          optionKey,
          optionName,
          keywords: option.keywords || []
        }
      });
    }
  }

  return results;
});

function rankString(queryTerms, string) {
  if (!queryTerms || !queryTerms.length || !string) {
    return Infinity;
  }

  const indexes = indexesOfSearchTermsInString(queryTerms, sanitizeString(string, false));
  const weighted = indexes.map(item => 100 - item.value * (Math.log(item.matchedIndex + 1) / Math.log(5) + 1));
  return weighted.length ? weighted.reduce((a, b) => a + b, 0) : Infinity;
}

function rankModule(queryTerms, context) {
  const string = [context.moduleID, context.moduleName, context.category, context.description, ...context.keywords].join('~');
  return rankString(queryTerms, string) * 0.9;
}

function rankOption(queryTerms, context) {
  const string = [context.optionKey, context.title, context.description, ...context.keywords, context.moduleID, context.moduleName, context.category].join('~');
  return rankString(queryTerms, string);
}

function indexesOfSearchTermsInString(needles, haystack) {
  if (!haystack || !haystack.length) return [];
  return needles.map((needle, i) => ({
    matchedIndex: i,
    value: haystack.indexOf(needle)
  })).filter(item => item.value !== -1);
}

function sanitizeString(text, preserveSpaces) {
  if (text === undefined || text === null) {
    return '';
  }

  const replaceSpacesWith = preserveSpaces ? ' ' : '';
  return text.toString().toLowerCase().replace(/[,\/\s]+/g, replaceSpacesWith);
}

function onSearchResultSelected(moduleID, optionKey) {
  settingsNavigation_open(moduleID, optionKey);
}

const search_input = Object(once["a" /* default */])(() => Object(flow["a" /* downcast */])(string_namespaceObject.html`<input id="SearchRES-input" type="text" placeholder="${i18n('searchRESSettings')}">`, HTMLInputElement));

function drawSearchResults(query, results) {
  const $resultsContainer = jquery_default()('#SearchRES-results-container');
  $resultsContainer.off('click', handleSearchResultClick).on('click', '.SearchRES-result-item', handleSearchResultClick);

  if (!query || !query.length) {
    $resultsContainer.hide();
    return;
  }

  const advancedResults = results.filter(({
    advanced
  }) => advanced).length;
  const count = results.length - advancedResults;
  const plural = count !== 1 ? 's' : '';
  jquery_default()('#SearchRES-count').text(`${count} result${plural} for ${query}`);
  $resultsContainer.show();
  $resultsContainer.find('#SearchRES-query').text(query);

  if (advancedResults) {
    $resultsContainer.find('#SearchRES-results-hidden').addClass('advancedResults');
    jquery_default()('#SearchRES-results-hidden a').off('click').on('click', () => {
      jquery_default()(document.getElementById('RESAllOptions')).click();
      search_search();
      return false;
    });
  } else {
    $resultsContainer.find('#SearchRES-results-hidden').removeClass('advancedResults');
  }

  if (!results.length) {
    $resultsContainer.find('#SearchRES-results').hide();
  } else {
    $resultsContainer.find('#SearchRES-results').show();
    const resultsList = document.getElementById('SearchRES-results');
    Object(dom["e" /* empty */])(resultsList);
    resultsList.append(...results.map(drawSearchResultItem));
  }
}

const searchResultTemplate = ({
  title,
  category,
  description,
  moduleName,
  moduleID,
  optionName,
  optionKey
}) => string_namespaceObject.html`
	<div>
		<div class="SearchRES-result-header">
			<span class="SearchRES-result-title">${title}</span>
			<span class="SearchRES-breadcrumb">${i18n('RESSettingsConsole')}
				→ ${category}
				→ ${moduleName} (${moduleID})
				${optionName && optionKey ? ` → ${optionName} (${optionKey})` : optionKey && ` → ${optionKey}`}
			</span>
		</div>
		<div class="SearchRES-result-description">
			${string_namespaceObject.safe(description)}
		</div>
	</div>
`;

const drawSearchResultItem = Object(memoize["a" /* default */])(result => {
  const element = document.createElement('li');
  element.classList.add('SearchRES-result-item');

  if (result.advanced) {
    element.classList.add('advanced');
  }

  element.setAttribute('data-module-id', result.moduleID);

  if (result.optionKey) {
    element.setAttribute('data-option-key', result.optionKey);
  }

  element.appendChild(searchResultTemplate(result));
  const copybutton = createElement_namespaceObject.icon(0xF159, 'span', 'SearchRES-result-copybutton res-icon', i18n('searchCopyResultForComment'));
  element.insertBefore(copybutton, element.firstChild);
  return element;
});

function handleSearchResultClick(event) {
  const moduleID = this.getAttribute('data-module-id');
  const optionKey = this.getAttribute('data-option-key');

  if (event.target.classList.contains('SearchRES-result-copybutton')) {
    onSearchResultCopy(moduleID, optionKey);
  } else {
    onSearchResultSelected(moduleID, optionKey);
  }

  event.preventDefault();
}

function onSearchResultCopy(moduleID, optionKey) {
  const markdown = makeOptionSearchResultLink(moduleID, optionKey);
  alert_namespaceObject.open(`<textarea rows="5" cols="50">${markdown}</textarea><p>Copy and paste this into your comment</p>`);
}

const optionLinkTemplate = ({
  title,
  url,
  description,
  settingsUrl,
  category,
  moduleName,
  moduleUrl,
  moduleID,
  optionKey,
  optionUrl
}) => `
**[${title}](${url})** -- [](#gear) [RES settings console](${settingsUrl}) > ${category} > [${moduleName}](${moduleUrl} "${moduleID}")${optionKey ? ` > [${optionKey}](${optionUrl})` : ''}

${description}
`.trim();

function makeOptionSearchResultLink(moduleID, optionKey) {
  const module = modules_get(moduleID);
  const context = {
    moduleID,
    moduleName: i18n(module.moduleName),
    category: i18n(module.category),
    optionKey,
    title: optionKey ? optionKey : i18n(module.moduleName),
    description: optionKey ? i18n(module.options[optionKey].description) : i18n(module.description),
    url: makeUrlHash(moduleID, optionKey),
    settingsUrl: makeUrlHash(),
    moduleUrl: makeUrlHash(moduleID),
    optionUrl: makeUrlHash(moduleID, optionKey)
  };
  return `${optionLinkTemplate(context)}\n\n\n`;
}
// CONCATENATED MODULE: ./lib/modules/searchHelper.js



const searchHelper_module = new Module('searchHelper');
searchHelper_module.moduleName = 'searchHelperName';
searchHelper_module.category = 'browsingCategory';
searchHelper_module.description = 'searchHelperDesc';
searchHelper_module.options = {
  addSearchOptions: {
    title: 'searchHelperAddSearchOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperAddSearchOptionsDesc'
  },
  defaultSortOption: {
    title: 'searchHelperDefaultSortOptionTitle',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'relevance',
      value: 'relevance'
    }, {
      name: 'new',
      value: 'new'
    }, {
      name: 'hot',
      value: 'hot'
    }, {
      name: 'top',
      value: 'top'
    }, {
      name: 'comments',
      value: 'comments'
    }],
    description: 'searchHelperDefaultSortOptionDesc',
    dependsOn: options => options.addSearchOptions.value,
    advanced: true
  },
  defaultTimeOption: {
    title: 'searchHelperDefaultTimeOptionTitle',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'all',
      value: 'all'
    }, {
      name: 'hour',
      value: 'hour'
    }, {
      name: 'day',
      value: 'day'
    }, {
      name: 'week',
      value: 'week'
    }, {
      name: 'month',
      value: 'month'
    }, {
      name: 'year',
      value: 'year'
    }],
    description: 'searchHelperDefaultTimeOptionDesc',
    dependsOn: options => options.addSearchOptions.value,
    advanced: true
  },
  legacySearch: {
    title: 'searchHelperLegacySearchTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperLegacySearchDesc'
  },
  toggleSearchOptions: {
    title: 'searchHelperToggleSearchOptionsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperToggleSearchOptionsDesc',
    advanced: true,
    dependsOn: options => options.legacySearch.value
  },
  hideSearchOptions: {
    title: 'searchHelperHideSearchOptionsTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperHideSearchOptionsDesc',
    advanced: true,
    dependsOn: options => options.legacySearch.value
  },
  userFilterBySubreddit: {
    title: 'searchHelperUserFilterBySubredditTitle',
    type: 'boolean',
    value: false,
    description: 'searchHelperUserFilterBySubredditDesc'
  },
  searchByFlair: {
    title: 'searchHelperSearchByFlairTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperSearchByFlairDesc'
  },
  searchPageTabs: {
    title: 'searchHelperSearchPageTabsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperSearchPageTabsDesc',
    bodyClass: true
  },
  defaultSearchTab: {
    title: 'searchHelperDefaultSearchTabTitle',
    type: 'enum',
    value: 'subreddits',
    values: [{
      name: 'none',
      value: 'none'
    }, {
      name: 'subreddits',
      value: 'subreddits'
    }, {
      name: 'limit to subreddit',
      value: 'facets'
    }, {
      name: 'refine',
      value: 'options'
    }],
    description: 'searchHelperDefaultSearchTabDesc',
    dependsOn: options => options.searchPageTabs.value,
    advanced: true
  },
  transitionSearchTabs: {
    title: 'searchHelperTransitionSearchTabsTitle',
    type: 'boolean',
    value: true,
    description: 'searchHelperTransitionSearchTabsDesc',
    dependsOn: options => options.searchPageTabs.value,
    advanced: true
  },
  searchBySubreddit: {
    title: 'searchHelperSearchBySubredditTitle',
    type: 'enum',
    value: 'default',
    values: [{
      name: 'default (let reddit manage it)',
      value: 'default'
    }, {
      name: 'always',
      value: 'always'
    }, {
      name: 'never',
      value: 'never'
    }],
    description: 'searchHelperSearchBySubredditDesc'
  }
};

searchHelper_module.contentStart = () => {
  if (searchHelper_module.options.addSearchOptions.value) {
    const searchExpando = document.getElementById('searchexpando');

    if (searchExpando) {
      let searchOptionsHtml = '<label>Sort:<select name="sort"><option value="relevance">relevance</option><option value="new">new</option><option value="hot">hot</option><option value="top">top</option><option value="comments">comments</option></select></label> <label>Time:<select name="t"><option value="all">all time</option><option value="hour">this hour</option><option value="day">today</option><option value="week">this week</option><option value="month">this month</option><option value="year">this year</option></select></label>';

      if (jquery_default()(searchExpando).find('input[name=restrict_sr]').length) {
        searchOptionsHtml = `<br />${searchOptionsHtml}`;
      }

      if (searchHelper_module.options.defaultSortOption.value !== 'none') {
        const defaultValue = searchHelper_module.options.defaultSortOption.value;
        searchOptionsHtml = searchOptionsHtml.replace(`value="${defaultValue}"`, `value="${defaultValue}" selected`);
      }

      if (searchHelper_module.options.defaultTimeOption.value !== 'none') {
        const defaultValue = searchHelper_module.options.defaultTimeOption.value;
        searchOptionsHtml = searchOptionsHtml.replace(`value="${defaultValue}"`, `value="${defaultValue}" selected`);
      }

      jquery_default()(searchExpando).find('#moresearchinfo').before(searchOptionsHtml);
    }
  }

  if (searchHelper_module.options.legacySearch.value) {
    jquery_default()('form#search').append('<input type="hidden" name="feature" value="legacy_search" />');
  }

  if (searchHelper_module.options.userFilterBySubreddit.value) {
    const [, userProfile] = location.pathname.match(utils_location["p" /* regexes */].profile) || [];

    if (userProfile && document.referrer) {
      const referrer = new URL(document.referrer);
      let match, previousPage;

      if (match = referrer.pathname.match(utils_location["p" /* regexes */].subreddit)) {
        previousPage = `r/${match[1]}`;
      } else if (match = referrer.pathname.match(utils_location["p" /* regexes */].multireddit)) {
        previousPage = match[1];
      }

      if (previousPage) {
        jquery_default()('.content[role=main]').prepend(`<div class="infobar"><a href="/${previousPage}/search?q=author:${userProfile} nsfw:no&restrict_sr=on">Search post of ${userProfile} on /${previousPage}</a></div>`);
      }
    }
  }

  const isLegacySearch = document.querySelector('#siteTable');

  if (searchHelper_module.options.toggleSearchOptions.value && Object(utils_location["n" /* isPageType */])('search') && isLegacySearch) {
    if (searchHelper_module.options.hideSearchOptions.value || location.hash === '#res-hide-options') {
      bodyClasses_namespaceObject.add('res-hide-options');
    }

    jquery_default()('.content .searchpane').append('<a href="#res-hide-options" class="searchpane-toggle-hide">hide search options</a>');
    jquery_default()('.content .searchpane ~ .menuarea').prepend('<a href="#res-show-options" class="searchpane-toggle-show">show search options</a>');
    jquery_default()('.searchpane-toggle-hide').on('click', () => bodyClasses_namespaceObject.add('res-hide-options'));
    jquery_default()('.searchpane-toggle-show').on('click', () => bodyClasses_namespaceObject.remove('res-hide-options'));
  }

  if (searchHelper_module.options.searchByFlair.value) {
    jquery_default()('#siteTable').on('mouseenter', '.linkflairlabel:not(.res-flairSearch)', e => {
      const subreddit = Thing["a" /* Thing */].checkedFrom(e.currentTarget).getSubreddit();
      const flair = e.currentTarget.title.replace(/\s/g, '+');

      if (flair) {
        e.currentTarget.classList.add('res-flairSearch');
        e.currentTarget.appendChild(string_namespaceObject.html`<a href="${string_namespaceObject.encode`/r/${subreddit}/search?sort=new&restrict_sr=on&q=flair%3A${flair}`}"></a>`);
      }
    });
  }

  if (searchHelper_module.options.searchPageTabs.value && !isLegacySearch) {
    const $searchTabsEle = jquery_default()('<ul>', {
      class: 'res-search-tabs'
    });
    const searchHeader = document.querySelector('#previoussearch');
    const searchForm = document.querySelector('.content form#search');
    const moreSearchInfo = document.querySelector('#moresearchinfo');
    const searchFacets = document.querySelector('body.search-page .searchfacets');
    const $searchOptions = jquery_default()('<div>', {
      class: 'res-search-options'
    });

    if (!searchForm) {
      return;
    }

    searchForm.removeChild(searchForm.querySelector('#moresearchinfo + p'));
    $searchTabsEle.appendTo(searchHeader);
    const subredditResultListing = document.querySelectorAll('.search-result-listing');

    if (subredditResultListing.length > 1) {
      subredditResultListing[0].classList.add('res-search-subreddits');
    }

    if (moreSearchInfo) {
      $searchOptions.appendTo(searchHeader);
      jquery_default()(moreSearchInfo).children().appendTo($searchOptions);
    }

    if (searchFacets) {
      jquery_default()(searchFacets).appendTo(searchHeader);
    }

    if (jquery_default()('.res-search-subreddits').length) {
      jquery_default()('.res-search-subreddits').appendTo(searchHeader);
    }

    const searchTabs = {
      subreddits: {
        label: 'subreddits',
        id: 'subs',
        target: '.res-search-subreddits',
        exists: jquery_default()('.res-search-subreddits').length
      },
      facets: {
        label: 'limit to subreddit',
        id: 'facets',
        target: '.searchfacets',
        exists: searchFacets
      },
      options: {
        label: 'refine',
        id: 'options',
        target: '.res-search-options',
        exists: $searchOptions.get(0)
      }
    };

    for (const searchTab of Object.values(searchTabs)) {
      if (searchTab.exists) {
        jquery_default()(searchTab.target).addClass('res-search-pane').slideUp(0);
        const $searchTabLi = jquery_default()('<li>').attr({
          class: `res-search-tab-${searchTab.id}`
        }).appendTo($searchTabsEle);
        jquery_default()('<a>').attr({
          href: '#'
        }).text(searchTab.label).appendTo($searchTabLi).click(e => searchTabToggle(searchTab.id, searchTab.target, e.currentTarget));
      }
    }

    if (searchHelper_module.options.defaultSearchTab.value !== 'none' && searchTabs[searchHelper_module.options.defaultSearchTab.value].exists) {
      searchTabToggle(searchTabs[searchHelper_module.options.defaultSearchTab.value].id, searchTabs[searchHelper_module.options.defaultSearchTab.value].target, null);
    }
  }
};

searchHelper_module.afterLoad = () => {
  if (searchHelper_module.options.searchBySubreddit.value !== 'default' && !Object(utils_location["n" /* isPageType */])('search')) {
    const restrictSearch = document.querySelector('input[name=restrict_sr]');

    if (restrictSearch) {
        restrictSearch.checked = searchHelper_module.options.searchBySubreddit.value === 'always';
      }
  }
};

function searchTabToggle(tabID, target, source) {
  const transitionSpd = searchHelper_module.options.transitionSearchTabs.value ? 200 : 0;
  const sourceParent = source ? Object(flow["a" /* downcast */])(source.parentNode, HTMLElement) : null;
  const tab = sourceParent || document.querySelector(`.res-search-tabs .res-search-tab-${tabID}`);
  const activeClass = 'res-search-tab-active';
  const openClass = 'res-search-pane-open';

  if (tab.classList.contains(activeClass)) {
    jquery_default()(target).removeClass(openClass).slideUp(transitionSpd);
    tab.classList.remove(activeClass);
  } else {
    jquery_default()('.res-search-pane').addClass(openClass).slideUp(transitionSpd);
    jquery_default()('.res-search-tabs li').removeClass(activeClass);
    jquery_default()('.res-search-pane').removeClass(openClass);
    tab.classList.add(activeClass);
    const speed = sourceParent ? transitionSpd : 0;
    jquery_default()(target).addClass(openClass).slideDown(speed);
  }

  return false;
}
// CONCATENATED MODULE: ./lib/modules/selectedEntry.js




const selectedEntry_module = new Module('selectedEntry');
selectedEntry_module.moduleName = 'selectedEntryName';
selectedEntry_module.category = 'browsingCategory';
selectedEntry_module.include = ['comments', 'linklist', 'commentsLinklist', 'modqueue', 'profile', 'inbox', 'search'];
selectedEntry_module.description = 'selectedEntryDesc';
selectedEntry_module.options = {
  autoSelectOnScroll: {
    title: 'selectedEntryAutoSelectOnScrollTitle',
    type: 'boolean',
    value: false,
    description: 'selectedEntryAutoSelectOnScrollDesc'
  },
  scrollToSelectedThingOnLoad: {
    title: 'selectedEntryScrollToSelectedThingOnLoadTitle',
    type: 'boolean',
    value: false,
    advanced: true,
    description: 'selectedEntryScrollToSelectedThingOnLoadDesc'
  },
  addLine: {
    title: 'selectedEntryAddLineTitle',
    type: 'boolean',
    value: false,
    description: 'selectedEntryAddLineDesc'
  },
  setColors: {
    title: 'selectedEntrySetColorsTitle',
    type: 'boolean',
    value: true,
    description: 'selectedEntrySetColorsDesc'
  },
  backgroundColor: {
    title: 'selectedEntryBackgroundColorTitle',
    type: 'color',
    value: '#f0f3fc',
    description: 'selectedEntryBackgroundColorDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  backgroundColorNight: {
    title: 'selectedEntryBackgroundColorNightTitle',
    type: 'color',
    value: '#373737',
    description: 'selectedEntryBackgroundColorNightDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  textColorNight: {
    title: 'selectedEntryTextColorNightTitle',
    type: 'color',
    value: '#dddddd',
    description: 'selectedEntryTextColorNightDesc',
    advanced: true,
    dependsOn: options => options.setColors.value
  },
  outlineStyle: {
    title: 'selectedEntryOutlineStyleTitle',
    type: 'text',
    value: '',
    description: 'selectedEntryOutlineStyleDesc',
    advanced: true
  },
  outlineStyleNight: {
    title: 'selectedEntryOutlineStyleNightTitle',
    type: 'text',
    value: '',
    description: 'selectedEntryOutlineStyleNightDesc',
    advanced: true
  }
};

selectedEntry_module.beforeLoad = () => {
  if (selectedEntry_module.options.addLine.value) styleLine();
  if (selectedEntry_module.options.setColors.value) styleColor();
  styleOutline();
  selectedThing_namespaceObject.setScrollToSelectedThingOnLoad(selectedEntry_module.options.scrollToSelectedThingOnLoad.value);
};

selectedEntry_module.contentStart = () => {
  jquery_default()(document.body).on('mouseup', Thing["a" /* Thing */].thingSelector, lodash_es_throttle(e => {
    if (dom["c" /* click */].isProgrammaticEvent(e)) return;
    const thing = Thing["a" /* Thing */].from(e.currentTarget);
    if (thing) selectedThing_namespaceObject.set(thing);
  }, 50, {
    leading: true,
    trailing: false
  }));

  if (selectedEntry_module.options.autoSelectOnScroll.value) {
    window.addEventListener('scroll', () => {
      selectedThing_namespaceObject.selectClosestInView();
    });
  }
};

selectedEntry_module.afterLoad = () => {
  if (!selectedThing_namespaceObject.current || !selectedThing_namespaceObject.current.isVisible()) selectedThing_namespaceObject.selectClosestInView();
};

function styleLine() {
  Object(dom["b" /* addCSS */])(`
		.entry.res-selected { box-shadow: 3px 0 0 -1px #c2d2e0 !important; }
		.res-nightmode .entry.res-selected { box-shadow: 3px 0 0 -1px grey !important; }
	`);
}

function styleColor() {
  selectedThing_namespaceObject.addListener((current, previous) => {
    if (previous) {
      previous.entry.classList.remove('RES-keyNav-activeElement');
      previous.element.classList.remove('RES-keyNav-activeThing');
    }

    if (current) {
      current.entry.classList.add('RES-keyNav-activeElement');
      current.element.classList.add('RES-keyNav-activeThing');
    }
  }, 'instantly');
  const backgroundColor = selectedEntry_module.options.backgroundColor.value ? `
		.entry.res-selected,
		.entry.res-selected .md-container {
			background-color: ${selectedEntry_module.options.backgroundColor.value} !important;
		}` : '';
  const backgroundColorNight = selectedEntry_module.options.backgroundColorNight.value ? `
		.res-nightmode .entry.res-selected,
		.res-nightmode .entry.res-selected .md-container {
			background-color: ${selectedEntry_module.options.backgroundColorNight.value} !important;
		}` : '';
  const textColorNight = selectedEntry_module.options.textColorNight.value ? `
		.res-nightmode .entry.res-selected > .tagline,
		.res-nightmode .entry.res-selected .md-container > .md,
		.res-nightmode .entry.res-selected .md-container > .md p {
			color: ${selectedEntry_module.options.textColorNight.value} !important;
		}` : '';
  Object(dom["b" /* addCSS */])(backgroundColor + backgroundColorNight + textColorNight);
}

function styleOutline() {
  const outlineStyle = selectedEntry_module.options.outlineStyle.value ? `
		.entry.res-selected {
			outline: ${selectedEntry_module.options.outlineStyle.value};
		}` : '';
  const outlineStyleNight = selectedEntry_module.options.outlineStyleNight.value ? `
		.res-nightmode .entry.res-selected {
			outline: ${selectedEntry_module.options.outlineStyleNight.value};
		}
	` : '';
  const style = outlineStyle + outlineStyleNight;

  if (style) {
    Object(dom["b" /* addCSS */])(style);
  }
}
// CONCATENATED MODULE: ./lib/modules/showKarma.js


const showKarma_module = new Module('showKarma');
showKarma_module.moduleName = 'showKarmaName';
showKarma_module.category = 'myAccountCategory';
showKarma_module.description = 'showKarmaDesc';
showKarma_module.options = {
  showCommentKarma: {
    title: 'showKarmaShowCommentKarmaTitle',
    type: 'boolean',
    value: true,
    description: 'showKarmaShowCommentKarmaDesc'
  },
  separator: {
    title: 'showKarmaSeparatorTitle',
    type: 'text',
    value: '\u00b7',
    description: 'showKarmaSeparatorDesc',
    advanced: true
  },
  useCommas: {
    title: 'showKarmaUseCommasTitle',
    type: 'boolean',
    value: true,
    description: 'showKarmaUseCommasDesc'
  },
  showGold: {
    title: 'showKarmaShowGoldTitle',
    type: 'boolean',
    value: false,
    description: 'showKarmaShowGoldDesc'
  }
};

showKarma_module.contentStart = async () => {
  if (!loggedInUser()) return;
  const {
    data
  } = await getUserInfo();
  updateKarmaDiv(data);

  if (showKarma_module.options.showGold.value && data.is_gold) {
    displayGold(data.gold_expiration);
  }
};

function updateKarmaDiv(data) {
  const karmaDiv = document.querySelector('#header-bottom-right .userkarma');
  if (!karmaDiv) return;
  karmaDiv.title = '';
  Object(dom["e" /* empty */])(karmaDiv);
  karmaDiv.append(string_namespaceObject.html`<a title="post karma" href="/user/me/submitted/">${showKarma_module.options.useCommas.value ? formatNumber(data.link_karma) : data.link_karma}</a>`);

  if (showKarma_module.options.showCommentKarma.value) {
    karmaDiv.append(showKarma_module.options.separator.value, string_namespaceObject.html`<a title="comment karma" href="/user/me/comments/">${showKarma_module.options.useCommas.value ? formatNumber(data.comment_karma) : data.comment_karma}</a>`);
  }
}

function displayGold(expires) {
  const userSpan = document.querySelector('#header-bottom-right .user');
  if (!userSpan) return;
  const today = new Date();
  const expDate = new Date(expires * 1000);
  const title = expDate > today ? `Until ${formatDate(expDate)} (${formatDateDiff(today, expDate)})` : '';
  userSpan.prepend(string_namespaceObject.html`<span title="${title}" class="gilded-icon"></span>`);
}
// CONCATENATED MODULE: ./lib/modules/sourceSnudown.js





const sourceSnudown_module = new Module('sourceSnudown');
sourceSnudown_module.moduleName = 'sourceSnudownName';
sourceSnudown_module.description = 'sourceSnudownDesc';
sourceSnudown_module.category = 'commentsCategory';

sourceSnudown_module.beforeLoad = () => {
  Object(watchers["watchForThings"])(['post', 'comment', 'message'], attachViewSourceButton);
};

const sourceButton = (e => () => Object(dom["k" /* preventCloning */])(e().cloneNode(true)))(Object(once["a" /* default */])(() => {
  jquery_default()(document.body).on('click', 'li.viewSource a', function (e) {
    e.preventDefault();
    viewSource(this);
  }).on('click', '.usertext-edit.viewSource .cancel', function () {
    jquery_default()(this).parents('.usertext-edit.viewSource').hide();
  });
  return string_namespaceObject.html`
		<li class="viewSource">
			<a class="noCtrlF" href="javascript:void 0" data-text="source"></a>
		</li>
	`;
}));

function attachViewSourceButton(thing) {
  if (thing.isLinkPost()) return;
  const buttons = thing.entry.querySelector('.flat-list.buttons > li.first') || thing.entry.querySelector('.flat-list.buttons > li');
  if (buttons) buttons.after(sourceButton());
}

const viewSource = Object(utils_async["g" /* keyedMutex */])(async button => {
  const $button = jquery_default()(button);
  const $buttonList = $button.closest('ul');

  if ($button.data('source-open')) {
    $button.closest('.thing').find('.usertext-edit.viewSource:first').toggle();
  } else {
    const path = $buttonList.find('a.bylink, .first a').get(0).pathname;
    const response = await ajax({
      url: `${path}.json`,
      query: {
        raw_json: 1
      },
      type: 'json'
    });
    const $userTextForm = jquery_default()('<div class="usertext-edit viewSource"><div><textarea rows="1" cols="1" name="text" readonly></textarea></div><div class="bottom-area"><div class="usertext-buttons"><button type="button" class="cancel">hide</button></div></div></div>');
    $userTextForm.find('textarea').one('dblclick', () => $userTextForm.removeAttr('readonly'));
    let sourceText;

    if (utils_location["p" /* regexes */].commentPermalink.test(path)) {
      sourceText = response[1].data.children[0].data.body;
    } else if (utils_location["p" /* regexes */].comments.test(path)) {
      sourceText = response[0].data.children[0].data.selftext;
    } else {
      const postId = /\/(\w*)\/?$/.exec(path)[1];
      const data = response.data.children[0].data;

      if (data.id === postId) {
        sourceText = data.body;
      } else {
        sourceText = data.replies.data.children.find(({
          data: {
            id
          }
        }) => id === postId).data.body;
      }
    }

    $userTextForm.find('textarea[name=text]').text(sourceText);
    $buttonList.before($userTextForm);
    jquery_default()(button).data('source-open', true);
  }
});
// CONCATENATED MODULE: ./lib/modules/spamButton.js


const spamButton_module = new Module('spamButton');
spamButton_module.moduleName = 'spamButtonName';
spamButton_module.category = 'submissionsCategory';
spamButton_module.disabledByDefault = true;
spamButton_module.description = 'spamButtonDesc';

spamButton_module.beforeLoad = () => {
  Object(watchers["watchForThings"])(['post', 'comment'], addSpamButton);
};

function addSpamButton(thing) {
  const authorElement = thing.getAuthorElement();
  const authorName = thing.getAuthor();
  if (!authorElement || !authorName || loggedInUser() === authorName) return;
  const spam = document.createElement('li');
  const buttons = thing.getButtons();
  if (buttons.lastElementChild) buttons.lastElementChild.before(spam);else buttons.append(spam);
  const a = document.createElement('a');
  a.setAttribute('class', 'option noCtrlF');
  a.setAttribute('title', 'Report this user as a spammer');
  a.href = `/message/compose?to=/r/reddit.com&subject=spam&message=${authorElement.href}`;
  a.target = '_blank';
  a.rel = 'noopener noreferer';
  a.dataset.text = 'rts';
  spam.appendChild(a);
}
// CONCATENATED MODULE: ./lib/modules/spoilerTags.js

const spoilerTags_module = new Module('spoilerTags');
spoilerTags_module.moduleName = 'spoilerTagsName';
spoilerTags_module.category = 'appearanceCategory';
spoilerTags_module.description = 'spoilerTagsDesc';
spoilerTags_module.include = ['profile'];
spoilerTags_module.bodyClass = true;
spoilerTags_module.options = {
  transition: {
    title: 'spoilerTagsTransitionTitle',
    type: 'boolean',
    value: true,
    description: 'spoilerTagsTransitionDesc',
    bodyClass: true
  }
};
// CONCATENATED MODULE: ./lib/modules/styleTweaks.js


const styleTweaks_module = new Module('styleTweaks');
styleTweaks_module.moduleName = 'styleTweaksName';
styleTweaks_module.category = 'appearanceCategory';
styleTweaks_module.description = 'styleTweaksDesc';
styleTweaks_module.options = {
  navTop: {
    title: 'styleTweaksNavTopTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksNavTopDesc',
    bodyClass: 'res-navTop'
  },
  disableAnimations: {
    title: 'styleTweaksDisableAnimationsTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksDisableAnimationsDesc',
    bodyClass: true
  },
  visitedStyle: {
    title: 'styleTweaksVisitedStyleTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksVisitedStyleDesc',
    bodyClass: true
  },
  showExpandos: {
    title: 'styleTweaksShowExpandosTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksShowExpandosDesc',
    advanced: true,
    bodyClass: true
  },
  hideUnvotable: {
    title: 'styleTweaksHideUnvotableTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksHideUnvotableDesc',
    bodyClass: true
  },
  showFullLinkFlair: {
    title: 'styleTweaksShowFullLinkFlairTitle',
    type: 'enum',
    values: [{
      name: 'Never',
      value: 'never'
    }, {
      name: 'On hover',
      value: 'hover'
    }, {
      name: 'Always',
      value: 'always'
    }],
    value: 'never',
    description: 'styleTweaksShowFullLinkFlairDesc',
    bodyClass: true
  },
  highlightEditedTime: {
    title: 'styleTweaksHighlightEditedTimeTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHighlightEditedTimeDesc',
    bodyClass: true
  },
  colorBlindFriendly: {
    title: 'styleTweaksColorBlindFriendlyTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksColorBlindFriendlyDesc',
    advanced: true,
    bodyClass: 'res-colorblind'
  },
  scrollSubredditDropdown: {
    title: 'styleTweaksScrollSubredditDropdownTitle',
    type: 'boolean',
    value: true,
    description: 'styleTweaksScrollSubredditDropdownDesc',
    advanced: true,
    bodyClass: true
  },
  highlightTopLevel: {
    title: 'styleTweaksHighlightTopLevelTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHighlightTopLevelDesc'
  },
  highlightTopLevelColor: {
    title: 'styleTweaksHighlightTopLevelColorTitle',
    type: 'color',
    dependsOn: options => options.highlightTopLevel.value,
    description: 'styleTweaksHighlightTopLevelColorDesc',
    value: '#8b0000'
  },
  highlightTopLevelSize: {
    title: 'styleTweaksHighlightTopLevelSizeTitle',
    type: 'text',
    dependsOn: options => options.highlightTopLevel.value,
    description: 'styleTweaksHighlightTopLevelSizeDesc',
    value: '2'
  },
  floatingSideBar: {
    title: 'styleTweaksFloatingSideBarTitle',
    type: 'boolean',
    value: false,
    description: 'styleTweaksFloatingSideBarDesc',
    advanced: true,
    bodyClass: true
  },
  postTitleCapitalization: {
    title: 'styleTweaksPostTitleCapitalizationTitle',
    description: 'styleTweaksPostTitleCapitalizationDesc',
    type: 'enum',
    value: 'none',
    values: [{
      name: 'do nothing',
      value: 'none'
    }, {
      name: 'Title Case',
      value: 'title'
    }, {
      name: 'Sentence case',
      value: 'sentence'
    }, {
      name: 'lowercase',
      value: 'lowercase'
    }],
    bodyClass: true
  },
  hideDomainLink: {
    title: 'styleTweaksHideDomainLink',
    type: 'boolean',
    value: false,
    description: 'styleTweaksHideDomainLinkDesc',
    bodyClass: true
  },
  flairEmojiAsText: {
    title: 'styleTweaksFlairEmojiAsText',
    description: 'styleTweaksFlairEmojiAsTextDesc',
    type: 'enum',
    value: 'never',
    values: [{
      name: 'styleTweaksFlairEmojiAsTextNever',
      value: 'never'
    }, {
      name: 'styleTweaksFlairEmojiAsTextNoSubStyle',
      value: 'nosubstyle'
    }, {
      name: 'styleTweaksFlairEmojiAsTextAlways',
      value: 'always'
    }],
    bodyClass: true
  }
};

styleTweaks_module.beforeLoad = () => {
  if (styleTweaks_module.options.highlightTopLevel.value) {
    const highlightTopLevelColor = styleTweaks_module.options.highlightTopLevelColor.value || styleTweaks_module.options.highlightTopLevelColor.default;
    const highlightTopLevelSize = parseInt(styleTweaks_module.options.highlightTopLevelSize.value || styleTweaks_module.options.highlightTopLevelSize.default, 10);
    Object(dom["b" /* addCSS */])(`
			.nestedlisting > .comment + .clearleft {
				height: ${highlightTopLevelSize}px !important;
				margin-bottom: 5px;
				background: ${highlightTopLevelColor} !important;
			}
			.Comment.top-level {
				border-top: ${highlightTopLevelSize}px solid ${highlightTopLevelColor};
			}
		`);
  }
};
// CONCATENATED MODULE: ./lib/modules/stylesheet.js





const stylesheet_module = new Module('stylesheet');
stylesheet_module.moduleName = 'stylesheetName';
stylesheet_module.description = 'stylesheetDesc';
stylesheet_module.category = 'appearanceCategory';
stylesheet_module.exclude = ['prefs', 'account', 'stylesheet', 'subredditAbout'];
stylesheet_module.options = {
  redditThemes: {
    title: 'stylesheetRedditThemesTitle',
    description: 'stylesheetRedditThemesDesc',
    type: 'button',
    text: 'learn more',

    callback() {
      window.location.href = 'https://www.reddit.com/r/Enhancement/wiki/faq/srstyle#reddit_themes';
    }

  },
  loadStylesheets: {
    title: 'stylesheetLoadStylesheetsTitle',
    type: 'table',
    description: 'stylesheetLoadStylesheetsDesc',
    value: [],
    fields: [{
      key: 'urlOrSubreddit',
      name: 'url or subreddit',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  snippets: {
    title: 'stylesheetSnippetsTitle',
    type: 'table',
    description: 'stylesheetSnippetsDesc',
    value: [],
    fields: [{
      key: 'snippet',
      name: 'snippet',
      type: 'textarea'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  bodyClasses: {
    title: 'stylesheetBodyClassesTitle',
    type: 'table',
    description: 'stylesheetBodyClassesDesc',
    value: [],
    fields: [{
      key: 'classes',
      name: 'classes',
      type: 'text'
    }, {
      key: 'applyTo',
      name: 'applyTo',
      type: 'select',
      values: [{
        name: 'Everywhere',
        value: 'everywhere'
      }, {
        name: 'Everywhere but:',
        value: 'exclude'
      }, {
        name: 'Only on:',
        value: 'include'
      }],
      value: 'everywhere'
    }, {
      key: 'applyToSubreddits',
      name: 'applyToSubreddits',
      type: 'list',
      listType: 'subreddits'
    }, {
      key: 'customToggle',
      name: 'customToggle',
      type: 'select',

      get values() {
        return stylesheet_getToggles();
      },

      value: ''
    }]
  },
  subredditClass: {
    title: 'stylesheetSubredditClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetSubredditClassDesc'
  },
  multiredditClass: {
    title: 'stylesheetMultiredditClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetMultiredditClassDesc'
  },
  usernameClass: {
    title: 'stylesheetUsernameClassTitle',
    type: 'boolean',
    value: true,
    description: 'stylesheetUsernameClassDesc'
  },
  loggedInUserClass: {
    title: 'stylesheetLoggedInUserClassTitle',
    type: 'boolean',
    value: false,
    description: 'stylesheetLoggedInUserClassDesc'
  }
};

stylesheet_module.beforeLoad = () => {
  if (stylesheet_module.options.subredditClass.value) {
    applySubredditClass();
  }

  if (stylesheet_module.options.usernameClass.value) {
    applyUsernameClass();
  }

  if (stylesheet_module.options.multiredditClass.value) {
    applyMultiredditClass();
  }

  jquery_default()(customToggles_module).on('toggle', applyStyles);
  applyStyles();

  function applyStyles() {
    applyBodyClasses();
    loadStylesheets();
    applyCssSnippets();
  }
};

stylesheet_module.contentStart = () => {
  if (stylesheet_module.options.loggedInUserClass.value) {
    applyLoggedInUserClass();
  }
};

function applySubredditClass() {
  let name = Object(utils_location["d" /* currentSubreddit */])();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-r-${name}`);
  }
}

function applyMultiredditClass() {
  let name = Object(utils_location["c" /* currentMultireddit */])();

  if (name) {
    name = name.toLowerCase().replace(/\//g, '-');
    bodyClasses_namespaceObject.add(`res-${name}`);
  }
}

function applyUsernameClass() {
  let name = Object(utils_location["e" /* currentUserProfile */])();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-user-${name}`);
  }
}

function applyLoggedInUserClass() {
  let name = loggedInUser();

  if (name) {
    name = name.toLowerCase();
    bodyClasses_namespaceObject.add(`res-me-${name}`);
  }
}

function applyBodyClasses() {
  const addClasses = stylesheet_module.options.bodyClasses.value.filter(row => shouldApply(row[3], row[1], row[2])).map(row => (row[0] || '').split(/[\s,]/)).reduce((a, b) => a.concat(b), []);
  const removeClasses = stylesheet_module.options.bodyClasses.value.filter(row => !shouldApply(row[3], row[1], row[2])).map(row => (row[0] || '').split(/[\s,]/)).reduce((a, b) => a.concat(b), []);
  bodyClasses_namespaceObject.add(...addClasses);
  bodyClasses_namespaceObject.remove(...removeClasses);
}

const subredditNameRegexp = /^(?:\/?r\/)?([\w_]+)\/?$/;
const urlRegexp = /^(?:https?:\/\/[\w\.]+)?\/\w+/;
const sanitizeStylesheetUrls = Object(utils_array["c" /* filterMap */])(([url]) => {
  const subredditMatch = subredditNameRegexp.exec(url);

  if (subredditMatch) {
    return [`/r/${subredditMatch[1]}/stylesheet.css`];
  } else if (urlRegexp.test(url)) {
    return [url];
  }
});

function loadStylesheets() {
  const stylesheetUrls = sanitizeStylesheetUrls(stylesheet_module.options.loadStylesheets.value.filter(row => shouldApply(row[3], row[1], row[2])));
  stylesheetManager.sync(stylesheetUrls);
}

const stylesheetManager = stylesheetElementManager(url => string_namespaceObject.html`<link rel="stylesheet" href="${url}">`);

function applyCssSnippets() {
  const snippets = stylesheet_module.options.snippets.value.filter(row => shouldApply(row[3], row[1], row[2])).map(([css]) => css);
  snippetManager.sync(snippets);
}

const snippetManager = stylesheetElementManager(css => {
  const style = document.createElement('style');
  style.textContent = css;
  return style;
});

function stylesheetElementManager(generateElement) {
  const current = new Map();
  return {
    sync: function (wantedKeys) {
      const currentKeys = Array.from(current.keys());
      lodash_es_difference(wantedKeys, currentKeys).forEach(x => {
        const ele = generateElement(x);
        current.set(x, ele);
        (document.head || document.documentElement).append(ele);
      });
      lodash_es_difference(currentKeys, wantedKeys).forEach(x => {
        const ele = current.get(x);
        current.delete(x);
        if (ele) ele.remove();
      });
    }
  };
}

function shouldApply(toggle, applyTo, applyList) {
  if (toggle && !toggleActive(toggle)) return false;
  let subreddit = Object(utils_location["d" /* currentSubreddit */])();

  if (!subreddit) {
    return applyTo !== 'include';
  }

  subreddit = subreddit.toLowerCase();
  applyList = typeof applyList === 'string' ? applyList.toLowerCase().split(',') : [];

  switch (applyTo) {
    case 'exclude':
      return !(applyList.includes(subreddit) || applyList.includes('all'));

    case 'include':
      return applyList.includes(subreddit) || applyList.includes('all');

    default:
      return true;
  }
}

function stylesheet_getToggles() {
  return [{
    name: 'No toggle needed',
    value: ''
  }, ...getToggles().map(({
    key,
    text
  }) => ({
    name: text,
    value: key
  }))];
}
// CONCATENATED MODULE: ./lib/modules/submitHelper.js







const submitHelper_module = new Module('submitHelper');
submitHelper_module.moduleName = 'submitHelperName';
submitHelper_module.category = 'submissionsCategory';
submitHelper_module.description = 'submitHelperDesc';
submitHelper_module.options = {
  warnAlreadySubmitted: {
    title: 'submitHelperWarnAlreadySubmittedTitle',
    type: 'boolean',
    value: true,
    description: 'submitHelperWarnAlreadySubmittedDesc'
  },
  uncheckSendRepliesToInbox: {
    title: 'submitHelperUncheckSendRepliesToInboxTitle',
    type: 'boolean',
    value: false,
    description: 'submitHelperUncheckSendRepliesToInboxDesc'
  },
  focusFormOnLoad: {
    title: 'submitHelperFocusFormOnLoadTitle',
    type: 'boolean',
    value: true,
    description: 'submitHelperFocusFormOnLoadDesc'
  }
};
const $repostWarning = Object(once["a" /* default */])(() => jquery_default()(string_namespaceObject.html`
	<div class="spacer" style="display: none">
		<div class="roundfield info-notice">
			<a style="float: right" class="gearIcon" href="${makeUrlHash(submitHelper_module.moduleID, 'warnAlreadySubmitted')}"></a>
			<p>This link was submitted to <a class="subredditLink" href="#"></a>:<span class="time"></span><a class="seeMore" href="#" target="_blank" rel="noopener noreferer">(see more)</a></p>
		</div>
	</div>
`));
let urlField, srField;

submitHelper_module.go = () => {
  implementOptions();

  if (!Object(utils_location["n" /* isPageType */])('submit')) {
    submitHelper_registerCommandLine();
  }
};

async function implementOptions() {
  if (Object(utils_location["i" /* isAppType */])('d2x')) {
    Object(dom["r" /* waitForEvent */])(document, 'reddit.urlChanged').then(implementOptions);
  }

  if (!Object(utils_location["n" /* isPageType */])('submit')) {
    return;
  }

  if (submitHelper_module.options.warnAlreadySubmitted.value) {
    const urlFieldDiv = document.querySelector('#url-field');

    if (urlFieldDiv) {
      jquery_default()(urlFieldDiv).parent().after($repostWarning());
      urlField = urlFieldDiv.querySelector('#url');
      srField = document.querySelector('#sr-autocomplete');
      jquery_default()([srField, urlField]).on('input keydown', Object(debounce["a" /* default */])(updateRepostWarning, 300));
      jquery_default()('#suggested-reddits a, #sr-drop-down').on('click', updateRepostWarning);
      const linkButton = document.querySelector('a.link-button');
      const textButton = document.querySelector('a.text-button');

      if (linkButton && textButton) {
        linkButton.addEventListener('click', () => {
          updateRepostWarning();
        });
        textButton.addEventListener('click', () => {
          $repostWarning().hide();
        });
      }
    }
  }

  if (submitHelper_module.options.uncheckSendRepliesToInbox.value) {
    const selector = Object(utils_location["i" /* isAppType */])('d2x') ? '[aria-labelledby="send-replies"]' : '#sendreplies';
    const sendReplies = await Object(dom["o" /* waitForDescendant */])(document.documentElement, selector);

    if (sendReplies) {
      sendReplies.click();
    }
  }

  if (submitHelper_module.options.focusFormOnLoad.value) {
    if (Object(utils_location["i" /* isAppType */])('d2x')) {
      jquery_default()('textarea').filter(':visible').first().focus();
    } else {
      jquery_default()('form.submit [name=url], form.submit [name=title]').filter(':visible').first().focus();
    }
  }
}

function submitHelper_registerCommandLine() {
  function commandLineParameters(val) {
    const urlResult = /(?:\s+(\w+:\/\/.+))$/.exec(val);
    const result = /^(?:(?:\/?r\/)?(\w+))?(?:\s+(.*))?$/.exec(urlResult ? val.slice(0, val.length - urlResult[0].length) : val);
    return result ? result.slice(1).concat(urlResult ? urlResult[1] : undefined) : [];
  }

  registerCommand(/^p(?:ost)?$/, 'post [subreddit] [title] [url] - submit a post to a subreddit', (command, val) => {
    const [subreddit, title, url] = commandLineParameters(val);

    if (!subreddit) {} else if (url) {
      return `Post ${url} to /r/${subreddit}: ${title || ''}`;
    } else if (title) {
      return `Post to /r/${subreddit}: ${title}`;
    } else if (subreddit) {
      return `Post to /r/${subreddit}`;
    }
  }, (command, val) => {
    const [subreddit, title, url] = commandLineParameters(val);
    const redirect = subreddit ? string_namespaceObject.encode`/r/${subreddit}/submit?title=${title || ''}&url=${url || ''}` : '/submit';
    window.location = redirect;
  });
}

function showRepostWarning(sr, url, date) {
  $repostWarning().find('.subredditLink').attr('href', `/r/${sr}`).text(`/r/${sr}`).end().find('.seeMore').attr('href', string_namespaceObject.encode`/r/${sr}/search?restrict_sr=on&sort=relevance&q=url%3A${url}`).end().find('.time').text(` ${i18n('submitHelperTimeAgo', formatDateDiff(date))} `).end().fadeIn(300);
}

function hideRepostWarning() {
  $repostWarning().fadeOut(300);
}

async function updateRepostWarning() {
  if (!urlField.value) return;
  const stripUrlRe = /^(?:https?:\/\/)?(?:(?:www|i|m)\.)?(.+?)\/?(?:\.\w+)?(?:#[^\/]*)?$/i;
  const subreddit = srField.value;
  const match = stripUrlRe.exec(urlField.value);

  if (subreddit && match) {
    const [, userUrl] = match;

    try {
      const {
        data
      } = await ajax({
        url: string_namespaceObject.encode`/r/${subreddit}/search.json`,
        query: {
          restrict_sr: 'on',
          sort: 'relevance',
          limit: 1,
          q: `url:${userUrl}`
        },
        type: 'json'
      });

      if (data && data.children.length && data.children[0].data.url.match(stripUrlRe)[1] === userUrl) {
        showRepostWarning(subreddit, userUrl, new Date(data.children[0].data.created_utc * 1000));
      } else {
        hideRepostWarning();
      }
    } catch (e) {
      hideRepostWarning();
      throw e;
    }
  } else {
    hideRepostWarning();
  }
}
// CONCATENATED MODULE: ./lib/modules/subredditInfo.js









const subredditInfo_module = new Module('subredditInfo');
subredditInfo_module.moduleName = 'subredditInfoName';
subredditInfo_module.category = 'subredditsCategory';
subredditInfo_module.description = 'subredditInfoDesc';
subredditInfo_module.options = {
  requireDirectLink: {
    title: 'subredditInfoRequireDirectLinkTitle',
    type: 'boolean',
    value: true,
    description: 'subredditInfoRequireDirectLinkDesc'
  },
  hoverDelay: {
    title: 'subredditInfoHoverDelayTitle',
    type: 'text',
    value: '800',
    description: 'subredditInfoHoverDelayDesc',
    advanced: true
  },
  fadeDelay: {
    title: 'subredditInfoFadeDelayTitle',
    type: 'text',
    value: '200',
    description: 'subredditInfoFadeDelayDesc',
    advanced: true
  },
  fadeSpeed: {
    title: 'subredditInfoFadeSpeedTitle',
    type: 'text',
    value: '0.7',
    description: 'subredditInfoFadeSpeedDesc',
    advanced: true
  }
};

subredditInfo_module.contentStart = () => {
  const linkSelector = ['a.subreddit', 'a.search-subreddit-link', '.md a[href^="/r/"]', '.Post a[href^="/r/"]:not([href*="/comments/"])', '.Comment a[href^="/r/"]:not([href*="/comments/"])', 'a[data-click-id="subreddit"]', !subredditInfo_module.options.requireDirectLink.value && '.md a[href*="reddit.com/r/"]'].filter(x => x).join(', ');
  infocard(subredditInfo_module.moduleID).options({
    width: 450,
    openDelay: parseFloat(subredditInfo_module.options.hoverDelay.value),
    fadeDelay: parseFloat(subredditInfo_module.options.fadeDelay.value),
    fadeSpeed: parseFloat(subredditInfo_module.options.fadeSpeed.value)
  }).populateWith(showSubredditInfo).watch(linkSelector);
};

async function showSubredditInfo(card) {
  const match = utils_location["p" /* regexes */].subreddit.exec(card.getCheckedTarget().pathname);
  const [, subreddit] = match || [];
  if (!subreddit || isFakeSubreddit(subreddit)) return;
  const header = string_namespaceObject.html`<div><a href="/r/${subreddit}">/r/${subreddit}</a></div>`;
  const url = `/r/${subreddit.toLowerCase()}/about.json`;
  let jsonData;

  try {
    jsonData = await ajax({
      url,
      type: 'json',
      cacheFor: utils_time["b" /* HOUR */]
    });
  } catch (e) {
    return [null, i18n('subredditInfoErrorLoadingSubredditInfo')];
  }

  if (jsonData.kind !== 't5') {
    return [null, i18n('subredditInfoSubredditNotFound')];
  }

  if (loggedInUser()) {
    const button = createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoSubscribe'), '', () => !!jsonData.data.user_is_subscriber, state => {
      subscribeToSubreddit(jsonData.data.name, state);
      ajax.invalidate({
        url
      });
    });
    button.style.marginLeft = '12px';
    header.appendChild(button);

    if (modules_isEnabled(subredditManager_namespaceObject)) {
      getMultiCounts(jsonData.data.display_name).then(v => jquery_default()(button).after(v));
    }
  }

  const d = new Date(jsonData.data.created_utc * 1000);
  const $newBody = jquery_default()(string_namespaceObject.html`
		<div class="subredditInfoToolTip">
			<div class="subredditLabel">${i18n('subredditInfoSubredditCreated')}</div> <div class="subredditDetail">${formatDate(d)} (${formatDateDiff(d)})</div>
			<div class="subredditLabel">${i18n('subredditInfoSubscribers')}</div> <div class="subredditDetail">${formatNumber(jsonData.data.subscribers)}</div>
			<div class="subredditLabel">${i18n('subredditInfoTitle')}</div> <div class="subredditDetail">${jsonData.data.title}</div>
			<div class="subredditLabel">${i18n('subredditInfoOver18')}</div> <div class="subredditDetail">${jsonData.data.over18 ? i18n('yes') : i18n('no')}</div>
			<div class="clear"></div>
			<div id="subTooltipButtons" class="bottomButtons">
				<div class="clear"></div>
			</div>
		</div>
	`);

  if (isRunning(subredditManager_namespaceObject)) {
    $newBody.find('#subTooltipButtons').append(createShortcutToggleButton(subreddit));
  }

  if (modules_isEnabled(modules_dashboard_namespaceObject)) {
    $newBody.find('#subTooltipButtons').append(createSubredditToggleButton(subreddit));
  }

  if (modules_isEnabled(filteReddit_namespaceObject)) {
    const button = createElement_namespaceObject.fancyToggleButton(i18n('subredditInfoAddRemoveFilter'), i18n('subredditInfoFilterFromAllAndDomain'), () => listFilters.subreddits.includesString(subreddit), state => listFilters.subreddits.toggleString(subreddit, state));
    $newBody.find('#subTooltipButtons').append(button);
  }

  return [header, $newBody];
}
// CONCATENATED MODULE: ./lib/modules/subredditStyleToggle.js






const subredditStyleToggle_module = new Module('subredditStyleToggle');
subredditStyleToggle_module.moduleName = 'subredditStyleToggleName';
subredditStyleToggle_module.category = 'appearanceCategory';
subredditStyleToggle_module.description = 'subredditStyleToggleDesc';
subredditStyleToggle_module.alwaysEnabled = true;
subredditStyleToggle_module.options = {
  browserToolbarButton: {
    title: 'subredditStyleToggleBrowserToolbarButtonTitle',
    type: 'boolean',
    value: true,
    description: 'subredditStyleToggleBrowserToolbarButtonDesc',
    keywords: ['css'],
    noconfig: true
  },
  checkbox: {
    title: 'subredditStyleToggleCheckboxTitle',
    type: 'boolean',
    value: true,
    description: 'subredditStyleToggleCheckboxDesc',
    keywords: ['css']
  }
};
const ignoredStorage = storage_namespaceObject.wrap('RESmodules.subredditStyleToggle.ignored', []);
let subredditStyleToggle_toggle;
let toggleIsAvailable;
const toggleAvailablePromise = new Promise(res => {
  toggleIsAvailable = res;
});
let allowRefresh;

subredditStyleToggle_module.onInit = () => {
  pageAction_namespaceObject.hide();
  allowRefresh = Promise.all([shouldDisable(), hasToggleableElements()]).then(([disable, has]) => {
    if (has) {
      bodyClasses_namespaceObject.add('res-srstyle-enabled');
      createToggle();
      subredditStyleToggle_refresh(disable);
    }
  });
  onUpdate.push(subredditStyleToggle_refresh);
};

subredditStyleToggle_module.beforeLoad = () => {
  toggleAvailablePromise.then(makeInteractable);
};

async function subredditStyleToggle_refresh(disable) {
  await allowRefresh;
  if (!subredditStyleToggle_toggle) return;
  if (typeof disable !== 'boolean') disable = await shouldDisable();
  subredditStyleToggle_toggle.toggle('autoLocal', !disable);
}

function createToggle() {
  const subreddit = (Object(utils_location["d" /* currentSubreddit */])() || '').toLowerCase();
  if (subredditStyleToggle_toggle || !subreddit) return;
  subredditStyleToggle_toggle = new customToggles_Toggle(`${subredditStyleToggle_module.moduleID}.${subreddit}`, 'Custom subreddit style', true);
  subredditStyleToggle_toggle.onToggle(type => {
    if (type !== 'manual') return;

    allowRefresh = (async () => {
      await toggledSubredditStyle(subredditStyleToggle_toggle.enabled);
      const ignoredSubreddits = new Set(await ignoredStorage.get());

      if (subredditStyleToggle_toggle.enabled) {
        ignoredSubreddits.delete(subreddit);
      } else if (compatibleSubredditStyle) {
        ignoredSubreddits.add(subreddit);
      }

      await ignoredStorage.set(Array.from(ignoredSubreddits));
    })();
  });
  subredditStyleToggle_toggle.onStateChange(() => {
    toggleElements(subredditStyleToggle_toggle.enabled);
    bodyClasses_namespaceObject.toggle(subredditStyleToggle_toggle.enabled, 'res-srstyle-enabled');
    bodyClasses_namespaceObject.toggle(!subredditStyleToggle_toggle.enabled, 'res-srstyle-disabled');
  });
  toggleIsAvailable();
}

function makeInteractable() {
  if (subredditStyleToggle_module.options.checkbox.value) {
    pagePhases.contentStart.then(() => {
      const place = document.body.querySelector('.titlebox h1.redditname');
      if (place) insertCheckbox(place);
    });
  }

  if (subredditStyleToggle_module.options.browserToolbarButton.value) {
    pageAction_namespaceObject.show(subredditStyleToggle_toggle.enabled);
    subredditStyleToggle_toggle.onStateChange(() => {
      pageAction_namespaceObject.show(subredditStyleToggle_toggle.enabled);
    });
    pageAction_namespaceObject.onClick(() => {
      subredditStyleToggle_toggle.toggle('manual');
    });
  }

  subredditStyleToggle_toggle.addCLI('srstyle');
}

function insertCheckbox(place) {
  const container = string_namespaceObject.html`
		<form class="toggle res-sr-style-toggle">
			<label for="res-style-checkbox">${i18n('subredditStyleToggleUse')}</label>
		</form>
	`;
  const checkbox = subredditStyleToggle_toggle.buildCheckbox();
  checkbox.setAttribute('id', 'res-style-checkbox');
  checkbox.setAttribute('name', 'res-style-checkbox');
  container.prepend(checkbox);
  place.after(container);
}

const shouldDisable = () => Object(utils_array["b" /* asyncSome */])([async () => (await ignoredStorage.get()).includes((Object(utils_location["d" /* currentSubreddit */])() || '').toLowerCase()), async () => !(await compatibleSubredditStyle)], f => f());

const hasToggleableElements = () => Object(utils_array["b" /* asyncSome */])([getStylesheet, async () => !!(await getHeaderImg()).headerImg], f => f());

const getStylesheet = Object(once["a" /* default */])(async () => {
  const query = () => (document.head || document.documentElement).querySelector('link[title=applied_subreddit_stylesheet]');

  return query() || (await pagePhases.bodyStart.then(query)) || null;
});
const getHeaderImg = Object(once["a" /* default */])(async () => {
  const imgWrapper = (await pagePhases.bodyStart.then(() => document.getElementById('header-img-a'))) || (await Object(dom["n" /* waitForChild */])(document.body, '#header').then(e => Object(dom["o" /* waitForDescendant */])(e, '#header-img-a')));
  return {
    imgWrapper,
    headerImg: imgWrapper && document.getElementById('header-img')
  };
});

const toggleElements = (() => {
  const toggleStylesheet = Object(utils_async["h" /* mutex */])(async shouldRestore => {
    const subredditStylesheet = await getStylesheet();
    if (!subredditStylesheet) return;

    if (shouldRestore) {
      if (!subredditStylesheet.parentNode) {
        document.head.appendChild(subredditStylesheet);
      }
    } else {
      if (subredditStylesheet.parentNode) {
        subredditStylesheet.remove();
      }
    }
  });
  const toggleHeaderImg = Object(utils_async["h" /* mutex */])(async shouldRestore => {
    const {
      imgWrapper,
      headerImg
    } = await getHeaderImg();
    if (!imgWrapper || !headerImg) return;

    if (shouldRestore) {
      if (!headerImg.parentNode) {
        imgWrapper.id = 'header-img-a';
        imgWrapper.classList.remove('default-header');
        imgWrapper.appendChild(headerImg);
      }
    } else {
      if (headerImg.parentNode) {
        headerImg.remove();
        imgWrapper.id = 'header-img';
        imgWrapper.classList.add('default-header');
      }
    }
  });
  return shouldRestore => Promise.all([toggleStylesheet(shouldRestore), toggleHeaderImg(shouldRestore)]);
})();
// CONCATENATED MODULE: ./lib/modules/subredditTagger.js



const subredditTagger_module = new Module('subRedditTagger');
subredditTagger_module.moduleName = 'subredditTaggerName';
subredditTagger_module.category = 'subredditsCategory';
subredditTagger_module.description = 'subredditTaggerDesc';
subredditTagger_module.options = {
  subReddits: {
    title: 'subRedditTaggerSubRedditsTitle',
    type: 'table',
    addRowText: '+add tag',
    fields: [{
      key: 'subreddit',
      name: 'subreddit',
      type: 'text'
    }, {
      key: 'doesntContain',
      name: 'doesntContain',
      type: 'text'
    }, {
      key: 'tag',
      name: 'tag',
      type: 'text'
    }],
    value: [],
    description: 'subRedditTaggerSubRedditsDesc'
  }
};
const SRTDoesntContain = new Map();
const SRTTagWith = new Map();

subredditTagger_module.beforeLoad = () => {
  if (!subredditTagger_module.options.subReddits.value.length) return;

  for (const [subreddit, doesntContain, tagWith] of subredditTagger_module.options.subReddits.value) {
    SRTDoesntContain.set(subreddit.toLowerCase(), doesntContain);
    SRTTagWith.set(subreddit.toLowerCase(), tagWith);
  }

  Object(watchers["watchForThings"])(['post'], scanTitle);
};

function scanTitle(thing) {
  const tagToAdd = getTag(thing);

  if (tagToAdd !== undefined) {
    const tagText = jquery_default()('<span>').append(escapeHTML(tagToAdd)).append('&nbsp;');
    jquery_default()(thing.getTitleElement()).parent().prepend(tagText);
  }
}

function getTag(thing) {
  let hasTag = false;
  const thisSubReddit = (thing.getSubreddit() || '').toLowerCase();

  if (thisSubReddit && SRTTagWith.has(thisSubReddit)) {
    let thisString = SRTDoesntContain.get(thisSubReddit);

    if (thisString === undefined || thisString === '') {
      thisString = `[${thisSubReddit}]`;
      SRTDoesntContain.set(thisSubReddit, thisString);
    }

    hasTag = thing.getTitle().includes(thisString) || thing.getPostFlairText().includes(thisString);
  }

  if (!hasTag) {
    return SRTTagWith.get(thisSubReddit);
  }
}
// CONCATENATED MODULE: ./lib/modules/tableTools.js



const tableTools_module = new Module('tableTools');
tableTools_module.moduleName = 'tableToolsName';
tableTools_module.category = 'productivityCategory';
tableTools_module.description = 'tableToolsDesc';
tableTools_module.options = {
  sort: {
    title: 'tableToolsSortTitle',
    type: 'boolean',
    value: true,
    description: 'tableToolsSortDesc',
    bodyClass: true
  }
};

tableTools_module.contentStart = () => {
  if (tableTools_module.options.sort.value) {
    jquery_default()(document.body).on('click', '.md th, .Comment th, .Post th', table_namespaceObject.sortByColumn);
  }
};
// CONCATENATED MODULE: ./lib/modules/temporaryDropdownLinks.js



const temporaryDropdownLinks_module = new Module('temporaryDropdownLinks');
temporaryDropdownLinks_module.moduleName = 'temporaryDropdownLinksName';
temporaryDropdownLinks_module.category = 'browsingCategory';
temporaryDropdownLinks_module.description = 'temporaryDropdownLinksDesc';
temporaryDropdownLinks_module.options = {
  always: {
    type: 'boolean',
    value: false,
    description: 'temporaryDropdownLinksAlwaysDesc',
    title: 'temporaryDropdownLinksAlwaysTitle'
  }
};
temporaryDropdownLinks_module.include = [/\/(?:top|controversial)\/$/];

temporaryDropdownLinks_module.contentStart = () => {
  setupMenu();
};

function setupMenu() {
  const mutateChoice = temporaryDropdownLinks_module.options.always.value ? removeListener : appendTemporaryButton;

  for (const choice of document.querySelectorAll('.menuarea .drop-choices a.choice')) {
    const form = choice.closest('form');
    if (!form) continue;
    const {
      name,
      value
    } = Object(flow["a" /* downcast */])(form.querySelector('input'), HTMLInputElement);

    if (name && value) {
      mutateChoice(choice, name, value);
    }
  }
}

function removeListener(choice, name, value) {
  choice.search = `?${name}=${value}`;
  choice.removeAttribute('onclick');
}

function appendTemporaryButton(choice, name, value) {
  const url = new URL(choice.href);
  url.searchParams.set(name, value);
  const link = string_namespaceObject.html`
		<a class="RES-dropdown-button" href="${url.href}">${i18n('temporaryDropdownLinksTemporarily')}</a>
	`;
  link.addEventListener('click', e => e.stopPropagation());
  choice.appendChild(link);
}
// CONCATENATED MODULE: ./lib/modules/userbarHider.js






const userbarHider_module = new Module('userbarHider');
userbarHider_module.moduleName = 'userbarHiderName';
userbarHider_module.description = 'userbarHiderDesc';
userbarHider_module.category = 'myAccountCategory';
userbarHider_module.disabledByDefault = true;
userbarHider_module.options = {
  userbarState: {
    title: 'userbarHiderUserbarStateTitle',
    type: 'enum',
    values: [{
      name: 'Visible',
      value: 'visible'
    }, {
      name: 'Hidden',
      value: 'hidden'
    }],
    value: 'visible',
    description: 'userbarHiderUserbarStateDesc'
  },
  toggleButtonState: {
    title: 'userbarHiderToggleButtonStateTitle',
    type: 'enum',
    values: [{
      name: 'Visible',
      value: 'visible'
    }, {
      name: 'Hidden',
      value: 'hidden'
    }],
    value: 'visible',
    description: 'userbarHiderToggleButtonStateDesc',
    advanced: true
  }
};
let userbarHider_userbar, $userbarToggle;

userbarHider_module.contentStart = () => {
  userbarHider();
};

function userbarHider() {
  userbarHider_userbar = document.getElementById('header-bottom-right');

  if (userbarHider_userbar) {
    if (userbarHider_module.options.toggleButtonState.value === 'visible' || userbarHider_module.options.userbarState.value === 'hidden') {
      addToggleButton();
    }

    if (userbarHider_module.options.userbarState.value === 'hidden') {
      updateUserBar();
      notifications_showNotification({
        moduleID: userbarHider_module.moduleID,
        optionKey: 'userbarState',
        cooldown: 24 * 60 * 60 * 1000,
        header: i18n('userbarHiderUserBarHidden'),
        message: i18n('userbarHiderContentHiddenNotification', '«')
      });
    }
  }
}

function toggleUserBar() {
  userbarHider_module.options.userbarState.value = userbarHider_module.options.userbarState.value === 'hidden' ? 'visible' : 'hidden';
  options_save(userbarHider_module.options.userbarState);
  updateUserBar();
}

function updateUserBar() {
  const userbarHidden = userbarHider_module.options.userbarState.value === 'hidden';
  updateToggleButton(userbarHidden);
  toggleUserbarElementsDisplay(userbarHidden);
}

function addToggleButton() {
  $userbarToggle = jquery_default()('<div>', {
    id: 'userbarToggle',
    title: i18n('userbarHiderToggleUserbar'),
    click: () => toggleUserBar()
  }).prependTo(userbarHider_userbar);
  document.querySelector('#header-bottom-right').classList.add('res-userbar-toggle');
  updateToggleButton(false);
}

function updateToggleButton(userbarHidden) {
  $userbarToggle.toggleClass('userbarHide', !userbarHidden).toggleClass('userbarShow', userbarHidden).html(userbarHidden ? '&laquo;' : '&raquo;');
}

function toggleUserbarElementsDisplay(userbarHidden) {
  bodyClasses_namespaceObject.toggle(userbarHidden, 'res-hide-userbar');
}
// EXTERNAL MODULE: ./node_modules/lodash-es/_Set.js
var _Set = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/lodash-es/noop.js
var noop = __webpack_require__(86);

// EXTERNAL MODULE: ./node_modules/lodash-es/_setToArray.js
var _setToArray = __webpack_require__(62);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createSet.js
var INFINITY=1/0;var createSet=!(_Set["a" /* default */]&&1/Object(_setToArray["a" /* default */])(new _Set["a" /* default */]([,-0]))[1]==INFINITY)?noop["a" /* default */]:function(values){return new _Set["a" /* default */](values);};/* harmony default export */ var _createSet = (createSet);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseUniq.js
var _baseUniq_LARGE_ARRAY_SIZE=200;function baseUniq(array,iteratee,comparator){var index=-1,includes=_arrayIncludes["a" /* default */],length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=_arrayIncludesWith;}else if(length>=_baseUniq_LARGE_ARRAY_SIZE){var set=iteratee?null:_createSet(array);if(set){return Object(_setToArray["a" /* default */])(set);}isCommon=false;includes=_cacheHas["a" /* default */];seen=new _SetCache["a" /* default */]();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/* harmony default export */ var _baseUniq = (baseUniq);
// CONCATENATED MODULE: ./node_modules/lodash-es/uniqBy.js
function uniqBy(array,iteratee){return array&&array.length?_baseUniq(array,Object(_baseIteratee["a" /* default */])(iteratee,2)):[];}/* harmony default export */ var lodash_es_uniqBy = (uniqBy);
// CONCATENATED MODULE: ./lib/modules/version.js






const version_module = new Module('version');
version_module.moduleName = 'versionName';
version_module.category = 'aboutCategory';
version_module.description = 'versionDesc';
version_module.alwaysEnabled = true;
version_module.hidden = true;
const concurrentInstallWiki = '/r/Enhancement/wiki/tutorials/concurrent_installs';

version_module.beforeLoad = () => {
  addVersionClasses();
};

version_module.go = () => {
  reportVersion();
};

version_module.afterLoad = () => {
  avoidConcurrentInstalls();
};

function addVersionClasses() {
  bodyClasses_namespaceObject.add('res');
  const versionComponents = metadata_version.split('.');

  for (const i of Object(generator["a" /* range */])(0, versionComponents.length)) {
    bodyClasses_namespaceObject.add(`res-v${versionComponents.slice(0, i + 1).join('-')}`);
  }
}

function reportVersion() {
  jquery_default()('<div>', {
    id: 'RESConsoleVersion',
    style: 'display: none;',
    text: metadata_version,
    'data-id': getExtensionId()
  }).appendTo(document.body);
}

function avoidConcurrentInstalls() {
  const installs = Array.from(document.querySelectorAll('#RESConsoleVersion'));
  const concurrentInstalls = lodash_es_uniqBy(installs, e => e.getAttribute('data-id') || Math.random()).map(e => e.textContent);

  if (concurrentInstalls.length > 1) {
    bodyClasses_namespaceObject.add('res-concurrent-installs');
    document.body.appendChild(string_namespaceObject.html`
			<div id="res-concurrent-installs">
				<p>You have enabled multiple versions of Reddit Enhancement Suite:</p>
				<ul>
					${concurrentInstalls.map(v => string_namespaceObject._html`
						<li>${v}</li>
					`)}
				</ul>
				<p>You should enable only one. <a href="${concurrentInstallWiki}">Find out how!</a>
			</div>
		`);
  }
}
// CONCATENATED MODULE: ./lib/modules/voteEnhancements.js



const voteEnhancements_module = new Module('voteEnhancements');
voteEnhancements_module.moduleName = 'voteEnhancementsName';
voteEnhancements_module.category = 'appearanceCategory';
voteEnhancements_module.description = 'voteEnhancementsDesc';
voteEnhancements_module.options = {
  highlightScores: {
    title: 'voteEnhancementsHighlightScoresTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsHighlightScoresDesc',
    bodyClass: true
  },
  colorLinkScore: {
    title: 'voteEnhancementsColorLinkScoreTitle',
    type: 'enum',
    values: [{
      name: 'No coloration',
      value: 'none'
    }, {
      name: 'Automatic coloration',
      value: 'automatic'
    }, {
      name: 'User-defined coloration',
      value: 'user'
    }],
    value: 'none',
    description: 'voteEnhancementsColorLinkScoreDesc',
    bodyClass: true
  },
  userDefinedLinkColoration: {
    title: 'voteEnhancementsUserDefinedLinkColorationTitle',
    dependsOn: options => options.colorLinkScore.value === 'user',
    type: 'table',
    addRowText: '+add threshold',
    fields: [{
      key: 'score',
      name: 'score',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'color'
    }],
    value: [[0, '#5f99cf'], [10, '#f2b035'], [50, '#ff4500'], [100, '#d92b2b']],
    description: 'voteEnhancementsUserDefinedLinkColorationDesc',

    sort([a], [b]) {
      return a - b || String(a).localeCompare(b, undefined, {
        numeric: true
      });
    }

  },
  colorCommentScore: {
    title: 'voteEnhancementsColorCommentScoreTitle',
    type: 'enum',
    values: [{
      name: 'No coloration',
      value: 'none'
    }, {
      name: 'Automatic coloration',
      value: 'automatic'
    }, {
      name: 'Reddit Classic',
      value: 'simple'
    }, {
      name: 'User-defined coloration',
      value: 'user'
    }],
    value: 'none',
    description: 'voteEnhancementsColorCommentScoreDesc'
  },
  userDefinedCommentColoration: {
    title: 'voteEnhancementsUserDefinedCommentColorationTitle',
    dependsOn: options => options.colorCommentScore.value === 'user',
    type: 'table',
    addRowText: '+add threshold',
    fields: [{
      key: 'score',
      name: 'score',
      type: 'text'
    }, {
      key: 'color',
      name: 'color',
      type: 'color'
    }],
    value: [[0, '#5f99cf'], [10, '#f2b035'], [50, '#ff4500'], [100, '#d92b2b']],
    description: 'voteEnhancementsUserDefinedCommentColorationDesc',

    sort([a], [b]) {
      return a - b || String(a).localeCompare(b, undefined, {
        numeric: true
      });
    }

  },
  interpolateScoreColor: {
    title: 'voteEnhancementsInterpolateScoreColorTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsInterpolateScoreColorDesc',
    advanced: true
  },
  highlightControversial: {
    title: 'voteEnhancementsHighlightControversialTitle',
    type: 'boolean',
    value: true,
    description: 'voteEnhancementsHighlightControversialDesc'
  },
  highlightControversialColor: {
    title: 'voteEnhancementsHighlightControversialColorTitle',
    dependsOn: options => options.highlightControversial.value,
    advanced: true,
    type: 'color',
    value: '#cc0000',
    description: 'voteEnhancementsHighlightControversialColorDesc'
  }
};
voteEnhancements_module.include = ['comments', 'commentsLinklist', 'linklist', 'modqueue', 'profile', 'inbox'];

voteEnhancements_module.beforeLoad = () => {
  if (voteEnhancements_module.options.colorLinkScore.value !== 'none') {
    Object(watchers["watchForThings"])(['post'], applyLinkScoreColor);
  }

  if (voteEnhancements_module.options.colorCommentScore.value !== 'none') {
    Object(watchers["watchForThings"])(['comment'], applyCommentScoreColor);
  }

  if (voteEnhancements_module.options.highlightControversial.value) {
    highlightControversial();
  }
};

function interpolateScoreColor(score, colors, defaultColor) {
  if (!colors.length) return defaultColor;
  const augmented = [[-Infinity, colors[0][1]], ...colors, [Infinity, colors.slice(-1)[0][1]]];

  for (const [[lowBound, lowColor], [highBound, highColor]] of Object(generator["b" /* zip */])(augmented.slice(0, -1), augmented.slice(1))) {
    if (score >= lowBound && score < highBound) {
      if (voteEnhancements_module.options.interpolateScoreColor.value) {
        return colorFromArray(lodash_es_zipWith(colorToArray(lowColor), colorToArray(highColor), (lowVal, highVal) => Math.round(projectInto(lowBound, highBound, lowVal, highVal, score))));
      } else {
        return score < 0 ? highColor : lowColor;
      }
    }
  }

  return defaultColor;
}

function getLinkScoreColor(score) {
  if (voteEnhancements_module.options.colorLinkScore.value === 'automatic') {
    return `hsl(${180 + 360 * (1 - 100 / (150 + score))}, 75%,50%)`;
  } else {
    return interpolateScoreColor(score, voteEnhancements_module.options.userDefinedLinkColoration.value, '#c6c6c6');
  }
}

function getCommentScoreColor(score) {
  if (voteEnhancements_module.options.colorCommentScore.value === 'automatic') {
    return `hsl(${180 + 360 * (1 - 50 / (100 + score))}, 75%,50%)`;
  } else {
    let colors;

    if (voteEnhancements_module.options.colorCommentScore.value === 'user') {
      colors = voteEnhancements_module.options.userDefinedCommentColoration.value;
    } else if (voteEnhancements_module.options.colorCommentScore.value === 'simple') {
      colors = [[0, '#9494ff'], [1, '#888'], [2, '#ff8b60']];
    } else {
      return false;
    }

    return interpolateScoreColor(score, colors, '#888');
  }
}

function applyLinkScoreColor(thing) {
  const score = thing.getScore();
  const rankEle = thing.getRankElement();
  const color = typeof score === 'number' && getLinkScoreColor(score);

  if (rankEle && color) {
    rankEle.style.background = color;
  }
}

function applyCommentScoreColor(thing) {
  for (const [scoreEle, score] of thing.getAllScoreElements()) {
    const color = getCommentScoreColor(score);

    if (color) {
      scoreEle.style.color = color;
    }
  }
}

function highlightControversial() {
  const color = voteEnhancements_module.options.highlightControversialColor.value || voteEnhancements_module.options.highlightControversialColor.default;
  Object(dom["b" /* addCSS */])(`
		.comment.controversial > .entry .score::after {
			color: ${color};
		}
	`);
}
// CONCATENATED MODULE: ./lib/modules/xPostLinks.js




const xPostLinks_module = new Module('xPostLinks');
xPostLinks_module.moduleName = 'xPostLinksName';
xPostLinks_module.category = 'submissionsCategory';
xPostLinks_module.description = 'xPostLinksDesc';
xPostLinks_module.include = ['linklist', 'modqueue', 'comments', 'profile', 'search'];
xPostLinks_module.exclude = ['d2x'];

xPostLinks_module.beforeLoad = () => {
  Object(watchers["watchForThings"])(['post'], createLinks);
};

const xpostRe = /(?:x|cross)[\s-]?post\S*(.+)/i;
const xpostFromRe = /^(?:\s+\S+)?\s+\/?(\w{2,20}\b)(?:[\)\]}]|\S*$)/i;
const subredditRe = /r\/(\w{2,20}\b)/i;

function parseSubreddit(title) {
  const [, xpostString] = xpostRe.exec(title) || [];
  if (!xpostString) return false;
  const [, sub] = subredditRe.exec(xpostString) || xpostFromRe.exec(xpostString) || [];
  return sub;
}

function appendToTagline(sub, thing) {
  jquery_default()().add(jquery_default()(thing.getSubredditLink()).prev()).add(thing.getUserattrsElement() || '').first().after(string_namespaceObject.escape` ${i18n('xPostLinksXpostedFrom')} `, jquery_default()('<a>', {
    class: 'subreddit hover',
    href: `/r/${sub}`,
    text: `/r/${sub}`
  }));
}

function createLinks(thing) {
  const sub = parseSubreddit(thing.getTitle());
  if (sub) appendToTagline(sub, thing);
}
// CONCATENATED MODULE: ./node_modules/sibling-loader?import=module!./lib/modules/about.js
/* generated by sibling-loader */


















































































/* harmony default export */ var about = ({ "RESTips.js": RESTips_module, "about.js": about_module, "accountSwitcher.js": accountSwitcher_module, "announcements.js": announcements_module, "autoHide.js": autoHide_module, "backupAndRestore.js": backupAndRestore_module, "betteReddit.js": betteReddit_module, "commandLine.js": commandLine_module, "commentDepth.js": commentDepth_module, "commentHidePersistor.js": commentHidePersistor_module, "commentNavigator.js": commentNavigator_module, "commentPreview.js": commentPreview_module, "commentQuickCollapse.js": commentQuickCollapse_module, "commentSortBy.js": commentSortBy_module, "commentStyle.js": commentStyle_module, "commentTools.js": commentTools_module, "context.js": context_module, "contribute.js": contribute_module, "customToggles.js": customToggles_module, "dashboard.js": dashboard_module, "disableChat.js": disableChat_module, "easterEgg.js": easterEgg_module, "filteReddit.js": filteReddit_module, "hideChildComments.js": hideChildComments_module, "hover.js": hover_module, "keyboardNav.js": keyboardNav_module, "localDate.js": localDate_module, "logoLink.js": logoLink_module, "menu.js": menu_module, "messageMenu.js": messageMenu_module, "modhelper.js": modhelper_module, "multiredditNavbar.js": multiredditNavbar_module, "neverEndingComments.js": neverEndingComments_module, "neverEndingReddit.js": neverEndingReddit_module, "newCommentCount.js": newCommentCount_module, "nightMode.js": nightMode_module, "noParticipation.js": noParticipation_module, "notifications.js": notifications_module, "onboarding.js": onboarding_module, "orangered.js": orangered_module, "pageNavigator.js": pageNavigator_module, "penaltyBox.js": penaltyBox_module, "presets.js": presets_module, "profileNavigator.js": profileNavigator_module, "profileRedirect.js": profileRedirect_module, "quarantineHide.js": quarantineHide_module, "quickMessage.js": quickMessage_module, "readComments.js": readComments_module, "redditUserInfo.js": redditUserInfo_module, "requestPermissions.js": requestPermissions_module, "saveComments.js": saveComments_module, "search.js": search_module, "searchHelper.js": searchHelper_module, "selectedEntry.js": selectedEntry_module, "settingsNavigation.js": settingsNavigation_module, "showImages.js": showImages_module, "showKarma.js": showKarma_module, "showParent.js": showParent_module, "singleClick.js": singleClick_module, "sourceSnudown.js": sourceSnudown_module, "spamButton.js": spamButton_module, "spoilerTags.js": spoilerTags_module, "styleTweaks.js": styleTweaks_module, "stylesheet.js": stylesheet_module, "submitHelper.js": submitHelper_module, "submitIssue.js": submitIssue_module, "subredditInfo.js": subredditInfo_module, "subredditManager.js": subredditManager_module, "subredditStyleToggle.js": subredditStyleToggle_module, "subredditTagger.js": subredditTagger_module, "tableTools.js": tableTools_module, "temporaryDropdownLinks.js": temporaryDropdownLinks_module, "troubleshooter.js": troubleshooter_module, "userHighlight.js": userHighlight_module, "userInfo.js": userInfo_module, "userTagger.js": userTagger_module, "userbarHider.js": userbarHider_module, "usernameHider.js": usernameHider_module, "version.js": version_module, "voteEnhancements.js": voteEnhancements_module, "wheelBrowse.js": wheelBrowse_module, "xPostLinks.js": xPostLinks_module });
// CONCATENATED MODULE: ./lib/core/modules/modules.js





const modules_enabled = new Map();
const modules = new Map(Array.from(Object.values(about)).map(module => [module.moduleID, Object(flow["a" /* downcast */])(module, Module)]));
const allowedModules = [];
async function _loadModulePrefs() {
  const storedPrefs = await storage_storage.getAll();

  for (const [id, module] of modules) {
    if (module.alwaysEnabled) {
      modules_enabled.set(id, true);
    } else if (storedPrefs.hasOwnProperty(id)) {
      modules_enabled.set(id, storedPrefs[id]);
    } else {
      modules_enabled.set(id, !module.disabledByDefault);
    }
  }
}
const ERRORED_KEY = Symbol('errored');
async function _runModuleStage(stage, {
  skipEnabledCheck = false
} = {}) {
  await Promise.all(modules_all().filter(module => module[stage] && !module[ERRORED_KEY] && (skipEnabledCheck || isRunning(module))).map(async module => {
    const tag = markStart();

    try {
      const fn = module[stage];
      await fn();
    } catch (e) {
      module[ERRORED_KEY] = true;
      console.error('Error in module:', module.moduleID, 'during:', stage);
      console.error(e);
    }

    markEnd(tag, `${module.moduleID} (${stage})`);
  }));
}
function modules_all() {
  return Array.from(modules.values());
}
function modules_isEnabled(opaqueId) {
  return !!modules_enabled.get(modules_get(opaqueId).moduleID);
}
function isRunning(opaqueId) {
  const module = modules_get(opaqueId);
  return (!allowedModules.length || allowedModules.includes(module.moduleID)) && modules_isEnabled(module) && Object(utils_location["o" /* matchesPageLocation */])(module.include, module.exclude) && module.shouldRun();
}
function modules_get(opaqueId) {
  return modules_modules_get(getModuleId(opaqueId));
}

function modules_modules_get(id) {
  const mod = getUnchecked(id);
  if (!mod) throw new Error(`Module "${id}" not found.`);
  return mod;
}

function getUnchecked(id) {
  return modules.get(id);
}
function getByCategory(category) {
  return modules_all().filter(module => !module.hidden).filter(module => module.category === category).sort((a, b) => {
    const sortComparison = (a.sort || 0) - (b.sort || 0);

    if (sortComparison !== 0) {
      return sortComparison;
    }

    return i18n(a.moduleName).toLowerCase() > i18n(b.moduleName).toLowerCase() ? 1 : -1;
  });
}
// CONCATENATED MODULE: ./lib/core/modules/index.js


// CONCATENATED MODULE: ./lib/core/options/options.js





function _loadModuleOptions() {
  const shouldPrunePromise = shouldPrune('RESoptions');
  return Promise.all(modules_all().map(async module => {
    if (!Object.values(module.options).some(v => v.hasOwnProperty('value'))) return;
    const storedOptions = await options_storage_storage.get(module.moduleID);

    for (const opt of Object.values(module.options)) {
      opt.default = opt.value;
    }

    if (!storedOptions) {
      return;
    }

    for (const [key, storedValue] of Object.entries(storedOptions)) {
      if (!storedValue) continue;

      if (storedValue.value === undefined) {
        console.error(`Option ${module.moduleID} ${key}'s value is \`undefined\`. Ignoring.`);
        continue;
      }

      if (!module.options[key]) continue;
      module.options[key].value = storedValue.value;
    }

    shouldPrunePromise.then(should => {
      if (should) prune(module, storedOptions);
    });
  }));
}

function prune(module, storedOptions) {
  if (!storedOptions || !Object.entries(storedOptions).length) {
    options_storage_storage.delete(module.moduleID);
    return;
  }

  for (const [key, {
    value
  }] of Object.entries(storedOptions)) {
    const option = module.options[key];

    if (!module.options[key]) {
      console.warn('Could not find option', module.moduleID, key);
      options_storage_storage.deletePath(module.moduleID, key);
      continue;
    }

    if (lodash_es_isEqual(option.default, value)) {
      console.warn('Stored option', module.moduleID, key, 'has the default value. Deleting.');
      options_storage_storage.deletePath(module.moduleID, key);
      continue;
    }
  }
}

const options_modifiedOptions = new Set();
const notifyModified = multicast(Object(utils_async["a" /* batch */])(keys => {
  for (const key of keys) options_modifiedOptions.add(key);
}, {
  size: Infinity
}), {
  name: 'modifiedOptions',
  local: false
});
function options_save(option) {
  for (const module of modules_all()) {
    for (const [key, _option] of Object.entries(module.options)) {
      if (option === _option) {
        if (option.value === undefined) {
          throw new Error('Option type can not be saved');
        }

        if (option.type === 'list' || option.type === 'builder' || option.type === 'table') {
          const id = `${module.moduleID}-${key}`;

          if (options_modifiedOptions.has(id)) {
            console.warn('Overwriting option', module.moduleID, key, 'saved in another tab');
          }

          notifyModified(id);
        }

        if (option.onChange) {
          option.onChange();
        }

        return options_storage_set(module.moduleID, key, option.value);
      }
    }
  }

  throw new Error('Option not found in module');
}
// CONCATENATED MODULE: ./lib/core/modules/bodyClasses.js


function _addModuleBodyClasses() {
  for (const module of modules_all()) {
    if (!isRunning(module)) continue;
    if (module.bodyClass) bodyClasses_namespaceObject.add(`res-${module.moduleID}`);

    for (const [optId, opt] of Object.entries(module.options)) {
      if (!(opt.bodyClass && opt.value)) continue;
      if (opt.dependsOn && !opt.dependsOn(module.options)) continue;
      let cls = typeof opt.bodyClass === 'string' ? opt.bodyClass : `res-${module.moduleID}-${optId}`;

      if (opt.type === 'enum') {
        cls += `-${opt.value.replace(/\s/g, '_')}`;
      }

      bodyClasses_namespaceObject.add(cls);
    }
  }
}
// CONCATENATED MODULE: ./lib/core/init.js







let _init;

function init() {
  _init();
}
const init_start = new Promise(resolve => {
  _init = resolve;
});
const loadI18n = init_start.then(() => _loadI18n());
const onInit = init_start.then(() => _runModuleStage('onInit', {
  skipEnabledCheck: true
}));
const loadOptions = onInit.then(() => Promise.all([_loadModuleOptions(), _loadModulePrefs()]));
const addModuleBodyClasses = loadOptions.then(() => _addModuleBodyClasses());
const always = Promise.all([loadI18n, loadOptions]).then(() => _runModuleStage('always', {
  skipEnabledCheck: true
}));
const beforeLoad = Promise.all([loadI18n, loadOptions]).then(() => _runModuleStage('beforeLoad'));
const contentStart = Promise.all([beforeLoad, pagePhases.contentStart]).then(() => Promise.all([_runModuleStage('contentStart'), Object(utils_location["i" /* isAppType */])('r2') ? Object(watchers["r2WatcherContentStart"])() : undefined]));
const go = Promise.all([beforeLoad, pagePhases.contentStart]).then(() => {
  const run = Object(once["a" /* default */])(() => Promise.all([Object(utils_location["i" /* isAppType */])('d2x') ? initD2xWatcher() : Object(watchers["r2WatcherContentLoaded"])(), _runModuleStage('go')]));
  window.addEventListener('DOMContentLoaded', run, true);
  return pagePhases.contentLoaded.then(run);
});
const afterLoad = Promise.all([go, pagePhases.loadComplete]).then(() => _runModuleStage('afterLoad'));
Promise.all([onInit, pagePhases.bodyStart]).then(bodyClasses_namespaceObject.addMissing);
// CONCATENATED MODULE: ./node_modules/sibling-loader!./lib/environment/foreground/messaging.js
/* generated by sibling-loader */

















/* harmony default export */ var messaging = ({ "ajax.js": ajax_namespaceObject, "auth.js": auth_namespaceObject, "context.js": context_namespaceObject, "download.js": download_namespaceObject, "history.js": history_namespaceObject, "i18n.js": i18n_namespaceObject, "id.js": id_namespaceObject, "loadScript.js": loadScript_namespaceObject, "messaging.js": foreground_messaging_namespaceObject, "multicast.js": multicast_namespaceObject, "pageAction.js": pageAction_namespaceObject, "permissions.js": permissions_namespaceObject, "privateBrowsing.js": privateBrowsing_namespaceObject, "session.js": session_namespaceObject, "storage.js": storage_namespaceObject, "tabs.js": tabs_namespaceObject, "xhrCache.js": xhrCache_namespaceObject });
// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--5-0!./lib/foreground.entry.js





const blockers = [];

if (location.hash === RES_DISABLED_HASH) {
  blockers.push(`Hash ${RES_DISABLED_HASH} disables RES.`);
} else {
  window.addEventListener('hashchange', () => {
    if (location.hash === RES_DISABLED_HASH) location.reload();
  });
}

if (location.hash.startsWith(RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH)) {
  location.href = getURL(`options.html${location.hash.replace(RES_SETTINGS_REDIRECT_TO_STANDALONE_HASH, RES_SETTINGS_HASH)}`);
  blockers.push('Redirecting to the options page.');
}

if (document.documentElement && document.documentElement.classList.contains('res')) {
  document.documentElement.setAttribute('res-warning', 'This page must be reloaded for Reddit Enhancement Suite to function correctly');
  blockers.push('RES is previously loaded on this page.');
}

if (window !== window.parent && new URL(location.href).searchParams.get('embedded') !== 'true') {
  blockers.push('Conditions for running on an embedded page are not met.');
}

if (blockers.length) {
  console.warn('Preventing initalization of RES:', blockers);
} else {
  init();
}

/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/identity.js
var identity = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/lodash-es/_WeakMap.js
var _WeakMap = __webpack_require__(56);

// CONCATENATED MODULE: ./node_modules/lodash-es/_metaMap.js
var metaMap=_WeakMap["a" /* default */]&&new _WeakMap["a" /* default */]();/* harmony default export */ var _metaMap = (metaMap);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSetData.js
var baseSetData=!_metaMap?identity["a" /* default */]:function(func,data){_metaMap.set(func,data);return func;};/* harmony default export */ var _baseSetData = (baseSetData);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseCreate.js
var _baseCreate = __webpack_require__(33);

// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js
var isObject = __webpack_require__(7);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createCtor.js
function createCtor(Ctor){return function(){var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=Object(_baseCreate["a" /* default */])(Ctor.prototype),result=Ctor.apply(thisBinding,args);return Object(isObject["a" /* default */])(result)?result:thisBinding;};}/* harmony default export */ var _createCtor = (createCtor);
// EXTERNAL MODULE: ./node_modules/lodash-es/_root.js
var _root = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG=1;function createBind(func,bitmask,thisArg){var Ctor=_createCtor(func);function wrapper(){var fn=this&&this!==_root["a" /* default */]&&this instanceof wrapper?Ctor:func;return fn.apply(bitmask&WRAP_BIND_FLAG?thisArg:this,arguments);}return wrapper;}/* harmony default export */ var _createBind = (createBind);
// EXTERNAL MODULE: ./node_modules/lodash-es/_apply.js
var _apply = __webpack_require__(41);

// CONCATENATED MODULE: ./node_modules/lodash-es/_composeArgs.js
var nativeMax=Math.max;function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength);while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(!isCurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/* harmony default export */ var _composeArgs = (composeArgs);
// CONCATENATED MODULE: ./node_modules/lodash-es/_composeArgsRight.js
var _composeArgsRight_nativeMax=Math.max;function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=_composeArgsRight_nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength);while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(!isCurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/* harmony default export */ var _composeArgsRight = (composeArgsRight);
// CONCATENATED MODULE: ./node_modules/lodash-es/_countHolders.js
function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/* harmony default export */ var _countHolders = (countHolders);
// CONCATENATED MODULE: ./node_modules/lodash-es/_baseLodash.js
function baseLodash(){}/* harmony default export */ var _baseLodash = (baseLodash);
// CONCATENATED MODULE: ./node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH=4294967295;function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}LazyWrapper.prototype=Object(_baseCreate["a" /* default */])(_baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/* harmony default export */ var _LazyWrapper = (LazyWrapper);
// EXTERNAL MODULE: ./node_modules/lodash-es/noop.js
var noop = __webpack_require__(86);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getData.js
var getData=!_metaMap?noop["a" /* default */]:function(func){return _metaMap.get(func);};/* harmony default export */ var _getData = (getData);
// CONCATENATED MODULE: ./node_modules/lodash-es/_realNames.js
var realNames={};/* harmony default export */ var _realNames = (realNames);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getFuncName.js
var objectProto=Object.prototype;var _getFuncName_hasOwnProperty=objectProto.hasOwnProperty;function getFuncName(func){var result=func.name+'',array=_realNames[result],length=_getFuncName_hasOwnProperty.call(_realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/* harmony default export */ var _getFuncName = (getFuncName);
// CONCATENATED MODULE: ./node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}LodashWrapper.prototype=Object(_baseCreate["a" /* default */])(_baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/* harmony default export */ var _LodashWrapper = (LodashWrapper);
// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js
var isArray = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/lodash-es/isObjectLike.js
var isObjectLike = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/lodash-es/_copyArray.js
var _copyArray = __webpack_require__(43);

// CONCATENATED MODULE: ./node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper){if(wrapper instanceof _LazyWrapper){return wrapper.clone();}var result=new _LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=Object(_copyArray["a" /* default */])(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/* harmony default export */ var _wrapperClone = (wrapperClone);
// CONCATENATED MODULE: ./node_modules/lodash-es/wrapperLodash.js
var wrapperLodash_objectProto=Object.prototype;var wrapperLodash_hasOwnProperty=wrapperLodash_objectProto.hasOwnProperty;function lodash(value){if(Object(isObjectLike["a" /* default */])(value)&&!Object(isArray["a" /* default */])(value)&&!(value instanceof _LazyWrapper)){if(value instanceof _LodashWrapper){return value;}if(wrapperLodash_hasOwnProperty.call(value,'__wrapped__')){return _wrapperClone(value);}}return new _LodashWrapper(value);}lodash.prototype=_baseLodash.prototype;lodash.prototype.constructor=lodash;/* harmony default export */ var wrapperLodash = (lodash);
// CONCATENATED MODULE: ./node_modules/lodash-es/_isLaziable.js
function isLaziable(func){var funcName=_getFuncName(func),other=wrapperLodash[funcName];if(typeof other!='function'||!(funcName in _LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=_getData(other);return!!data&&func===data[0];}/* harmony default export */ var _isLaziable = (isLaziable);
// EXTERNAL MODULE: ./node_modules/lodash-es/_shortOut.js
var _shortOut = __webpack_require__(77);

// CONCATENATED MODULE: ./node_modules/lodash-es/_setData.js
var setData=Object(_shortOut["a" /* default */])(_baseSetData);/* harmony default export */ var _setData = (setData);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/* harmony default export */ var _getWrapDetails = (getWrapDetails);
// CONCATENATED MODULE: ./node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/* harmony default export */ var _insertWrapDetails = (insertWrapDetails);
// EXTERNAL MODULE: ./node_modules/lodash-es/_setToString.js + 2 modules
var _setToString = __webpack_require__(68);

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayEach.js
var _arrayEach = __webpack_require__(64);

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayIncludes.js
var _arrayIncludes = __webpack_require__(44);

// CONCATENATED MODULE: ./node_modules/lodash-es/_updateWrapDetails.js
var _updateWrapDetails_WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',_updateWrapDetails_WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];function updateWrapDetails(details,bitmask){Object(_arrayEach["a" /* default */])(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!Object(_arrayIncludes["a" /* default */])(details,value)){details.push(value);}});return details.sort();}/* harmony default export */ var _updateWrapDetails = (updateWrapDetails);
// CONCATENATED MODULE: ./node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return Object(_setToString["a" /* default */])(wrapper,_insertWrapDetails(source,_updateWrapDetails(_getWrapDetails(source),bitmask)));}/* harmony default export */ var _setWrapToString = (setWrapToString);
// CONCATENATED MODULE: ./node_modules/lodash-es/_createRecurry.js
var _createRecurry_WRAP_BIND_FLAG=1,_createRecurry_WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,_createRecurry_WRAP_CURRY_FLAG=8,_createRecurry_WRAP_PARTIAL_FLAG=32,_createRecurry_WRAP_PARTIAL_RIGHT_FLAG=64;function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&_createRecurry_WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?_createRecurry_WRAP_PARTIAL_FLAG:_createRecurry_WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?_createRecurry_WRAP_PARTIAL_RIGHT_FLAG:_createRecurry_WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(_createRecurry_WRAP_BIND_FLAG|_createRecurry_WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(_isLaziable(func)){_setData(result,newData);}result.placeholder=placeholder;return _setWrapToString(result,func,bitmask);}/* harmony default export */ var _createRecurry = (createRecurry);
// CONCATENATED MODULE: ./node_modules/lodash-es/_getHolder.js
function getHolder(func){return func.placeholder;}/* harmony default export */ var _getHolder = (getHolder);
// EXTERNAL MODULE: ./node_modules/lodash-es/_isIndex.js
var _isIndex = __webpack_require__(21);

// CONCATENATED MODULE: ./node_modules/lodash-es/_reorder.js
var nativeMin=Math.min;function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=Object(_copyArray["a" /* default */])(array);while(length--){var index=indexes[length];array[length]=Object(_isIndex["a" /* default */])(index,arrLength)?oldArray[index]:undefined;}return array;}/* harmony default export */ var _reorder = (reorder);
// CONCATENATED MODULE: ./node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER='__lodash_placeholder__';function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/* harmony default export */ var _replaceHolders = (replaceHolders);
// CONCATENATED MODULE: ./node_modules/lodash-es/_createHybrid.js
var _createHybrid_WRAP_BIND_FLAG=1,_createHybrid_WRAP_BIND_KEY_FLAG=2,_createHybrid_WRAP_CURRY_FLAG=8,_createHybrid_WRAP_CURRY_RIGHT_FLAG=16,_createHybrid_WRAP_ARY_FLAG=128,_createHybrid_WRAP_FLIP_FLAG=512;function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isBindKey=bitmask&_createHybrid_WRAP_BIND_KEY_FLAG,isCurried=bitmask&(_createHybrid_WRAP_CURRY_FLAG|_createHybrid_WRAP_CURRY_RIGHT_FLAG),Ctor=isBindKey?undefined:_createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=_getHolder(wrapper),holdersCount=_countHolders(args,placeholder);}if(partials){args=_composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=_composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=_replaceHolders(args,placeholder);return _createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=bitmask&_createHybrid_WRAP_BIND_FLAG?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=_reorder(args,argPos);}else if(bitmask&_createHybrid_WRAP_FLIP_FLAG&&length>1){args.reverse();}if(bitmask&_createHybrid_WRAP_ARY_FLAG&&ary<length){args.length=ary;}if(this&&this!==_root["a" /* default */]&&this instanceof wrapper){fn=Ctor||_createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/* harmony default export */ var _createHybrid = (createHybrid);
// CONCATENATED MODULE: ./node_modules/lodash-es/_createCurry.js
function createCurry(func,bitmask,arity){var Ctor=_createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=_getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:_replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return _createRecurry(func,bitmask,_createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==_root["a" /* default */]&&this instanceof wrapper?Ctor:func;return Object(_apply["a" /* default */])(fn,this,args);}return wrapper;}/* harmony default export */ var _createCurry = (createCurry);
// CONCATENATED MODULE: ./node_modules/lodash-es/_createPartial.js
var _createPartial_WRAP_BIND_FLAG=1;function createPartial(func,bitmask,thisArg,partials){var Ctor=_createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==_root["a" /* default */]&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return Object(_apply["a" /* default */])(fn,bitmask&_createPartial_WRAP_BIND_FLAG?thisArg:this,args);}return wrapper;}/* harmony default export */ var _createPartial = (createPartial);
// CONCATENATED MODULE: ./node_modules/lodash-es/_mergeData.js
var _mergeData_PLACEHOLDER='__lodash_placeholder__';var _mergeData_WRAP_BIND_FLAG=1,_mergeData_WRAP_BIND_KEY_FLAG=2,_mergeData_WRAP_CURRY_BOUND_FLAG=4,_mergeData_WRAP_CURRY_FLAG=8,_mergeData_WRAP_ARY_FLAG=128,_mergeData_WRAP_REARG_FLAG=256;var _mergeData_nativeMin=Math.min;function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(_mergeData_WRAP_BIND_FLAG|_mergeData_WRAP_BIND_KEY_FLAG|_mergeData_WRAP_ARY_FLAG);var isCombo=srcBitmask==_mergeData_WRAP_ARY_FLAG&&bitmask==_mergeData_WRAP_CURRY_FLAG||srcBitmask==_mergeData_WRAP_ARY_FLAG&&bitmask==_mergeData_WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(_mergeData_WRAP_ARY_FLAG|_mergeData_WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==_mergeData_WRAP_CURRY_FLAG;if(!(isCommon||isCombo)){return data;}if(srcBitmask&_mergeData_WRAP_BIND_FLAG){data[2]=source[2];newBitmask|=bitmask&_mergeData_WRAP_BIND_FLAG?0:_mergeData_WRAP_CURRY_BOUND_FLAG;}var value=source[3];if(value){var partials=data[3];data[3]=partials?_composeArgs(partials,value,source[4]):value;data[4]=partials?_replaceHolders(data[3],_mergeData_PLACEHOLDER):source[4];}value=source[5];if(value){partials=data[5];data[5]=partials?_composeArgsRight(partials,value,source[6]):value;data[6]=partials?_replaceHolders(data[5],_mergeData_PLACEHOLDER):source[6];}value=source[7];if(value){data[7]=value;}if(srcBitmask&_mergeData_WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:_mergeData_nativeMin(data[8],source[8]);}if(data[9]==null){data[9]=source[9];}data[0]=source[0];data[1]=newBitmask;return data;}/* harmony default export */ var _mergeData = (mergeData);
// EXTERNAL MODULE: ./node_modules/lodash-es/toInteger.js
var toInteger = __webpack_require__(72);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT='Expected a function';var _createWrap_WRAP_BIND_FLAG=1,_createWrap_WRAP_BIND_KEY_FLAG=2,_createWrap_WRAP_CURRY_FLAG=8,_createWrap_WRAP_CURRY_RIGHT_FLAG=16,_createWrap_WRAP_PARTIAL_FLAG=32,_createWrap_WRAP_PARTIAL_RIGHT_FLAG=64;var _createWrap_nativeMax=Math.max;function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&_createWrap_WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(_createWrap_WRAP_PARTIAL_FLAG|_createWrap_WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:_createWrap_nativeMax(Object(toInteger["a" /* default */])(ary),0);arity=arity===undefined?arity:Object(toInteger["a" /* default */])(arity);length-=holders?holders.length:0;if(bitmask&_createWrap_WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:_getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){_mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:_createWrap_nativeMax(newData[9]-length,0);if(!arity&&bitmask&(_createWrap_WRAP_CURRY_FLAG|_createWrap_WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(_createWrap_WRAP_CURRY_FLAG|_createWrap_WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==_createWrap_WRAP_BIND_FLAG){var result=_createBind(func,bitmask,thisArg);}else if(bitmask==_createWrap_WRAP_CURRY_FLAG||bitmask==_createWrap_WRAP_CURRY_RIGHT_FLAG){result=_createCurry(func,bitmask,arity);}else if((bitmask==_createWrap_WRAP_PARTIAL_FLAG||bitmask==(_createWrap_WRAP_BIND_FLAG|_createWrap_WRAP_PARTIAL_FLAG))&&!holders.length){result=_createPartial(func,bitmask,thisArg,partials);}else{result=_createHybrid.apply(undefined,newData);}var setter=data?_baseSetData:_setData;return _setWrapToString(setter(result,newData),func,bitmask);}/* harmony default export */ var _createWrap = (createWrap);
// CONCATENATED MODULE: ./node_modules/lodash-es/curryRight.js
var curryRight_WRAP_CURRY_RIGHT_FLAG=16;function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=_createWrap(func,curryRight_WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}curryRight.placeholder={};/* harmony default export */ var lodash_es_curryRight = __webpack_exports__["a"] = (curryRight);

/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/toInteger.js
var toInteger = __webpack_require__(72);

// CONCATENATED MODULE: ./node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT='Expected a function';function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=Object(toInteger["a" /* default */])(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/* harmony default export */ var lodash_es_before = (before);
// CONCATENATED MODULE: ./node_modules/lodash-es/once.js
function once(func){return lodash_es_before(2,func);}/* harmony default export */ var lodash_es_once = __webpack_exports__["a"] = (once);

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseRest.js
var _baseRest = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayMap.js
var _arrayMap = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIndexOf.js + 3 modules
var _baseIndexOf = __webpack_require__(87);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/* harmony default export */ var _baseIndexOfWith = (baseIndexOfWith);
// EXTERNAL MODULE: ./node_modules/lodash-es/_baseUnary.js
var _baseUnary = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/lodash-es/_copyArray.js
var _copyArray = __webpack_require__(43);

// CONCATENATED MODULE: ./node_modules/lodash-es/_basePullAll.js
var arrayProto=Array.prototype;var splice=arrayProto.splice;function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?_baseIndexOfWith:_baseIndexOf["a" /* default */],index=-1,length=values.length,seen=array;if(array===values){values=Object(_copyArray["a" /* default */])(values);}if(iteratee){seen=Object(_arrayMap["a" /* default */])(array,Object(_baseUnary["a" /* default */])(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/* harmony default export */ var _basePullAll = (basePullAll);
// CONCATENATED MODULE: ./node_modules/lodash-es/pullAll.js
function pullAll(array,values){return array&&array.length&&values&&values.length?_basePullAll(array,values):array;}/* harmony default export */ var lodash_es_pullAll = (pullAll);
// CONCATENATED MODULE: ./node_modules/lodash-es/pull.js
var pull=Object(_baseRest["a" /* default */])(lodash_es_pullAll);/* harmony default export */ var lodash_es_pull = __webpack_exports__["a"] = (pull);

/***/ })
/******/ ]);
//# sourceMappingURL=foreground.entry.js.map